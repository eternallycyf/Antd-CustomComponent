(self.webpackChunk=self.webpackChunk||[]).push([[101],{45634:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ components_line; }
});

// NAMESPACE OBJECT: ./node_modules/fecha/lib/fecha.js
var fecha_namespaceObject = {};
__webpack_require__.r(fecha_namespaceObject);
__webpack_require__.d(fecha_namespaceObject, {
  "assign": function() { return fecha_assign; },
  "default": function() { return lib_fecha; },
  "defaultI18n": function() { return defaultI18n; },
  "format": function() { return format; },
  "parse": function() { return parse; },
  "setGlobalDateI18n": function() { return setGlobalDateI18n; },
  "setGlobalDateMasks": function() { return setGlobalDateMasks; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/annotation/index.js
var annotation_namespaceObject = {};
__webpack_require__.r(annotation_namespaceObject);
__webpack_require__.d(annotation_namespaceObject, {
  "Arc": function() { return arc; },
  "DataMarker": function() { return data_marker; },
  "DataRegion": function() { return data_region; },
  "Html": function() { return html; },
  "Image": function() { return annotation_image; },
  "Line": function() { return line; },
  "Region": function() { return region; },
  "RegionFilter": function() { return region_filter; },
  "Shape": function() { return annotation_shape; },
  "Text": function() { return annotation_text; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
var auto_ellipsis_namespaceObject = {};
__webpack_require__.r(auto_ellipsis_namespaceObject);
__webpack_require__.d(auto_ellipsis_namespaceObject, {
  "ellipsisHead": function() { return ellipsisHead; },
  "ellipsisMiddle": function() { return ellipsisMiddle; },
  "ellipsisTail": function() { return ellipsisTail; },
  "getDefault": function() { return getDefault; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/axis/overlap/auto-hide.js
var auto_hide_namespaceObject = {};
__webpack_require__.r(auto_hide_namespaceObject);
__webpack_require__.d(auto_hide_namespaceObject, {
  "equidistance": function() { return equidistance; },
  "equidistanceWithReverseBoth": function() { return equidistanceWithReverseBoth; },
  "getDefault": function() { return auto_hide_getDefault; },
  "reserveBoth": function() { return reserveBoth; },
  "reserveFirst": function() { return reserveFirst; },
  "reserveLast": function() { return reserveLast; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
var auto_rotate_namespaceObject = {};
__webpack_require__.r(auto_rotate_namespaceObject);
__webpack_require__.d(auto_rotate_namespaceObject, {
  "fixedAngle": function() { return fixedAngle; },
  "getDefault": function() { return auto_rotate_getDefault; },
  "unfixedAngle": function() { return unfixedAngle; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/axis/overlap/index.js
var overlap_namespaceObject = {};
__webpack_require__.r(overlap_namespaceObject);
__webpack_require__.d(overlap_namespaceObject, {
  "autoEllipsis": function() { return auto_ellipsis_namespaceObject; },
  "autoHide": function() { return auto_hide_namespaceObject; },
  "autoRotate": function() { return auto_rotate_namespaceObject; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/crosshair/index.js
var crosshair_namespaceObject = {};
__webpack_require__.r(crosshair_namespaceObject);
__webpack_require__.d(crosshair_namespaceObject, {
  "Base": function() { return crosshair_base; },
  "Circle": function() { return crosshair_circle; },
  "Html": function() { return crosshair_html; },
  "Line": function() { return crosshair_line; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/component/esm/tooltip/css-const.js
var tooltip_css_const_namespaceObject = {};
__webpack_require__.r(tooltip_css_const_namespaceObject);
__webpack_require__.d(tooltip_css_const_namespaceObject, {
  "CONTAINER_CLASS": function() { return css_const_CONTAINER_CLASS; },
  "CROSSHAIR_X": function() { return CROSSHAIR_X; },
  "CROSSHAIR_Y": function() { return CROSSHAIR_Y; },
  "LIST_CLASS": function() { return LIST_CLASS; },
  "LIST_ITEM_CLASS": function() { return LIST_ITEM_CLASS; },
  "MARKER_CLASS": function() { return MARKER_CLASS; },
  "NAME_CLASS": function() { return NAME_CLASS; },
  "TITLE_CLASS": function() { return TITLE_CLASS; },
  "VALUE_CLASS": function() { return VALUE_CLASS; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/g-canvas/esm/shape/index.js
var esm_shape_namespaceObject = {};
__webpack_require__.r(esm_shape_namespaceObject);
__webpack_require__.d(esm_shape_namespaceObject, {
  "Base": function() { return shape_base; },
  "Circle": function() { return shape_circle; },
  "Ellipse": function() { return ellipse; },
  "Image": function() { return shape_image; },
  "Line": function() { return esm_shape_line; },
  "Marker": function() { return marker; },
  "Path": function() { return path; },
  "Polygon": function() { return polygon; },
  "Polyline": function() { return polyline; },
  "Rect": function() { return rect; },
  "Text": function() { return shape_text; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/g-canvas/esm/index.js
var g_canvas_esm_namespaceObject = {};
__webpack_require__.r(g_canvas_esm_namespaceObject);
__webpack_require__.d(g_canvas_esm_namespaceObject, {
  "Canvas": function() { return canvas; },
  "Group": function() { return esm_group; },
  "Shape": function() { return esm_shape_namespaceObject; },
  "getArcParams": function() { return getArcParams; },
  "version": function() { return version; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/g-svg/esm/shape/index.js
var g_svg_esm_shape_namespaceObject = {};
__webpack_require__.r(g_svg_esm_shape_namespaceObject);
__webpack_require__.d(g_svg_esm_shape_namespaceObject, {
  "Base": function() { return esm_shape_base; },
  "Circle": function() { return esm_shape_circle; },
  "Dom": function() { return dom; },
  "Ellipse": function() { return shape_ellipse; },
  "Image": function() { return esm_shape_image; },
  "Line": function() { return g_svg_esm_shape_line; },
  "Marker": function() { return shape_marker; },
  "Path": function() { return shape_path; },
  "Polygon": function() { return shape_polygon; },
  "Polyline": function() { return shape_polyline; },
  "Rect": function() { return shape_rect; },
  "Text": function() { return esm_shape_text; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/g-svg/esm/index.js
var g_svg_esm_namespaceObject = {};
__webpack_require__.r(g_svg_esm_namespaceObject);
__webpack_require__.d(g_svg_esm_namespaceObject, {
  "Canvas": function() { return esm_canvas; },
  "Group": function() { return g_svg_esm_group; },
  "Shape": function() { return g_svg_esm_shape_namespaceObject; },
  "version": function() { return esm_version; }
});

// NAMESPACE OBJECT: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/index.js
var src_namespaceObject = {};
__webpack_require__.r(src_namespaceObject);
__webpack_require__.d(src_namespaceObject, {
  "cluster": function() { return cluster; },
  "hierarchy": function() { return hierarchy; },
  "pack": function() { return pack; },
  "packEnclose": function() { return enclose; },
  "packSiblings": function() { return siblings; },
  "partition": function() { return src_partition; },
  "stratify": function() { return stratify; },
  "tree": function() { return src_tree; },
  "treemap": function() { return treemap; },
  "treemapBinary": function() { return binary; },
  "treemapDice": function() { return dice; },
  "treemapResquarify": function() { return resquarify; },
  "treemapSlice": function() { return slice; },
  "treemapSliceDice": function() { return sliceDice; },
  "treemapSquarify": function() { return squarify; }
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(97582);
// EXTERNAL MODULE: ./node_modules/@antv/util/esm/index.js + 104 modules
var esm = __webpack_require__(45098);
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/constant.js
/**
 * view \u4E2D\u4E09\u5C42 group \u5206\u5C42 key
 */
var LAYER;
(function (LAYER) {
    /** \u524D\u666F\u5C42 */
    LAYER["FORE"] = "fore";
    /** \u4E2D\u95F4\u5C42 */
    LAYER["MID"] = "mid";
    /** \u80CC\u666F\u5C42 */
    LAYER["BG"] = "bg";
})(LAYER || (LAYER = {}));
/**
 * \u7EC4\u4EF6\u5728\u753B\u5E03\u7684\u5E03\u5C40\u65B9\u4F4D 12 \u65B9\u4F4D
 */
var constant_DIRECTION;
(function (DIRECTION) {
    DIRECTION["TOP"] = "top";
    DIRECTION["TOP_LEFT"] = "top-left";
    DIRECTION["TOP_RIGHT"] = "top-right";
    DIRECTION["RIGHT"] = "right";
    DIRECTION["RIGHT_TOP"] = "right-top";
    DIRECTION["RIGHT_BOTTOM"] = "right-bottom";
    DIRECTION["LEFT"] = "left";
    DIRECTION["LEFT_TOP"] = "left-top";
    DIRECTION["LEFT_BOTTOM"] = "left-bottom";
    DIRECTION["BOTTOM"] = "bottom";
    DIRECTION["BOTTOM_LEFT"] = "bottom-left";
    DIRECTION["BOTTOM_RIGHT"] = "bottom-right";
    DIRECTION["RADIUS"] = "radius";
    DIRECTION["CIRCLE"] = "circle";
    // no direction information
    DIRECTION["NONE"] = "none";
})(constant_DIRECTION || (constant_DIRECTION = {}));
/**
 * \u7EC4\u4EF6\u7684\u7C7B\u578B\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u5230\u5E03\u5C40\u7B97\u6CD5
 */
var COMPONENT_TYPE;
(function (COMPONENT_TYPE) {
    /** axis \u7EC4\u4EF6 */
    COMPONENT_TYPE["AXIS"] = "axis";
    /** grid \u7EC4\u4EF6 */
    COMPONENT_TYPE["GRID"] = "grid";
    /** legend \u7EC4\u4EF6 */
    COMPONENT_TYPE["LEGEND"] = "legend";
    /** tooltip \u7EC4\u4EF6 */
    COMPONENT_TYPE["TOOLTIP"] = "tooltip";
    /** annotation \u7EC4\u4EF6 */
    COMPONENT_TYPE["ANNOTATION"] = "annotation";
    /** \u7F29\u7565\u8F74\u7EC4\u4EF6 */
    COMPONENT_TYPE["SLIDER"] = "slider";
    /** \u6EDA\u52A8\u6761\u7EC4\u4EF6 */
    COMPONENT_TYPE["SCROLLBAR"] = "scrollbar";
    /** \u5176\u4ED6\u7EC4\u4EF6\uFF0C\u81EA\u5B9A\u4E49\u7EC4\u4EF6 */
    COMPONENT_TYPE["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
/**
 * \u4E09\u5C42 group \u7684 z index
 */
var GROUP_Z_INDEX = {
    FORE: 3,
    MID: 2,
    BG: 1,
};
/**
 * View \u7684\u751F\u547D\u5468\u671F\u9636\u6BB5\uFF08\u548C 3.x \u7684\u751F\u547D\u5468\u671F\u7565\u6709\u4E0D\u540C\uFF09
 * \u6211\u4EEC\u9700\u8981\u5148\u786E\u5B9A\u5728\u90A3\u5199\u573A\u666F\u9700\u8981\u7528\u5230\u751F\u547D\u5468\u671F\uFF0C\u5982\u679C\u53EA\u662F\u4E3A\u4E86\u5728\u751F\u547D\u5468\u671F\u63D2\u5165\u4E00\u4E0B\u4EC0\u4E48\u7EC4\u4EF6\u4E4B\u7C7B\u7684\uFF0C\u90A3\u4E48\u5728\u73B0\u6709\u67B6\u6784\u5C31\u662F\u4E0D\u9700\u8981\u7684
 */
var VIEW_LIFE_CIRCLE;
(function (VIEW_LIFE_CIRCLE) {
    VIEW_LIFE_CIRCLE["BEFORE_RENDER"] = "beforerender";
    VIEW_LIFE_CIRCLE["AFTER_RENDER"] = "afterrender";
    VIEW_LIFE_CIRCLE["BEFORE_PAINT"] = "beforepaint";
    VIEW_LIFE_CIRCLE["AFTER_PAINT"] = "afterpaint";
    VIEW_LIFE_CIRCLE["BEFORE_CHANGE_DATA"] = "beforechangedata";
    VIEW_LIFE_CIRCLE["AFTER_CHANGE_DATA"] = "afterchangedata";
    VIEW_LIFE_CIRCLE["BEFORE_CLEAR"] = "beforeclear";
    VIEW_LIFE_CIRCLE["AFTER_CLEAR"] = "afterclear";
    VIEW_LIFE_CIRCLE["BEFORE_DESTROY"] = "beforedestroy";
    VIEW_LIFE_CIRCLE["BEFORE_CHANGE_SIZE"] = "beforechangesize";
    VIEW_LIFE_CIRCLE["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
/**
 * geometry \u7684\u751F\u547D\u5468\u671F
 */
var GEOMETRY_LIFE_CIRCLE;
(function (GEOMETRY_LIFE_CIRCLE) {
    GEOMETRY_LIFE_CIRCLE["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
    GEOMETRY_LIFE_CIRCLE["AFTER_DRAW_ANIMATE"] = "afteranimate";
    GEOMETRY_LIFE_CIRCLE["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
    GEOMETRY_LIFE_CIRCLE["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
/**
 * \u7ED8\u56FE\u533A\u7684\u4E8B\u4EF6\u5217\u8868
 */
var PLOT_EVENTS;
(function (PLOT_EVENTS) {
    // mouse \u4E8B\u4EF6
    PLOT_EVENTS["MOUSE_ENTER"] = "plot:mouseenter";
    PLOT_EVENTS["MOUSE_DOWN"] = "plot:mousedown";
    PLOT_EVENTS["MOUSE_MOVE"] = "plot:mousemove";
    PLOT_EVENTS["MOUSE_UP"] = "plot:mouseup";
    PLOT_EVENTS["MOUSE_LEAVE"] = "plot:mouseleave";
    // \u79FB\u52A8\u7AEF\u4E8B\u4EF6
    PLOT_EVENTS["TOUCH_START"] = "plot:touchstart";
    PLOT_EVENTS["TOUCH_MOVE"] = "plot:touchmove";
    PLOT_EVENTS["TOUCH_END"] = "plot:touchend";
    PLOT_EVENTS["TOUCH_CANCEL"] = "plot:touchcancel";
    // click \u4E8B\u4EF6
    PLOT_EVENTS["CLICK"] = "plot:click";
    PLOT_EVENTS["DBLCLICK"] = "plot:dblclick";
    PLOT_EVENTS["CONTEXTMENU"] = "plot:contextmenu";
    PLOT_EVENTS["LEAVE"] = "plot:leave";
    PLOT_EVENTS["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
/**
 * Element \u56FE\u5F62\u4EA4\u4E92\u72B6\u6001
 */
var ELEMENT_STATE;
(function (ELEMENT_STATE) {
    ELEMENT_STATE["ACTIVE"] = "active";
    ELEMENT_STATE["INACTIVE"] = "inactive";
    ELEMENT_STATE["SELECTED"] = "selected";
    ELEMENT_STATE["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
/** \u53C2\u4E0E\u5206\u7EC4\u7684\u56FE\u5F62\u5C5E\u6027\u540D */
var GROUP_ATTRS = ['color', 'shape', 'size'];
/** \u5B58\u50A8\u539F\u59CB\u6570\u636E\u7684\u5B57\u6BB5\u540D */
var FIELD_ORIGIN = '_origin';
/** \u6700\u5C0F\u7684\u56FE\u8868\u5BBD\u5EA6 */
var MIN_CHART_WIDTH = 1;
/** \u6700\u5C0F\u7684\u56FE\u8868\u9AD8\u5EA6 */
var MIN_CHART_HEIGHT = 1;
/** \u8F85\u52A9\u7EC4\u4EF6\u5360\u56FE\u8868\u7684\u5C3A\u5BF8\u7684\u6700\u5927\u6BD4\u4F8B\uFF1A\u5982\u56FE\u8868\u4E0A\u65B9\u7684\u56FE\u4F8B\u6700\u591A\u5360\u56FE\u8868\u9AD8\u5EA6\u768425% */
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/engine/index.js
var ENGINES = {};
/**
 * \u901A\u8FC7\u540D\u5B57\u83B7\u53D6\u6E32\u67D3 engine
 * @param name \u6E32\u67D3\u5F15\u64CE\u540D\u5B57
 * @returns G engine
 */
function getEngine(name) {
    var G = ENGINES[name];
    if (!G) {
        throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
    }
    return G;
}
/**
 * \u6CE8\u518C\u6E32\u67D3\u5F15\u64CE
 * @param name
 * @param engine
 */
function registerEngine(name, engine) {
    ENGINES[name] = engine;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/create-dom.js
/**
 * \u521B\u5EFADOM \u8282\u70B9
 * @param  {String} str Dom \u5B57\u7B26\u4E32
 * @return {HTMLElement}  DOM \u8282\u70B9
 */
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
    TABLE = document.createElement('table');
    TABLE_TR = document.createElement('tr');
    FRAGMENT_REG = /^\\s*<(\\w+|!)[^>]*>/;
    CONTAINERS = {
        tr: document.createElement('tbody'),
        tbody: TABLE,
        thead: TABLE,
        tfoot: TABLE,
        td: TABLE_TR,
        th: TABLE_TR,
        '*': document.createElement('div'),
    };
}
function createDom(str) {
    if (!TABLE) {
        initConstants();
    }
    var name = FRAGMENT_REG.test(str) && RegExp.$1;
    if (!name || !(name in CONTAINERS)) {
        name = '*';
    }
    var container = CONTAINERS[name];
    str = typeof str === 'string' ? str.replace(/(^\\s*)|(\\s*$)/g, '') : str;
    container.innerHTML = '' + str;
    var dom = container.childNodes[0];
    if (dom && container.contains(dom)) {
        container.removeChild(dom);
    }
    return dom;
}
//# sourceMappingURL=create-dom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
    if (dom) {
        for (var key in css) {
            if (css.hasOwnProperty(key)) {
                dom.style[key] = css[key];
            }
        }
    }
    return dom;
}
//# sourceMappingURL=modify-css.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/dom.js

/**
 * get the element's bounding size
 * @param ele dom element
 * @returns the element width and height
 */
function getElementSize(ele) {
    var style = getComputedStyle(ele);
    return {
        width: (ele.clientWidth || parseInt(style.width, 10)) -
            parseInt(style.paddingLeft, 10) -
            parseInt(style.paddingRight, 10),
        height: (ele.clientHeight || parseInt(style.height, 10)) -
            parseInt(style.paddingTop, 10) -
            parseInt(style.paddingBottom, 10),
    };
}
/**
 * is value a valid number
 * @param v the input value
 * @returns whether it is a number
 */
function isNumber(v) {
    return typeof v === 'number' && !isNaN(v);
}
/**
 * @ignore
 * calculate the chart size
 * @param ele DOM element
 * @param autoFit should auto fit
 * @param width chart width which is set by user
 * @param height chart height which is set by user
 * @returns the chart width and height
 */
function getChartSize(ele, autoFit, width, height) {
    var w = width;
    var h = height;
    if (autoFit) {
        var size = getElementSize(ele);
        w = size.width ? size.width : w;
        h = size.height ? size.height : h;
    }
    return {
        width: Math.max(isNumber(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
        height: Math.max(isNumber(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
    };
}
/**
 * @ignore
 * remove html element from its parent
 * @param dom
 */
function removeDom(dom) {
    var parent = dom.parentNode;
    if (parent) {
        parent.removeChild(dom);
    }
}
/** @ignore */

//# sourceMappingURL=dom.js.map
// EXTERNAL MODULE: ./node_modules/@antv/event-emitter/esm/index.js
var event_emitter_esm = __webpack_require__(90494);
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/base.js


/**
 * G2 Chart\u3001View\u3001Geometry \u4EE5\u53CA Element \u7B49\u7684\u57FA\u7C7B\uFF0C\u63D0\u4F9B\u4E8B\u4EF6\u4EE5\u53CA\u4E00\u4E9B\u901A\u7528\u7684\u65B9\u6CD5\u3002
 */
var Base = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Base, _super);
    function Base(cfg) {
        var _this = _super.call(this) || this;
        /** \u6807\u8BC6\u5BF9\u8C61\u662F\u5426\u5DF2\u9500\u6BC1 */
        _this.destroyed = false;
        var _a = cfg.visible, visible = _a === void 0 ? true : _a;
        _this.visible = visible;
        return _this;
    }
    /**
     * \u663E\u793A\u3002
     */
    Base.prototype.show = function () {
        var visible = this.visible;
        if (!visible) {
            this.changeVisible(true);
        }
    };
    /**
     * \u9690\u85CF\u3002
     */
    Base.prototype.hide = function () {
        var visible = this.visible;
        if (visible) {
            this.changeVisible(false);
        }
    };
    /**
     * \u9500\u6BC1\u3002
     */
    Base.prototype.destroy = function () {
        this.off();
        this.destroyed = true;
    };
    /**
     * \u663E\u793A\u6216\u8005\u9690\u85CF\u3002
     * @param visible
     * @returns
     */
    Base.prototype.changeVisible = function (visible) {
        if (this.visible === visible) {
            return;
        }
        this.visible = visible;
    };
    return Base;
}(event_emitter_esm/* default */.Z));
/* harmony default export */ var base = (Base);
//# sourceMappingURL=base.js.map
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/index.js
var g_base_esm = __webpack_require__(98190);
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/constant.js
var DEFAULT_Y = 0; // \u9ED8\u8BA4\u7684 y \u7684\u503C
// \u504F\u79FB\u4E4B\u540E\uFF0C\u95F4\u8DDD
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
// \u6563\u70B9\u5206\u5F00\u4E4B\u540E\uFF0C\u8DDD\u79BB\u8FB9\u754C\u7684\u8DDD\u79BB
var GAP = 0.05;
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/adjusts/adjust.js


var Adjust = /** @class */ (function () {
    function Adjust(cfg) {
        var xField = cfg.xField, yField = cfg.yField, _a = cfg.adjustNames, adjustNames = _a === void 0 ? ['x', 'y'] : _a, dimValuesMap = cfg.dimValuesMap;
        this.adjustNames = adjustNames;
        this.xField = xField;
        this.yField = yField;
        this.dimValuesMap = dimValuesMap;
    }
    /**
     * \u67E5\u770B\u7EF4\u5EA6\u662F\u5426\u662F adjust \u5B57\u6BB5
     * @param dim
     */
    Adjust.prototype.isAdjust = function (dim) {
        return this.adjustNames.indexOf(dim) >= 0;
    };
    Adjust.prototype.getAdjustRange = function (dim, dimValue, values) {
        var yField = this.yField;
        var index = values.indexOf(dimValue);
        var length = values.length;
        var pre;
        var next;
        // \u6CA1\u6709 y \u5B57\u6BB5\uFF0C\u4F46\u662F\u9700\u8981\u6839\u636E y \u8C03\u6574
        if (!yField && this.isAdjust('y')) {
            pre = 0;
            next = 1;
        }
        else if (length > 1) {
            // \u5982\u679C\u4EE5\u5176\u5F00\u5934\uFF0C\u5219\u53D6\u4E4B\uFF0C\u5426\u5219\u53D6\u4ED6\u524D\u9762\u4E00\u4E2A
            pre = values[index === 0 ? 0 : index - 1];
            // \u5982\u679C\u4EE5\u5176\u7ED3\u5C3E\uFF0C\u5219\u53D6\u4E4B\uFF0C\u5426\u5219\u53D6\u4ED6\u540E\u9762\u4E00\u4E2A
            next = values[index === length - 1 ? length - 1 : index + 1];
            if (index !== 0) {
                pre += (dimValue - pre) / 2;
            }
            else {
                pre -= (next - dimValue) / 2;
            }
            if (index !== length - 1) {
                next -= (next - dimValue) / 2;
            }
            else {
                next += (dimValue - values[length - 2]) / 2;
            }
        }
        else {
            pre = dimValue === 0 ? 0 : dimValue - 0.5;
            next = dimValue === 0 ? 1 : dimValue + 0.5;
        }
        return {
            pre: pre,
            next: next,
        };
    };
    Adjust.prototype.adjustData = function (groupedDataArray, mergedData) {
        var _this = this;
        // \u6240\u6709\u8C03\u6574\u7EF4\u5EA6\u7684\u503C\u6570\u7EC4
        var dimValuesMap = this.getDimValues(mergedData);
        // \u6309\u7167\u6BCF\u4E00\u4E2A\u5206\u7EC4\u6765\u8FDB\u884C\u8C03\u6574
        esm/* each */.S6(groupedDataArray, function (dataArray, index) {
            // \u904D\u5386\u6240\u6709\u6570\u636E\u96C6\u5408
            // \u6BCF\u4E2A\u5206\u7EC4\u4E2D\uFF0C\u5206\u522B\u6309\u7167\u4E0D\u540C\u7684 dim \u8FDB\u884C\u8C03\u6574
            esm/* each */.S6(dimValuesMap, function (values, dim) {
                // \u6839\u636E\u4E0D\u540C\u7684\u5EA6\u91CF\u5206\u522B\u8C03\u6574\u4F4D\u7F6E
                _this.adjustDim(dim, values, dataArray, index);
            });
        });
    };
    /**
     * \u5BF9\u6570\u636E\u8FDB\u884C\u5206\u7EC4adjustData
     * @param data \u6570\u636E
     * @param dim \u5206\u7EC4\u7684\u5B57\u6BB5
     * @return \u5206\u7EC4\u7ED3\u679C
     */
    Adjust.prototype.groupData = function (data, dim) {
        // \u8865\u9F50\u6570\u636E\u7A7A\u6570\u636E\u4E3A\u9ED8\u8BA4\u503C
        esm/* each */.S6(data, function (record) {
            if (record[dim] === undefined) {
                record[dim] = DEFAULT_Y;
            }
        });
        // \u6309\u7167 dim \u7EF4\u5EA6\u5206\u7EC4
        return esm/* groupBy */.vM(data, dim);
    };
    /** @override */
    Adjust.prototype.adjustDim = function (dim, values, data, index) { };
    /**
     * \u83B7\u53D6\u53EF\u8C03\u6574\u5EA6\u91CF\u5BF9\u5E94\u7684\u503C
     * @param mergedData \u6570\u636E
     * @return \u503C\u7684\u6620\u5C04
     */
    Adjust.prototype.getDimValues = function (mergedData) {
        var _a = this, xField = _a.xField, yField = _a.yField;
        var dimValuesMap = esm/* assign */.f0({}, this.dimValuesMap);
        // \u6240\u6709\u7684\u7EF4\u5EA6
        var dims = [];
        if (xField && this.isAdjust('x')) {
            dims.push(xField);
        }
        if (yField && this.isAdjust('y')) {
            dims.push(yField);
        }
        dims.forEach(function (dim) {
            if (dimValuesMap && dimValuesMap[dim]) {
                return;
            }
            // \u5728\u6BCF\u4E2A\u7EF4\u5EA6\u4E0A\uFF0C\u6240\u6709\u7684\u503C
            dimValuesMap[dim] = esm/* valuesOfKey */.I(mergedData, dim).sort(function (v1, v2) { return v1 - v2; });
        });
        // \u53EA\u6709\u4E00\u7EF4\u7684\u60C5\u51B5\u4E0B\uFF0C\u540C\u65F6\u8C03\u6574 y\uFF0C\u8D4B\u4E88\u9ED8\u8BA4\u503C
        if (!yField && this.isAdjust('y')) {
            var dim = 'y';
            dimValuesMap[dim] = [DEFAULT_Y, 1]; // \u9ED8\u8BA4\u5206\u5E03\u5728 y \u8F74\u7684 0 \u4E0E 1 \u4E4B\u95F4
        }
        return dimValuesMap;
    };
    return Adjust;
}());
/* harmony default export */ var adjust = (Adjust);
//# sourceMappingURL=adjust.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/factory.js

var ADJUST_MAP = {};
/**
 * \u6839\u636E\u7C7B\u578B\u83B7\u53D6 Adjust \u7C7B
 * @param type
 */
var getAdjust = function (type) {
    return ADJUST_MAP[type.toLowerCase()];
};
/**
 * \u6CE8\u518C\u81EA\u5B9A\u4E49 Adjust
 * @param type
 * @param ctor
 */
var registerAdjust = function (type, ctor) {
    // \u6CE8\u518C\u7684\u65F6\u5019\uFF0C\u9700\u8981\u6821\u9A8C type \u91CD\u540D\uFF0C\u4E0D\u533A\u5206\u5927\u5C0F\u5199
    if (getAdjust(type)) {
        throw new Error("Adjust type '" + type + "' existed.");
    }
    // \u5B58\u50A8\u5230 map \u4E2D
    ADJUST_MAP[type.toLowerCase()] = ctor;
};


//# sourceMappingURL=factory.js.map
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(52677);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/node_modules/tslib/tslib.es6.js

/*! *****************************************************************************\r
Copyright (c) Microsoft Corporation.\r
\r
Permission to use, copy, modify, and/or distribute this software for any\r
purpose with or without fee is hereby granted.\r
\r
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r
PERFORMANCE OF THIS SOFTWARE.\r
***************************************************************************** */
/* global Reflect, Promise */

var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };
  return _extendStatics(d, b);
};
function __extends(d, b) {
  _extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return _assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
;
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/adjusts/dodge.js




var Dodge = /** @class */ (function (_super) {
    __extends(Dodge, _super);
    function Dodge(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.cacheMap = {};
        _this.adjustDataArray = [];
        _this.mergeData = [];
        var _a = cfg.marginRatio, marginRatio = _a === void 0 ? MARGIN_RATIO : _a, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
        _this.marginRatio = marginRatio;
        _this.dodgeRatio = dodgeRatio;
        _this.dodgeBy = dodgeBy;
        _this.intervalPadding = intervalPadding;
        _this.dodgePadding = dodgePadding;
        _this.xDimensionLegenth = xDimensionLength;
        _this.groupNum = groupNum;
        _this.defaultSize = defaultSize;
        _this.maxColumnWidth = maxColumnWidth;
        _this.minColumnWidth = minColumnWidth;
        _this.columnWidthRatio = columnWidthRatio;
        _this.customOffset = customOffset;
        return _this;
    }
    Dodge.prototype.process = function (groupDataArray) {
        var groupedDataArray = esm/* clone */.d9(groupDataArray);
        // \u5C06\u6570\u636E\u6570\u7EC4\u5C55\u5F00\u4E00\u5C42
        var mergeData = esm/* flatten */.xH(groupedDataArray);
        var dodgeBy = this.dodgeBy;
        // \u5982\u679C\u6307\u5B9A\u4E86\u5206\u7EC4 dim \u7684\u5B57\u6BB5
        var adjustDataArray = dodgeBy ? esm/* group */.ru(mergeData, dodgeBy) : groupedDataArray;
        this.cacheMap = {};
        this.adjustDataArray = adjustDataArray;
        this.mergeData = mergeData;
        this.adjustData(adjustDataArray, mergeData);
        this.adjustDataArray = [];
        this.mergeData = [];
        return groupedDataArray;
    };
    Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {
        var _this = this;
        var customOffset = this.customOffset;
        var map = this.getDistribution(dim);
        var groupData = this.groupData(data, dim); // \u6839\u636E\u503C\u5206\u7EC4
        esm/* each */.S6(groupData, function (group, key) {
            var range;
            // xField \u4E2D\u53EA\u6709\u4E00\u4E2A\u503C\uFF0C\u4E0D\u9700\u8981\u505A dodge
            if (values.length === 1) {
                range = {
                    pre: values[0] - 1,
                    next: values[0] + 1,
                };
            }
            else {
                // \u5982\u679C\u6709\u591A\u4E2A\uFF0C\u5219\u9700\u8981\u83B7\u53D6\u8C03\u6574\u7684\u8303\u56F4
                range = _this.getAdjustRange(dim, parseFloat(key), values);
            }
            esm/* each */.S6(group, function (d) {
                var value = d[dim];
                var valueArr = map[value];
                var valIndex = valueArr.indexOf(frameIndex);
                if (!esm/* isNil */.UM(customOffset)) {
                    var pre = range.pre, next = range.next;
                    d[dim] = esm/* isFunction */.mf(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;
                }
                else {
                    d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
                }
            });
        });
        return [];
    };
    Dodge.prototype.getDodgeOffset = function (range, idx, len) {
        var _a = this, dodgeRatio = _a.dodgeRatio, marginRatio = _a.marginRatio, intervalPadding = _a.intervalPadding, dodgePadding = _a.dodgePadding;
        var pre = range.pre, next = range.next;
        var tickLength = next - pre;
        var position;
        // \u5206\u591A\u79CD\u8F93\u5165\u60C5\u51B5
        if (!esm/* isNil */.UM(intervalPadding) && esm/* isNil */.UM(dodgePadding) && intervalPadding >= 0) {
            // \u4EC5\u914D\u7F6EintervalPadding
            var offset = this.getIntervalOnlyOffset(len, idx);
            position = pre + offset;
        }
        else if (!esm/* isNil */.UM(dodgePadding) && esm/* isNil */.UM(intervalPadding) && dodgePadding >= 0) {
            // \u4EC5\u914D\u7F6EdodgePadding
            var offset = this.getDodgeOnlyOffset(len, idx);
            position = pre + offset;
        }
        else if (!esm/* isNil */.UM(intervalPadding) &&
            !esm/* isNil */.UM(dodgePadding) &&
            intervalPadding >= 0 &&
            dodgePadding >= 0) {
            // \u540C\u65F6\u914D\u7F6EintervalPadding\u548CdodgePadding
            var offset = this.getIntervalAndDodgeOffset(len, idx);
            position = pre + offset;
        }
        else {
            // \u9ED8\u8BA4\u60C5\u51B5
            var width = (tickLength * dodgeRatio) / len;
            var margin = marginRatio * width;
            var offset = (1 / 2) * (tickLength - len * width - (len - 1) * margin) +
                ((idx + 1) * width + idx * margin) -
                (1 / 2) * width -
                (1 / 2) * tickLength;
            position = (pre + next) / 2 + offset;
        }
        return position;
    };
    Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {
        var _a = this, defaultSize = _a.defaultSize, intervalPadding = _a.intervalPadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum, dodgeRatio = _a.dodgeRatio, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, columnWidthRatio = _a.columnWidthRatio;
        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
        var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        // \u6839\u636EcolumnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth\u8C03\u6574\u5BBD\u5EA6
        geomWidth = (!esm/* isNil */.UM(columnWidthRatio)) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
        if (!esm/* isNil */.UM(maxColumnWidth)) {
            var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
            geomWidth = Math.min(geomWidth, normalizedMaxWidht);
        }
        if (!esm/* isNil */.UM(minColumnWidth)) {
            var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
            geomWidth = Math.max(geomWidth, normalizedMinWidht);
        }
        geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;
        // \u8C03\u6574\u7EC4\u5185\u95F4\u9694
        normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +
            (1 / 2) * normalizedIntervalPadding) * groupNum -
            normalizedIntervalPadding / 2;
        return offset;
    };
    Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {
        var _a = this, defaultSize = _a.defaultSize, dodgePadding = _a.dodgePadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum, marginRatio = _a.marginRatio, maxColumnWidth = _a.maxColumnWidth, minColumnWidth = _a.minColumnWidth, columnWidthRatio = _a.columnWidthRatio;
        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
        var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        // \u6839\u636EcolumnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth\u8C03\u6574\u5BBD\u5EA6
        geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
        if (!esm/* isNil */.UM(maxColumnWidth)) {
            var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
            geomWidth = Math.min(geomWidth, normalizedMaxWidht);
        }
        if (!esm/* isNil */.UM(minColumnWidth)) {
            var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
            geomWidth = Math.max(geomWidth, normalizedMinWidht);
        }
        geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;
        // \u8C03\u6574\u7EC4\u95F4\u8DDD
        normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +
            (1 / 2) * normalizedIntervalPadding) * groupNum -
            normalizedIntervalPadding / 2;
        return offset;
    };
    Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {
        var _a = this, intervalPadding = _a.intervalPadding, dodgePadding = _a.dodgePadding, xDimensionLegenth = _a.xDimensionLegenth, groupNum = _a.groupNum;
        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +
            (1 / 2) * normalizedIntervalPadding) * groupNum -
            normalizedIntervalPadding / 2;
        return offset;
    };
    Dodge.prototype.getDistribution = function (dim) {
        var groupedDataArray = this.adjustDataArray;
        var cacheMap = this.cacheMap;
        var map = cacheMap[dim];
        if (!map) {
            map = {};
            esm/* each */.S6(groupedDataArray, function (data, index) {
                var values = esm/* valuesOfKey */.I(data, dim);
                if (!values.length) {
                    values.push(0);
                }
                esm/* each */.S6(values, function (val) {
                    if (!map[val]) {
                        map[val] = [];
                    }
                    map[val].push(index);
                });
            });
            cacheMap[dim] = map;
        }
        return map;
    };
    return Dodge;
}(adjust));
/* harmony default export */ var dodge = (Dodge);
//# sourceMappingURL=dodge.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/adjusts/jitter.js




function randomNumber(min, max) {
    return (max - min) * Math.random() + min;
}
var Jitter = /** @class */ (function (_super) {
    __extends(Jitter, _super);
    function Jitter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Jitter.prototype.process = function (groupDataArray) {
        var groupedDataArray = esm/* clone */.d9(groupDataArray);
        // \u4E4B\u524D\u5206\u7EC4\u4E4B\u540E\u7684\u6570\u636E\uFF0C\u7136\u540E\u6709\u5408\u5E76\u56DE\u53BB\uFF08\u548C\u5206\u7EC4\u524D\u53EF\u4EE5\u7406\u89E3\u6210\u662F\u4E00\u6837\u7684\uFF09
        var mergeData = esm/* flatten */.xH(groupedDataArray);
        // \u8FD4\u56DE\u503C
        this.adjustData(groupedDataArray, mergeData);
        return groupedDataArray;
    };
    /**
     * \u5F53\u524D\u6570\u636E\u5206\u7EC4\uFF08index\uFF09\u4E2D\uFF0C\u6309\u7167\u7EF4\u5EA6 dim \u8FDB\u884C jitter \u8C03\u6574
     * @param dim
     * @param values
     * @param dataArray
     */
    Jitter.prototype.adjustDim = function (dim, values, dataArray) {
        var _this = this;
        // \u5728\u6BCF\u4E00\u4E2A\u5206\u7EC4\u4E2D\uFF0C\u5C06\u6570\u636E\u518D\u6309\u7167 dim \u5206\u7EC4\uFF0C\u7528\u4E8E\u6563\u5217
        var groupDataArray = this.groupData(dataArray, dim);
        return esm/* each */.S6(groupDataArray, function (data, dimValue) {
            return _this.adjustGroup(data, dim, parseFloat(dimValue), values);
        });
    };
    // \u968F\u673A\u51FA\u6765\u7684\u5B57\u6BB5\u503C
    Jitter.prototype.getAdjustOffset = function (range) {
        var pre = range.pre, next = range.next;
        // \u968F\u673A\u7684\u8303\u56F4
        var margin = (next - pre) * GAP;
        return randomNumber(pre + margin, next - margin);
    };
    // adjust group data
    Jitter.prototype.adjustGroup = function (group, dim, dimValue, values) {
        var _this = this;
        // \u8C03\u6574\u8303\u56F4
        var range = this.getAdjustRange(dim, dimValue, values);
        esm/* each */.S6(group, function (data) {
            data[dim] = _this.getAdjustOffset(range); // \u83B7\u53D6\u8C03\u6574\u7684\u4F4D\u7F6E
        });
        return group;
    };
    return Jitter;
}(adjust));
/* harmony default export */ var jitter = (Jitter);
//# sourceMappingURL=jitter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/adjusts/stack.js



var Cache = esm/* Cache */.Ct;
var Stack = /** @class */ (function (_super) {
    __extends(Stack, _super);
    function Stack(cfg) {
        var _this = _super.call(this, cfg) || this;
        var _a = cfg.adjustNames, adjustNames = _a === void 0 ? ['y'] : _a, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
        _this.adjustNames = adjustNames;
        _this.height = height;
        _this.size = size;
        _this.reverseOrder = reverseOrder;
        return _this;
    }
    /**
     * \u65B9\u6CD5\u5165\u53C2\u662F\u7ECF\u8FC7\u6570\u636E\u5206\u7EC4\u3001\u6570\u636E\u6570\u5B57\u5316\u4E4B\u540E\u7684\u4E8C\u7EF4\u6570\u7EC4
     * @param groupDataArray \u5206\u7EC4\u4E4B\u540E\u7684\u6570\u636E
     */
    Stack.prototype.process = function (groupDataArray) {
        var _a = this, yField = _a.yField, reverseOrder = _a.reverseOrder;
        // \u5982\u679C\u6709\u6307\u5B9A y \u5B57\u6BB5\uFF0C\u90A3\u4E48\u6309\u7167 y \u5B57\u6BB5\u6765 stack
        // \u5426\u5219\uFF0C\u6309\u7167\u9AD8\u5EA6\u5747\u5206
        var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
        return reverseOrder ? this.reverse(d) : d;
    };
    Stack.prototype.reverse = function (groupedDataArray) {
        return groupedDataArray.slice(0).reverse();
    };
    Stack.prototype.processStack = function (groupDataArray) {
        var _a = this, xField = _a.xField, yField = _a.yField, reverseOrder = _a.reverseOrder;
        // \u5C42\u53E0\u987A\u5E8F\u7FFB\u8F6C
        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
        // \u7528\u6765\u7F13\u5B58\uFF0C\u6B63\u6570\u548C\u8D1F\u6570\u7684\u5806\u53E0\u95EE\u9898
        var positive = new Cache();
        var negative = new Cache();
        return groupedDataArray.map(function (dataArray) {
            return dataArray.map(function (data) {
                var _a;
                var x = esm/* get */.U2(data, xField, 0);
                var y = esm/* get */.U2(data, [yField]);
                var xKey = x.toString();
                // todo \u662F\u5426\u5E94\u8BE5\u53D6 _origin\uFF1F\u56E0\u4E3A y \u53EF\u80FD\u53D6\u5230\u7684\u503C\u4E0D\u6B63\u786E\uFF0C\u6BD4\u5982\u5148 symmetric\uFF0C\u518D stack\uFF01
                y = esm/* isArray */.kJ(y) ? y[1] : y;
                if (!esm/* isNil */.UM(y)) {
                    var cache = y >= 0 ? positive : negative;
                    if (!cache.has(xKey)) {
                        cache.set(xKey, 0);
                    }
                    var xValue = cache.get(xKey);
                    var newXValue = y + xValue;
                    // \u5B58\u8D77\u6765
                    cache.set(xKey, newXValue);
                    return _assign(_assign({}, data), (_a = {}, _a[yField] = [xValue, newXValue], _a));
                }
                // \u6CA1\u6709\u4FEE\u6539\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE
                return data;
            });
        });
    };
    Stack.prototype.processOneDimStack = function (groupDataArray) {
        var _this = this;
        var _a = this, xField = _a.xField, height = _a.height, reverseOrder = _a.reverseOrder;
        var yField = 'y';
        // \u5982\u679C\u5C42\u53E0\u7684\u987A\u5E8F\u7FFB\u8F6C
        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
        // \u7F13\u5B58\u7D2F\u52A0\u6570\u636E
        var cache = new Cache();
        return groupedDataArray.map(function (dataArray) {
            return dataArray.map(function (data) {
                var _a;
                var size = _this.size;
                var xValue = data[xField];
                // todo \u6CA1\u6709\u770B\u5230\u8FD9\u4E2A stack \u8BA1\u7B97\u539F\u7406
                var stackHeight = (size * 2) / height;
                if (!cache.has(xValue)) {
                    cache.set(xValue, stackHeight / 2); // \u521D\u59CB\u503C\u5927\u5C0F
                }
                var stackValue = cache.get(xValue);
                // \u589E\u52A0\u4E00\u5C42 stackHeight
                cache.set(xValue, stackValue + stackHeight);
                return _assign(_assign({}, data), (_a = {}, _a[yField] = stackValue, _a));
            });
        });
    };
    return Stack;
}(adjust));
/* harmony default export */ var stack = (Stack);
//# sourceMappingURL=stack.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/adjusts/symmetric.js



var Symmetric = /** @class */ (function (_super) {
    __extends(Symmetric, _super);
    function Symmetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Symmetric.prototype.process = function (groupDataArray) {
        var mergeData = esm/* flatten */.xH(groupDataArray);
        var _a = this, xField = _a.xField, yField = _a.yField;
        // \u6BCF\u4E2A x \u503C\u5BF9\u5E94\u7684 \u6700\u5927\u503C
        var cache = this.getXValuesMaxMap(mergeData);
        // \u6240\u6709\u6570\u636E\u7684\u6700\u5927\u7684\u503C
        var max = Math.max.apply(Math, Object.keys(cache).map(function (key) { return cache[key]; }));
        return esm/* map */.UI(groupDataArray, function (dataArray) {
            return esm/* map */.UI(dataArray, function (data) {
                var _a, _b;
                var yValue = data[yField];
                var xValue = data[xField];
                // \u6570\u7EC4\u5904\u7406\u903B\u8F91
                if (esm/* isArray */.kJ(yValue)) {
                    var off_1 = (max - cache[xValue]) / 2;
                    return _assign(_assign({}, data), (_a = {}, _a[yField] = esm/* map */.UI(yValue, function (y) { return off_1 + y; }), _a));
                }
                // \u975E\u6570\u7EC4\u5904\u7406\u903B\u8F91
                var offset = (max - yValue) / 2;
                return _assign(_assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
            });
        });
    };
    // \u83B7\u53D6\u6BCF\u4E2A x \u5BF9\u5E94\u7684\u6700\u5927\u7684\u503C
    Symmetric.prototype.getXValuesMaxMap = function (mergeData) {
        var _this = this;
        var _a = this, xField = _a.xField, yField = _a.yField;
        // \u6839\u636E xField \u7684\u503C\u8FDB\u884C\u5206\u7EC4
        var groupDataArray = esm/* groupBy */.vM(mergeData, function (data) { return data[xField]; });
        // \u83B7\u53D6\u6BCF\u4E2A xField \u503C\u4E2D\u7684\u6700\u5927\u503C
        return esm/* mapValues */.Q8(groupDataArray, function (dataArray) { return _this.getDimMaxValue(dataArray, yField); });
    };
    Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {
        // \u6240\u6709\u7684 value \u503C
        var dimValues = esm/* map */.UI(mergeData, function (data) { return esm/* get */.U2(data, dim, []); });
        // \u5C06\u6570\u7EC4\u6253\u5E73\uFF08dim value \u6709\u53EF\u80FD\u662F\u6570\u7EC4\uFF0C\u6BD4\u5982 stack \u4E4B\u540E\u7684\uFF09
        var flattenValues = esm/* flatten */.xH(dimValues);
        // \u6C42\u51FA\u6570\u7EC4\u7684\u6700\u5927\u503C
        return Math.max.apply(Math, flattenValues);
    };
    return Symmetric;
}(adjust));
/* harmony default export */ var symmetric = (Symmetric);
//# sourceMappingURL=symmetric.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/adjust/esm/index.js






// \u6CE8\u518C\u5185\u7F6E\u7684 adjust
registerAdjust('Dodge', dodge);
registerAdjust('Jitter', jitter);
registerAdjust('Stack', stack);
registerAdjust('Symmetric', symmetric);
// \u6700\u7EC8\u66B4\u9732\u7ED9\u5916\u90E8\u7684\u65B9\u6CD5


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/base.js

// todo \u8FD9\u4E2A\u5230\u5E95\u76EE\u7684\u662F\u4EC0\u4E48\uFF1F
var toScaleString = function (scale, value) {
    if ((0,esm/* isString */.HD)(value)) {
        return value;
    }
    return scale.invert(scale.scale(value));
};
/**
 * \u6240\u6709\u89C6\u89C9\u901A\u9053\u5C5E\u6027\u7684\u57FA\u7C7B
 * @class Base
 */
var Attribute = /** @class */ (function () {
    function Attribute(cfg) {
        this.names = [];
        this.scales = [];
        this.linear = false;
        this.values = [];
        this.callback = function () { return []; };
        // \u89E3\u6790\u914D\u7F6E
        this._parseCfg(cfg);
    }
    /**
     * \u6620\u5C04\u7684\u503C\u7EC4\u6210\u7684\u6570\u7EC4
     * @param params \u5BF9\u5E94 scale \u987A\u5E8F\u7684\u503C\u4F20\u5165
     */
    Attribute.prototype.mapping = function () {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var values = params.map(function (param, idx) {
            return _this._toOriginParam(param, _this.scales[idx]);
        });
        return this.callback.apply(this, values);
    };
    /**
     * \u5982\u679C\u8FDB\u884C\u7EBF\u6027\u6620\u5C04\uFF0C\u8FD4\u56DE\u5BF9\u5E94\u7684\u6620\u5C04\u503C
     * @param percent
     */
    Attribute.prototype.getLinearValue = function (percent) {
        // \u5206\u6BB5\u6570\u91CF
        var steps = this.values.length - 1;
        var step = Math.floor(steps * percent);
        var leftPercent = steps * percent - step;
        // todo \u4E0D\u61C2\u8FD9\u4E2A\u903B\u8F91
        var start = this.values[step];
        var end = step === steps ? start : this.values[step + 1];
        // \u7EBF\u6027\u65B9\u7A0B
        return start + (end - start) * leftPercent;
    };
    /**
     * \u6839\u636E\u5EA6\u91CF\u83B7\u53D6\u5C5E\u6027\u540D
     */
    Attribute.prototype.getNames = function () {
        var scales = this.scales;
        var names = this.names;
        var length = Math.min(scales.length, names.length);
        var rst = [];
        for (var i = 0; i < length; i += 1) {
            rst.push(names[i]);
        }
        return rst;
    };
    /**
     * \u83B7\u53D6\u6240\u6709\u7684\u7EF4\u5EA6\u540D
     */
    Attribute.prototype.getFields = function () {
        return this.scales.map(function (scale) { return scale.field; });
    };
    /**
     * \u6839\u636E\u540D\u79F0\u83B7\u53D6\u5EA6\u91CF
     * @param name
     */
    Attribute.prototype.getScale = function (name) {
        return this.scales[this.names.indexOf(name)];
    };
    /**
     * \u9ED8\u8BA4\u7684\u56DE\u8C03\u51FD\u6570\uFF08\u7528\u6237\u6CA1\u6709\u81EA\u5B9A\u4E49 callback\uFF0C\u6216\u8005\u7528\u6237\u81EA\u5B9A\u4E49 callback \u8FD4\u56DE\u7A7A\u7684\u65F6\u5019\uFF0C\u4F7F\u7528 values \u6620\u5C04\uFF09
     * @param params
     */
    Attribute.prototype.defaultCallback = function () {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        // \u6CA1\u6709 params \u7684\u60C5\u51B5\uFF0C\u662F\u6307\u6CA1\u6709\u6307\u5B9A fields\uFF0C\u76F4\u63A5\u8FD4\u56DE\u914D\u7F6E\u7684 values \u5E38\u91CF
        if (params.length === 0) {
            return this.values;
        }
        return params.map(function (param, idx) {
            var scale = _this.scales[idx];
            return scale.type === 'identity' ? scale.values[0] : _this._getAttributeValue(scale, param);
        });
    };
    // \u89E3\u6790\u914D\u7F6E
    Attribute.prototype._parseCfg = function (cfg) {
        var _this = this;
        var _a = cfg.type, type = _a === void 0 ? 'base' : _a, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values = _d === void 0 ? [] : _d, callback = cfg.callback;
        this.type = type;
        this.scales = scales;
        this.values = values;
        this.names = names;
        // \u6784\u9020 callback \u65B9\u6CD5
        this.callback = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            /**
             * \u5F53\u7528\u6237\u8BBE\u7F6E\u7684 callback \u8FD4\u56DE null \u65F6, \u5E94\u8BE5\u8FD4\u56DE\u9ED8\u8BA4 callback \u4E2D\u7684\u503C
             */
            if (callback) {
                // \u4F7F\u7528\u7528\u6237\u8FD4\u56DE\u7684\u503C\u5904\u7406
                var ret = callback.apply(void 0, params);
                if (!(0,esm/* isNil */.UM)(ret)) {
                    return [ret];
                }
            }
            // \u6CA1\u6709 callback \u6216\u8005\u7528\u6237 callback \u8FD4\u56DE\u503C\u4E3A\u7A7A\uFF0C\u5219\u4F7F\u7528\u9ED8\u8BA4\u7684\u903B\u8F91\u5904\u7406
            return _this.defaultCallback.apply(_this, params);
        };
    };
    // \u83B7\u53D6\u5C5E\u6027\u503C\uFF0C\u5C06\u503C\u6620\u5C04\u5230\u89C6\u89C9\u901A\u9053
    Attribute.prototype._getAttributeValue = function (scale, value) {
        // \u5982\u679C\u662F\u975E\u7EBF\u6027\u7684\u5B57\u6BB5\uFF0C\u76F4\u63A5\u4ECE values \u4E2D\u53D6\u503C\u5373\u53EF
        if (scale.isCategory && !this.linear) {
            // \u79BB\u6563 scale \u53D8\u6362\u6210\u7D22\u5F15
            var idx = scale.translate(value);
            return this.values[idx % this.values.length];
        }
        // \u7EBF\u6027\u5219\u4F7F\u7528\u7EBF\u6027\u503C
        var percent = scale.scale(value);
        return this.getLinearValue(percent);
    };
    /**
     * \u901A\u8FC7 scale \u62FF\u5230\u6570\u636E\u5BF9\u5E94\u7684\u539F\u59CB\u7684\u53C2\u6570
     * @param param
     * @param scale
     * @private
     */
    Attribute.prototype._toOriginParam = function (param, scale) {
        // \u662F\u7EBF\u6027\uFF0C\u76F4\u63A5\u8FD4\u56DE
        // \u975E\u7EBF\u6027\uFF0C\u4F7F\u7528 scale \u53D8\u6362
        return !scale.isLinear
            ? (0,esm/* isArray */.kJ)(param)
                ? param.map(function (p) { return toScaleString(scale, p); })
                : toScaleString(scale, param)
            : param;
    };
    return Attribute;
}());
/* harmony default export */ var attributes_base = (Attribute);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/color-util/esm/index.js

var RGB_REG = /rgba?\\(([\\s.,0-9]+)\\)/;
var regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;
var isGradientColor = function (val) { return /^[r,R,L,l]{1}[\\s]*\\(/.test(val); };
// \u521B\u5EFA\u8F85\u52A9 tag \u53D6\u989C\u8272
var createTmp = function () {
    var i = document.createElement('i');
    i.title = 'Web Colour Picker';
    i.style.display = 'none';
    document.body.appendChild(i);
    return i;
};
// \u83B7\u53D6\u989C\u8272\u4E4B\u95F4\u7684\u63D2\u503C
var getValue = function (start, end, percent, index) {
    return start[index] + (end[index] - start[index]) * percent;
};
// \u6570\u7EC4\u8F6C\u6362\u6210\u989C\u8272
function arr2rgb(arr) {
    return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
// rgb \u989C\u8272\u8F6C\u6362\u6210\u6570\u7EC4
var rgb2arr = function (str) {
    return [
        parseInt(str.substr(1, 2), 16),
        parseInt(str.substr(3, 2), 16),
        parseInt(str.substr(5, 2), 16),
    ];
};
// \u5C06\u6570\u503C\u4ECE 0-255 \u8F6C\u6362\u621016\u8FDB\u5236\u5B57\u7B26\u4E32
var toHex = function (value) {
    var x16Value = Math.round(value).toString(16);
    return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
// \u8BA1\u7B97\u989C\u8272
var calColor = function (points, percent) {
    var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 :
        percent > 1 ? 1 :
            Number(percent);
    var steps = points.length - 1;
    var step = Math.floor(steps * fixedPercent);
    var left = steps * fixedPercent - step;
    var start = points[step];
    var end = step === steps ? start : points[step + 1];
    return arr2rgb([
        getValue(start, end, left, 0),
        getValue(start, end, left, 1),
        getValue(start, end, left, 2),
    ]);
};
// \u7528\u4E8E\u7ED9 toRGB \u7684\u7F13\u5B58\uFF08\u4F7F\u7528 memoize \u65B9\u6CD5\u66FF\u6362\uFF09
// const colorCache = {};
var iEl;
/**
 * \u5C06\u989C\u8272\u8F6C\u6362\u5230 rgb \u7684\u683C\u5F0F
 * @param {color} color \u989C\u8272
 * @return \u5C06\u989C\u8272\u8F6C\u6362\u5230 '#ffffff' \u7684\u683C\u5F0F
 */
var toRGB = function (color) {
    // \u5982\u679C\u5DF2\u7ECF\u662F rgb\u7684\u683C\u5F0F
    if (color[0] === '#' && color.length === 7) {
        return color;
    }
    if (!iEl) {
        // \u9632\u6B62\u9632\u6B62\u5728\u9875\u5934\u62A5\u9519
        iEl = createTmp();
    }
    iEl.style.color = color;
    var rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
    var matches = RGB_REG.exec(rst);
    var cArray = matches[1].split(/\\s*,\\s*/).map(function (s) { return Number(s); });
    rst = arr2rgb(cArray);
    return rst;
};
/**
 * \u83B7\u53D6\u6E10\u53D8\u51FD\u6570
 * @param colors \u591A\u4E2A\u989C\u8272
 * @return \u989C\u8272\u503C
 */
var gradient = function (colors) {
    var colorArray = (0,esm/* isString */.HD)(colors) ? colors.split('-') : colors;
    var points = (0,esm/* map */.UI)(colorArray, function (color) {
        return rgb2arr(color.indexOf('#') === -1 ? toRGB(color) : color);
    });
    // \u8FD4\u56DE\u4E00\u4E2A\u51FD\u6570
    return function (percent) {
        return calColor(points, percent);
    };
};
var toCSSGradient = function (gradientColor) {
    if (isGradientColor(gradientColor)) {
        var cssColor_1;
        var steps = void 0;
        if (gradientColor[0] === 'l') {
            // \u7EBF\u6027\u6E10\u53D8
            var arr = regexLG.exec(gradientColor);
            var angle = +arr[1] + 90; // css \u548C g \u7684\u6E10\u53D8\u8D77\u59CB\u89D2\u5EA6\u4E0D\u540C
            steps = arr[2];
            cssColor_1 = "linear-gradient(" + angle + "deg, ";
        }
        else if (gradientColor[0] === 'r') {
            // \u5F84\u5411\u6E10\u53D8
            cssColor_1 = 'radial-gradient(';
            var arr = regexRG.exec(gradientColor);
            steps = arr[4];
        }
        var colorStops_1 = steps.match(regexColorStop);
        (0,esm/* each */.S6)(colorStops_1, function (item, index) {
            var itemArr = item.split(':');
            cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
            if (index !== (colorStops_1.length - 1)) {
                cssColor_1 += ', ';
            }
        });
        cssColor_1 += ')';
        return cssColor_1;
    }
    return gradientColor;
};
/* harmony default export */ var color_util_esm = ({
    rgb2arr: rgb2arr,
    gradient: gradient,
    toRGB: (0,esm/* memoize */.HP)(toRGB),
    toCSSGradient: toCSSGradient,
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/color.js




var Color = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Color, _super);
    function Color(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'color';
        _this.names = ['color'];
        if ((0,esm/* isString */.HD)(_this.values)) {
            _this.linear = true;
        }
        _this.gradient = color_util_esm.gradient(_this.values);
        return _this;
    }
    /**
     * @override
     */
    Color.prototype.getLinearValue = function (percent) {
        return this.gradient(percent);
    };
    return Color;
}(attributes_base));
/* harmony default export */ var color = (Color);
//# sourceMappingURL=color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/opacity.js


var Opacity = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Opacity, _super);
    function Opacity(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'opacity';
        _this.names = ['opacity'];
        return _this;
    }
    return Opacity;
}(attributes_base));
/* harmony default export */ var opacity = (Opacity);
//# sourceMappingURL=opacity.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/position.js



var Position = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Position, _super);
    function Position(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.names = ['x', 'y'];
        _this.type = 'position';
        return _this;
    }
    Position.prototype.mapping = function (x, y) {
        var _a = this.scales, scaleX = _a[0], scaleY = _a[1];
        if ((0,esm/* isNil */.UM)(x) || (0,esm/* isNil */.UM)(y)) {
            return [];
        }
        return [
            (0,esm/* isArray */.kJ)(x) ? x.map(function (xi) { return scaleX.scale(xi); }) : scaleX.scale(x),
            (0,esm/* isArray */.kJ)(y) ? y.map(function (yi) { return scaleY.scale(yi); }) : scaleY.scale(y),
        ];
    };
    return Position;
}(attributes_base));
/* harmony default export */ var position = (Position);
//# sourceMappingURL=position.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/shape.js


var Shape = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Shape, _super);
    function Shape(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'shape';
        _this.names = ['shape'];
        return _this;
    }
    /**
     * @override
     */
    Shape.prototype.getLinearValue = function (percent) {
        var idx = Math.round((this.values.length - 1) * percent);
        return this.values[idx];
    };
    return Shape;
}(attributes_base));
/* harmony default export */ var shape = (Shape);
//# sourceMappingURL=shape.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/attributes/size.js


var Size = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Size, _super);
    function Size(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'size';
        _this.names = ['size'];
        return _this;
    }
    return Size;
}(attributes_base));
/* harmony default export */ var size = (Size);
//# sourceMappingURL=size.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
/**
 * \u83B7\u53D6\u8BA1\u7B97 ticks \u7684\u65B9\u6CD5
 * @param key \u952E\u503C
 * @returns \u8BA1\u7B97 ticks \u7684\u65B9\u6CD5
 */
function getTickMethod(key) {
    return methodCache[key];
}
/**
 * \u6CE8\u518C\u8BA1\u7B97 ticks \u7684\u65B9\u6CD5
 * @param key \u952E\u503C
 * @param method \u65B9\u6CD5
 */
function registerTickMethod(key, method) {
    methodCache[key] = method;
}
//# sourceMappingURL=register.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/base.js


var Scale = /** @class */ (function () {
    function Scale(cfg) {
        /**
         * \u5EA6\u91CF\u7684\u7C7B\u578B
         */
        this.type = 'base';
        /**
         * \u662F\u5426\u5206\u7C7B\u7C7B\u578B\u7684\u5EA6\u91CF
         */
        this.isCategory = false;
        /**
         * \u662F\u5426\u7EBF\u6027\u5EA6\u91CF\uFF0C\u6709linear, time \u5EA6\u91CF
         */
        this.isLinear = false;
        /**
         * \u662F\u5426\u8FDE\u7EED\u7C7B\u578B\u7684\u5EA6\u91CF\uFF0Clinear,time,log, pow, quantile, quantize \u90FD\u652F\u6301
         */
        this.isContinuous = false;
        /**
         * \u662F\u5426\u662F\u5E38\u91CF\u7684\u5EA6\u91CF\uFF0C\u4F20\u5165\u548C\u4F20\u51FA\u4E00\u81F4
         */
        this.isIdentity = false;
        this.values = [];
        this.range = [0, 1];
        this.ticks = [];
        this.__cfg__ = cfg;
        this.initCfg();
        this.init();
    }
    // \u5BF9\u4E8E\u539F\u59CB\u503C\u7684\u5FC5\u8981\u8F6C\u6362\uFF0C\u5982\u5206\u7C7B\u3001\u65F6\u95F4\u5B57\u6BB5\u9700\u8F6C\u6362\u6210\u6570\u503C\uFF0C\u7528transform/map\u547D\u540D\u53EF\u80FD\u66F4\u597D
    Scale.prototype.translate = function (v) {
        return v;
    };
    /** \u91CD\u65B0\u521D\u59CB\u5316 */
    Scale.prototype.change = function (cfg) {
        // \u8986\u76D6\u914D\u7F6E\u9879\uFF0C\u800C\u4E0D\u66FF\u4EE3
        (0,esm/* assign */.f0)(this.__cfg__, cfg);
        this.init();
    };
    Scale.prototype.clone = function () {
        return this.constructor(this.__cfg__);
    };
    /** \u83B7\u53D6\u5750\u6807\u8F74\u9700\u8981\u7684ticks */
    Scale.prototype.getTicks = function () {
        var _this = this;
        return (0,esm/* map */.UI)(this.ticks, function (tick, idx) {
            if ((0,esm/* isObject */.Kn)(tick)) {
                // \u4EC5\u5F53\u7B26\u5408Tick\u7C7B\u578B\u65F6\u624D\u6709\u610F\u4E49
                return tick;
            }
            return {
                text: _this.getText(tick, idx),
                tickValue: tick,
                value: _this.scale(tick),
            };
        });
    };
    /** \u83B7\u53D6Tick\u7684\u683C\u5F0F\u5316\u7ED3\u679C */
    Scale.prototype.getText = function (value, key) {
        var formatter = this.formatter;
        var res = formatter ? formatter(value, key) : value;
        if ((0,esm/* isNil */.UM)(res) || !(0,esm/* isFunction */.mf)(res.toString)) {
            return '';
        }
        return res.toString();
    };
    // \u83B7\u53D6\u914D\u7F6E\u9879\u4E2D\u7684\u503C\uFF0C\u5F53\u524D scale \u4E0A\u7684\u503C\u53EF\u80FD\u4F1A\u88AB\u4FEE\u6539
    Scale.prototype.getConfig = function (key) {
        return this.__cfg__[key];
    };
    // scale\u521D\u59CB\u5316
    Scale.prototype.init = function () {
        (0,esm/* assign */.f0)(this, this.__cfg__);
        this.setDomain();
        if ((0,esm/* isEmpty */.xb)(this.getConfig('ticks'))) {
            this.ticks = this.calculateTicks();
        }
    };
    // \u5B50\u7C7B\u4E0A\u8986\u76D6\u67D0\u4E9B\u5C5E\u6027\uFF0C\u4E0D\u80FD\u76F4\u63A5\u5728\u7C7B\u4E0A\u58F0\u660E\uFF0C\u5426\u5219\u4F1A\u88AB\u8986\u76D6
    Scale.prototype.initCfg = function () { };
    Scale.prototype.setDomain = function () { };
    Scale.prototype.calculateTicks = function () {
        var tickMethod = this.tickMethod;
        var ticks = [];
        if ((0,esm/* isString */.HD)(tickMethod)) {
            var method = getTickMethod(tickMethod);
            if (!method) {
                throw new Error('There is no method to to calculate ticks!');
            }
            ticks = method(this);
        }
        else if ((0,esm/* isFunction */.mf)(tickMethod)) {
            ticks = tickMethod(this);
        }
        return ticks;
    };
    // range \u7684\u6700\u5C0F\u503C
    Scale.prototype.rangeMin = function () {
        return this.range[0];
    };
    // range \u7684\u6700\u5927\u503C
    Scale.prototype.rangeMax = function () {
        return this.range[1];
    };
    /** \u5B9A\u4E49\u57DF\u8F6C 0~1 */
    Scale.prototype.calcPercent = function (value, min, max) {
        if ((0,esm/* isNumber */.hj)(value)) {
            return (value - min) / (max - min);
        }
        return NaN;
    };
    /** 0~1\u8F6C\u5B9A\u4E49\u57DF */
    Scale.prototype.calcValue = function (percent, min, max) {
        return min + percent * (max - min);
    };
    return Scale;
}());
/* harmony default export */ var esm_base = (Scale);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/category/base.js



/**
 * \u5206\u7C7B\u5EA6\u91CF
 * @class
 */
var Category = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Category, _super);
    function Category() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'cat';
        _this.isCategory = true;
        return _this;
    }
    Category.prototype.buildIndexMap = function () {
        if (!this.translateIndexMap) {
            this.translateIndexMap = new Map();
            // \u91CD\u65B0\u6784\u5EFA\u7F13\u5B58
            for (var i = 0; i < this.values.length; i++) {
                this.translateIndexMap.set(this.values[i], i);
            }
        }
    };
    Category.prototype.translate = function (value) {
        // \u6309\u9700\u6784\u5EFA map
        this.buildIndexMap();
        // \u627E\u5F97\u5230
        var idx = this.translateIndexMap.get(value);
        if (idx === undefined) {
            idx = (0,esm/* isNumber */.hj)(value) ? value : NaN;
        }
        return idx;
    };
    Category.prototype.scale = function (value) {
        var order = this.translate(value);
        // \u5206\u7C7B\u6570\u636E\u5141\u8BB8 0.5 \u8303\u56F4\u5185\u8C03\u6574
        // if (order < this.min - 0.5 || order > this.max + 0.5) {
        //   return NaN;
        // }
        var percent = this.calcPercent(order, this.min, this.max);
        return this.calcValue(percent, this.rangeMin(), this.rangeMax());
    };
    Category.prototype.invert = function (scaledValue) {
        var domainRange = this.max - this.min;
        var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
        var idx = Math.round(domainRange * percent) + this.min;
        if (idx < this.min || idx > this.max) {
            return NaN;
        }
        return this.values[idx];
    };
    Category.prototype.getText = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var v = value;
        // value\u4E3Aindex
        if ((0,esm/* isNumber */.hj)(value) && !this.values.includes(value)) {
            v = this.values[v];
        }
        return _super.prototype.getText.apply(this, (0,tslib_es6/* __spreadArrays */.pr)([v], args));
    };
    // \u590D\u5199\u5C5E\u6027
    Category.prototype.initCfg = function () {
        this.tickMethod = 'cat';
    };
    // \u8BBE\u7F6E min, max
    Category.prototype.setDomain = function () {
        // \u7528\u6237\u6709\u53EF\u80FD\u8BBE\u7F6E min
        if ((0,esm/* isNil */.UM)(this.getConfig('min'))) {
            this.min = 0;
        }
        if ((0,esm/* isNil */.UM)(this.getConfig('max'))) {
            var size = this.values.length;
            this.max = size > 1 ? size - 1 : size;
        }
        // scale.init \u7684\u65F6\u5019\u6E05\u9664\u7F13\u5B58
        if (this.translateIndexMap) {
            this.translateIndexMap = undefined;
        }
    };
    return Category;
}(esm_base));
/* harmony default export */ var category_base = (Category);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/fecha/lib/fecha.js
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\\\d\\\\d?";
var twoDigits = "\\\\d\\\\d";
var threeDigits = "\\\\d{3}";
var fourDigits = "\\\\d{4}";
var word = "[^\\\\s]+";
var literal = /\\[([^]*?)\\]/gm;
function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
}
var monthUpdate = function (arrName) { return function (v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function (v) { return v.toLowerCase(); });
    var index = lowerCaseArr.indexOf(v.toLowerCase());
    if (index > -1) {
        return index;
    }
    return null;
}; };
function fecha_assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var obj = args_1[_a];
        for (var key in obj) {
            // @ts-ignore ex
            origObj[key] = obj[key];
        }
    }
    return origObj;
}
var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
];
var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ["am", "pm"],
    DoFn: function (dayOfMonth) {
        return (dayOfMonth +
            ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3
                ? 0
                : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);
    }
};
var globalI18n = fecha_assign({}, defaultI18n);
var setGlobalDateI18n = function (i18n) {
    return (globalI18n = fecha_assign(globalI18n, i18n));
};
var regexEscape = function (str) {
    return str.replace(/[|\\\\{()[^$+*?.-]/g, "\\\\$&");
};
var pad = function (val, len) {
    if (len === void 0) { len = 2; }
    val = String(val);
    while (val.length < len) {
        val = "0" + val;
    }
    return val;
};
var formatFlags = {
    D: function (dateObj) { return String(dateObj.getDate()); },
    DD: function (dateObj) { return pad(dateObj.getDate()); },
    Do: function (dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
    },
    d: function (dateObj) { return String(dateObj.getDay()); },
    dd: function (dateObj) { return pad(dateObj.getDay()); },
    ddd: function (dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function (dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
    },
    M: function (dateObj) { return String(dateObj.getMonth() + 1); },
    MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },
    MMM: function (dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function (dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function (dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },
    h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },
    hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },
    H: function (dateObj) { return String(dateObj.getHours()); },
    HH: function (dateObj) { return pad(dateObj.getHours()); },
    m: function (dateObj) { return String(dateObj.getMinutes()); },
    mm: function (dateObj) { return pad(dateObj.getMinutes()); },
    s: function (dateObj) { return String(dateObj.getSeconds()); },
    ss: function (dateObj) { return pad(dateObj.getSeconds()); },
    S: function (dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function (dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },
    a: function (dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function (dateObj, i18n) {
        return dateObj.getHours() < 12
            ? i18n.amPm[0].toUpperCase()
            : i18n.amPm[1].toUpperCase();
    },
    ZZ: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));
    },
    Z: function (dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return ((offset > 0 ? "-" : "+") +
            pad(Math.floor(Math.abs(offset) / 60), 2) +
            ":" +
            pad(Math.abs(offset) % 60, 2));
    }
};
var monthParse = function (v) { return +v - 1; };
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
    "isPm",
    word,
    function (v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
            return 0;
        }
        else if (val === i18n.amPm[1]) {
            return 1;
        }
        return null;
    }
];
var timezoneOffset = [
    "timezoneOffset",
    "[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?",
    function (v) {
        var parts = (v + "").match(/([+-]|\\d\\d)/gi);
        if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
    }
];
var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function (v) { return parseInt(v, 10); }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
        "year",
        twoDigits,
        function (v) {
            var now = new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
    ],
    h: ["hour", twoDigitsOptional, undefined, "isPm"],
    hh: ["hour", twoDigits, undefined, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\\\d", function (v) { return +v * 100; }],
    SS: ["millisecond", twoDigits, function (v) { return +v * 10; }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
};
// Some common format strings
var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function (masks) { return fecha_assign(globalMasks, masks); };
/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 * @returns {string} Formatted date string
 */
var format = function (dateObj, mask, i18n) {
    if (mask === void 0) { mask = globalMasks["default"]; }
    if (i18n === void 0) { i18n = {}; }
    if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" ||
        isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    // Make literals inactive by replacing them with @@@
    mask = mask.replace(literal, function ($0, $1) {
        literals.push($1);
        return "@@@";
    });
    var combinedI18nSettings = fecha_assign(fecha_assign({}, globalI18n), i18n);
    // Apply formatting rules
    mask = mask.replace(token, function ($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    // Inline literal values back into the formatted value
    return mask.replace(/@@@/g, function () { return literals.shift(); });
};
/**
 * Parse a date string into a Javascript Date object /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
 * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
 */
function parse(dateStr, format, i18n) {
    if (i18n === void 0) { i18n = {}; }
    if (typeof format !== "string") {
        throw new Error("Invalid format in fecha parse");
    }
    // Check to see if the format is actually a mask
    format = globalMasks[format] || format;
    // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS
    if (dateStr.length > 1000) {
        return null;
    }
    // Default to the beginning of the year.
    var today = new Date();
    var dateInfo = {
        year: today.getFullYear(),
        month: 0,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        isPm: null,
        timezoneOffset: null
    };
    var parseInfo = [];
    var literals = [];
    // Replace all the literals with @@@. Hopefully a string that won't exist in the format
    var newFormat = format.replace(literal, function ($0, $1) {
        literals.push(regexEscape($1));
        return "@@@";
    });
    var specifiedFields = {};
    var requiredFields = {};
    // Change every token that we find into the correct regex
    newFormat = regexEscape(newFormat).replace(token, function ($0) {
        var info = parseFlags[$0];
        var field = info[0], regex = info[1], requiredField = info[3];
        // Check if the person has specified the same field twice. This will lead to confusing results.
        if (specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " specified twice in format");
        }
        specifiedFields[field] = true;
        // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified
        if (requiredField) {
            requiredFields[requiredField] = true;
        }
        parseInfo.push(info);
        return "(" + regex + ")";
    });
    // Check all the required fields are present
    Object.keys(requiredFields).forEach(function (field) {
        if (!specifiedFields[field]) {
            throw new Error("Invalid format. " + field + " is required in specified format");
        }
    });
    // Add back all the literals after
    newFormat = newFormat.replace(/@@@/g, function () { return literals.shift(); });
    // Check if the date string matches the format. If it doesn't return null
    var matches = dateStr.match(new RegExp(newFormat, "i"));
    if (!matches) {
        return null;
    }
    var combinedI18nSettings = fecha_assign(fecha_assign({}, globalI18n), i18n);
    // For each match, call the parser function for that date part
    for (var i = 1; i < matches.length; i++) {
        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
        var value = parser
            ? parser(matches[i], combinedI18nSettings)
            : +matches[i];
        // If the parser can't make sense of the value, return null
        if (value == null) {
            return null;
        }
        dateInfo[field] = value;
    }
    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
        dateInfo.hour = +dateInfo.hour + 12;
    }
    else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
        dateInfo.hour = 0;
    }
    var dateTZ;
    if (dateInfo.timezoneOffset == null) {
        dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
        var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
        ];
        for (var i = 0, len = validateFields.length; i < len; i++) {
            // Check to make sure the date field is within the allowed range. Javascript dates allows values
            // outside the allowed range. If the values don't match the value was invalid
            if (specifiedFields[validateFields[i][0]] &&
                dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
                return null;
            }
        }
    }
    else {
        dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
        // We can't validate dates in another timezone unfortunately. Do a basic check instead
        if (dateInfo.month > 11 ||
            dateInfo.month < 0 ||
            dateInfo.day > 31 ||
            dateInfo.day < 1 ||
            dateInfo.hour > 23 ||
            dateInfo.hour < 0 ||
            dateInfo.minute > 59 ||
            dateInfo.minute < 0 ||
            dateInfo.second > 59 ||
            dateInfo.second < 0) {
            return null;
        }
    }
    // Don't allow invalid dates
    return dateTZ;
}
var fecha = {
    format: format,
    parse: parse,
    defaultI18n: defaultI18n,
    setGlobalDateI18n: setGlobalDateI18n,
    setGlobalDateMasks: setGlobalDateMasks
};

/* harmony default export */ var lib_fecha = (fecha);

//# sourceMappingURL=fecha.js.map

;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/bisector.js

/**
 * \u4E8C\u5206\u53F3\u4FA7\u67E5\u627E
 * https://github.com/d3/d3-array/blob/master/src/bisector.js
 */
/* harmony default export */ function bisector(getter) {
    /**
     * x: \u76EE\u6807\u503C
     * lo: \u8D77\u59CB\u4F4D\u7F6E
     * hi: \u7ED3\u675F\u4F4D\u7F6E
     */
    return function (a, x, _lo, _hi) {
        var lo = (0,esm/* isNil */.UM)(_lo) ? 0 : _lo;
        var hi = (0,esm/* isNil */.UM)(_hi) ? a.length : _hi;
        while (lo < hi) {
            var mid = (lo + hi) >>> 1;
            if (getter(a[mid]) > x) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        return lo;
    };
}
//# sourceMappingURL=bisector.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/time.js




var FORMAT_METHOD = 'format';
function timeFormat(time, mask) {
    var method = fecha_namespaceObject[FORMAT_METHOD] || lib_fecha[FORMAT_METHOD];
    return method(time, mask);
}
/**
 * \u8F6C\u6362\u6210\u65F6\u95F4\u6233
 * @param value \u65F6\u95F4\u503C
 */
function toTimeStamp(value) {
    if ((0,esm/* isString */.HD)(value)) {
        if (value.indexOf('T') > 0) {
            value = new Date(value).getTime();
        }
        else {
            // new Date('2010/01/10') \u548C new Date('2010-01-10') \u7684\u5DEE\u522B\u5728\u4E8E:
            // \u5982\u679C\u4EC5\u6709\u5E74\u6708\u65E5\u65F6\uFF0C\u524D\u8005\u662F\u5E26\u6709\u65F6\u533A\u7684: Fri Jan 10 2020 02:40:13 GMT+0800 (\u4E2D\u56FD\u6807\u51C6\u65F6\u95F4)
            // \u540E\u8005\u4F1A\u683C\u5F0F\u5316\u6210 Sun Jan 10 2010 08:00:00 GMT+0800 (\u4E2D\u56FD\u6807\u51C6\u65F6\u95F4)
            value = new Date(value.replace(/-/gi, '/')).getTime();
        }
    }
    if ((0,esm/* isDate */.J_)(value)) {
        value = value.getTime();
    }
    return value;
}
var SECOND = 1000;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;

var intervals = [
    ['HH:mm:ss', SECOND],
    ['HH:mm:ss', SECOND * 10],
    ['HH:mm:ss', SECOND * 30],
    ['HH:mm', MINUTE],
    ['HH:mm', MINUTE * 10],
    ['HH:mm', MINUTE * 30],
    ['HH', HOUR],
    ['HH', HOUR * 6],
    ['HH', HOUR * 12],
    ['YYYY-MM-DD', DAY],
    ['YYYY-MM-DD', DAY * 4],
    ['YYYY-WW', DAY * 7],
    ['YYYY-MM', MONTH],
    ['YYYY-MM', MONTH * 4],
    ['YYYY-MM', MONTH * 6],
    ['YYYY', DAY * 380],
];
function getTickInterval(min, max, tickCount) {
    var target = (max - min) / tickCount;
    var idx = bisector(function (o) { return o[1]; })(intervals, target) - 1;
    var interval = intervals[idx];
    if (idx < 0) {
        interval = intervals[0];
    }
    else if (idx >= intervals.length) {
        interval = (0,esm/* last */.Z$)(intervals);
    }
    return interval;
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/category/time.js




/**
 * \u65F6\u95F4\u5206\u7C7B\u5EA6\u91CF
 * @class
 */
var TimeCat = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TimeCat, _super);
    function TimeCat() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'timeCat';
        return _this;
    }
    /**
     * @override
     */
    TimeCat.prototype.translate = function (value) {
        value = toTimeStamp(value);
        var index = this.values.indexOf(value);
        if (index === -1) {
            if ((0,esm/* isNumber */.hj)(value) && value < this.values.length) {
                index = value;
            }
            else {
                index = NaN;
            }
        }
        return index;
    };
    /**
     * \u7531\u4E8E\u65F6\u95F4\u7C7B\u578B\u6570\u636E\u9700\u8981\u8F6C\u6362\u4E00\u4E0B\uFF0C\u6240\u4EE5\u590D\u5199 getText
     * @override
     */
    TimeCat.prototype.getText = function (value, tickIndex) {
        var index = this.translate(value);
        if (index > -1) {
            var result = this.values[index];
            var formatter = this.formatter;
            result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
            return result;
        }
        return value;
    };
    TimeCat.prototype.initCfg = function () {
        this.tickMethod = 'time-cat';
        this.mask = 'YYYY-MM-DD';
        this.tickCount = 7; // \u4E00\u822C\u65F6\u95F4\u6570\u636E\u4F1A\u663E\u793A 7\uFF0C 14\uFF0C 30 \u5929\u7684\u6570\u5B57
    };
    TimeCat.prototype.setDomain = function () {
        var values = this.values;
        // \u9488\u5BF9\u65F6\u95F4\u5206\u7C7B\u7C7B\u578B\uFF0C\u4F1A\u5C06\u65F6\u95F4\u7EDF\u4E00\u8F6C\u6362\u4E3A\u65F6\u95F4\u6233
        (0,esm/* each */.S6)(values, function (v, i) {
            values[i] = toTimeStamp(v);
        });
        values.sort(function (v1, v2) {
            return v1 - v2;
        });
        _super.prototype.setDomain.call(this);
    };
    return TimeCat;
}(category_base));
/* harmony default export */ var time = (TimeCat);
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/base.js



/**
 * \u8FDE\u7EED\u5EA6\u91CF\u7684\u57FA\u7C7B
 * @class
 */
var Continuous = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Continuous, _super);
    function Continuous() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isContinuous = true;
        return _this;
    }
    Continuous.prototype.scale = function (value) {
        if ((0,esm/* isNil */.UM)(value)) {
            return NaN;
        }
        var rangeMin = this.rangeMin();
        var rangeMax = this.rangeMax();
        var max = this.max;
        var min = this.min;
        if (max === min) {
            return rangeMin;
        }
        var percent = this.getScalePercent(value);
        return rangeMin + percent * (rangeMax - rangeMin);
    };
    Continuous.prototype.init = function () {
        _super.prototype.init.call(this);
        // init \u5B8C\u6210\u540E\u4FDD\u8BC1 min, max \u5305\u542B ticks \u7684\u8303\u56F4
        var ticks = this.ticks;
        var firstTick = (0,esm/* head */.YM)(ticks);
        var lastTick = (0,esm/* last */.Z$)(ticks);
        if (firstTick < this.min) {
            this.min = firstTick;
        }
        if (lastTick > this.max) {
            this.max = lastTick;
        }
        // strict-limit \u65B9\u5F0F
        if (!(0,esm/* isNil */.UM)(this.minLimit)) {
            this.min = firstTick;
        }
        if (!(0,esm/* isNil */.UM)(this.maxLimit)) {
            this.max = lastTick;
        }
    };
    Continuous.prototype.setDomain = function () {
        var _a = (0,esm/* getRange */.rx)(this.values), min = _a.min, max = _a.max;
        if ((0,esm/* isNil */.UM)(this.min)) {
            this.min = min;
        }
        if ((0,esm/* isNil */.UM)(this.max)) {
            this.max = max;
        }
        if (this.min > this.max) {
            this.min = min;
            this.max = max;
        }
    };
    Continuous.prototype.calculateTicks = function () {
        var _this = this;
        var ticks = _super.prototype.calculateTicks.call(this);
        if (!this.nice) {
            ticks = (0,esm/* filter */.hX)(ticks, function (tick) {
                return tick >= _this.min && tick <= _this.max;
            });
        }
        return ticks;
    };
    // \u8BA1\u7B97\u539F\u59CB\u503C\u503C\u5360\u7684\u767E\u5206\u6BD4
    Continuous.prototype.getScalePercent = function (value) {
        var max = this.max;
        var min = this.min;
        return (value - min) / (max - min);
    };
    Continuous.prototype.getInvertPercent = function (value) {
        return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous;
}(esm_base));
/* harmony default export */ var continuous_base = (Continuous);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/linear.js


/**
 * \u7EBF\u6027\u5EA6\u91CF
 * @class
 */
var Linear = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Linear, _super);
    function Linear() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'linear';
        _this.isLinear = true;
        return _this;
    }
    Linear.prototype.invert = function (value) {
        var percent = this.getInvertPercent(value);
        return this.min + percent * (this.max - this.min);
    };
    Linear.prototype.initCfg = function () {
        this.tickMethod = 'wilkinson-extended';
        this.nice = false;
    };
    return Linear;
}(continuous_base));
/* harmony default export */ var linear = (Linear);
//# sourceMappingURL=linear.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/math.js

// \u6C42\u4EE5a\u4E3A\u6B21\u5E42\uFF0C\u7ED3\u679C\u4E3Ab\u7684\u57FA\u6570\uFF0C\u5982 x^^a = b;\u6C42x
// \u867D\u7136\u6570\u5B66\u4E0A b \u4E0D\u652F\u6301\u8D1F\u6570\uFF0C\u4F46\u662F\u8FD9\u91CC\u9700\u8981\u652F\u6301 \u8D1F\u6570
function calBase(a, b) {
    var e = Math.E;
    var value;
    if (b >= 0) {
        value = Math.pow(e, Math.log(b) / a); // \u4F7F\u7528\u6362\u5E95\u516C\u5F0F\u6C42\u5E95
    }
    else {
        value = Math.pow(e, Math.log(-b) / a) * -1; // \u4F7F\u7528\u6362\u5E95\u516C\u5F0F\u6C42\u5E95
    }
    return value;
}
function log(a, b) {
    if (a === 1) {
        return 1;
    }
    return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values, base, max) {
    if ((0,esm/* isNil */.UM)(max)) {
        max = Math.max.apply(null, values);
    }
    var positiveMin = max;
    (0,esm/* each */.S6)(values, function (value) {
        if (value > 0 && value < positiveMin) {
            positiveMin = value;
        }
    });
    if (positiveMin === max) {
        positiveMin = max / base;
    }
    if (positiveMin > 1) {
        positiveMin = 1;
    }
    return positiveMin;
}
function digitLength(num) {
    // Get digit length of e
    var eSplit = num.toString().split(/[eE]/);
    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
    return len > 0 ? len : 0;
}
/**
 * \u9AD8\u7CBE\u5EA6\u52A0\u6CD5\uFF0C\u89E3\u51B3 0.1 + 0.2 !== 0.3 \u7684\u7ECF\u5178\u95EE\u9898
 *
 * @param num1 \u52A0\u6570
 * @param num2 \u88AB\u52A0\u6570
 * @return {number} \u8FD4\u56DE\u503C
 */
function precisionAdd(num1, num2) {
    var num1Digits = digitLength(num1);
    var num2Digits = digitLength(num2);
    var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
    return (num1 * baseNum + num2 * baseNum) / baseNum;
}
//# sourceMappingURL=math.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/log.js



/**
 * Log \u5EA6\u91CF\uFF0C\u5904\u7406\u975E\u5747\u5300\u5206\u5E03
 */
var Log = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Log, _super);
    function Log() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'log';
        return _this;
    }
    /**
     * @override
     */
    Log.prototype.invert = function (value) {
        var base = this.base;
        var max = log(base, this.max);
        var rangeMin = this.rangeMin();
        var range = this.rangeMax() - rangeMin;
        var min;
        var positiveMin = this.positiveMin;
        if (positiveMin) {
            if (value === 0) {
                return 0;
            }
            min = log(base, positiveMin / base);
            var appendPercent = (1 / (max - min)) * range; // 0 \u5230 positiveMin\u7684\u5360\u6BD4
            if (value < appendPercent) {
                // \u843D\u5230 0 - positiveMin \u4E4B\u95F4
                return (value / appendPercent) * positiveMin;
            }
        }
        else {
            min = log(base, this.min);
        }
        var percent = (value - rangeMin) / range;
        var tmp = percent * (max - min) + min;
        return Math.pow(base, tmp);
    };
    Log.prototype.initCfg = function () {
        this.tickMethod = 'log';
        this.base = 10;
        this.tickCount = 6;
        this.nice = true;
    };
    // \u8BBE\u7F6E
    Log.prototype.setDomain = function () {
        _super.prototype.setDomain.call(this);
        var min = this.min;
        if (min < 0) {
            throw new Error('When you use log scale, the minimum value must be greater than zero!');
        }
        if (min === 0) {
            this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
        }
    };
    // \u6839\u636E\u5F53\u524D\u503C\u83B7\u53D6\u5360\u6BD4
    Log.prototype.getScalePercent = function (value) {
        var max = this.max;
        var min = this.min;
        if (max === min) {
            return 0;
        }
        // \u5982\u679C\u503C\u5C0F\u4E8E\u7B49\u4E8E0\uFF0C\u5219\u6309\u71670\u5904\u7406
        if (value <= 0) {
            return 0;
        }
        var base = this.base;
        var positiveMin = this.positiveMin;
        // \u5982\u679Cmin == 0, \u5219\u6839\u636E\u6BD40\u5927\u7684\u6700\u5C0F\u503C\uFF0C\u8BA1\u7B97\u6BD4\u4F8B\u5173\u7CFB\u3002\u8FD9\u4E2A\u6700\u5C0F\u503C\u4F5C\u4E3A\u5750\u6807\u8F74\u4E0A\u7684\u7B2C\u4E8C\u4E2Atick\uFF0C\u7B2C\u4E00\u4E2A\u662F0\u4F46\u662F\u4E0D\u663E\u793A
        if (positiveMin) {
            min = (positiveMin * 1) / base;
        }
        var percent;
        // \u5982\u679C\u6570\u503C\u5C0F\u4E8E\u6B21\u5C0F\u503C\uFF0C\u90A3\u4E48\u5C31\u8BA1\u7B97 value / \u6B21\u5C0F\u503C \u5360\u6574\u4F53\u7684\u6BD4\u4F8B
        if (value < positiveMin) {
            percent = value / positiveMin / (log(base, max) - log(base, min));
        }
        else {
            percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
        }
        return percent;
    };
    return Log;
}(continuous_base));
/* harmony default export */ var continuous_log = (Log);
//# sourceMappingURL=log.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/pow.js



/**
 * Pow \u5EA6\u91CF\uFF0C\u5904\u7406\u975E\u5747\u5300\u5206\u5E03
 */
var Pow = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Pow, _super);
    function Pow() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'pow';
        return _this;
    }
    /**
     * @override
     */
    Pow.prototype.invert = function (value) {
        var percent = this.getInvertPercent(value);
        var exponent = this.exponent;
        var max = calBase(exponent, this.max);
        var min = calBase(exponent, this.min);
        var tmp = percent * (max - min) + min;
        var factor = tmp >= 0 ? 1 : -1;
        return Math.pow(tmp, exponent) * factor;
    };
    Pow.prototype.initCfg = function () {
        this.tickMethod = 'pow';
        this.exponent = 2;
        this.tickCount = 5;
        this.nice = true;
    };
    // \u83B7\u53D6\u5EA6\u91CF\u8BA1\u7B97\u65F6\uFF0Cvalue\u5360\u7684\u5B9A\u4E49\u57DF\u767E\u5206\u6BD4
    Pow.prototype.getScalePercent = function (value) {
        var max = this.max;
        var min = this.min;
        if (max === min) {
            return 0;
        }
        var exponent = this.exponent;
        var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
        return percent;
    };
    return Pow;
}(continuous_base));
/* harmony default export */ var pow = (Pow);
//# sourceMappingURL=pow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/time.js




/**
 * \u65F6\u95F4\u5EA6\u91CF
 * @class
 */
var Time = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Time, _super);
    function Time() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'time';
        return _this;
    }
    /**
     * @override
     */
    Time.prototype.getText = function (value, index) {
        var numberValue = this.translate(value);
        var formatter = this.formatter;
        return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
    };
    /**
     * @override
     */
    Time.prototype.scale = function (value) {
        var v = value;
        if ((0,esm/* isString */.HD)(v) || (0,esm/* isDate */.J_)(v)) {
            v = this.translate(v);
        }
        return _super.prototype.scale.call(this, v);
    };
    /**
     * \u5C06\u65F6\u95F4\u8F6C\u6362\u6210\u6570\u5B57
     * @override
     */
    Time.prototype.translate = function (v) {
        return toTimeStamp(v);
    };
    Time.prototype.initCfg = function () {
        this.tickMethod = 'time-pretty';
        this.mask = 'YYYY-MM-DD';
        this.tickCount = 7;
        this.nice = false;
    };
    Time.prototype.setDomain = function () {
        var values = this.values;
        // \u662F\u5426\u8BBE\u7F6E\u4E86 min, max\uFF0C\u800C\u4E0D\u662F\u76F4\u63A5\u53D6 this.min, this.max
        var minConfig = this.getConfig('min');
        var maxConfig = this.getConfig('max');
        // \u5982\u679C\u8BBE\u7F6E\u4E86 min,max \u5219\u8F6C\u6362\u6210\u65F6\u95F4\u6233
        if (!(0,esm/* isNil */.UM)(minConfig) || !(0,esm/* isNumber */.hj)(minConfig)) {
            this.min = this.translate(this.min);
        }
        if (!(0,esm/* isNil */.UM)(maxConfig) || !(0,esm/* isNumber */.hj)(maxConfig)) {
            this.max = this.translate(this.max);
        }
        // \u6CA1\u6709\u8BBE\u7F6E min, max \u65F6
        if (values && values.length) {
            // \u91CD\u65B0\u8BA1\u7B97\u6700\u5927\u6700\u5C0F\u503C
            var timeStamps_1 = [];
            var min_1 = Infinity; // \u6700\u5C0F\u503C
            var secondMin_1 = min_1; // \u6B21\u5C0F\u503C
            var max_1 = 0;
            // \u4F7F\u7528\u4E00\u4E2A\u5FAA\u73AF\uFF0C\u8BA1\u7B97min,max,secondMin
            (0,esm/* each */.S6)(values, function (v) {
                var timeStamp = toTimeStamp(v);
                if (isNaN(timeStamp)) {
                    throw new TypeError("Invalid Time: " + v + " in time scale!");
                }
                if (min_1 > timeStamp) {
                    secondMin_1 = min_1;
                    min_1 = timeStamp;
                }
                else if (secondMin_1 > timeStamp) {
                    secondMin_1 = timeStamp;
                }
                if (max_1 < timeStamp) {
                    max_1 = timeStamp;
                }
                timeStamps_1.push(timeStamp);
            });
            // \u5B58\u5728\u591A\u4E2A\u503C\u65F6\uFF0C\u8BBE\u7F6E\u6700\u5C0F\u95F4\u8DDD
            if (values.length > 1) {
                this.minTickInterval = secondMin_1 - min_1;
            }
            if ((0,esm/* isNil */.UM)(minConfig)) {
                this.min = min_1;
            }
            if ((0,esm/* isNil */.UM)(maxConfig)) {
                this.max = max_1;
            }
        }
    };
    return Time;
}(linear));
/* harmony default export */ var continuous_time = (Time);
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/quantize.js



/**
 * \u5206\u6BB5\u5EA6\u91CF
 */
var Quantize = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Quantize, _super);
    function Quantize() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'quantize';
        return _this;
    }
    Quantize.prototype.invert = function (value) {
        var ticks = this.ticks;
        var length = ticks.length;
        var percent = this.getInvertPercent(value);
        var minIndex = Math.floor(percent * (length - 1));
        // \u6700\u540E\u4E00\u4E2A
        if (minIndex >= length - 1) {
            return (0,esm/* last */.Z$)(ticks);
        }
        // \u8D85\u51FA\u5DE6\u8FB9\u754C\uFF0C \u5219\u53D6\u7B2C\u4E00\u4E2A
        if (minIndex < 0) {
            return (0,esm/* head */.YM)(ticks);
        }
        var minTick = ticks[minIndex];
        var nextTick = ticks[minIndex + 1];
        // \u6BD4\u5F53\u524D\u503C\u5C0F\u7684 tick \u5728\u5EA6\u91CF\u4E0A\u7684\u5360\u6BD4
        var minIndexPercent = minIndex / (length - 1);
        var maxIndexPercent = (minIndex + 1) / (length - 1);
        return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
    };
    Quantize.prototype.initCfg = function () {
        this.tickMethod = 'r-pretty';
        this.tickCount = 5;
        this.nice = true;
    };
    Quantize.prototype.calculateTicks = function () {
        var ticks = _super.prototype.calculateTicks.call(this);
        if (!this.nice) { // \u5982\u679C nice = false ,\u8865\u5145 min, max
            if ((0,esm/* last */.Z$)(ticks) !== this.max) {
                ticks.push(this.max);
            }
            if ((0,esm/* head */.YM)(ticks) !== this.min) {
                ticks.unshift(this.min);
            }
        }
        return ticks;
    };
    // \u8BA1\u7B97\u5F53\u524D\u503C\u5728\u523B\u5EA6\u4E2D\u7684\u5360\u6BD4
    Quantize.prototype.getScalePercent = function (value) {
        var ticks = this.ticks;
        // \u8D85\u51FA\u5DE6\u8FB9\u754C
        if (value < (0,esm/* head */.YM)(ticks)) {
            return 0;
        }
        // \u8D85\u51FA\u53F3\u8FB9\u754C
        if (value > (0,esm/* last */.Z$)(ticks)) {
            return 1;
        }
        var minIndex = 0;
        (0,esm/* each */.S6)(ticks, function (tick, index) {
            if (value >= tick) {
                minIndex = index;
            }
            else {
                return false;
            }
        });
        return minIndex / (ticks.length - 1);
    };
    return Quantize;
}(continuous_base));
/* harmony default export */ var quantize = (Quantize);
//# sourceMappingURL=quantize.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/continuous/quantile.js


var Quantile = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Quantile, _super);
    function Quantile() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'quantile';
        return _this;
    }
    Quantile.prototype.initCfg = function () {
        this.tickMethod = 'quantile';
        this.tickCount = 5;
        this.nice = true;
    };
    return Quantile;
}(quantize));
/* harmony default export */ var quantile = (Quantile);
//# sourceMappingURL=quantile.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/factory.js

var map = {};
function getClass(key) {
    return map[key];
}
function registerClass(key, cls) {
    if (getClass(key)) {
        throw new Error("type '" + key + "' existed.");
    }
    map[key] = cls;
}

//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/identity/index.js



/**
 * identity scale\u539F\u5219\u4E0A\u662F\u5B9A\u4E49\u57DF\u548C\u503C\u57DF\u4E00\u81F4\uFF0Cscale/invert\u65B9\u6CD5\u4E5F\u662F\u4E00\u81F4\u7684
 * \u53C2\u8003R\u7684\u5B9E\u73B0\uFF1Ahttps://github.com/r-lib/scales/blob/master/R/pal-identity.r
 * \u53C2\u8003d3\u7684\u5B9E\u73B0\uFF08\u505A\u4E86\u4E0B\u8F6C\u578B\uFF09\uFF1Ahttps://github.com/d3/d3-scale/blob/master/src/identity.js
 */
var Identity = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Identity, _super);
    function Identity() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'identity';
        _this.isIdentity = true;
        return _this;
    }
    Identity.prototype.calculateTicks = function () {
        return this.values;
    };
    Identity.prototype.scale = function (value) {
        // \u5982\u679C\u4F20\u5165\u7684\u503C\u4E0D\u7B49\u4E8E identity \u7684\u503C\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE\uFF0C\u7528\u4E8E\u4E00\u7EF4\u56FE\u65F6\u7684 dodge
        if (this.values[0] !== value && (0,esm/* isNumber */.hj)(value)) {
            return value;
        }
        return this.range[0];
    };
    Identity.prototype.invert = function (value) {
        var range = this.range;
        if (value < range[0] || value > range[1]) {
            return NaN;
        }
        return this.values[0];
    };
    return Identity;
}(esm_base));
/* harmony default export */ var identity = (Identity);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/cat.js

/**
 * \u8BA1\u7B97\u5206\u7C7B ticks
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function calculateCatTicks(cfg) {
    var values = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
    if ((0,esm/* isNumber */.hj)(tickInterval)) {
        var ticks_1 = (0,esm/* filter */.hX)(values, function (__, i) { return i % tickInterval === 0; });
        var lastValue = (0,esm/* last */.Z$)(values);
        if (showLast && (0,esm/* last */.Z$)(ticks_1) !== lastValue) {
            ticks_1.push(lastValue);
        }
        return ticks_1;
    }
    var len = values.length;
    var min = cfg.min, max = cfg.max;
    if ((0,esm/* isNil */.UM)(min)) {
        min = 0;
    }
    if ((0,esm/* isNil */.UM)(max)) {
        max = values.length - 1;
    }
    if (!(0,esm/* isNumber */.hj)(tickCount) || tickCount >= len)
        return values.slice(min, max + 1);
    if (tickCount <= 0 || max <= 0)
        return [];
    var interval = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
    var ticks = [];
    var idx = min;
    for (var i = 0; i < tickCount; i++) {
        if (idx >= max)
            break;
        idx = Math.min(min + i * interval, max);
        if (i === tickCount - 1 && showLast)
            ticks.push(values[max]);
        else
            ticks.push(values[idx]);
    }
    return ticks;
}
//# sourceMappingURL=cat.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
    var min = cfg.min, max = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
    var linear = new D3Linear();
    linear.domain([min, max]);
    if (nice) {
        linear.nice(tickCount);
    }
    return linear.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
// https://github.com/d3/d3-scale
var D3Linear = /** @class */ (function () {
    function D3Linear() {
        this._domain = [0, 1];
    }
    D3Linear.prototype.domain = function (domain) {
        if (domain) {
            this._domain = Array.from(domain, Number);
            return this;
        }
        return this._domain.slice();
    };
    D3Linear.prototype.nice = function (count) {
        var _a, _b;
        if (count === void 0) { count = DEFAULT_COUNT; }
        var d = this._domain.slice();
        var i0 = 0;
        var i1 = this._domain.length - 1;
        var start = this._domain[i0];
        var stop = this._domain[i1];
        var step;
        if (stop < start) {
            _a = [stop, start], start = _a[0], stop = _a[1];
            _b = [i1, i0], i0 = _b[0], i1 = _b[1];
        }
        step = tickIncrement(start, stop, count);
        if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
            step = tickIncrement(start, stop, count);
        }
        else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
            step = tickIncrement(start, stop, count);
        }
        if (step > 0) {
            d[i0] = Math.floor(start / step) * step;
            d[i1] = Math.ceil(stop / step) * step;
            this.domain(d);
        }
        else if (step < 0) {
            d[i0] = Math.ceil(start * step) / step;
            d[i1] = Math.floor(stop * step) / step;
            this.domain(d);
        }
        return this;
    };
    D3Linear.prototype.ticks = function (count) {
        if (count === void 0) { count = DEFAULT_COUNT; }
        return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
    };
    return D3Linear;
}());

function d3ArrayTicks(start, stop, count) {
    var reverse;
    var i = -1;
    var n;
    var ticks;
    var step;
    (stop = +stop), (start = +start), (count = +count);
    if (start === stop && count > 0) {
        return [start];
    }
    // tslint:disable-next-line
    if ((reverse = stop < start)) {
        (n = start), (start = stop), (stop = n);
    }
    // tslint:disable-next-line
    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
        return [];
    }
    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array((n = Math.ceil(stop - start + 1)));
        while (++i < n) {
            ticks[i] = (start + i) * step;
        }
    }
    else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array((n = Math.ceil(start - stop + 1)));
        while (++i < n) {
            ticks[i] = (start - i) / step;
        }
    }
    if (reverse) {
        ticks.reverse();
    }
    return ticks;
}
function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count);
    var power = Math.floor(Math.log(step) / Math.LN10);
    var error = step / Math.pow(10, power);
    return power >= 0
        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
//# sourceMappingURL=d3-linear.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/interval.js

function snapMultiple(v, base, snapType) {
    var div;
    if (snapType === 'ceil') {
        div = Math.ceil(v / base);
    }
    else if (snapType === 'floor') {
        div = Math.floor(v / base);
    }
    else {
        div = Math.round(v / base);
    }
    return div * base;
}
function intervalTicks(min, max, interval) {
    // \u53D8\u6210 interval \u7684\u500D\u6570
    var minTick = snapMultiple(min, interval, 'floor');
    var maxTick = snapMultiple(max, interval, 'ceil');
    // \u7EDF\u4E00\u5C0F\u6570\u4F4D\u6570
    minTick = (0,esm/* fixedBase */.ri)(minTick, interval);
    maxTick = (0,esm/* fixedBase */.ri)(maxTick, interval);
    var ticks = [];
    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
    var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval);
    for (var i = minTick; i <= maxTick; i = i + availableInterval) {
        var tickValue = (0,esm/* fixedBase */.ri)(i, availableInterval); // \u9632\u6B62\u6D6E\u70B9\u6570\u52A0\u6CD5\u51FA\u73B0\u95EE\u9898
        ticks.push(tickValue);
    }
    return {
        min: minTick,
        max: maxTick,
        ticks: ticks
    };
}
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/strict-limit.js

/**
 * \u6309\u7167\u7ED9\u5B9A\u7684 minLimit/maxLimit/tickCount \u5747\u5300\u8BA1\u7B97\u51FA\u523B\u5EA6 ticks
 *
 * @param cfg Scale \u914D\u7F6E\u9879
 * @return ticks
 */
function strictLimit(cfg, defaultMin, defaultMax) {
    var _a;
    var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min = cfg.min, max = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
    var tickMin = (0,esm/* isNil */.UM)(minLimit) ? ((0,esm/* isNil */.UM)(defaultMin) ? min : defaultMin) : minLimit;
    var tickMax = (0,esm/* isNil */.UM)(maxLimit) ? ((0,esm/* isNil */.UM)(defaultMax) ? max : defaultMax) : maxLimit;
    if (tickMin > tickMax) {
        _a = [tickMin, tickMax], tickMax = _a[0], tickMin = _a[1];
    }
    if (tickCount <= 2) {
        return [tickMin, tickMax];
    }
    var step = (tickMax - tickMin) / (tickCount - 1);
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
        ticks.push(tickMin + step * i);
    }
    return ticks;
}
//# sourceMappingURL=strict-limit.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/d3-linear.js




function d3LinearTickMethod(cfg) {
    var min = cfg.min, max = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = d3Linear(cfg);
    if (!(0,esm/* isNil */.UM)(minLimit) || !(0,esm/* isNil */.UM)(maxLimit)) {
        return strictLimit(cfg, (0,esm/* head */.YM)(ticks), (0,esm/* last */.Z$)(ticks));
    }
    if (tickInterval) {
        return intervalTicks(min, max, tickInterval).ticks;
    }
    return ticks;
}
//# sourceMappingURL=d3-linear.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/pretty-number.js
// \u4E3A\u4E86\u89E3\u51B3 js \u8FD0\u7B97\u7684\u7CBE\u5EA6\u95EE\u9898
function prettyNumber(n) {
    return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}
//# sourceMappingURL=pretty-number.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/extended.js


var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var ALL_Q = (/* unused pure expression or super */ null && ([1, 5, 2, 2.5, 4, 3, 1.5, 7, 6, 8, 9]));
var eps = Number.EPSILON * 100;
function mod(n, m) {
    return ((n % m) + m) % m;
}
function round(n) {
    return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
    var n = (0,esm/* size */.dp)(Q);
    var i = (0,esm/* indexOf */.cq)(Q, q);
    var v = 0;
    var m = mod(lmin, lstep);
    if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
        v = 1;
    }
    return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
    var n = (0,esm/* size */.dp)(Q);
    var i = (0,esm/* indexOf */.cq)(Q, q);
    var v = 1;
    return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
    var r = (k - 1) / (lMax - lMin);
    var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
    return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
    if (k >= m) {
        return 2 - (k - 1) / (m - 1);
    }
    return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
    var range = dMax - dMin;
    return 1 - (0.5 * (Math.pow((dMax - lMax), 2) + Math.pow((dMin - lMin), 2))) / Math.pow((0.1 * range), 2);
}
function coverageMax(dMin, dMax, span) {
    var range = dMax - dMin;
    if (span > range) {
        var half = (span - range) / 2;
        return 1 - Math.pow(half, 2) / Math.pow((0.1 * range), 2);
    }
    return 1;
}
function legibility() {
    return 1;
}
/**
 * An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes
 * https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf
 * @param dMin \u6700\u5C0F\u503C
 * @param dMax \u6700\u5927\u503C
 * @param m tick\u4E2A\u6570
 * @param onlyLoose \u662F\u5426\u5141\u8BB8\u6269\u5C55min\u3001max\uFF0C\u4E0D\u7EDD\u5BF9\u5F3A\u5236\uFF0C\u4F8B\u5982[3, 97]
 * @param Q nice numbers\u96C6\u5408
 * @param w \u56DB\u4E2A\u4F18\u5316\u7EC4\u4EF6\u7684\u6743\u91CD
 */
function extended(dMin, dMax, n, onlyLoose, Q, w) {
    if (n === void 0) { n = 5; }
    if (onlyLoose === void 0) { onlyLoose = true; }
    if (Q === void 0) { Q = DEFAULT_Q; }
    if (w === void 0) { w = [0.25, 0.2, 0.5, 0.05]; }
    // \u5904\u7406\u5C0F\u4E8E 0 \u548C\u5C0F\u6570\u7684 tickCount
    var m = n < 0 ? 0 : Math.round(n);
    // nan \u4E5F\u4F1A\u5BFC\u81F4\u5F02\u5E38
    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== 'number' || typeof dMax !== 'number' || !m) {
        return {
            min: 0,
            max: 0,
            ticks: [],
        };
    }
    // js \u6781\u5927\u503C\u6781\u5C0F\u503C\u95EE\u9898\uFF0C\u5DEE\u503C\u5C0F\u4E8E 1e-15 \u4F1A\u5BFC\u81F4\u8BA1\u7B97\u51FA\u9519
    if (dMax - dMin < 1e-15 || m === 1) {
        return {
            min: dMin,
            max: dMax,
            ticks: [dMin],
        };
    }
    // js \u8D85\u5927\u503C\u95EE\u9898
    if (dMax - dMin > 1e148) {
        var count = n || 5;
        var step_1 = (dMax - dMin) / count;
        return {
            min: dMin,
            max: dMax,
            ticks: Array(count).fill(null).map(function (_, idx) {
                return prettyNumber(dMin + step_1 * idx);
            }),
        };
    }
    var best = {
        score: -2,
        lmin: 0,
        lmax: 0,
        lstep: 0,
    };
    var j = 1;
    while (j < Infinity) {
        for (var i = 0; i < Q.length; i += 1) {
            var q = Q[i];
            var sm = simplicityMax(q, Q, j);
            if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
                j = Infinity;
                break;
            }
            var k = 2;
            while (k < Infinity) {
                var dm = densityMax(k, m);
                if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
                    break;
                }
                var delta = (dMax - dMin) / (k + 1) / j / q;
                var z = Math.ceil(Math.log10(delta));
                while (z < Infinity) {
                    var step = j * q * Math.pow(10, z);
                    var cm = coverageMax(dMin, dMax, step * (k - 1));
                    if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
                        break;
                    }
                    var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
                    var maxStart = Math.ceil(dMin / step) * j;
                    if (minStart <= maxStart) {
                        var count = maxStart - minStart;
                        for (var i_1 = 0; i_1 <= count; i_1 += 1) {
                            var start = minStart + i_1;
                            var lMin = start * (step / j);
                            var lMax = lMin + step * (k - 1);
                            var lStep = step;
                            var s = simplicity(q, Q, j, lMin, lMax, lStep);
                            var c = coverage(dMin, dMax, lMin, lMax);
                            var g = density(k, m, dMin, dMax, lMin, lMax);
                            var l = legibility();
                            var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
                            if (score > best.score && (!onlyLoose || (lMin <= dMin && lMax >= dMax))) {
                                best.lmin = lMin;
                                best.lmax = lMax;
                                best.lstep = lStep;
                                best.score = score;
                            }
                        }
                    }
                    z += 1;
                }
                k += 1;
            }
        }
        j += 1;
    }
    // \u5904\u7406\u7CBE\u5EA6\u95EE\u9898\uFF0C\u4FDD\u8BC1\u8FD9\u4E09\u4E2A\u6570\u6CA1\u6709\u7CBE\u5EA6\u95EE\u9898
    var lmax = prettyNumber(best.lmax);
    var lmin = prettyNumber(best.lmin);
    var lstep = prettyNumber(best.lstep);
    // \u52A0 round \u662F\u4E3A\u5904\u7406 extended(0.94, 1, 5)
    // \u4FDD\u8BC1\u751F\u6210\u7684 tickCount \u6CA1\u6709\u7CBE\u5EA6\u95EE\u9898
    var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
    var ticks = new Array(tickCount);
    // \u5C11\u7528\u4E58\u6CD5\uFF1A\u9632\u6B62\u51FA\u73B0 -1.2 + 1.2 * 3 = 2.3999999999999995 \u7684\u60C5\u51B5
    ticks[0] = prettyNumber(lmin);
    for (var i = 1; i < tickCount; i++) {
        ticks[i] = prettyNumber(ticks[i - 1] + lstep);
    }
    return {
        min: Math.min(dMin, (0,esm/* head */.YM)(ticks)),
        max: Math.max(dMax, (0,esm/* last */.Z$)(ticks)),
        ticks: ticks,
    };
}
//# sourceMappingURL=extended.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/linear.js




/**
 * \u8BA1\u7B97\u7EBF\u6027\u7684 ticks\uFF0C\u4F7F\u7528 wilkinson extended \u65B9\u6CD5
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function linear_linear(cfg) {
    var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = extended(min, max, tickCount, nice).ticks;
    if (!(0,esm/* isNil */.UM)(minLimit) || !(0,esm/* isNil */.UM)(maxLimit)) {
        return strictLimit(cfg, (0,esm/* head */.YM)(ticks), (0,esm/* last */.Z$)(ticks));
    }
    if (tickInterval) {
        return intervalTicks(min, max, tickInterval).ticks;
    }
    return ticks;
}
//# sourceMappingURL=linear.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/log.js

/**
 * \u8BA1\u7B97 log \u7684 ticks\uFF0C\u8003\u8651 min = 0 \u7684\u573A\u666F
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function calculateLogTicks(cfg) {
    var base = cfg.base, tickCount = cfg.tickCount, min = cfg.min, max = cfg.max, values = cfg.values;
    var minTick;
    var maxTick = log(base, max);
    if (min > 0) {
        minTick = Math.floor(log(base, min));
    }
    else {
        var positiveMin = getLogPositiveMin(values, base, max);
        minTick = Math.floor(log(base, positiveMin));
    }
    var count = maxTick - minTick;
    var avg = Math.ceil(count / tickCount);
    var ticks = [];
    for (var i = minTick; i < maxTick + avg; i = i + avg) {
        ticks.push(Math.pow(base, i));
    }
    if (min <= 0) {
        // \u6700\u5C0F\u503C <= 0 \u65F6\u663E\u793A 0
        ticks.unshift(0);
    }
    return ticks;
}
//# sourceMappingURL=log.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/util/pretty.js

function pretty(min, max, m) {
    if (m === void 0) { m = 5; }
    if (min === max) {
        return {
            max: max,
            min: min,
            ticks: [min],
        };
    }
    var n = m < 0 ? 0 : Math.round(m);
    if (n === 0)
        return { max: max, min: min, ticks: [] };
    /*
      R pretty:
      https://svn.r-project.org/R/trunk/src/appl/pretty.c
      https://www.rdocumentation.org/packages/base/versions/3.5.2/topics/pretty
      */
    var h = 1.5; // high.u.bias
    var h5 = 0.5 + 1.5 * h; // u5.bias
    // \u53CD\u6B63\u6211\u4E5F\u4E0D\u4F1A\u8C03\u53C2\uFF0C\u8DF3\u8FC7\u6240\u6709\u5224\u65AD\u6B65\u9AA4
    var d = max - min;
    var c = d / n;
    // \u5F53d\u975E\u5E38\u5C0F\u7684\u65F6\u5019\u89E6\u53D1\uFF0C\u4F46\u4F3C\u4E4E\u6CA1\u4EC0\u4E48\u7528
    // const min_n = Math.floor(n / 3);
    // const shrink_sml = Math.pow(2, 5);
    // if (Math.log10(d) < -2) {
    //   c = (_.max([ Math.abs(max), Math.abs(min) ]) * shrink_sml) / min_n;
    // }
    var base = Math.pow(10, Math.floor(Math.log10(c)));
    var unit = base;
    if (2 * base - c < h * (c - unit)) {
        unit = 2 * base;
        if (5 * base - c < h5 * (c - unit)) {
            unit = 5 * base;
            if (10 * base - c < h * (c - unit)) {
                unit = 10 * base;
            }
        }
    }
    var nu = Math.ceil(max / unit);
    var ns = Math.floor(min / unit);
    var hi = Math.max(nu * unit, max);
    var lo = Math.min(ns * unit, min);
    var size = Math.floor((hi - lo) / unit) + 1;
    var ticks = new Array(size);
    for (var i = 0; i < size; i++) {
        ticks[i] = prettyNumber(lo + i * unit);
    }
    return {
        min: lo,
        max: hi,
        ticks: ticks,
    };
}
//# sourceMappingURL=pretty.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/pow.js


/**
 * \u8BA1\u7B97 Pow \u7684 ticks
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function calculatePowTicks(cfg) {
    var exponent = cfg.exponent, tickCount = cfg.tickCount;
    var max = Math.ceil(calBase(exponent, cfg.max));
    var min = Math.floor(calBase(exponent, cfg.min));
    var ticks = pretty(min, max, tickCount).ticks;
    return ticks.map(function (tick) {
        var factor = tick >= 0 ? 1 : -1;
        return Math.pow(tick, exponent) * factor;
    });
}
//# sourceMappingURL=pow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/quantile.js
/**
 * \u8BA1\u7B97\u51E0\u5206\u4F4D https://github.com/simple-statistics/simple-statistics/blob/master/src/quantile_sorted.js
 * @param x  \u6570\u7EC4
 * @param p  \u767E\u5206\u6BD4
 */
function quantileSorted(x, p) {
    var idx = x.length * p;
    /*if (x.length === 0) { // \u5F53\u524D\u573A\u666F\u8FD9\u4E9B\u6761\u4EF6\u4E0D\u53EF\u80FD\u547D\u4E2D
      throw new Error('quantile requires at least one value.');
    } else if (p < 0 || p > 1) {
      throw new Error('quantiles must be between 0 and 1');
    } else */
    if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    }
    else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    }
    else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    }
    else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    }
    else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}
function calculateTicks(cfg) {
    var tickCount = cfg.tickCount, values = cfg.values;
    if (!values || !values.length) {
        return [];
    }
    var sorted = values.slice().sort(function (a, b) {
        return a - b;
    });
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
        var p = i / (tickCount - 1);
        ticks.push(quantileSorted(sorted, p));
    }
    return ticks;
}
//# sourceMappingURL=quantile.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/r-prettry.js




/**
 * \u8BA1\u7B97\u7EBF\u6027\u7684 ticks\uFF0C\u4F7F\u7528 R's pretty \u65B9\u6CD5
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function linearPretty(cfg) {
    var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = pretty(min, max, tickCount).ticks;
    if (!(0,esm/* isNil */.UM)(minLimit) || !(0,esm/* isNil */.UM)(maxLimit)) {
        return strictLimit(cfg, (0,esm/* head */.YM)(ticks), (0,esm/* last */.Z$)(ticks));
    }
    if (tickInterval) {
        return intervalTicks(min, max, tickInterval).ticks;
    }
    return ticks;
}
//# sourceMappingURL=r-prettry.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/time.js

function calculateTimeTicks(cfg) {
    var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval;
    var tickInterval = cfg.tickInterval;
    var tickCount = cfg.tickCount;
    // \u6307\u5B9A tickInterval \u540E tickCount \u4E0D\u751F\u6548\uFF0C\u9700\u8981\u91CD\u65B0\u8BA1\u7B97
    if (tickInterval) {
        tickCount = Math.ceil((max - min) / tickInterval);
    }
    else {
        tickInterval = getTickInterval(min, max, tickCount)[1];
        var count = (max - min) / tickInterval;
        var ratio = count / tickCount;
        if (ratio > 1) {
            tickInterval = tickInterval * Math.ceil(ratio);
        }
        // \u5982\u679C\u8BBE\u7F6E\u4E86\u6700\u5C0F\u95F4\u8DDD\uFF0C\u5219\u4F7F\u7528\u6700\u5C0F\u95F4\u8DDD
        if (minTickInterval && tickInterval < minTickInterval) {
            tickInterval = minTickInterval;
        }
    }
    tickInterval = Math.max(Math.floor((max - min) / (Math.pow(2, 12) - 1)), tickInterval);
    var ticks = [];
    for (var i = min; i < max + tickInterval; i += tickInterval) {
        ticks.push(i);
    }
    return ticks;
}
//# sourceMappingURL=time.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/time-cat.js


/**
 * \u8BA1\u7B97\u65F6\u95F4\u5206\u7C7B\u7684 ticks, \u4FDD\u5934\uFF0C\u4FDD\u5C3E
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function timeCat(cfg) {
    // \u9ED8\u8BA4\u4FDD\u7559\u6700\u540E\u4E00\u6761
    var ticks = calculateCatTicks((0,tslib_es6/* __assign */.pi)({ showLast: true }, cfg));
    return ticks;
}
//# sourceMappingURL=time-cat.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/time-pretty.js

function getYear(date) {
    return new Date(date).getFullYear();
}
function createYear(year) {
    return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
    return new Date(date).getMonth();
}
function diffMonth(min, max) {
    var minYear = getYear(min);
    var maxYear = getYear(max);
    var minMonth = getMonth(min);
    var maxMonth = getMonth(max);
    return (maxYear - minYear) * 12 + ((maxMonth - minMonth) % 12);
}
function creatMonth(year, month) {
    return new Date(year, month, 1).getTime();
}
function diffDay(min, max) {
    return Math.ceil((max - min) / DAY);
}
function diffHour(min, max) {
    return Math.ceil((max - min) / HOUR);
}
function diffMinus(min, max) {
    return Math.ceil((max - min) / (60 * 1000));
}
/**
 * \u8BA1\u7B97 time \u7684 ticks\uFF0C\u5BF9 month, year \u8FDB\u884C pretty \u5904\u7406
 * @param cfg \u5EA6\u91CF\u7684\u914D\u7F6E\u9879
 * @returns \u8BA1\u7B97\u540E\u7684 ticks
 */
function timePretty(cfg) {
    var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
    var tickInterval = cfg.tickInterval;
    var ticks = [];
    // \u6307\u5B9A tickInterval \u540E tickCount \u4E0D\u751F\u6548\uFF0C\u9700\u8981\u91CD\u65B0\u8BA1\u7B97
    if (!tickInterval) {
        tickInterval = (max - min) / tickCount;
        // \u5982\u679C\u8BBE\u7F6E\u4E86\u6700\u5C0F\u95F4\u8DDD\uFF0C\u5219\u4F7F\u7528\u6700\u5C0F\u95F4\u8DDD
        if (minTickInterval && tickInterval < minTickInterval) {
            tickInterval = minTickInterval;
        }
    }
    tickInterval = Math.max(Math.floor((max - min) / (Math.pow(2, 12) - 1)), tickInterval);
    var minYear = getYear(min);
    // \u5982\u679C\u95F4\u8DDD\u5927\u4E8E 1 \u5E74\uFF0C\u5219\u5C06\u5F00\u59CB\u65E5\u671F\u4ECE\u6574\u5E74\u5F00\u59CB
    if (tickInterval > YEAR) {
        var maxYear = getYear(max);
        var yearInterval = Math.ceil(tickInterval / YEAR);
        for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
            ticks.push(createYear(i));
        }
    }
    else if (tickInterval > MONTH) {
        // \u5927\u4E8E\u6708\u65F6
        var monthInterval = Math.ceil(tickInterval / MONTH);
        var mmMoth = getMonth(min);
        var dMonths = diffMonth(min, max);
        for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
            ticks.push(creatMonth(minYear, i + mmMoth));
        }
    }
    else if (tickInterval > DAY) {
        // \u5927\u4E8E\u5929
        var date = new Date(min);
        var year = date.getFullYear();
        var month = date.getMonth();
        var mday = date.getDate();
        var day = Math.ceil(tickInterval / DAY);
        var ddays = diffDay(min, max);
        for (var i = 0; i < ddays + day; i = i + day) {
            ticks.push(new Date(year, month, mday + i).getTime());
        }
    }
    else if (tickInterval > HOUR) {
        // \u5927\u4E8E\u5C0F\u65F6
        var date = new Date(min);
        var year = date.getFullYear();
        var month = date.getMonth();
        var day = date.getDate();
        var hour = date.getHours();
        var hours = Math.ceil(tickInterval / HOUR);
        var dHours = diffHour(min, max);
        for (var i = 0; i <= dHours + hours; i = i + hours) {
            ticks.push(new Date(year, month, day, hour + i).getTime());
        }
    }
    else if (tickInterval > MINUTE) {
        // \u5927\u4E8E\u5206\u949F
        var dMinus = diffMinus(min, max);
        var minutes = Math.ceil(tickInterval / MINUTE);
        for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
            ticks.push(min + i * MINUTE);
        }
    }
    else {
        // \u5C0F\u4E8E\u5206\u949F
        var interval = tickInterval;
        if (interval < SECOND) {
            interval = SECOND;
        }
        var minSecond = Math.floor(min / SECOND) * SECOND;
        var dSeconds = Math.ceil((max - min) / SECOND);
        var seconds = Math.ceil(interval / SECOND);
        for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
            ticks.push(minSecond + i * SECOND);
        }
    }
    // \u6700\u597D\u662F\u80FD\u4ECE\u7B97\u6CD5\u80FD\u89E3\u51B3\u8FD9\u4E2A\u95EE\u9898\uFF0C\u4F46\u662F\u5982\u679C\u6307\u5B9A\u4E86 tickInterval\uFF0C\u8BA1\u7B97 ticks\uFF0C\u4E5F\u53EA\u80FD\u8FD9\u4E48\u7B97\uFF0C\u6240\u4EE5
    // \u6253\u5370\u8B66\u544A\u63D0\u793A
    if (ticks.length >= 512) {
        console.warn("Notice: current ticks length(" + ticks.length + ") >= 512, may cause performance issues, even out of memory. Because of the configure \\"tickInterval\\"(in milliseconds, current is " + tickInterval + ") is too small, increase the value to solve the problem!");
    }
    return ticks;
}
//# sourceMappingURL=time-pretty.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/tick-method/index.js











registerTickMethod('cat', calculateCatTicks);
registerTickMethod('time-cat', timeCat);
registerTickMethod('wilkinson-extended', linear_linear);
registerTickMethod('r-pretty', linearPretty);
registerTickMethod('time', calculateTimeTicks);
registerTickMethod('time-pretty', timePretty);
registerTickMethod('log', calculateLogTicks);
registerTickMethod('pow', calculatePowTicks);
registerTickMethod('quantile', calculateTicks);
registerTickMethod('d3-linear', d3LinearTickMethod);

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/scale/esm/index.js












registerClass('cat', category_base);
registerClass('category', category_base);
registerClass('identity', identity);
registerClass('linear', linear);
registerClass('log', continuous_log);
registerClass('pow', pow);
registerClass('time', continuous_time);
registerClass('timeCat', time);
registerClass('quantize', quantize);
registerClass('quantile', quantile);

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/interface.js


//# sourceMappingURL=interface.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/factory.js

// \u6240\u6709\u7684 attribute map
var ATTRIBUTE_MAP = {};
/**
 * \u901A\u8FC7\u7C7B\u578B\u83B7\u5F97 Attribute \u7C7B
 * @param type
 */
var getAttribute = function (type) {
    return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function (type, ctor) {
    // \u6CE8\u518C\u7684\u65F6\u5019\uFF0C\u9700\u8981\u6821\u9A8C type \u91CD\u540D\uFF0C\u4E0D\u533A\u5206\u5927\u5C0F\u5199
    if (getAttribute(type)) {
        throw new Error("Attribute type '".concat(type, "' existed."));
    }
    // \u5B58\u50A8\u5230 map \u4E2D
    ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};


//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/attr/esm/index.js







registerAttribute('Color', color);
registerAttribute('Opacity', opacity);
registerAttribute('Position', position);
registerAttribute('Shape', shape);
registerAttribute('Size', size);


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/common.js
var common = __webpack_require__(49685);
;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new common/* ARRAY_TYPE */.WT(3);

  if (common/* ARRAY_TYPE */.WT != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function vec3_length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function vec3_round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function vec3_distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = (/* unused pure expression or super */ null && (subtract));
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = (/* unused pure expression or super */ null && (multiply));
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = (/* unused pure expression or super */ null && (divide));
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = (/* unused pure expression or super */ null && (vec3_distance));
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = (/* unused pure expression or super */ null && (squaredDistance));
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = (/* unused pure expression or super */ null && (vec3_length));
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = (/* unused pure expression or super */ null && (squaredLength));
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat3.js
var mat3 = __webpack_require__(35600);
// EXTERNAL MODULE: ./node_modules/@antv/matrix-util/esm/ext.js
var ext = __webpack_require__(31506);
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/coord/base.js



/**
 * Coordinate Base Class
 */
var Coordinate = /** @class */ (function () {
    function Coordinate(cfg) {
        // \u81EA\u8EAB\u5C5E\u6027
        this.type = 'coordinate';
        this.isRect = false;
        this.isHelix = false;
        this.isPolar = false;
        this.isReflectX = false;
        this.isReflectY = false;
        var start = cfg.start, end = cfg.end, _a = cfg.matrix, matrix = _a === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
        this.start = start;
        this.end = end;
        this.matrix = matrix;
        this.originalMatrix = (0,tslib_es6/* __spreadArray */.ev)([], matrix); // \u53BB\u9664\u5F15\u7528
        this.isTransposed = isTransposed;
    }
    /**
     * \u521D\u59CB\u5316\u6D41\u7A0B
     */
    Coordinate.prototype.initial = function () {
        // center\u3001width\u3001height
        this.center = {
            x: (this.start.x + this.end.x) / 2,
            y: (this.start.y + this.end.y) / 2,
        };
        this.width = Math.abs(this.end.x - this.start.x);
        this.height = Math.abs(this.end.y - this.start.y);
    };
    /**
     * \u66F4\u65B0\u914D\u7F6E
     * @param cfg
     */
    Coordinate.prototype.update = function (cfg) {
        (0,esm/* assign */.f0)(this, cfg);
        this.initial();
    };
    Coordinate.prototype.convertDim = function (percent, dim) {
        var _a;
        var _b = this[dim], start = _b.start, end = _b.end;
        // \u4EA4\u6362
        if (this.isReflect(dim)) {
            _a = [end, start], start = _a[0], end = _a[1];
        }
        return start + percent * (end - start);
    };
    Coordinate.prototype.invertDim = function (value, dim) {
        var _a;
        var _b = this[dim], start = _b.start, end = _b.end;
        // \u4EA4\u6362
        if (this.isReflect(dim)) {
            _a = [end, start], start = _a[0], end = _a[1];
        }
        return (value - start) / (end - start);
    };
    /**
     * \u5C06\u5750\u6807\u70B9\u8FDB\u884C\u77E9\u9635\u53D8\u6362
     * @param x   \u5BF9\u5E94 x \u8F74\u753B\u5E03\u5750\u6807
     * @param y   \u5BF9\u5E94 y \u8F74\u753B\u5E03\u5750\u6807
     * @param tag \u9ED8\u8BA4\u4E3A 0\uFF0C\u53EF\u53D6\u503C 0, 1
     * @return    \u8FD4\u56DE\u53D8\u6362\u540E\u7684\u4E09\u9636\u5411\u91CF [x, y, z]
     */
    Coordinate.prototype.applyMatrix = function (x, y, tag) {
        if (tag === void 0) { tag = 0; }
        var matrix = this.matrix;
        var vector = [x, y, tag];
        transformMat3(vector, vector, matrix);
        return vector;
    };
    /**
     * \u5C06\u5750\u6807\u70B9\u8FDB\u884C\u77E9\u9635\u9006\u53D8\u6362
     * @param x   \u5BF9\u5E94 x \u8F74\u753B\u5E03\u5750\u6807
     * @param y   \u5BF9\u5E94 y \u8F74\u753B\u5E03\u5750\u6807
     * @param tag \u9ED8\u8BA4\u4E3A 0\uFF0C\u53EF\u53D6\u503C 0, 1
     * @return    \u8FD4\u56DE\u77E9\u9635\u9006\u53D8\u6362\u540E\u7684\u4E09\u9636\u5411\u91CF [x, y, z]
     */
    Coordinate.prototype.invertMatrix = function (x, y, tag) {
        if (tag === void 0) { tag = 0; }
        var matrix = this.matrix;
        var inverted = mat3/* invert */.U_([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
        var vector = [x, y, tag];
        if (inverted) {
            // \u5982\u679C\u4E3A\u7A7A\u5219\u4E0D\u8FDB\u884C\u77E9\u9635\u53D8\u5316\uFF0C\u9632\u6B62\u62A5\u9519
            transformMat3(vector, vector, inverted);
        }
        return vector;
    };
    /**
     * \u5C06\u5F52\u4E00\u5316\u7684\u5750\u6807\u70B9\u6570\u636E\u8F6C\u6362\u4E3A\u753B\u5E03\u5750\u6807\uFF0C\u5E76\u6839\u636E\u5750\u6807\u7CFB\u5F53\u524D\u77E9\u9635\u8FDB\u884C\u53D8\u6362
     * @param point \u5F52\u4E00\u5316\u7684\u5750\u6807\u70B9
     * @return      \u8FD4\u56DE\u8FDB\u884C\u77E9\u9635\u53D8\u6362\u540E\u7684\u753B\u5E03\u5750\u6807
     */
    Coordinate.prototype.convert = function (point) {
        var _a = this.convertPoint(point), x = _a.x, y = _a.y;
        var vector = this.applyMatrix(x, y, 1);
        return {
            x: vector[0],
            y: vector[1],
        };
    };
    /**
     * \u5C06\u8FDB\u884C\u8FC7\u77E9\u9635\u53D8\u6362\u753B\u5E03\u5750\u6807\u8F6C\u6362\u4E3A\u5F52\u4E00\u5316\u5750\u6807
     * @param point \u753B\u5E03\u5750\u6807
     * @return      \u8FD4\u56DE\u5F52\u4E00\u5316\u7684\u5750\u6807\u70B9
     */
    Coordinate.prototype.invert = function (point) {
        var vector = this.invertMatrix(point.x, point.y, 1);
        return this.invertPoint({
            x: vector[0],
            y: vector[1],
        });
    };
    /**
     * \u5750\u6807\u7CFB\u65CB\u8F6C\u53D8\u6362
     * @param  radian \u65CB\u8F6C\u5F27\u5EA6
     * @return        \u8FD4\u56DE\u5750\u6807\u7CFB\u5BF9\u8C61
     */
    Coordinate.prototype.rotate = function (radian) {
        var matrix = this.matrix;
        var center = this.center;
        ext/* leftTranslate */.m$(matrix, matrix, [-center.x, -center.y]);
        ext/* leftRotate */.zu(matrix, matrix, radian);
        ext/* leftTranslate */.m$(matrix, matrix, [center.x, center.y]);
        return this;
    };
    /**
     * \u5750\u6807\u7CFB\u53CD\u5C04\u53D8\u6362
     * @param dim \u53CD\u5C04\u7EF4\u5EA6
     * @return    \u8FD4\u56DE\u5750\u6807\u7CFB\u5BF9\u8C61
     */
    Coordinate.prototype.reflect = function (dim) {
        if (dim === 'x') {
            this.isReflectX = !this.isReflectX;
        }
        else {
            this.isReflectY = !this.isReflectY;
        }
        return this;
    };
    /**
     * \u5750\u6807\u7CFB\u6BD4\u4F8B\u53D8\u6362
     * @param s1 x \u65B9\u5411\u7F29\u653E\u6BD4\u4F8B
     * @param s2 y \u65B9\u5411\u7F29\u653E\u6BD4\u4F8B
     * @return     \u8FD4\u56DE\u5750\u6807\u7CFB\u5BF9\u8C61
     */
    Coordinate.prototype.scale = function (s1, s2) {
        var matrix = this.matrix;
        var center = this.center;
        ext/* leftTranslate */.m$(matrix, matrix, [-center.x, -center.y]);
        ext/* leftScale */.lh(matrix, matrix, [s1, s2]);
        ext/* leftTranslate */.m$(matrix, matrix, [center.x, center.y]);
        return this;
    };
    /**
     * \u5750\u6807\u7CFB\u5E73\u79FB\u53D8\u6362
     * @param x x \u65B9\u5411\u5E73\u79FB\u50CF\u7D20
     * @param y y \u65B9\u5411\u5E73\u79FB\u50CF\u7D20
     * @return    \u8FD4\u56DE\u5750\u6807\u7CFB\u5BF9\u8C61
     */
    Coordinate.prototype.translate = function (x, y) {
        var matrix = this.matrix;
        ext/* leftTranslate */.m$(matrix, matrix, [x, y]);
        return this;
    };
    /**
     * \u5C06\u5750\u6807\u7CFB x y \u4E24\u4E2A\u8F74\u8FDB\u884C\u8F6C\u7F6E
     * @return \u8FD4\u56DE\u5750\u6807\u7CFB\u5BF9\u8C61
     */
    Coordinate.prototype.transpose = function () {
        this.isTransposed = !this.isTransposed;
        return this;
    };
    Coordinate.prototype.getCenter = function () {
        return this.center;
    };
    Coordinate.prototype.getWidth = function () {
        return this.width;
    };
    Coordinate.prototype.getHeight = function () {
        return this.height;
    };
    Coordinate.prototype.getRadius = function () {
        return this.radius;
    };
    /**
     * whether has reflect
     * @param dim
     */
    Coordinate.prototype.isReflect = function (dim) {
        return dim === 'x' ? this.isReflectX : this.isReflectY;
    };
    /**
     * \u91CD\u7F6E matrix
     * @param matrix \u5982\u679C\u4F20\u5165\uFF0C\u5219\u4F7F\u7528\uFF0C\u5426\u5219\u4F7F\u7528\u6784\u9020\u51FD\u6570\u4E2D\u4F20\u5165\u7684\u9ED8\u8BA4 matrix
     */
    Coordinate.prototype.resetMatrix = function (matrix) {
        // \u53BB\u9664\u5F15\u7528\u5173\u7CFB
        this.matrix = matrix ? matrix : (0,tslib_es6/* __spreadArray */.ev)([], this.originalMatrix);
    };
    return Coordinate;
}());
/* harmony default export */ var coord_base = (Coordinate);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/coord/cartesian.js


/**
 * \u7B1B\u5361\u5C14\u5750\u6807\u7CFB
 * https://www.zhihu.com/question/20665303
 */
var Cartesian = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Cartesian, _super);
    function Cartesian(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.isRect = true;
        _this.type = 'cartesian';
        _this.initial();
        return _this;
    }
    Cartesian.prototype.initial = function () {
        _super.prototype.initial.call(this);
        var start = this.start;
        var end = this.end;
        this.x = {
            start: start.x,
            end: end.x,
        };
        this.y = {
            start: start.y,
            end: end.y,
        };
    };
    Cartesian.prototype.convertPoint = function (point) {
        var _a;
        var x = point.x, y = point.y;
        // \u4EA4\u6362
        if (this.isTransposed) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        return {
            x: this.convertDim(x, 'x'),
            y: this.convertDim(y, 'y'),
        };
    };
    Cartesian.prototype.invertPoint = function (point) {
        var _a;
        var x = this.invertDim(point.x, 'x');
        var y = this.invertDim(point.y, 'y');
        if (this.isTransposed) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        return { x: x, y: y };
    };
    return Cartesian;
}(coord_base));
/* harmony default export */ var cartesian = (Cartesian);
//# sourceMappingURL=cartesian.js.map
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js
var vec2 = __webpack_require__(31437);
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/coord/helix.js




/**
 * \u87BA\u65CB\u5750\u6807\u7CFB
 */
var Helix = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Helix, _super);
    function Helix(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.isHelix = true;
        _this.type = 'helix';
        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
        _this.startAngle = startAngle;
        _this.endAngle = endAngle;
        _this.innerRadius = innerRadius;
        _this.radius = radius;
        _this.initial();
        return _this;
    }
    Helix.prototype.initial = function () {
        _super.prototype.initial.call(this);
        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // \u87BA\u7EBF\u5708\u6570
        var maxRadius = Math.min(this.width, this.height) / 2;
        if (this.radius && this.radius >= 0 && this.radius <= 1) {
            maxRadius = maxRadius * this.radius;
        }
        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);
        this.a = this.d / (Math.PI * 2); // \u87BA\u7EBF\u7CFB\u6570
        this.x = {
            start: this.startAngle,
            end: this.endAngle,
        };
        this.y = {
            start: this.innerRadius * maxRadius,
            end: this.innerRadius * maxRadius + this.d * 0.99,
        };
    };
    /**
     * \u5C06\u767E\u5206\u6BD4\u6570\u636E\u53D8\u6210\u5C4F\u5E55\u5750\u6807
     * @param point \u5F52\u4E00\u5316\u7684\u70B9\u5750\u6807
     * @return      \u8FD4\u56DE\u5BF9\u5E94\u7684\u5C4F\u5E55\u5750\u6807
     */
    Helix.prototype.convertPoint = function (point) {
        var _a;
        var x = point.x, y = point.y;
        if (this.isTransposed) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        var thi = this.convertDim(x, 'x');
        var r = this.a * thi;
        var newY = this.convertDim(y, 'y');
        return {
            x: this.center.x + Math.cos(thi) * (r + newY),
            y: this.center.y + Math.sin(thi) * (r + newY),
        };
    };
    /**
     * \u5C06\u5C4F\u5E55\u5750\u6807\u70B9\u8FD8\u539F\u6210\u767E\u5206\u6BD4\u6570\u636E
     * @param point \u5C4F\u5E55\u5750\u6807
     * @return      \u8FD4\u56DE\u5BF9\u5E94\u7684\u5F52\u4E00\u5316\u540E\u7684\u6570\u636E
     */
    Helix.prototype.invertPoint = function (point) {
        var _a;
        var d = this.d + this.y.start;
        var v = vec2/* subtract */.$X([0, 0], [point.x, point.y], [this.center.x, this.center.y]);
        var thi = ext/* angleTo */.Dg(v, [1, 0], true);
        var rMin = thi * this.a; // \u5750\u6807\u4E0E\u539F\u70B9\u7684\u8FDE\u7EBF\u5728\u7B2C\u4E00\u5708\u4E0A\u7684\u4EA4\u70B9\uFF0C\u6700\u5C0Fr\u503C
        if (vec2/* length */.kE(v) < rMin) {
            // \u5750\u6807\u4E0E\u539F\u70B9\u7684\u8FDE\u7EBF\u4E0D\u53EF\u80FD\u5C0F\u4E8E\u6700\u5C0Fr\u503C\uFF0C\u4F46\u4E0D\u6392\u9664\u56E0\u5C0F\u6570\u8BA1\u7B97\u4EA7\u751F\u7684\u7565\u5C0F\u4E8ErMin\u7684\u60C5\u51B5
            rMin = vec2/* length */.kE(v);
        }
        var index = Math.floor((vec2/* length */.kE(v) - rMin) / d); // \u5F53\u524D\u70B9\u4F4D\u4E8E\u7B2Cindex\u5708
        thi = 2 * index * Math.PI + thi;
        var r = this.a * thi;
        var newY = vec2/* length */.kE(v) - r;
        newY = (0,esm/* isNumberEqual */.vQ)(newY, 0) ? 0 : newY;
        var x = this.invertDim(thi, 'x');
        var y = this.invertDim(newY, 'y');
        x = (0,esm/* isNumberEqual */.vQ)(x, 0) ? 0 : x;
        y = (0,esm/* isNumberEqual */.vQ)(y, 0) ? 0 : y;
        if (this.isTransposed) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        return { x: x, y: y };
    };
    return Helix;
}(coord_base));
/* harmony default export */ var helix = (Helix);
//# sourceMappingURL=helix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/coord/polar.js




var Polar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Polar, _super);
    function Polar(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.isPolar = true;
        _this.type = 'polar';
        var _a = cfg.startAngle, startAngle = _a === void 0 ? -Math.PI / 2 : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? (Math.PI * 3) / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
        _this.startAngle = startAngle;
        _this.endAngle = endAngle;
        _this.innerRadius = innerRadius;
        _this.radius = radius;
        _this.initial();
        return _this;
    }
    Polar.prototype.initial = function () {
        _super.prototype.initial.call(this);
        while (this.endAngle < this.startAngle) {
            this.endAngle += Math.PI * 2;
        }
        var oneBox = this.getOneBox();
        var oneWidth = oneBox.maxX - oneBox.minX;
        var oneHeight = oneBox.maxY - oneBox.minY;
        var left = Math.abs(oneBox.minX) / oneWidth;
        var top = Math.abs(oneBox.minY) / oneHeight;
        var maxRadius;
        if (this.height / oneHeight > this.width / oneWidth) {
            // width \u4E3A\u4E3B
            maxRadius = this.width / oneWidth;
            this.circleCenter = {
                x: this.center.x - (0.5 - left) * this.width,
                y: this.center.y - (0.5 - top) * maxRadius * oneHeight,
            };
        }
        else {
            // height \u4E3A\u4E3B
            maxRadius = this.height / oneHeight;
            this.circleCenter = {
                x: this.center.x - (0.5 - left) * maxRadius * oneWidth,
                y: this.center.y - (0.5 - top) * this.height,
            };
        }
        this.polarRadius = this.radius;
        if (!this.radius) {
            this.polarRadius = maxRadius;
        }
        else if (this.radius > 0 && this.radius <= 1) {
            this.polarRadius = maxRadius * this.radius;
        }
        else if (this.radius <= 0 || this.radius > maxRadius) {
            this.polarRadius = maxRadius;
        }
        this.x = {
            start: this.startAngle,
            end: this.endAngle,
        };
        this.y = {
            start: this.innerRadius * this.polarRadius,
            end: this.polarRadius,
        };
    };
    Polar.prototype.getRadius = function () {
        return this.polarRadius;
    };
    Polar.prototype.convertPoint = function (point) {
        var _a;
        var center = this.getCenter();
        var x = point.x, y = point.y;
        if (this.isTransposed) {
            _a = [y, x], x = _a[0], y = _a[1];
        }
        x = this.convertDim(x, 'x');
        y = this.convertDim(y, 'y');
        return {
            x: center.x + Math.cos(x) * y,
            y: center.y + Math.sin(x) * y,
        };
    };
    Polar.prototype.invertPoint = function (point) {
        var _a;
        var center = this.getCenter();
        var vPoint = [point.x - center.x, point.y - center.y];
        var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
        if (this.isReflect('x')) {
            _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];
        }
        var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        ext/* leftRotate */.zu(m, m, startAngle);
        var vStart3 = [1, 0, 0];
        transformMat3(vStart3, vStart3, m);
        var vStart2 = [vStart3[0], vStart3[1]];
        var angle = ext/* angleTo */.Dg(vStart2, vPoint, endAngle < startAngle);
        if ((0,esm/* isNumberEqual */.vQ)(angle, Math.PI * 2)) {
            angle = 0;
        }
        var radius = vec2/* length */.kE(vPoint);
        var xPercent = angle / (endAngle - startAngle);
        xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
        var yPercent = this.invertDim(radius, 'y');
        var rst = { x: 0, y: 0 };
        rst.x = this.isTransposed ? yPercent : xPercent;
        rst.y = this.isTransposed ? xPercent : yPercent;
        return rst;
    };
    Polar.prototype.getCenter = function () {
        return this.circleCenter;
    };
    Polar.prototype.getOneBox = function () {
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
            return {
                minX: -1,
                maxX: 1,
                minY: -1,
                maxY: 1,
            };
        }
        var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
        var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
        for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
            xs.push(Math.cos(i));
            ys.push(Math.sin(i));
        }
        return {
            minX: Math.min.apply(Math, xs),
            maxX: Math.max.apply(Math, xs),
            minY: Math.min.apply(Math, ys),
            maxY: Math.max.apply(Math, ys),
        };
    };
    return Polar;
}(coord_base));
/* harmony default export */ var polar = (Polar);
//# sourceMappingURL=polar.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/factory.js
// \u6240\u6709\u7684 Coordinate map
var COORDINATE_MAP = {};
/**
 * \u901A\u8FC7\u7C7B\u578B\u83B7\u5F97 coordinate \u7C7B
 * @param type
 */
var getCoordinate = function (type) {
    return COORDINATE_MAP[type.toLowerCase()];
};
/**
 * \u6CE8\u518C coordinate \u7C7B
 * @param type
 * @param ctor
 */
var registerCoordinate = function (type, ctor) {
    // \u5B58\u50A8\u5230 map \u4E2D
    COORDINATE_MAP[type.toLowerCase()] = ctor;
};

//# sourceMappingURL=factory.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/coord/esm/index.js





registerCoordinate('rect', cartesian);
registerCoordinate('cartesian', cartesian);
registerCoordinate('polar', polar);
registerCoordinate('helix', helix);

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/event.js

/**
 *
 * @param group \u5206\u7EC4
 * @param eventName \u4E8B\u4EF6\u540D
 * @param eventObject \u4E8B\u4EF6\u5BF9\u8C61
 */
function propagationDelegate(group, eventName, eventObject) {
    var event = new g_base_esm.Event(eventName, eventObject);
    event.target = group;
    event.propagationPath.push(group); // \u4ECE\u5F53\u524D group \u5F00\u59CB\u89E6\u53D1 delegation
    group.emitDelegation(eventName, event);
    var parent = group.getParent();
    // \u6267\u884C\u5192\u6CE1
    while (parent) {
        // \u59D4\u6258\u4E8B\u4EF6\u8981\u5148\u89E6\u53D1
        parent.emitDelegation(eventName, event);
        event.propagationPath.push(parent);
        parent = parent.getParent();
    }
}
//# sourceMappingURL=event.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/matrix.js

var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point, angle, matrix) {
    if (matrix === void 0) { matrix = identityMatrix; }
    if (!angle) {
        // \u89D2\u5EA6\u4E3A 0 \u6216\u8005 null \u65F6\u8FD4\u56DE null
        return null;
    }
    var m = ext/* transform */.vs(matrix, [
        ['t', -point.x, -point.y],
        ['r', angle],
        ['t', point.x, point.y],
    ]);
    return m;
}
function getMatrixByTranslate(point, currentMatrix) {
    if (!point.x && !point.y) {
        // 0\uFF0C0 \u6216\u8005 nan \u7684\u60C5\u51B5\u4E0B\u8FD4\u56DE null
        return null;
    }
    return ext/* transform */.vs(currentMatrix || identityMatrix, [['t', point.x, point.y]]);
}
// \u4ECE\u77E9\u9635\u83B7\u53D6\u65CB\u8F6C\u7684\u89D2\u5EA6
function getAngleByMatrix(matrix) {
    var xVector = [1, 0, 0];
    var out = [0, 0, 0];
    transformMat3(out, xVector, matrix);
    return Math.atan2(out[1], out[0]);
}
// \u77E9\u9635 * \u5411\u91CF
function multiplyVec2(matrix, v) {
    var out = [0, 0];
    vec2/* transformMat3 */.kK(out, v, matrix);
    return out;
}
function applyMatrix2BBox(matrix, bbox) {
    var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
    var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
    var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
    var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
    var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
function applyRotate(shape, rotate, x, y) {
    if (rotate) {
        var matrix = getMatrixByAngle({ x: x, y: y }, rotate, shape.getMatrix());
        shape.setMatrix(matrix);
    }
}
function applyTranslate(shape, x, y) {
    var translateMatrix = getMatrixByTranslate({ x: x, y: y });
    shape.attr('matrix', translateMatrix);
}
//# sourceMappingURL=matrix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/util.js

function formatPadding(padding) {
    var top = 0;
    var left = 0;
    var right = 0;
    var bottom = 0;
    if ((0,esm/* isNumber */.hj)(padding)) {
        top = left = right = bottom = padding;
    }
    else if ((0,esm/* isArray */.kJ)(padding)) {
        top = padding[0];
        right = !(0,esm/* isNil */.UM)(padding[1]) ? padding[1] : padding[0];
        bottom = !(0,esm/* isNil */.UM)(padding[2]) ? padding[2] : padding[0];
        left = !(0,esm/* isNil */.UM)(padding[3]) ? padding[3] : right;
    }
    return [top, right, bottom, left];
}
function clearDom(container) {
    var children = container.childNodes;
    var length = children.length;
    for (var i = length - 1; i >= 0; i--) {
        container.removeChild(children[i]);
    }
}
function hasClass(elements, cName) {
    return !!elements.className.match(new RegExp("(\\\\s|^)" + cName + "(\\\\s|$)"));
}
function regionToBBox(region) {
    var start = region.start, end = region.end;
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    var maxX = Math.max(start.x, end.x);
    var maxY = Math.max(start.y, end.y);
    return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
function pointsToBBox(points) {
    var xs = points.map(function (point) { return point.x; });
    var ys = points.map(function (point) { return point.y; });
    var minX = Math.min.apply(Math, xs);
    var minY = Math.min.apply(Math, ys);
    var maxX = Math.max.apply(Math, xs);
    var maxY = Math.max.apply(Math, ys);
    return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
function createBBox(x, y, width, height) {
    var maxX = x + width;
    var maxY = y + height;
    return {
        x: x,
        y: y,
        width: width,
        height: height,
        minX: x,
        minY: y,
        // \u975E\u5E38\u5947\u8469\u7684 js \u7279\u6027
        // Infinity + Infinity = Infinity
        // Infinity - Infinity = NaN
        // fixed https://github.com/antvis/G2Plot/issues/1243
        maxX: isNaN(maxX) ? 0 : maxX,
        maxY: isNaN(maxY) ? 0 : maxY,
    };
}
function getValueByPercent(min, max, percent) {
    return (1 - percent) * min + max * percent;
}
function getCirclePoint(center, radius, angle) {
    return {
        x: center.x + Math.cos(angle) * radius,
        y: center.y + Math.sin(angle) * radius,
    };
}
function util_distance(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
}
var wait = function (interval) {
    return new Promise(function (resolve) {
        setTimeout(resolve, interval);
    });
};
/**
 * \u5224\u65AD\u4E24\u4E2A\u6570\u503C \u662F\u5426\u63A5\u8FD1
 * - \u89E3\u51B3\u7CBE\u5EA6\u95EE\u9898\uFF08\u7531\u4E8E\u65E0\u6CD5\u786E\u5B9A\u7CBE\u5EA6\u4E0A\u9650\uFF0C\u6839\u636E\u5177\u4F53\u573A\u666F\u53EF\u4F20\u5165 \u7CBE\u5EA6 \u53C2\u6570\uFF09
 */
var near = function (x, y, e) {
    if (e === void 0) { e = Math.pow(Number.EPSILON, 0.5); }
    return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox(box1, box2) {
    var minX = Math.max(box1.minX, box2.minX);
    var minY = Math.max(box1.minY, box2.minY);
    var maxX = Math.min(box1.maxX, box2.maxX);
    var maxY = Math.min(box1.maxY, box2.maxY);
    return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function mergeBBox(box1, box2) {
    var minX = Math.min(box1.minX, box2.minX);
    var minY = Math.min(box1.minY, box2.minY);
    var maxX = Math.max(box1.maxX, box2.maxX);
    var maxY = Math.max(box1.maxY, box2.maxY);
    return createBBox(minX, minY, maxX - minX, maxY - minY);
}
function getBBoxWithClip(element) {
    var clipShape = element.getClip();
    var clipBBox = clipShape && clipShape.getBBox();
    var bbox;
    if (!element.isGroup()) {
        // \u5982\u679C\u662F\u666E\u901A\u7684\u56FE\u5F62
        bbox = element.getBBox();
    }
    else {
        var minX_1 = Infinity;
        var maxX_1 = -Infinity;
        var minY_1 = Infinity;
        var maxY_1 = -Infinity;
        var children = element.getChildren();
        if (children.length > 0) {
            (0,esm/* each */.S6)(children, function (child) {
                if (child.get('visible')) {
                    // \u5982\u679C\u5206\u7EC4\u6CA1\u6709\u5B50\u5143\u7D20\uFF0C\u5219\u76F4\u63A5\u8DF3\u8FC7
                    if (child.isGroup() && child.get('children').length === 0) {
                        return true;
                    }
                    var box = getBBoxWithClip(child);
                    // \u8BA1\u7B97 4 \u4E2A\u9876\u70B9
                    var leftTop = child.applyToMatrix([box.minX, box.minY, 1]);
                    var leftBottom = child.applyToMatrix([box.minX, box.maxY, 1]);
                    var rightTop = child.applyToMatrix([box.maxX, box.minY, 1]);
                    var rightBottom = child.applyToMatrix([box.maxX, box.maxY, 1]);
                    // \u4ECE\u4E2D\u53D6\u6700\u5C0F\u7684\u8303\u56F4
                    var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                    var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
                    var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
                    var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
                    if (boxMinX < minX_1) {
                        minX_1 = boxMinX;
                    }
                    if (boxMaxX > maxX_1) {
                        maxX_1 = boxMaxX;
                    }
                    if (boxMinY < minY_1) {
                        minY_1 = boxMinY;
                    }
                    if (boxMaxY > maxY_1) {
                        maxY_1 = boxMaxY;
                    }
                }
            });
        }
        else {
            minX_1 = 0;
            maxX_1 = 0;
            minY_1 = 0;
            maxY_1 = 0;
        }
        bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
    }
    if (clipBBox) {
        return intersectBBox(bbox, clipBBox);
    }
    else {
        return bbox;
    }
}
function updateClip(element, newElement) {
    if (!element.getClip() && !newElement.getClip()) {
        // \u4E24\u8005\u90FD\u6CA1\u6709 clip
        return;
    }
    var newClipShape = newElement.getClip();
    if (!newClipShape) {
        // \u65B0\u7684 element \u6CA1\u6709 clip
        element.setClip(null); // \u79FB\u9664 clip
        return;
    }
    var clipCfg = {
        type: newClipShape.get('type'),
        attrs: newClipShape.attr(),
    };
    element.setClip(clipCfg);
}
function toPx(number) {
    return number + "px";
}
function getTextPoint(start, end, position, offset) {
    var lineLength = util_distance(start, end);
    var offsetPercent = offset / lineLength; // \u8BA1\u7B97\u95F4\u8DDD\u540C\u7EBF\u7684\u6BD4\u4F8B\uFF0C\u7528\u4E8E\u8BA1\u7B97\u6700\u7EC8\u7684\u4F4D\u7F6E
    var percent = 0;
    if (position === 'start') {
        percent = 0 - offsetPercent;
    }
    else if (position === 'end') {
        percent = 1 + offsetPercent;
    }
    return {
        x: getValueByPercent(start.x, end.x, percent),
        y: getValueByPercent(start.y, end.y, percent),
    };
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/abstract/component.js



var LOCATION_FIELD_MAP = {
    none: [],
    point: ['x', 'y'],
    region: ['start', 'end'],
    points: ['points'],
    circle: ['center', 'radius', 'startAngle', 'endAngle'],
};
var Component = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Component, _super);
    function Component(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.initCfg();
        return _this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    Component.prototype.getDefaultCfg = function () {
        return {
            id: '',
            name: '',
            type: '',
            locationType: 'none',
            offsetX: 0,
            offsetY: 0,
            animate: false,
            capture: true,
            updateAutoRender: false,
            animateOption: {
                appear: null,
                update: {
                    duration: 400,
                    easing: 'easeQuadInOut',
                },
                enter: {
                    duration: 400,
                    easing: 'easeQuadInOut',
                },
                leave: {
                    duration: 350,
                    easing: 'easeQuadIn',
                },
            },
            events: null,
            defaultCfg: {},
            visible: true,
        };
    };
    /**
     * \u6E05\u7406\u7EC4\u4EF6\u7684\u5185\u5BB9\uFF0C\u4E00\u822C\u914D\u5408 render \u4F7F\u7528
     * @example
     * axis.clear();
     * axis.render();
     */
    Component.prototype.clear = function () { };
    /**
     * \u66F4\u65B0\u7EC4\u4EF6
     * @param {object} cfg \u66F4\u65B0\u5C5E\u6027
     */
    Component.prototype.update = function (cfg) {
        var _this = this;
        var defaultCfg = this.get('defaultCfg') || {};
        (0,esm/* each */.S6)(cfg, function (value, name) {
            var originCfg = _this.get(name);
            var newCfg = value;
            if (originCfg !== value) {
                // \u5224\u65AD\u4E24\u8005\u662F\u5426\u76F8\u7B49\uFF0C\u4E3B\u8981\u662F\u8FDB\u884C null \u7684\u5224\u5B9A
                if ((0,esm/* isObject */.Kn)(value) && defaultCfg[name]) {
                    // \u65B0\u8BBE\u7F6E\u7684\u5C5E\u6027\u4E0E\u9ED8\u8BA4\u503C\u8FDB\u884C\u5408\u5E76
                    newCfg = (0,esm/* deepMix */.b$)({}, defaultCfg[name], value);
                }
                _this.set(name, newCfg);
            }
        });
        this.updateInner(cfg);
        this.afterUpdate(cfg);
    };
    // \u66F4\u65B0\u5185\u90E8
    Component.prototype.updateInner = function (cfg) {
    };
    Component.prototype.afterUpdate = function (cfg) {
        // \u66F4\u65B0\u65F6\u8003\u8651\u663E\u793A\u3001\u9690\u85CF
        if ((0,esm/* hasKey */.wH)(cfg, 'visible')) {
            if (cfg.visible) {
                this.show();
            }
            else {
                this.hide();
            }
        }
        // \u66F4\u65B0\u65F6\u8003\u8651capture
        if ((0,esm/* hasKey */.wH)(cfg, 'capture')) {
            this.setCapture(cfg.capture);
        }
    };
    Component.prototype.getLayoutBBox = function () {
        return this.getBBox(); // \u9ED8\u8BA4\u8FD4\u56DE getBBox\uFF0C\u4E0D\u540C\u7684\u7EC4\u4EF6\u5185\u90E8\u5355\u72EC\u5B9E\u73B0
    };
    Component.prototype.getLocationType = function () {
        return this.get('locationType');
    };
    Component.prototype.getOffset = function () {
        return {
            offsetX: this.get('offsetX'),
            offsetY: this.get('offsetY'),
        };
    };
    // \u9ED8\u8BA4\u4F7F\u7528 update
    Component.prototype.setOffset = function (offsetX, offsetY) {
        this.update({
            offsetX: offsetX,
            offsetY: offsetY,
        });
    };
    Component.prototype.setLocation = function (cfg) {
        var location = (0,tslib_es6/* __assign */.pi)({}, cfg);
        this.update(location);
    };
    // \u5B9E\u73B0 ILocation \u63A5\u53E3\u7684 getLocation
    Component.prototype.getLocation = function () {
        var _this = this;
        var location = {};
        var locationType = this.get('locationType');
        var fields = LOCATION_FIELD_MAP[locationType];
        (0,esm/* each */.S6)(fields, function (field) {
            location[field] = _this.get(field);
        });
        return location;
    };
    Component.prototype.isList = function () {
        return false;
    };
    Component.prototype.isSlider = function () {
        return false;
    };
    /**
     * @protected
     * \u521D\u59CB\u5316\uFF0C\u7528\u4E8E\u5177\u4F53\u7684\u7EC4\u4EF6\u7EE7\u627F
     */
    Component.prototype.init = function () { };
    // \u5C06\u7EC4\u4EF6\u9ED8\u8BA4\u7684\u914D\u7F6E\u9879\u8BBE\u7F6E\u5408\u5E76\u5230\u4F20\u5165\u7684\u914D\u7F6E\u9879
    Component.prototype.initCfg = function () {
        var _this = this;
        var defaultCfg = this.get('defaultCfg');
        (0,esm/* each */.S6)(defaultCfg, function (value, name) {
            var cfg = _this.get(name);
            if ((0,esm/* isObject */.Kn)(cfg)) {
                var newCfg = (0,esm/* deepMix */.b$)({}, value, cfg);
                _this.set(name, newCfg);
            }
        });
    };
    return Component;
}(g_base_esm.Base));
/* harmony default export */ var component = (Component);
//# sourceMappingURL=component.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/abstract/group-component.js






var STATUS_UPDATE = 'update_status';
var COPY_PROPERTIES = ['visible', 'tip', 'delegateObject']; // \u66F4\u65B0\u5BF9\u8C61\u65F6\u9700\u8981\u590D\u5236\u7684\u5C5E\u6027
var COPY_PROPERTIES_EXCLUDES = ['container', 'group', 'shapesMap', 'isRegister', 'isUpdating', 'destroyed']; // \u66F4\u65B0\u5B50\u7EC4\u4EF6\u65F6\u6392\u9664\u7684\u5C5E\u6027
var GroupComponent = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(GroupComponent, _super);
    function GroupComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupComponent.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { container: null, 
            /**
             * @private
             * \u7F13\u5B58\u56FE\u5F62\u7684 Map
             */
            shapesMap: {}, group: null, capture: true, 
            /**
             * @private \u7EC4\u4EF6\u6216\u8005\u56FE\u5F62\u662F\u5426\u5141\u8BB8\u6CE8\u518C
             * @type {false}
             */
            isRegister: false, 
            /**
             * @private \u662F\u5426\u6B63\u5728\u66F4\u65B0
             * @type {false}
             */
            isUpdating: false, 
            /**
             * @private
             * \u662F\u5426\u521D\u59CB\u72B6\u6001\uFF0C\u4E00\u65E6 render\uFF0Cupdate \u540E\uFF0C\u8FD9\u4E2A\u72B6\u6001\u5C31\u53D8\u6210 false, clear \u540E\u6062\u590D
             */
            isInit: true });
    };
    GroupComponent.prototype.remove = function () {
        this.clear();
        var group = this.get('group');
        group.remove();
    };
    GroupComponent.prototype.clear = function () {
        var group = this.get('group');
        group.clear();
        this.set('shapesMap', {});
        this.clearOffScreenCache();
        this.set('isInit', true);
    };
    GroupComponent.prototype.getChildComponentById = function (id) {
        var group = this.getElementById(id);
        var inst = group && group.get('component');
        return inst;
    };
    GroupComponent.prototype.getElementById = function (id) {
        return this.get('shapesMap')[id];
    };
    GroupComponent.prototype.getElementByLocalId = function (localId) {
        var id = this.getElementId(localId);
        return this.getElementById(id);
    };
    GroupComponent.prototype.getElementsByName = function (name) {
        var rst = [];
        (0,esm/* each */.S6)(this.get('shapesMap'), function (elem) {
            if (elem.get('name') === name) {
                rst.push(elem);
            }
        });
        return rst;
    };
    GroupComponent.prototype.getContainer = function () {
        return this.get('container');
    };
    GroupComponent.prototype.updateInner = function (cfg) {
        // this.updateInner();
        // this.set('isUpdating', false);
        this.offScreenRender();
        if (this.get('updateAutoRender')) {
            this.render();
        }
    };
    GroupComponent.prototype.render = function () {
        var offScreenGroup = this.get('offScreenGroup');
        if (!offScreenGroup) {
            offScreenGroup = this.offScreenRender();
        }
        var group = this.get('group');
        this.updateElements(offScreenGroup, group);
        this.deleteElements();
        this.applyOffset();
        if (!this.get('eventInitted')) {
            this.initEvent();
            this.set('eventInitted', true);
        }
        this.set('isInit', false);
    };
    GroupComponent.prototype.show = function () {
        var group = this.get('group');
        group.show();
        this.set('visible', true);
    };
    GroupComponent.prototype.hide = function () {
        var group = this.get('group');
        group.hide();
        this.set('visible', false);
    };
    GroupComponent.prototype.setCapture = function (capture) {
        var group = this.get('group');
        group.set('capture', capture);
        this.set('capture', capture);
    };
    GroupComponent.prototype.destroy = function () {
        this.removeEvent();
        this.remove();
        _super.prototype.destroy.call(this);
    };
    GroupComponent.prototype.getBBox = function () {
        return this.get('group').getCanvasBBox();
    };
    GroupComponent.prototype.getLayoutBBox = function () {
        var group = this.get('group');
        // \u9632\u6B62\u88AB clear \u4E86\uFF0CoffScreenBBox \u4E0D\u5B58\u5728
        var bbox = this.getInnerLayoutBBox();
        var matrix = group.getTotalMatrix();
        if (matrix) {
            bbox = applyMatrix2BBox(matrix, bbox);
        }
        return bbox; // \u9ED8\u8BA4\u8FD4\u56DE getBBox\uFF0C\u4E0D\u540C\u7684\u7EC4\u4EF6\u5185\u90E8\u5355\u72EC\u5B9E\u73B0
    };
    // \u590D\u5199 on, off, emit \u900F\u4F20\u5230 group
    GroupComponent.prototype.on = function (evt, callback, once) {
        var group = this.get('group');
        group.on(evt, callback, once);
        return this;
    };
    GroupComponent.prototype.off = function (evt, callback) {
        var group = this.get('group');
        group && group.off(evt, callback);
        return this;
    };
    GroupComponent.prototype.emit = function (eventName, eventObject) {
        var group = this.get('group');
        group.emit(eventName, eventObject);
    };
    GroupComponent.prototype.init = function () {
        _super.prototype.init.call(this);
        if (!this.get('group')) {
            this.initGroup();
        }
        this.offScreenRender(); // \u7ED8\u5236\u79BB\u5C4F group
    };
    // \u83B7\u53D6\u7EC4\u4EF6\u5185\u90E8\u5E03\u5C40\u5360\u7684\u5305\u56F4\u76D2
    GroupComponent.prototype.getInnerLayoutBBox = function () {
        return this.get('offScreenBBox') || this.get('group').getBBox();
    };
    // \u629B\u51FA\u59D4\u6258\u5BF9\u8C61
    GroupComponent.prototype.delegateEmit = function (eventName, eventObject) {
        var group = this.get('group');
        eventObject.target = group;
        group.emit(eventName, eventObject);
        propagationDelegate(group, eventName, eventObject);
    };
    // \u521B\u5EFA\u79BB\u5C4F\u7684 group ,\u4E0D\u6DFB\u52A0\u5728 canvas \u4E2D
    GroupComponent.prototype.createOffScreenGroup = function () {
        var group = this.get('group');
        var GroupClass = group.getGroupBase(); // \u83B7\u53D6\u5206\u7EC4\u7684\u6784\u9020\u51FD\u6570
        var newGroup = new GroupClass({
            delegateObject: this.getDelegateObject(),
        });
        return newGroup;
    };
    // \u5E94\u7528 offset
    GroupComponent.prototype.applyOffset = function () {
        var offsetX = this.get('offsetX');
        var offsetY = this.get('offsetY');
        this.moveElementTo(this.get('group'), {
            x: offsetX,
            y: offsetY,
        });
    };
    GroupComponent.prototype.initGroup = function () {
        var container = this.get('container');
        this.set('group', container.addGroup({
            id: this.get('id'),
            name: this.get('name'),
            capture: this.get('capture'),
            visible: this.get('visible'),
            isComponent: true,
            component: this,
            delegateObject: this.getDelegateObject(),
        }));
    };
    // \u79BB\u5C4F\u6E32\u67D3
    GroupComponent.prototype.offScreenRender = function () {
        this.clearOffScreenCache();
        var offScreenGroup = this.createOffScreenGroup();
        this.renderInner(offScreenGroup);
        this.set('offScreenGroup', offScreenGroup);
        // \u5305\u542B\u5305\u56F4\u76D2\u7684 bbox
        this.set('offScreenBBox', getBBoxWithClip(offScreenGroup));
        return offScreenGroup;
    };
    /**
     * @protected
     * \u5728\u7EC4\u4EF6\u4E0A\u6DFB\u52A0\u5206\u7EC4\uFF0C\u4E3B\u8981\u89E3\u51B3 isReigeter \u7684\u95EE\u9898
     * @param {IGroup} parent \u7236\u5143\u7D20
     * @param {object} cfg    \u5206\u7EC4\u7684\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.addGroup = function (parent, cfg) {
        this.appendDelegateObject(parent, cfg);
        var group = parent.addGroup(cfg);
        if (this.get('isRegister')) {
            this.registerElement(group);
        }
        return group;
    };
    /**
     * @protected
     * \u5728\u7EC4\u4EF6\u4E0A\u6DFB\u52A0\u56FE\u5F62\uFF0C\u4E3B\u8981\u89E3\u51B3 isReigeter \u7684\u95EE\u9898
     * @param {IGroup} parent \u7236\u5143\u7D20
     * @param {object} cfg    \u5206\u7EC4\u7684\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.addShape = function (parent, cfg) {
        this.appendDelegateObject(parent, cfg);
        var shape = parent.addShape(cfg);
        if (this.get('isRegister')) {
            this.registerElement(shape);
        }
        return shape;
    };
    /**
     * \u5728\u7EC4\u4EF6\u4E0A\u6DFB\u52A0\u5B50\u7EC4\u4EF6
     *
     * @param parent \u7236\u5143\u7D20
     * @param cfg \u5B50\u7EC4\u4EF6\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.addComponent = function (parent, cfg) {
        var id = cfg.id, Ctor = cfg.component, restCfg = (0,tslib_es6/* __rest */._T)(cfg, ["id", "component"]);
        // @ts-ignore
        var inst = new Ctor((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, restCfg), { id: id, container: parent, updateAutoRender: this.get('updateAutoRender') }));
        inst.init();
        inst.render();
        if (this.get('isRegister')) {
            this.registerElement(inst.get('group'));
        }
        return inst;
    };
    GroupComponent.prototype.initEvent = function () { };
    GroupComponent.prototype.removeEvent = function () {
        var group = this.get('group');
        group.off();
    };
    GroupComponent.prototype.getElementId = function (localId) {
        var id = this.get('id'); // \u7EC4\u4EF6\u7684 Id
        var name = this.get('name'); // \u7EC4\u4EF6\u7684\u540D\u79F0
        return id + "-" + name + "-" + localId;
    };
    GroupComponent.prototype.registerElement = function (element) {
        var id = element.get('id');
        this.get('shapesMap')[id] = element;
    };
    GroupComponent.prototype.unregisterElement = function (element) {
        var id = element.get('id');
        delete this.get('shapesMap')[id];
    };
    // \u79FB\u52A8\u5143\u7D20
    GroupComponent.prototype.moveElementTo = function (element, point) {
        var matrix = getMatrixByTranslate(point);
        element.attr('matrix', matrix);
    };
    /**
     * \u56FE\u5F62\u5143\u7D20\u65B0\u51FA\u73B0\u65F6\u7684\u52A8\u753B\uFF0C\u9ED8\u8BA4\u56FE\u5F62\u4ECE\u900F\u660E\u5EA6 0 \u5230\u5F53\u524D\u900F\u660E\u5EA6
     * @protected
     * @param {string} elmentName \u56FE\u5F62\u5143\u7D20\u540D\u79F0
     * @param {IElement} newElement  \u65B0\u7684\u56FE\u5F62\u5143\u7D20
     * @param {object} animateCfg \u52A8\u753B\u7684\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.addAnimation = function (elmentName, newElement, animateCfg) {
        // \u7F13\u5B58\u900F\u660E\u5EA6
        var originOpacity = newElement.attr('opacity');
        if ((0,esm/* isNil */.UM)(originOpacity)) {
            originOpacity = 1;
        }
        newElement.attr('opacity', 0);
        newElement.animate({ opacity: originOpacity }, animateCfg);
    };
    /**
     * \u56FE\u5F62\u5143\u7D20\u65B0\u51FA\u73B0\u65F6\u7684\u52A8\u753B\uFF0C\u9ED8\u8BA4\u56FE\u5F62\u4ECE\u900F\u660E\u5EA6 0 \u5230\u5F53\u524D\u900F\u660E\u5EA6
     * @protected
     * @param {string} elmentName \u56FE\u5F62\u5143\u7D20\u540D\u79F0
     * @param {IElement} originElement \u8981\u5220\u9664\u7684\u56FE\u5F62\u5143\u7D20
     * @param {object} animateCfg \u52A8\u753B\u7684\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.removeAnimation = function (elementName, originElement, animateCfg) {
        originElement.animate({ opacity: 0 }, animateCfg);
    };
    /**
     * \u56FE\u5F62\u5143\u7D20\u7684\u66F4\u65B0\u52A8\u753B
     * @param {string} elmentName \u56FE\u5F62\u5143\u7D20\u540D\u79F0
     * @param {IElement} originElement \u73B0\u6709\u7684\u56FE\u5F62\u5143\u7D20
     * @param {object} newAttrs  \u65B0\u7684\u56FE\u5F62\u5143\u7D20
     * @param {object} animateCfg \u52A8\u753B\u7684\u914D\u7F6E\u9879
     */
    GroupComponent.prototype.updateAnimation = function (elementName, originElement, newAttrs, animateCfg) {
        originElement.animate(newAttrs, animateCfg);
    };
    // \u66F4\u65B0\u7EC4\u4EF6\u7684\u56FE\u5F62
    GroupComponent.prototype.updateElements = function (newGroup, originGroup) {
        var _this = this;
        var animate = this.get('animate');
        var animateOption = this.get('animateOption');
        var children = newGroup.getChildren().slice(0); // \u521B\u5EFA\u4E00\u4E2A\u65B0\u6570\u7EC4\uFF0C\u9632\u6B62\u6DFB\u52A0\u5230 originGroup \u65F6\uFF0C children \u53D8\u52A8
        var preElement; // \u524D\u9762\u5DF2\u7ECF\u5339\u914D\u5230\u7684\u56FE\u5F62\u5143\u7D20\uFF0C\u7528\u4E8E
        (0,esm/* each */.S6)(children, function (element) {
            var elementId = element.get('id');
            var originElement = _this.getElementById(elementId);
            var elementName = element.get('name');
            if (originElement) {
                if (element.get('isComponent')) {
                    // \u5D4C\u5957\u5B50\u7EC4\u4EF6\u66F4\u65B0
                    var childComponent = element.get('component');
                    var origChildComponent = originElement.get('component');
                    var newCfg = (0,esm/* pick */.ei)(childComponent.cfg, (0,esm/* difference */.e5)((0,esm/* keys */.XP)(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
                    origChildComponent.update(newCfg);
                    originElement.set(STATUS_UPDATE, 'update');
                }
                else {
                    var replaceAttrs = _this.getReplaceAttrs(originElement, element);
                    // \u66F4\u65B0
                    if (animate && animateOption.update) {
                        // \u6CA1\u6709\u52A8\u753B
                        _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
                    }
                    else {
                        // originElement.attrs = replaceAttrs; // \u76F4\u63A5\u66FF\u6362
                        originElement.attr(replaceAttrs);
                    }
                    // \u5982\u679C\u662F\u5206\u7EC4\uFF0C\u5219\u7EE7\u7EED\u6267\u884C
                    if (element.isGroup()) {
                        _this.updateElements(element, originElement);
                    }
                    // \u590D\u5236\u5C5E\u6027
                    (0,esm/* each */.S6)(COPY_PROPERTIES, function (name) {
                        originElement.set(name, element.get(name));
                    });
                    updateClip(originElement, element);
                    preElement = originElement;
                    // \u6267\u884C\u5B8C\u66F4\u65B0\u540E\u8BBE\u7F6E\u72B6\u6001\u4F4D\u4E3A\u66F4\u65B0
                    originElement.set(STATUS_UPDATE, 'update');
                }
            }
            else {
                // \u6CA1\u6709\u5BF9\u5E94\u7684\u56FE\u5F62\uFF0C\u5219\u63D2\u5165\u5F53\u524D\u56FE\u5F62
                originGroup.add(element); // \u5E94\u8BE5\u5728 group \u52A0\u4E2A insertAt \u7684\u65B9\u6CD5
                var siblings = originGroup.getChildren(); // \u5144\u5F1F\u8282\u70B9
                siblings.splice(siblings.length - 1, 1); // \u5148\u4ECE\u6570\u7EC4\u4E2D\u79FB\u9664\uFF0C\u7136\u540E\u653E\u5230\u5408\u9002\u7684\u4F4D\u7F6E
                if (preElement) {
                    // \u524D\u9762\u5DF2\u7ECF\u6709\u66F4\u65B0\u7684\u56FE\u5F62\u6216\u8005\u63D2\u5165\u7684\u56FE\u5F62\uFF0C\u5219\u5728\u8FD9\u4E2A\u56FE\u5F62\u540E\u9762\u63D2\u5165
                    var index = siblings.indexOf(preElement);
                    siblings.splice(index + 1, 0, element); // \u5728\u5DF2\u7ECF\u66F4\u65B0\u7684\u56FE\u5F62\u5143\u7D20\u540E\u9762\u63D2\u5165
                }
                else {
                    siblings.unshift(element);
                }
                _this.registerElement(element); // \u6CE8\u518C\u8282\u70B9
                element.set(STATUS_UPDATE, 'add'); // \u6267\u884C\u5B8C\u66F4\u65B0\u540E\u8BBE\u7F6E\u72B6\u6001\u4F4D\u4E3A\u6DFB\u52A0
                if (element.get('isComponent')) {
                    // \u76F4\u63A5\u65B0\u589E\u5B50\u7EC4\u4EF6container\u5C5E\u6027\uFF0C\u5B9E\u4F8B\u4E0D\u53D8
                    var childComponent = element.get('component');
                    childComponent.set('container', originGroup);
                }
                else if (element.isGroup()) {
                    // \u5982\u679C\u5143\u7D20\u662F\u65B0\u589E\u52A0\u7684\u5143\u7D20\uFF0C\u5219\u904D\u5386\u6CE8\u518C\u6240\u6709\u7684\u5B50\u8282\u70B9
                    _this.registerNewGroup(element);
                }
                preElement = element;
                if (animate) {
                    var animateCfg = _this.get('isInit') ? animateOption.appear : animateOption.enter;
                    if (animateCfg) {
                        _this.addAnimation(elementName, element, animateCfg);
                    }
                }
            }
        });
    };
    GroupComponent.prototype.clearUpdateStatus = function (group) {
        var children = group.getChildren();
        (0,esm/* each */.S6)(children, function (el) {
            el.set(STATUS_UPDATE, null); // \u6E05\u7406\u6389\u66F4\u65B0\u72B6\u6001
        });
    };
    // \u6E05\u7406\u79BB\u5C4F\u7F13\u5B58
    GroupComponent.prototype.clearOffScreenCache = function () {
        var offScreenGroup = this.get('offScreenGroup');
        if (offScreenGroup) {
            // \u9500\u6BC1\u539F\u5148\u7684\u79BB\u7EBF Group
            offScreenGroup.destroy();
        }
        this.set('offScreenGroup', null);
        this.set('offScreenBBox', null);
    };
    // private updateInner() {
    //   const group = this.get('group');
    //   const newGroup = this.createOffScreenGroup();
    //   this.renderInner(newGroup);
    //   this.applyOffset();
    //   this.updateElements(newGroup, group);
    //   this.deleteElements();
    //   newGroup.destroy(); // \u9500\u6BC1\u865A\u62DF\u5206\u7EC4
    // }
    // \u83B7\u53D6\u53D1\u751F\u59D4\u6258\u65F6\u7684\u5BF9\u8C61\uFF0C\u5728\u4E8B\u4EF6\u4E2D\u629B\u51FA
    GroupComponent.prototype.getDelegateObject = function () {
        var _a;
        var name = this.get('name');
        var delegateObject = (_a = {},
            _a[name] = this,
            _a.component = this,
            _a);
        return delegateObject;
    };
    // \u9644\u52A0\u59D4\u6258\u4FE1\u606F\uFF0C\u7528\u4E8E\u4E8B\u4EF6
    GroupComponent.prototype.appendDelegateObject = function (parent, cfg) {
        var parentObject = parent.get('delegateObject');
        if (!cfg.delegateObject) {
            cfg.delegateObject = {};
        }
        (0,esm/* mix */.CD)(cfg.delegateObject, parentObject); // \u5C06\u7236\u5143\u7D20\u4E0A\u7684\u59D4\u6258\u4FE1\u606F\u590D\u5236\u5230\u81EA\u8EAB
    };
    // \u83B7\u53D6\u9700\u8981\u66FF\u6362\u7684\u5C5E\u6027\uFF0C\u5982\u679C\u539F\u5148\u56FE\u5F62\u5143\u7D20\u5B58\u5728\uFF0C\u800C\u65B0\u56FE\u5F62\u4E0D\u5B58\u5728\uFF0C\u5219\u8BBE\u7F6E undefined
    GroupComponent.prototype.getReplaceAttrs = function (originElement, newElement) {
        var originAttrs = originElement.attr();
        var newAttrs = newElement.attr();
        (0,esm/* each */.S6)(originAttrs, function (v, k) {
            if (newAttrs[k] === undefined) {
                newAttrs[k] = undefined;
            }
        });
        return newAttrs;
    };
    GroupComponent.prototype.registerNewGroup = function (group) {
        var _this = this;
        var children = group.getChildren();
        (0,esm/* each */.S6)(children, function (element) {
            _this.registerElement(element); // \u6CE8\u518C\u8282\u70B9
            element.set(STATUS_UPDATE, 'add'); // \u6267\u884C\u5B8C\u66F4\u65B0\u540E\u8BBE\u7F6E\u72B6\u6001\u4F4D\u4E3A\u6DFB\u52A0
            if (element.isGroup()) {
                _this.registerNewGroup(element);
            }
        });
    };
    // \u79FB\u9664\u591A\u4F59\u7684\u5143\u7D20
    GroupComponent.prototype.deleteElements = function () {
        var _this = this;
        var shapesMap = this.get('shapesMap');
        var deleteArray = [];
        // \u904D\u5386\u83B7\u53D6\u9700\u8981\u5220\u9664\u7684\u56FE\u5F62\u5143\u7D20
        (0,esm/* each */.S6)(shapesMap, function (element, id) {
            if (!element.get(STATUS_UPDATE) || element.destroyed) {
                deleteArray.push([id, element]);
            }
            else {
                element.set(STATUS_UPDATE, null); // \u6E05\u7406\u6389\u66F4\u65B0\u72B6\u6001
            }
        });
        var animate = this.get('animate');
        var animateOption = this.get('animateOption');
        // \u5220\u9664\u56FE\u5F62\u5143\u7D20
        (0,esm/* each */.S6)(deleteArray, function (item) {
            var id = item[0], element = item[1];
            if (!element.destroyed) {
                var elementName = element.get('name');
                if (animate && animateOption.leave) {
                    // \u9700\u8981\u52A8\u753B\u7ED3\u675F\u65F6\u79FB\u9664\u56FE\u5F62
                    var callbackAnimCfg = (0,esm/* mix */.CD)({
                        callback: function () {
                            _this.removeElement(element);
                        },
                    }, animateOption.leave);
                    _this.removeAnimation(elementName, element, callbackAnimCfg);
                }
                else {
                    _this.removeElement(element);
                }
            }
            delete shapesMap[id]; // \u4ECE\u7F13\u5B58\u4E2D\u79FB\u9664
        });
    };
    GroupComponent.prototype.removeElement = function (element) {
        if (element.get('isGroup')) {
            var component = element.get('component');
            if (component) {
                component.destroy();
            }
        }
        element.remove();
    };
    return GroupComponent;
}(component));
/* harmony default export */ var group_component = (GroupComponent);
//# sourceMappingURL=group-component.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/text.js
var ELLIPSIS_CODE = '\\u2026';
/** \u83B7\u53D6\u5B57\u7B26\u4E32\u957F\u5EA6 */
function strLen(str) {
    var len = 0;
    for (var i = 0; i < str.length; i++) {
        len += charAtLength(str, i);
    }
    return len;
}
/** \u662F\u5426\u5C5E\u4E8EASCII\u7F16\u7801\u8303\u7574 */
function charAtLength(str, i) {
    if (str.charCodeAt(i) > 0 && str.charCodeAt(i) < 128) {
        return 1;
    }
    else {
        return 2;
    }
}
/** \u6587\u672C\u7701\u7565 */
function ellipsisString(str, reseveLength, position) {
    if (position === void 0) { position = 'tail'; }
    var count = str.length;
    var rst = '';
    if (position === 'tail') {
        for (var i = 0, index = 0; i < reseveLength;) {
            var charLength = charAtLength(str, index);
            if (i + charLength <= reseveLength) {
                rst += str[index];
                i += charAtLength(str, index);
                index++;
            }
            else {
                break;
            }
        }
        rst += ELLIPSIS_CODE;
    }
    else if (position === 'head') {
        for (var i = 0, index = count - 1; i < reseveLength;) {
            var charLength = charAtLength(str, index);
            if (i + charLength <= reseveLength) {
                rst += str[index];
                i += charAtLength(str, index);
                index--;
            }
            else {
                break;
            }
        }
        rst = ELLIPSIS_CODE + rst;
    }
    else {
        var startStr = '';
        var endStr = '';
        for (var i = 0, startIndex = 0, endIndex = count - 1; i < reseveLength;) {
            var startCodeLen = charAtLength(str, startIndex);
            var hasAdd = false; // \u8BBE\u7F6E\u6807\u5FD7\u4F4D\uFF0C\u9632\u6B62\u5934\u5C3E\u90FD\u6CA1\u6709\u9644\u52A0\u5B57\u7B26
            if (startCodeLen + i <= reseveLength) {
                startStr += str[startIndex];
                startIndex++;
                i += startCodeLen;
                hasAdd = true;
            }
            var endCodeLen = charAtLength(str, endIndex);
            if (endCodeLen + i <= reseveLength) {
                endStr = str[endIndex] + endStr;
                i += endCodeLen;
                endIndex--;
                hasAdd = true;
            }
            if (!hasAdd) {
                // \u5982\u679C\u90FD\u6CA1\u6709\u589E\u52A0\u5B57\u7B26\uFF0C\u8BF4\u660E\u90FD\u4E0D\u9002\u5408\u5219\u4E2D\u65AD
                break;
            }
        }
        rst = startStr + ELLIPSIS_CODE + endStr;
    }
    return rst;
}
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/label.js


var label_ELLIPSIS_CODE = '\\u2026';
var ELLIPSIS_CODE_LENGTH = 2; // \u7701\u7565\u53F7\u7684\u957F\u5EA6
/** \u5927\u6570\u636E\u91CF\u9608\u503C */
var OPTIMIZE_THRESHOLD = 400;
/**
 * \u9488\u5BF9\u5927\u6570\u636E\u91CF\u505A\u4F18\u5316\u7684 getMaxLabelWidth\uFF0C\u505A\u6CD5\u4E0D\u662F\u76F4\u63A5\u53BB\u6BD4\u8F83\u6BCF\u4E00\u4E2A label \u7684\u6700\u5927\u5BBD\u5EA6
 * \u800C\u662F\u5148\u901A\u8FC7\u6BD4\u8F83\u6BCF\u4E2A label \u6BCF\u4E2A\u7684\u5B57\u7B26\u4E32\u7684\u957F\u5EA6\uFF0C\u8FD9\u91CC\u533A\u5206\u4E86\u4E0B\u4E2D\u82F1\u6587\u5B57\u7B26
 * \u6700\u7EC8\u662F\u53BB\u5B57\u7B26\u4E32\u6700\u201C\u957F\u201D\u7684\u90A3\u4E2A label \u7684\u5BBD\u5EA6\u3002
 * @param labels
 */
function getMaxLabelWidthOptimized(labels) {
    var texts = labels.map(function (label) {
        var text = label.attr('text');
        return (0,esm/* isNil */.UM)(text) ? '' : "" + text;
    });
    var maxLen = 0;
    var maxIdx = 0;
    for (var i = 0; i < texts.length; i += 1) {
        var len = 0;
        for (var j = 0; j <= texts[i].length; j += 1) {
            var code = texts[i].charCodeAt(j);
            if (code >= 19968 && code <= 40869) {
                len += 2;
            }
            else {
                len += 1;
            }
        }
        if (len > maxLen) {
            maxLen = len;
            maxIdx = i;
        }
    }
    return labels[maxIdx].getBBox().width;
}
/** \u83B7\u53D6\u6700\u957F\u7684 label */
function getMaxLabelWidth(labels) {
    if (labels.length > OPTIMIZE_THRESHOLD) {
        return getMaxLabelWidthOptimized(labels);
    }
    var max = 0;
    (0,esm/* each */.S6)(labels, function (label) {
        var bbox = label.getBBox();
        var width = bbox.width;
        if (max < width) {
            max = width;
        }
    });
    return max;
}
/** \u83B7\u53D6label\u957F\u5EA6 */
function getLabelLength(isVertical, label) {
    var bbox = label.getCanvasBBox();
    return isVertical ? bbox.width : bbox.height;
}
/* label\u957F\u5EA6\u662F\u5426\u8D85\u8FC7\u7EA6\u675F\u503C */
function testLabel(label, limitLength) {
    return label.getBBox().width < limitLength;
}
/** \u5904\u7406 text shape \u7684\u81EA\u52A8\u7701\u7565 */
function ellipsisLabel(isVertical, label, limitLength, position) {
    var _a;
    if (position === void 0) { position = 'tail'; }
    var text = (_a = label.attr('text')) !== null && _a !== void 0 ? _a : ''; // \u907F\u514D\u51FA\u73B0null\u3001undefined
    if (position === 'tail') {
        // component \u91CC\u7684\u7F29\u7565\u5904\u7406\u505A\u5F97\u5F88\u7CDF\u7CD5\uFF0C\u6587\u5B57\u957F\u5EA6\u6D4B\u7B97\u5B8C\u5168\u4E0D\u51C6\u786E
        // \u8FD9\u91CC\u6682\u65F6\u53EA\u5BF9 tail \u505A\u5904\u7406
        var font = (0,esm/* pick */.ei)(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);
        var ellipsisText = (0,esm/* getEllipsisText */.Lo)(text, limitLength, font, '\u2026');
        if (text !== ellipsisText) {
            label.attr('text', ellipsisText);
            label.set('tip', text);
            return true;
        }
        label.set('tip', null);
        return false;
    }
    var labelLength = getLabelLength(isVertical, label);
    var codeLength = strLen(text);
    var ellipsisFlag = false;
    if (limitLength < labelLength) {
        var reserveLength = Math.floor((limitLength / labelLength) * codeLength) - ELLIPSIS_CODE_LENGTH; // \u8BA1\u7B97\u51FA\u6765\u7684\u5E94\u8BE5\u4FDD\u5B58\u7684\u957F\u5EA6
        var newText = void 0;
        if (reserveLength >= 0) {
            newText = ellipsisString(text, reserveLength, position);
        }
        else {
            newText = label_ELLIPSIS_CODE;
        }
        if (newText) {
            label.attr('text', newText);
            ellipsisFlag = true;
        }
    }
    if (ellipsisFlag) {
        label.set('tip', text);
    }
    else {
        label.set('tip', null);
    }
    return ellipsisFlag;
}
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/graphic.js





function renderTag(container, tagCfg) {
    var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
    var tagGroup = container.addGroup({
        id: id + "-group",
        name: name + "-group",
        attrs: {
            x: x,
            y: y,
        }
    });
    // Text shape
    var text = tagGroup.addShape({
        type: 'text',
        id: id,
        name: name,
        attrs: (0,tslib_es6/* __assign */.pi)({ x: 0, y: 0, text: content }, style),
    });
    // maxLength \u5E94\u5305\u542B background \u4E2D\u7684 padding \u503C
    var padding = formatPadding((0,esm/* get */.U2)(background, 'padding', 0));
    if (maxLength && autoEllipsis) {
        var maxTextLength = maxLength - (padding[1] + padding[3]);
        // \u8D85\u51FA\u81EA\u52A8\u7701\u7565
        ellipsisLabel(!isVertical, text, maxTextLength, ellipsisPosition);
    }
    if (background) {
        // \u6E32\u67D3\u6587\u672C\u80CC\u666F
        var backgroundStyle = (0,esm/* get */.U2)(background, 'style', {});
        var _a = text.getCanvasBBox(), minX = _a.minX, minY = _a.minY, width = _a.width, height = _a.height;
        var tagBg = tagGroup.addShape('rect', {
            id: id + "-bg",
            name: id + "-bg",
            attrs: (0,tslib_es6/* __assign */.pi)({ x: minX - padding[3], y: minY - padding[0], width: width + padding[1] + padding[3], height: height + padding[0] + padding[2] }, backgroundStyle),
        });
        tagBg.toBack();
    }
    applyTranslate(tagGroup, x, y);
    applyRotate(tagGroup, rotate, x, y);
}
//# sourceMappingURL=graphic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/theme.js
/* harmony default export */ var theme = ({
    fontFamily: "\\n  BlinkMacSystemFont, \\"Segoe UI\\", Roboto,\\"Helvetica Neue\\",\\n  Helvetica, \\"PingFang SC\\", \\"Hiragino Sans GB\\", \\"Microsoft YaHei\\",\\n  SimSun, \\"sans-serif\\"",
    textColor: '#2C3542',
    activeTextColor: '#333333',
    uncheckedColor: '#D8D8D8',
    lineColor: '#416180',
    regionColor: '#CCD7EB',
    verticalAxisRotate: -Math.PI / 4,
    horizontalAxisRotate: Math.PI / 4,
    // descriptionIcon theme
    descriptionIconStroke: '#fff',
    descriptionIconFill: 'rgba(58, 73, 101, .25)',
});
//# sourceMappingURL=theme.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/line.js






var LineAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(LineAnnotation, _super);
    function LineAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    LineAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'line', locationType: 'region', start: null, end: null, style: {}, text: null, defaultCfg: {
                style: {
                    fill: theme.textColor,
                    fontSize: 12,
                    textAlign: 'center',
                    textBaseline: 'bottom',
                    fontFamily: theme.fontFamily,
                },
                text: {
                    position: 'center',
                    autoRotate: true,
                    content: null,
                    offsetX: 0,
                    offsetY: 0,
                    style: {
                        stroke: theme.lineColor,
                        lineWidth: 1,
                    },
                },
            } });
    };
    LineAnnotation.prototype.renderInner = function (group) {
        this.renderLine(group);
        if (this.get('text')) {
            this.renderLabel(group);
        }
    };
    // \u7ED8\u5236\u7EBF
    LineAnnotation.prototype.renderLine = function (group) {
        var start = this.get('start');
        var end = this.get('end');
        var style = this.get('style');
        this.addShape(group, {
            type: 'line',
            id: this.getElementId('line'),
            name: 'annotation-line',
            attrs: (0,tslib_es6/* __assign */.pi)({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style),
        });
    };
    // \u83B7\u53D6 label \u7684\u4F4D\u7F6E
    LineAnnotation.prototype.getLabelPoint = function (start, end, position) {
        var percent;
        if (position === 'start') {
            percent = 0;
        }
        else if (position === 'center') {
            percent = 0.5;
        }
        else if ((0,esm/* isString */.HD)(position) && position.indexOf('%') !== -1) {
            percent = parseInt(position, 10) / 100;
        }
        else if ((0,esm/* isNumber */.hj)(position)) {
            percent = position;
        }
        else {
            percent = 1;
        }
        if (percent > 1 || percent < 0) {
            percent = 1;
        }
        return {
            x: getValueByPercent(start.x, end.x, percent),
            y: getValueByPercent(start.y, end.y, percent),
        };
    };
    // \u7ED8\u5236 label
    LineAnnotation.prototype.renderLabel = function (group) {
        var text = this.get('text');
        var start = this.get('start');
        var end = this.get('end');
        var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a = text.isVertical, isVertical = _a === void 0 ? false : _a;
        var point = this.getLabelPoint(start, end, position);
        var x = point.x + offsetX;
        var y = point.y + offsetY;
        var cfg = {
            id: this.getElementId('line-text'),
            name: 'annotation-line-text',
            x: x,
            y: y,
            content: content,
            style: style,
            maxLength: maxLength,
            autoEllipsis: autoEllipsis,
            ellipsisPosition: ellipsisPosition,
            background: background,
            isVertical: isVertical,
        };
        // \u5982\u679C\u81EA\u52A8\u65CB\u8F6C
        if (autoRotate) {
            var vector = [end.x - start.x, end.y - start.y];
            cfg.rotate = Math.atan2(vector[1], vector[0]);
        }
        renderTag(group, cfg);
    };
    return LineAnnotation;
}(group_component));
/* harmony default export */ var line = (LineAnnotation);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/text.js





var TextAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TextAnnotation, _super);
    function TextAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    TextAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'text', locationType: 'point', x: 0, y: 0, content: '', rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: 'tail', defaultCfg: {
                style: {
                    fill: theme.textColor,
                    fontSize: 12,
                    textAlign: 'center',
                    textBaseline: 'middle',
                    fontFamily: theme.fontFamily,
                },
            } });
    };
    // \u590D\u5199 setLocation \u65B9\u6CD5\uFF0C\u4E0D\u9700\u8981\u91CD\u65B0\u521B\u5EFA text
    TextAnnotation.prototype.setLocation = function (location) {
        this.set('x', location.x);
        this.set('y', location.y);
        this.resetLocation();
    };
    TextAnnotation.prototype.renderInner = function (group) {
        var _a = this.getLocation(), x = _a.x, y = _a.y;
        var content = this.get('content');
        var style = this.get('style');
        var id = this.getElementId('text');
        var name = this.get('name') + "-text";
        var maxLength = this.get('maxLength');
        var autoEllipsis = this.get('autoEllipsis');
        var isVertical = this.get('isVertical');
        var ellipsisPosition = this.get('ellipsisPosition');
        var background = this.get('background');
        var rotate = this.get('rotate');
        var cfg = {
            id: id,
            name: name,
            x: x,
            y: y,
            content: content,
            style: style,
            maxLength: maxLength,
            autoEllipsis: autoEllipsis,
            isVertical: isVertical,
            ellipsisPosition: ellipsisPosition,
            background: background,
            rotate: rotate,
        };
        renderTag(group, cfg);
    };
    TextAnnotation.prototype.resetLocation = function () {
        var textGroup = this.getElementByLocalId('text-group');
        if (textGroup) {
            var _a = this.getLocation(), x = _a.x, y = _a.y;
            var rotate = this.get('rotate');
            applyTranslate(textGroup, x, y);
            applyRotate(textGroup, rotate, x, y);
        }
    };
    return TextAnnotation;
}(group_component));
/* harmony default export */ var annotation_text = (TextAnnotation);
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/arc.js



var ArcAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ArcAnnotation, _super);
    function ArcAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    ArcAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'arc', locationType: 'circle', center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2, style: {
                stroke: '#999',
                lineWidth: 1,
            } });
    };
    ArcAnnotation.prototype.renderInner = function (group) {
        this.renderArc(group);
    };
    ArcAnnotation.prototype.getArcPath = function () {
        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;
        var startPoint = getCirclePoint(center, radius, startAngle);
        var endPoint = getCirclePoint(center, radius, endAngle);
        var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
        var path = [['M', startPoint.x, startPoint.y]];
        if (endAngle - startAngle === Math.PI * 2) {
            // \u6574\u4E2A\u5706\u662F\u5206\u5272\u6210\u4E24\u4E2A\u5706
            var middlePoint = getCirclePoint(center, radius, startAngle + Math.PI);
            path.push(['A', radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
            path.push(['A', radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
        }
        else {
            path.push(['A', radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
        }
        return path;
    };
    // \u7ED8\u5236 arc
    ArcAnnotation.prototype.renderArc = function (group) {
        // \u4E5F\u53EF\u4EE5 \u901A\u8FC7 get('center') \u7C7B\u4F3C\u7684\u65B9\u5F0F\u9010\u4E2A\u83B7\u53D6
        var path = this.getArcPath();
        var style = this.get('style');
        this.addShape(group, {
            type: 'path',
            id: this.getElementId('arc'),
            name: 'annotation-arc',
            attrs: (0,tslib_es6/* __assign */.pi)({ path: path }, style),
        });
    };
    return ArcAnnotation;
}(group_component));
/* harmony default export */ var arc = (ArcAnnotation);
//# sourceMappingURL=arc.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/region.js




var RegionAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RegionAnnotation, _super);
    function RegionAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    RegionAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'region', locationType: 'region', start: null, end: null, style: {}, defaultCfg: {
                style: {
                    lineWidth: 0,
                    fill: theme.regionColor,
                    opacity: 0.4,
                },
            } });
    };
    RegionAnnotation.prototype.renderInner = function (group) {
        this.renderRegion(group);
    };
    RegionAnnotation.prototype.renderRegion = function (group) {
        var start = this.get('start');
        var end = this.get('end');
        var style = this.get('style');
        var bbox = regionToBBox({ start: start, end: end });
        this.addShape(group, {
            type: 'rect',
            id: this.getElementId('region'),
            name: 'annotation-region',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style),
        });
    };
    return RegionAnnotation;
}(group_component));
/* harmony default export */ var region = (RegionAnnotation);
//# sourceMappingURL=region.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/image.js



var ImageAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ImageAnnotation, _super);
    function ImageAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    ImageAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'image', locationType: 'region', start: null, end: null, src: null, style: {} });
    };
    ImageAnnotation.prototype.renderInner = function (group) {
        this.renderImage(group);
    };
    ImageAnnotation.prototype.getImageAttrs = function () {
        var start = this.get('start');
        var end = this.get('end');
        var style = this.get('style');
        var bbox = regionToBBox({ start: start, end: end });
        var src = this.get('src');
        return (0,tslib_es6/* __assign */.pi)({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
    };
    // \u7ED8\u5236\u56FE\u7247
    ImageAnnotation.prototype.renderImage = function (group) {
        this.addShape(group, {
            type: 'image',
            id: this.getElementId('image'),
            name: 'annotation-image',
            attrs: this.getImageAttrs(),
        });
    };
    return ImageAnnotation;
}(group_component));
/* harmony default export */ var annotation_image = (ImageAnnotation);
//# sourceMappingURL=image.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/data-marker.js






var DataMarkerAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DataMarkerAnnotation, _super);
    function DataMarkerAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    DataMarkerAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'dataMarker', locationType: 'point', x: 0, y: 0, point: {}, line: {}, text: {}, direction: 'upward', autoAdjust: true, coordinateBBox: null, defaultCfg: {
                point: {
                    display: true,
                    style: {
                        r: 3,
                        fill: '#FFFFFF',
                        stroke: '#1890FF',
                        lineWidth: 2,
                    },
                },
                line: {
                    display: true,
                    length: 20,
                    style: {
                        stroke: theme.lineColor,
                        lineWidth: 1,
                    },
                },
                text: {
                    content: '',
                    display: true,
                    style: {
                        fill: theme.textColor,
                        opacity: 0.65,
                        fontSize: 12,
                        textAlign: 'start',
                        fontFamily: theme.fontFamily,
                    },
                },
            } });
    };
    DataMarkerAnnotation.prototype.renderInner = function (group) {
        if ((0,esm/* get */.U2)(this.get('line'), 'display')) {
            this.renderLine(group);
        }
        if ((0,esm/* get */.U2)(this.get('text'), 'display')) {
            this.renderText(group);
        }
        if ((0,esm/* get */.U2)(this.get('point'), 'display')) {
            this.renderPoint(group);
        }
        if (this.get('autoAdjust')) {
            this.autoAdjust(group);
        }
    };
    DataMarkerAnnotation.prototype.applyOffset = function () {
        this.moveElementTo(this.get('group'), {
            x: this.get('x') + this.get('offsetX'),
            y: this.get('y') + this.get('offsetY'),
        });
    };
    DataMarkerAnnotation.prototype.renderPoint = function (group) {
        var point = this.getShapeAttrs().point;
        this.addShape(group, {
            type: 'circle',
            id: this.getElementId('point'),
            name: 'annotation-point',
            attrs: point,
        });
    };
    DataMarkerAnnotation.prototype.renderLine = function (group) {
        var line = this.getShapeAttrs().line;
        this.addShape(group, {
            type: 'path',
            id: this.getElementId('line'),
            name: 'annotation-line',
            attrs: line,
        });
    };
    DataMarkerAnnotation.prototype.renderText = function (group) {
        var textAttrs = this.getShapeAttrs().text;
        var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = (0,tslib_es6/* __rest */._T)(textAttrs, ["x", "y", "text"]);
        var _a = this.get('text'), background = _a.background, maxLength = _a.maxLength, autoEllipsis = _a.autoEllipsis, isVertival = _a.isVertival, ellipsisPosition = _a.ellipsisPosition;
        var tagCfg = {
            x: x,
            y: y,
            id: this.getElementId('text'),
            name: 'annotation-text',
            content: text,
            style: style,
            background: background,
            maxLength: maxLength,
            autoEllipsis: autoEllipsis,
            isVertival: isVertival,
            ellipsisPosition: ellipsisPosition,
        };
        renderTag(group, tagCfg);
    };
    DataMarkerAnnotation.prototype.autoAdjust = function (group) {
        var direction = this.get('direction');
        var x = this.get('x');
        var y = this.get('y');
        var lineLength = (0,esm/* get */.U2)(this.get('line'), 'length', 0);
        var coordinateBBox = this.get('coordinateBBox');
        var _a = group.getBBox(), minX = _a.minX, maxX = _a.maxX, minY = _a.minY, maxY = _a.maxY;
        var textGroup = group.findById(this.getElementId('text-group'));
        var textShape = group.findById(this.getElementId('text'));
        var lineShape = group.findById(this.getElementId('line'));
        if (!coordinateBBox) {
            return;
        }
        if (textGroup) {
            var translateX = textGroup.attr('x'), translateY = textGroup.attr('y');
            var _b = textShape.getCanvasBBox(), width = _b.width, height = _b.height;
            var xFactor = 0, yFactor = 0;
            if (x + minX <= coordinateBBox.minX) {
                // \u5DE6\u4FA7\u8D85\u51FA
                if (direction === 'leftward') {
                    xFactor = 1;
                }
                else {
                    var overflow = coordinateBBox.minX - (x + minX);
                    translateX = textGroup.attr('x') + overflow;
                }
            }
            else if (x + maxX >= coordinateBBox.maxX) {
                // \u53F3\u4FA7\u8D85\u51FA
                if (direction === 'rightward') {
                    xFactor = -1;
                }
                else {
                    var overflow = x + maxX - coordinateBBox.maxX;
                    translateX = textGroup.attr('x') - overflow;
                }
            }
            if (!!xFactor) {
                if (lineShape) {
                    lineShape.attr('path', [
                        ['M', 0, 0],
                        ['L', lineLength * xFactor, 0],
                    ]);
                }
                translateX = (lineLength + 2 + width) * xFactor;
            }
            if (y + minY <= coordinateBBox.minY) {
                // \u4E0A\u65B9\u8D85\u51FA
                if (direction === 'upward') {
                    yFactor = 1;
                }
                else {
                    var overflow = coordinateBBox.minY - (y + minY);
                    translateY = textGroup.attr('y') + overflow;
                }
            }
            else if (y + maxY >= coordinateBBox.maxY) {
                // \u4E0B\u65B9\u8D85\u51FA
                if (direction === 'downward') {
                    yFactor = -1;
                }
                else {
                    var overflow = y + maxY - coordinateBBox.maxY;
                    translateY = textGroup.attr('y') - overflow;
                }
            }
            if (!!yFactor) {
                if (lineShape) {
                    lineShape.attr('path', [
                        ['M', 0, 0],
                        ['L', 0, lineLength * yFactor],
                    ]);
                }
                translateY = (lineLength + 2 + height) * yFactor;
            }
            if (translateX !== textGroup.attr('x') || translateY !== textGroup.attr('y'))
                applyTranslate(textGroup, translateX, translateY);
        }
    };
    DataMarkerAnnotation.prototype.getShapeAttrs = function () {
        var lineDisplay = (0,esm/* get */.U2)(this.get('line'), 'display');
        var pointStyle = (0,esm/* get */.U2)(this.get('point'), 'style', {});
        var lineStyle = (0,esm/* get */.U2)(this.get('line'), 'style', {});
        var textStyle = (0,esm/* get */.U2)(this.get('text'), 'style', {});
        var direction = this.get('direction');
        var lineLength = lineDisplay ? (0,esm/* get */.U2)(this.get('line'), 'length', 0) : 0;
        var xFactor = 0, yFactor = 0;
        var textBaseline = 'top', textAlign = 'start';
        switch (direction) {
            case 'upward':
                yFactor = -1;
                textBaseline = 'bottom';
                break;
            case 'downward':
                yFactor = 1;
                textBaseline = 'top';
                break;
            case 'leftward':
                xFactor = -1;
                textAlign = 'end';
                break;
            case 'rightward':
                xFactor = 1;
                textAlign = 'start';
                break;
        }
        return {
            point: (0,tslib_es6/* __assign */.pi)({ x: 0, y: 0 }, pointStyle),
            line: (0,tslib_es6/* __assign */.pi)({ path: [
                    ['M', 0, 0],
                    ['L', lineLength * xFactor, lineLength * yFactor],
                ] }, lineStyle),
            text: (0,tslib_es6/* __assign */.pi)({ x: (lineLength + 2) * xFactor, y: (lineLength + 2) * yFactor, text: (0,esm/* get */.U2)(this.get('text'), 'content', ''), textBaseline: textBaseline,
                textAlign: textAlign }, textStyle),
        };
    };
    return DataMarkerAnnotation;
}(group_component));
/* harmony default export */ var data_marker = (DataMarkerAnnotation);
//# sourceMappingURL=data-marker.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/data-region.js






var DataRegionAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DataRegionAnnotation, _super);
    function DataRegionAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    DataRegionAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'dataRegion', locationType: 'points', points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
                region: {
                    style: {
                        lineWidth: 0,
                        fill: theme.regionColor,
                        opacity: 0.4,
                    },
                },
                text: {
                    content: '',
                    style: {
                        textAlign: 'center',
                        textBaseline: 'bottom',
                        fontSize: 12,
                        fill: theme.textColor,
                        fontFamily: theme.fontFamily,
                    },
                },
            } });
    };
    DataRegionAnnotation.prototype.renderInner = function (group) {
        var regionStyle = (0,esm/* get */.U2)(this.get('region'), 'style', {});
        var textStyle = (0,esm/* get */.U2)(this.get('text'), 'style', {});
        var lineLength = this.get('lineLength') || 0;
        var points = this.get('points');
        if (!points.length) {
            return;
        }
        var bbox = pointsToBBox(points);
        // render region
        var path = [];
        path.push(['M', points[0].x, bbox.minY - lineLength]);
        points.forEach(function (point) {
            path.push(['L', point.x, point.y]);
        });
        path.push(['L', points[points.length - 1].x, points[points.length - 1].y - lineLength]);
        this.addShape(group, {
            type: 'path',
            id: this.getElementId('region'),
            name: 'annotation-region',
            attrs: (0,tslib_es6/* __assign */.pi)({ path: path }, regionStyle),
        });
        // render text
        var textCfg = (0,tslib_es6/* __assign */.pi)({ id: this.getElementId('text'), name: 'annotation-text', x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get('text'));
        renderTag(group, textCfg);
    };
    return DataRegionAnnotation;
}(group_component));
/* harmony default export */ var data_region = (DataRegionAnnotation);
//# sourceMappingURL=data-region.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/region-filter.js




var RegionFilterAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RegionFilterAnnotation, _super);
    function RegionFilterAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    RegionFilterAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'regionFilter', locationType: 'region', start: null, end: null, color: null, shape: [] });
    };
    RegionFilterAnnotation.prototype.renderInner = function (group) {
        var _this = this;
        var start = this.get('start');
        var end = this.get('end');
        // 1. add region layer
        var layer = this.addGroup(group, {
            id: this.getElementId('region-filter'),
            capture: false,
        });
        // 2. clone shape & color it
        (0,esm/* each */.S6)(this.get('shapes'), function (shape, shapeIdx) {
            var type = shape.get('type');
            var attrs = (0,esm/* clone */.d9)(shape.attr());
            _this.adjustShapeAttrs(attrs);
            _this.addShape(layer, {
                id: _this.getElementId("shape-" + type + "-" + shapeIdx),
                capture: false,
                type: type,
                attrs: attrs,
            });
        });
        // 3. clip
        var clipBBox = regionToBBox({ start: start, end: end });
        layer.setClip({
            type: 'rect',
            attrs: {
                x: clipBBox.minX,
                y: clipBBox.minY,
                width: clipBBox.width,
                height: clipBBox.height,
            },
        });
    };
    RegionFilterAnnotation.prototype.adjustShapeAttrs = function (attr) {
        var color = this.get('color');
        if (attr.fill) {
            attr.fill = attr.fillStyle = color;
        }
        attr.stroke = attr.strokeStyle = color;
    };
    return RegionFilterAnnotation;
}(group_component));
/* harmony default export */ var region_filter = (RegionFilterAnnotation);
//# sourceMappingURL=region-filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/shape.js



var ShapeAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ShapeAnnotation, _super);
    function ShapeAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'shape', draw: esm/* noop */.ZT });
    };
    ShapeAnnotation.prototype.renderInner = function (group) {
        var render = this.get('render');
        if ((0,esm/* isFunction */.mf)(render)) {
            render(group);
        }
    };
    return ShapeAnnotation;
}(group_component));
/* harmony default export */ var annotation_shape = (ShapeAnnotation);
//# sourceMappingURL=shape.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/get-style.js
/**
 * \u83B7\u53D6\u6837\u5F0F
 * @param  {Object} dom DOM\u8282\u70B9
 * @param  {String} name \u6837\u5F0F\u540D
 * @param  {Any} defaultValue \u9ED8\u8BA4\u503C
 * @return {String} \u5C5E\u6027\u503C
 */
function getStyle(dom, name, defaultValue) {
    var v;
    try {
        v = window.getComputedStyle ?
            window.getComputedStyle(dom, null)[name] :
            dom.style[name]; // \u4E00\u822C\u4E0D\u4F1A\u8D70\u5230\u8FD9\u4E2A\u903B\u8F91\uFF0Cdom.style \u83B7\u53D6\u7684\u662F\u6807\u7B7E style \u5C5E\u6027\uFF0C\u4E5F\u4E0D\u51C6\u786E
    }
    catch (e) {
        // do nothing
    }
    finally {
        v = v === undefined ? defaultValue : v;
    }
    return v;
}
//# sourceMappingURL=get-style.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/get-width.js

function getHeight(el, defaultValue) {
    var width = getStyle(el, 'width', defaultValue);
    if (width === 'auto') {
        width = el.offsetWidth;
    }
    return parseFloat(width);
}
//# sourceMappingURL=get-width.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/get-outer-width.js


function getOuterWidth(el, defaultValue) {
    var width = getHeight(el, defaultValue);
    var bLeft = parseFloat(getStyle(el, 'borderLeftWidth')) || 0;
    var pLeft = parseFloat(getStyle(el, 'paddingLeft')) || 0;
    var pRight = parseFloat(getStyle(el, 'paddingRight')) || 0;
    var bRight = parseFloat(getStyle(el, 'borderRightWidth')) || 0;
    var mRight = parseFloat(getStyle(el, 'marginRight')) || 0;
    var mLeft = parseFloat(getStyle(el, 'marginLeft')) || 0;
    return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}
//# sourceMappingURL=get-outer-width.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/get-height.js

function get_height_getHeight(el, defaultValue) {
    var height = getStyle(el, 'height', defaultValue);
    if (height === 'auto') {
        height = el.offsetHeight;
    }
    return parseFloat(height);
}
//# sourceMappingURL=get-height.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/get-outer-height.js


function getOuterHeight(el, defaultValue) {
    var height = get_height_getHeight(el, defaultValue);
    var bTop = parseFloat(getStyle(el, 'borderTopWidth')) || 0;
    var pTop = parseFloat(getStyle(el, 'paddingTop')) || 0;
    var pBottom = parseFloat(getStyle(el, 'paddingBottom')) || 0;
    var bBottom = parseFloat(getStyle(el, 'borderBottomWidth')) || 0;
    var mTop = parseFloat(getStyle(el, 'marginTop')) || 0;
    var mBottom = parseFloat(getStyle(el, 'marginBottom')) || 0;
    return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}
//# sourceMappingURL=get-outer-height.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/abstract/html-component.js





var HtmlComponent = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(HtmlComponent, _super);
    function HtmlComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlComponent.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { container: null, containerTpl: '<div></div>', updateAutoRender: true, containerClassName: '', parent: null });
    };
    HtmlComponent.prototype.getContainer = function () {
        return this.get('container');
    };
    /**
     * \u663E\u793A\u7EC4\u4EF6
     */
    HtmlComponent.prototype.show = function () {
        var container = this.get('container');
        container.style.display = '';
        this.set('visible', true);
    };
    /**
     * \u9690\u85CF\u7EC4\u4EF6
     */
    HtmlComponent.prototype.hide = function () {
        var container = this.get('container');
        container.style.display = 'none';
        this.set('visible', false);
    };
    /**
     * \u662F\u5426\u5141\u8BB8\u6355\u6349\u4E8B\u4EF6
     * @param capture \u4E8B\u4EF6\u6355\u6349
     */
    HtmlComponent.prototype.setCapture = function (capture) {
        var container = this.getContainer();
        var value = capture ? 'auto' : 'none';
        container.style.pointerEvents = value;
        this.set('capture', capture);
    };
    HtmlComponent.prototype.getBBox = function () {
        var container = this.getContainer();
        var x = parseFloat(container.style.left) || 0;
        var y = parseFloat(container.style.top) || 0;
        return createBBox(x, y, container.clientWidth, container.clientHeight);
    };
    HtmlComponent.prototype.clear = function () {
        var container = this.get('container');
        clearDom(container);
    };
    HtmlComponent.prototype.destroy = function () {
        this.removeEvent();
        this.removeDom();
        _super.prototype.destroy.call(this);
    };
    /**
     * \u590D\u5199 init\uFF0C\u4E3B\u8981\u662F\u521D\u59CB\u5316 DOM \u548C\u4E8B\u4EF6
     */
    HtmlComponent.prototype.init = function () {
        _super.prototype.init.call(this);
        this.initContainer();
        this.initDom();
        this.resetStyles(); // \u521D\u59CB\u5316\u6837\u5F0F
        this.applyStyles(); // \u5E94\u7528\u6837\u5F0F
        this.initEvent();
        this.initCapture();
        this.initVisible();
    };
    HtmlComponent.prototype.initCapture = function () {
        this.setCapture(this.get('capture'));
    };
    HtmlComponent.prototype.initVisible = function () {
        if (!this.get('visible')) {
            // \u8BBE\u7F6E\u521D\u59CB\u663E\u793A\u72B6\u6001
            this.hide();
        }
        else {
            this.show();
        }
    };
    HtmlComponent.prototype.initDom = function () {
    };
    HtmlComponent.prototype.initContainer = function () {
        var container = this.get('container');
        if ((0,esm/* isNil */.UM)(container)) {
            // \u672A\u6307\u5B9A container \u5219\u521B\u5EFA
            container = this.createDom();
            var parent_1 = this.get('parent');
            if ((0,esm/* isString */.HD)(parent_1)) {
                parent_1 = document.getElementById(parent_1);
                this.set('parent', parent_1);
            }
            parent_1.appendChild(container);
            if (this.get('containerId')) {
                container.setAttribute('id', this.get('containerId'));
            }
            this.set('container', container);
        }
        else if ((0,esm/* isString */.HD)(container)) {
            // \u7528\u6237\u4F20\u5165\u7684 id, \u4F5C\u4E3A container
            container = document.getElementById(container);
            this.set('container', container);
        } // else container \u662F DOM
        if (!this.get('parent')) {
            this.set('parent', container.parentNode);
        }
    };
    // \u6837\u5F0F\u9700\u8981\u8FDB\u884C\u5408\u5E76\uFF0C\u4E0D\u80FD\u5355\u7EAF\u7684\u66FF\u6362\uFF0C\u5426\u5219\u4F7F\u7528\u975E\u5E38\u4E0D\u65B9\u4FBF
    HtmlComponent.prototype.resetStyles = function () {
        var style = this.get('domStyles');
        var defaultStyles = this.get('defaultStyles');
        if (!style) {
            style = defaultStyles;
        }
        else {
            style = (0,esm/* deepMix */.b$)({}, defaultStyles, style);
        }
        this.set('domStyles', style);
    };
    // \u5E94\u7528\u6240\u6709\u7684\u6837\u5F0F
    HtmlComponent.prototype.applyStyles = function () {
        var domStyles = this.get('domStyles');
        if (!domStyles) {
            return;
        }
        var container = this.getContainer();
        this.applyChildrenStyles(container, domStyles);
        var containerClassName = this.get('containerClassName');
        if (containerClassName && hasClass(container, containerClassName)) {
            var containerCss = domStyles[containerClassName];
            modifyCSS(container, containerCss);
        }
    };
    HtmlComponent.prototype.applyChildrenStyles = function (element, styles) {
        (0,esm/* each */.S6)(styles, function (style, name) {
            var elements = element.getElementsByClassName(name);
            (0,esm/* each */.S6)(elements, function (el) {
                modifyCSS(el, style);
            });
        });
    };
    // \u5E94\u7528\u5230\u5355\u4E2A DOM
    HtmlComponent.prototype.applyStyle = function (cssName, dom) {
        var domStyles = this.get('domStyles');
        modifyCSS(dom, domStyles[cssName]);
    };
    /**
     * @protected
     */
    HtmlComponent.prototype.createDom = function () {
        var containerTpl = this.get('containerTpl');
        return createDom(containerTpl);
    };
    /**
     * @protected
     * \u521D\u59CB\u5316\u4E8B\u4EF6
     */
    HtmlComponent.prototype.initEvent = function () { };
    /**
     * @protected
     * \u6E05\u7406 DOM
     */
    HtmlComponent.prototype.removeDom = function () {
        var container = this.get('container');
        // \u8282\u70B9\u4E0D\u4E00\u5B9A\u6709parentNode
        container && container.parentNode && container.parentNode.removeChild(container);
    };
    /**
     * @protected
     * \u6E05\u7406\u4E8B\u4EF6
     */
    HtmlComponent.prototype.removeEvent = function () { };
    HtmlComponent.prototype.updateInner = function (cfg) {
        // \u66F4\u65B0\u6837\u5F0F
        if ((0,esm/* hasKey */.wH)(cfg, 'domStyles')) {
            this.resetStyles();
            this.applyStyles();
        }
        // \u53EA\u8981\u5C5E\u6027\u53D1\u751F\u53D8\u5316\uFF0C\u90FD\u8C03\u6574\u4E00\u4E9B\u4F4D\u7F6E
        this.resetPosition();
    };
    HtmlComponent.prototype.resetPosition = function () { };
    ;
    return HtmlComponent;
}(component));
/* harmony default export */ var html_component = (HtmlComponent);
//# sourceMappingURL=html-component.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/html.js





var HtmlAnnotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(HtmlAnnotation, _super);
    function HtmlAnnotation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlAnnotation.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'annotation', type: 'html', locationType: 'point', x: 0, y: 0, containerTpl: "<div class=\\"g2-html-annotation\\" style=\\"position:absolute\\"></div>", alignX: 'left', alignY: 'top', html: '', zIndex: 7 });
    };
    HtmlAnnotation.prototype.render = function () {
        var container = this.getContainer();
        var html = this.get('html');
        clearDom(container);
        var rst = (0,esm/* isFunction */.mf)(html) ? html(container) : html;
        if ((0,esm/* isElement */.kK)(rst)) {
            container.appendChild(rst);
        }
        else if ((0,esm/* isString */.HD)(rst) || (0,esm/* isNumber */.hj)(rst)) {
            var dom = createDom("" + rst);
            if (dom) {
                container.appendChild(dom);
            }
        }
        this.resetPosition();
    };
    HtmlAnnotation.prototype.resetPosition = function () {
        var container = this.getContainer();
        var _a = this.getLocation(), x = _a.x, y = _a.y;
        var alignX = this.get('alignX');
        var alignY = this.get('alignY');
        var offsetX = this.get('offsetX');
        var offsetY = this.get('offsetY');
        var domWidth = getOuterWidth(container);
        var domHeight = getOuterHeight(container);
        var position = {
            x: x,
            y: y,
        };
        if (alignX === 'middle') {
            position.x -= Math.round(domWidth / 2);
        }
        else if (alignX === 'right') {
            position.x -= Math.round(domWidth);
        }
        if (alignY === 'middle') {
            position.y -= Math.round(domHeight / 2);
        }
        else if (alignY === 'bottom') {
            position.y -= Math.round(domHeight);
        }
        if (offsetX) {
            position.x += offsetX;
        }
        if (offsetY) {
            position.y += offsetY;
        }
        modifyCSS(container, {
            position: 'absolute',
            left: position.x + "px",
            top: position.y + "px",
            zIndex: this.get('zIndex'),
        });
    };
    return HtmlAnnotation;
}(html_component));
/* harmony default export */ var html = (HtmlAnnotation);
//# sourceMappingURL=html.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/annotation/index.js










//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/state.js

// \u83B7\u53D6\u591A\u4E2A\u72B6\u6001\u91CF\u7684\u5408\u5E76\u503C
function getStatesStyle(item, elementName, stateStyles) {
    var styleName = elementName + "Style"; // activeStyle
    var styles = null;
    (0,esm/* each */.S6)(stateStyles, function (v, state) {
        if (item[state] && v[styleName]) {
            if (!styles) {
                styles = {};
            }
            (0,esm/* mix */.CD)(styles, v[styleName]); // \u5408\u5E76\u6837\u5F0F
        }
    });
    return styles;
}
//# sourceMappingURL=state.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/base.js







var AxisBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(AxisBase, _super);
    function AxisBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisBase.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'axis', ticks: [], line: {}, tickLine: {}, subTickLine: null, title: null, 
            /**
             * \u6587\u672C\u6807\u7B7E\u7684\u914D\u7F6E\u9879
             */
            label: {}, 
            /**
             * \u5782\u76F4\u4E8E\u5750\u6807\u8F74\u65B9\u5411\u7684\u56E0\u5B50\uFF0C\u51B3\u5B9A\u6587\u672C\u3001title\u3001tickLine \u5728\u5750\u6807\u8F74\u7684\u54EA\u4E00\u4FA7
             */
            verticalFactor: 1, 
            // \u5782\u76F4\u65B9\u5411\u9650\u5236\u7684\u957F\u5EA6\uFF0C\u5BF9\u6587\u672C\u81EA\u9002\u5E94\u6709\u5F88\u5927\u5F71\u54CD
            verticalLimitLength: null, overlapOrder: ['autoRotate', 'autoEllipsis', 'autoHide'], tickStates: {}, optimize: {}, defaultCfg: {
                line: {
                    // @type {Attrs} \u5750\u6807\u8F74\u7EBF\u7684\u56FE\u5F62\u5C5E\u6027,\u5982\u679C\u8BBE\u7F6E\u6210null\uFF0C\u5219\u4E0D\u663E\u793A\u8F74\u7EBF
                    style: {
                        lineWidth: 1,
                        stroke: theme.lineColor,
                    },
                },
                tickLine: {
                    // @type {Attrs} \u6807\u6CE8\u5750\u6807\u7EBF\u7684\u56FE\u5F62\u5C5E\u6027
                    style: {
                        lineWidth: 1,
                        stroke: theme.lineColor,
                    },
                    alignTick: true,
                    length: 5,
                    displayWithLabel: true,
                },
                subTickLine: {
                    // @type {Attrs} \u6807\u6CE8\u5750\u6807\u7EBF\u7684\u56FE\u5F62\u5C5E\u6027
                    style: {
                        lineWidth: 1,
                        stroke: theme.lineColor,
                    },
                    count: 4,
                    length: 2,
                },
                label: {
                    autoRotate: true,
                    autoHide: false,
                    autoEllipsis: false,
                    style: {
                        fontSize: 12,
                        fill: theme.textColor,
                        fontFamily: theme.fontFamily,
                        fontWeight: 'normal',
                    },
                    offset: 10,
                    offsetX: 0,
                    offsetY: 0,
                },
                title: {
                    autoRotate: true,
                    spacing: 5,
                    position: 'center',
                    style: {
                        fontSize: 12,
                        fill: theme.textColor,
                        textBaseline: 'middle',
                        fontFamily: theme.fontFamily,
                        textAlign: 'center',
                    },
                    iconStyle: {
                        fill: theme.descriptionIconFill,
                        stroke: theme.descriptionIconStroke,
                    },
                    description: ''
                },
                tickStates: {
                    active: {
                        labelStyle: {
                            fontWeight: 500,
                        },
                        tickLineStyle: {
                            lineWidth: 2,
                        },
                    },
                    inactive: {
                        labelStyle: {
                            fill: theme.uncheckedColor,
                        },
                    },
                },
                // \u9488\u5BF9\u5927\u6570\u636E\u91CF\u8FDB\u884C\u4F18\u5316\u914D\u7F6E
                optimize: {
                    enable: true,
                    threshold: 400,
                },
            }, theme: {} });
    };
    /**
     * \u7ED8\u5236\u7EC4\u4EF6
     */
    AxisBase.prototype.renderInner = function (group) {
        if (this.get('line')) {
            this.drawLine(group);
        }
        // drawTicks \u5305\u62EC drawLabels \u548C drawTickLines
        this.drawTicks(group);
        if (this.get('title')) {
            this.drawTitle(group);
        }
    };
    // \u5B9E\u73B0 IList \u63A5\u53E3
    AxisBase.prototype.isList = function () {
        return true;
    };
    /**
     * \u83B7\u53D6\u56FE\u4F8B\u9879
     * @return {ListItem[]} \u5217\u8868\u9879\u96C6\u5408
     */
    AxisBase.prototype.getItems = function () {
        return this.get('ticks');
    };
    /**
     * \u8BBE\u7F6E\u5217\u8868\u9879
     * @param {ListItem[]} items \u5217\u8868\u9879\u96C6\u5408
     */
    AxisBase.prototype.setItems = function (items) {
        this.update({
            ticks: items,
        });
    };
    /**
     * \u66F4\u65B0\u5217\u8868\u9879
     * @param {ListItem} item \u5217\u8868\u9879
     * @param {object}   cfg  \u5217\u8868\u9879
     */
    AxisBase.prototype.updateItem = function (item, cfg) {
        (0,esm/* mix */.CD)(item, cfg);
        this.clear(); // \u7531\u4E8E\u5355\u4E2A\u56FE\u4F8B\u9879\u53D8\u5316\uFF0C\u4F1A\u5F15\u8D77\u5168\u5C40\u53D8\u5316\uFF0C\u6240\u4EE5\u5168\u90E8\u66F4\u65B0
        this.render();
    };
    /**
     * \u6E05\u7A7A\u5217\u8868
     */
    AxisBase.prototype.clearItems = function () {
        var itemGroup = this.getElementByLocalId('label-group');
        itemGroup && itemGroup.clear();
    };
    /**
     * \u8BBE\u7F6E\u5217\u8868\u9879\u7684\u72B6\u6001
     * @param {ListItem} item  \u5217\u8868\u9879
     * @param {string}   state \u72B6\u6001\u540D
     * @param {boolean}  value \u72B6\u6001\u503C, true, false
     */
    AxisBase.prototype.setItemState = function (item, state, value) {
        item[state] = value;
        this.updateTickStates(item); // \u5E94\u7528\u72B6\u6001\u6837\u5F0F
    };
    /**
     * \u662F\u5426\u5B58\u5728\u6307\u5B9A\u7684\u72B6\u6001
     * @param {ListItem} item  \u5217\u8868\u9879
     * @param {boolean} state \u72B6\u6001\u540D
     */
    AxisBase.prototype.hasState = function (item, state) {
        return !!item[state];
    };
    AxisBase.prototype.getItemStates = function (item) {
        var tickStates = this.get('tickStates');
        var rst = [];
        (0,esm/* each */.S6)(tickStates, function (v, k) {
            if (item[k]) {
                // item.selected
                rst.push(k);
            }
        });
        return rst;
    };
    /**
     * \u6E05\u695A\u6240\u6709\u5217\u8868\u9879\u7684\u72B6\u6001
     * @param {string} state \u72B6\u6001\u503C
     */
    AxisBase.prototype.clearItemsState = function (state) {
        var _this = this;
        var items = this.getItemsByState(state);
        (0,esm/* each */.S6)(items, function (item) {
            _this.setItemState(item, state, false);
        });
    };
    /**
     * \u6839\u636E\u72B6\u6001\u83B7\u53D6\u56FE\u4F8B\u9879
     * @param  {string}     state [description]
     * @return {ListItem[]}       [description]
     */
    AxisBase.prototype.getItemsByState = function (state) {
        var _this = this;
        var items = this.getItems();
        return (0,esm/* filter */.hX)(items, function (item) {
            return _this.hasState(item, state);
        });
    };
    AxisBase.prototype.getSidePoint = function (point, offset) {
        var self = this;
        var vector = self.getSideVector(offset, point);
        return {
            x: point.x + vector[0],
            y: point.y + vector[1],
        };
    };
    AxisBase.prototype.getTextAnchor = function (vector) {
        var align;
        if ((0,esm/* isNumberEqual */.vQ)(vector[0], 0)) {
            align = 'center';
        }
        else if (vector[0] > 0) {
            align = 'start';
        }
        else if (vector[0] < 0) {
            align = 'end';
        }
        return align;
    };
    AxisBase.prototype.getTextBaseline = function (vector) {
        var base;
        if ((0,esm/* isNumberEqual */.vQ)(vector[1], 0)) {
            base = 'middle';
        }
        else if (vector[1] > 0) {
            base = 'top';
        }
        else if (vector[1] < 0) {
            base = 'bottom';
        }
        return base;
    };
    AxisBase.prototype.processOverlap = function (labelGroup) { };
    // \u7ED8\u5236\u5750\u6807\u8F74\u7EBF
    AxisBase.prototype.drawLine = function (group) {
        var path = this.getLinePath();
        var line = this.get('line'); // line \u7684\u5224\u7A7A\u5728\u8C03\u7528 drawLine \u4E4B\u524D\uFF0C\u4E0D\u5728\u8FD9\u91CC\u5224\u5B9A
        this.addShape(group, {
            type: 'path',
            id: this.getElementId('line'),
            name: 'axis-line',
            attrs: (0,esm/* mix */.CD)({
                path: path,
            }, line.style),
        });
    };
    AxisBase.prototype.getTickLineItems = function (ticks) {
        var _this = this;
        var tickLineItems = [];
        var tickLine = this.get('tickLine');
        var alignTick = tickLine.alignTick;
        var tickLineLength = tickLine.length;
        var tickSegment = 1;
        var tickCount = ticks.length;
        if (tickCount >= 2) {
            tickSegment = ticks[1].value - ticks[0].value;
        }
        (0,esm/* each */.S6)(ticks, function (tick) {
            var point = tick.point;
            if (!alignTick) {
                // tickLine \u4E0D\u540C tick \u5BF9\u9F50\u65F6\u9700\u8981\u8C03\u6574 point
                point = _this.getTickPoint(tick.value - tickSegment / 2);
            }
            var endPoint = _this.getSidePoint(point, tickLineLength);
            tickLineItems.push({
                startPoint: point,
                tickValue: tick.value,
                endPoint: endPoint,
                tickId: tick.id,
                id: "tickline-" + tick.id,
            });
        });
        // \u5982\u679C tickLine \u4E0D\u5C45\u4E2D\u5BF9\u9F50\uFF0C\u5219\u9700\u8981\u5728\u6700\u540E\u9762\u8865\u5145\u4E00\u4E2A tickLine
        // if (!alignTick && tickCount > 0) {
        //   const tick = ticks[tickCount - 1];
        //   const point = this.getTickPoint(tick.value + tickSegment / 2);
        // }
        return tickLineItems;
    };
    AxisBase.prototype.getSubTickLineItems = function (tickLineItems) {
        var subTickLineItems = [];
        var subTickLine = this.get('subTickLine');
        var subCount = subTickLine.count;
        var tickLineCount = tickLineItems.length;
        // \u523B\u5EA6\u7EBF\u7684\u6570\u91CF\u5927\u4E8E 2 \u65F6\uFF0C\u624D\u7ED8\u5236\u5B50\u523B\u5EA6
        if (tickLineCount >= 2) {
            for (var i = 0; i < tickLineCount - 1; i++) {
                var pre = tickLineItems[i];
                var next = tickLineItems[i + 1];
                for (var j = 0; j < subCount; j++) {
                    var percent = (j + 1) / (subCount + 1);
                    var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
                    var point = this.getTickPoint(tickValue);
                    var endPoint = this.getSidePoint(point, subTickLine.length);
                    subTickLineItems.push({
                        startPoint: point,
                        endPoint: endPoint,
                        tickValue: tickValue,
                        id: "sub-" + pre.id + "-" + j,
                    });
                }
            }
        }
        return subTickLineItems;
    };
    AxisBase.prototype.getTickLineAttrs = function (tickItem, type, index, tickItems) {
        var style = this.get(type).style;
        // \u4FDD\u6301\u548C grid \u76F8\u540C\u7684\u6570\u636E\u7ED3\u6784
        var item = {
            points: [tickItem.startPoint, tickItem.endPoint],
        };
        var defaultTickLineStyle = (0,esm/* get */.U2)(this.get('theme'), ['tickLine', 'style'], {});
        style = (0,esm/* isFunction */.mf)(style) ? (0,esm/* mix */.CD)({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
        var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
        return (0,tslib_es6/* __assign */.pi)({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
    };
    // \u7ED8\u5236\u5750\u6807\u8F74\u523B\u5EA6\u7EBF
    AxisBase.prototype.drawTick = function (tickItem, tickLineGroup, type, index, tickItems) {
        this.addShape(tickLineGroup, {
            type: 'line',
            id: this.getElementId(tickItem.id),
            name: "axis-" + type,
            attrs: this.getTickLineAttrs(tickItem, type, index, tickItems),
        });
    };
    // \u7ED8\u5236\u5750\u6807\u8F74\u523B\u5EA6\u7EBF\uFF0C\u5305\u62EC\u5B50\u523B\u5EA6\u7EBF
    AxisBase.prototype.drawTickLines = function (group) {
        var _this = this;
        var ticks = this.get('ticks');
        var subTickLine = this.get('subTickLine');
        var tickLineItems = this.getTickLineItems(ticks);
        var tickLineGroup = this.addGroup(group, {
            name: 'axis-tickline-group',
            id: this.getElementId('tickline-group'),
        });
        var tickCfg = this.get('tickLine');
        (0,esm/* each */.S6)(tickLineItems, function (item, index) {
            if (tickCfg.displayWithLabel) {
                // \u5982\u679C\u8DDF\u968F label \u663E\u793A\uFF0C\u5219\u68C0\u6D4B\u662F\u5426\u5B58\u5728\u5BF9\u5E94\u7684 label
                var labelId = _this.getElementId("label-" + item.tickId);
                if (group.findById(labelId)) {
                    _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
                }
            }
            else {
                _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
            }
        });
        if (subTickLine) {
            var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
            (0,esm/* each */.S6)(subTickLineItems_1, function (item, index) {
                _this.drawTick(item, tickLineGroup, 'subTickLine', index, subTickLineItems_1);
            });
        }
    };
    // \u9884\u5904\u7406 ticks \u786E\u5B9A\u4F4D\u7F6E\u548C\u8865\u5145 id
    AxisBase.prototype.processTicks = function () {
        var _this = this;
        var ticks = this.get('ticks');
        (0,esm/* each */.S6)(ticks, function (tick) {
            tick.point = _this.getTickPoint(tick.value);
            // \u8865\u5145 tick \u7684 id\uFF0C\u4E3A\u52A8\u753B\u548C\u66F4\u65B0\u505A\u51C6\u5907
            if ((0,esm/* isNil */.UM)(tick.id)) {
                // \u9ED8\u8BA4\u4F7F\u7528 tick.name \u4F5C\u4E3Aid
                tick.id = tick.name;
            }
        });
    };
    // \u7ED8\u5236 ticks \u5305\u62EC\u6587\u672C\u548C tickLine
    AxisBase.prototype.drawTicks = function (group) {
        var _this = this;
        this.optimizeTicks();
        this.processTicks();
        if (this.get('label')) {
            this.drawLabels(group);
        }
        if (this.get('tickLine')) {
            this.drawTickLines(group);
        }
        var ticks = this.get('ticks');
        (0,esm/* each */.S6)(ticks, function (tick) {
            _this.applyTickStates(tick, group);
        });
    };
    /**
     * \u6839\u636E optimize \u914D\u7F6E\u5BF9 ticks \u8FDB\u884C\u62BD\u6837\uFF0C\u5BF9\u62BD\u6837\u8FC7\u540E\u7684 ticks \u624D\u8FDB\u884C\u771F\u5B9E\u7684\u6E32\u67D3
     */
    AxisBase.prototype.optimizeTicks = function () {
        var optimize = this.get('optimize');
        var ticks = this.get('ticks');
        if (optimize && optimize.enable && optimize.threshold > 0) {
            var len = (0,esm/* size */.dp)(ticks);
            if (len > optimize.threshold) {
                var page_1 = Math.ceil(len / optimize.threshold);
                var optimizedTicks = ticks.filter(function (tick, idx) { return idx % page_1 === 0; });
                this.set('ticks', optimizedTicks);
                this.set('originalTicks', ticks);
            }
        }
    };
    // \u83B7\u53D6 label \u7684\u914D\u7F6E\u9879
    AxisBase.prototype.getLabelAttrs = function (tick, index, ticks) {
        var labelCfg = this.get('label');
        var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate = labelCfg.rotate, formatter = labelCfg.formatter;
        var point = this.getSidePoint(tick.point, offset);
        var vector = this.getSideVector(offset, point);
        var text = formatter ? formatter(tick.name, tick, index) : tick.name;
        var style = labelCfg.style;
        style = (0,esm/* isFunction */.mf)(style) ? (0,esm/* get */.U2)(this.get('theme'), ['label', 'style'], {}) : style;
        var attrs = (0,esm/* mix */.CD)({
            x: point.x + offsetX,
            y: point.y + offsetY,
            text: text,
            textAlign: this.getTextAnchor(vector),
            textBaseline: this.getTextBaseline(vector),
        }, style);
        if (rotate) {
            attrs.matrix = getMatrixByAngle(point, rotate);
        }
        return attrs;
    };
    // \u7ED8\u5236\u6587\u672C
    AxisBase.prototype.drawLabels = function (group) {
        var _this = this;
        var ticks = this.get('ticks');
        var labelGroup = this.addGroup(group, {
            name: 'axis-label-group',
            id: this.getElementId('label-group'),
        });
        (0,esm/* each */.S6)(ticks, function (tick, index) {
            _this.addShape(labelGroup, {
                type: 'text',
                name: 'axis-label',
                id: _this.getElementId("label-" + tick.id),
                attrs: _this.getLabelAttrs(tick, index, ticks),
                delegateObject: {
                    tick: tick,
                    item: tick,
                    index: index,
                },
            });
        });
        this.processOverlap(labelGroup);
        // \u5904\u7406\u5B8C\u540E\u518D\u8FDB\u884C style \u56DE\u8C03\u5904\u7406
        var labels = labelGroup.getChildren();
        var defaultLabelStyle = (0,esm/* get */.U2)(this.get('theme'), ['label', 'style'], {});
        var _a = this.get('label'), style = _a.style, formatter = _a.formatter;
        if ((0,esm/* isFunction */.mf)(style)) {
            var afterProcessTicks_1 = labels.map(function (label) { return (0,esm/* get */.U2)(label.get('delegateObject'), 'tick'); });
            (0,esm/* each */.S6)(labels, function (label, index) {
                var tick = label.get('delegateObject').tick;
                var text = formatter ? formatter(tick.name, tick, index) : tick.name;
                var newStyle = (0,esm/* mix */.CD)({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
                label.attr(newStyle);
            });
        }
    };
    // \u6807\u9898\u7684\u5C5E\u6027
    AxisBase.prototype.getTitleAttrs = function () {
        var titleCfg = this.get('title');
        var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a = titleCfg.spacing, spacing = _a === void 0 ? 0 : _a, autoRotate = titleCfg.autoRotate;
        var titleHeight = style.fontSize;
        var percent = 0.5;
        if (position === 'start') {
            percent = 0;
        }
        else if (position === 'end') {
            percent = 1;
        }
        var point = this.getTickPoint(percent); // \u6807\u9898\u5BF9\u5E94\u7684\u5750\u6807\u8F74\u4E0A\u7684\u70B9
        // \u5982\u679C\u6CA1\u6709\u6307\u5B9A titleOffset \u4E5F\u6CA1\u6709\u6E32\u67D3 label\uFF0C\u8FD9\u91CC\u9700\u8981\u81EA\u52A8\u8BA1\u7B97 offset
        var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2); // \u6807\u9898\u7684\u70B9
        var attrs = (0,esm/* mix */.CD)({
            x: titlePoint.x,
            y: titlePoint.y,
            text: titleCfg.text,
        }, style);
        var rotate = titleCfg.rotate; // rotate \u662F\u89D2\u5EA6\u503C
        var angle = rotate;
        if ((0,esm/* isNil */.UM)(rotate) && autoRotate) {
            // \u7528\u6237\u6CA1\u6709\u8BBE\u5B9A\u65CB\u8F6C\u89D2\u5EA6\uFF0C\u540C\u65F6\u8BBE\u7F6E\u81EA\u52A8\u65CB\u8F6C
            var vector = this.getAxisVector(point);
            var v1 = [1, 0]; // \u6C34\u5E73\u65B9\u5411\u7684\u5411\u91CF
            angle = ext/* angleTo */.Dg(vector, v1, true);
        }
        if (angle) {
            var matrix = getMatrixByAngle(titlePoint, angle);
            attrs.matrix = matrix;
        }
        return attrs;
    };
    // \u7ED8\u5236\u6807\u9898
    AxisBase.prototype.drawTitle = function (group) {
        var _a;
        var titleAttrs = this.getTitleAttrs();
        var titleShape = this.addShape(group, {
            type: 'text',
            id: this.getElementId('title'),
            name: 'axis-title',
            attrs: titleAttrs
        });
        // description\u5B57\u6BB5\u5B58\u5728\u65F6\uFF0C\u663E\u793Aicon
        if ((_a = this.get('title')) === null || _a === void 0 ? void 0 : _a.description) {
            this.drawDescriptionIcon(group, titleShape, titleAttrs.matrix);
        }
    };
    AxisBase.prototype.drawDescriptionIcon = function (group, titleShape, matrix) {
        var descriptionShape = this.addGroup(group, {
            name: 'axis-description',
            id: this.getElementById('description')
        });
        var _a = titleShape.getBBox(), maxX = _a.maxX, maxY = _a.maxY, height = _a.height;
        var iconStyle = this.get('title').iconStyle;
        var spacing = 4; // \u8BBE\u7F6Eicon\u4E0E\u6587\u672C\u4E4B\u95F4\u8DDD\u79BB
        var r = height / 2;
        var lineWidth = r / 6;
        var startX = maxX + spacing;
        var startY = maxY - height / 2;
        // \u7ED8\u5236 information icon \u8DEF\u5F84
        // \u5916\u5706\u73AFpath
        var _b = [startX + r, startY - r], x0 = _b[0], y0 = _b[1];
        var _c = [x0 + r, y0 + r], x1 = _c[0], y1 = _c[1];
        var _d = [x0, y1 + r], x2 = _d[0], y2 = _d[1];
        var _e = [startX, y0 + r], x3 = _e[0], y3 = _e[1];
        // i path
        var _f = [startX + r, startY - height / 4], x4 = _f[0], y4 = _f[1];
        var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
        var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
        var _j = [x6, y6 + r * 3 / 4], x7 = _j[0], y7 = _j[1];
        this.addShape(descriptionShape, {
            type: 'path',
            id: this.getElementId('title-description-icon'),
            name: 'axis-title-description-icon',
            attrs: (0,tslib_es6/* __assign */.pi)({ path: [
                    ['M', x0, y0],
                    ['A', r, r, 0, 0, 1, x1, y1],
                    ['A', r, r, 0, 0, 1, x2, y2],
                    ['A', r, r, 0, 0, 1, x3, y3],
                    ['A', r, r, 0, 0, 1, x0, y0],
                    ['M', x4, y4],
                    ['L', x5, y5],
                    ['M', x6, y6],
                    ['L', x7, y7]
                ], lineWidth: lineWidth,
                matrix: matrix }, iconStyle),
        });
        // \u70B9\u51FB\u70ED\u533A\uFF0C\u8BBE\u7F6E\u900F\u660E\u77E9\u5F62
        this.addShape(descriptionShape, {
            type: 'rect',
            id: this.getElementId('title-description-rect'),
            name: 'axis-title-description-rect',
            attrs: {
                x: startX,
                y: startY - height / 2,
                width: height,
                height: height,
                stroke: '#000',
                fill: '#000',
                opacity: 0,
                matrix: matrix,
                cursor: 'pointer'
            }
        });
    };
    AxisBase.prototype.applyTickStates = function (tick, group) {
        var states = this.getItemStates(tick);
        if (states.length) {
            var tickStates = this.get('tickStates');
            // \u5206\u522B\u66F4\u65B0 label \u548C tickLine
            var labelId = this.getElementId("label-" + tick.id);
            var labelShape = group.findById(labelId);
            if (labelShape) {
                var labelStateStyle = getStatesStyle(tick, 'label', tickStates);
                labelStateStyle && labelShape.attr(labelStateStyle);
            }
            var tickLineId = this.getElementId("tickline-" + tick.id);
            var tickLineShape = group.findById(tickLineId);
            if (tickLineShape) {
                var tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);
                tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
            }
        }
    };
    AxisBase.prototype.updateTickStates = function (tick) {
        var states = this.getItemStates(tick);
        var tickStates = this.get('tickStates');
        var labelCfg = this.get('label');
        var labelShape = this.getElementByLocalId("label-" + tick.id);
        var tickLineCfg = this.get('tickLine');
        var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
        if (states.length) {
            if (labelShape) {
                var labelStateStyle = getStatesStyle(tick, 'label', tickStates);
                labelStateStyle && labelShape.attr(labelStateStyle);
            }
            if (tickLineShape) {
                var tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);
                tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
            }
        }
        else {
            if (labelShape) {
                labelShape.attr(labelCfg.style);
            }
            if (tickLineShape) {
                tickLineShape.attr(tickLineCfg.style);
            }
        }
    };
    return AxisBase;
}(group_component));
/* harmony default export */ var axis_base = (AxisBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js


function ellipseLabels(isVertical, labelGroup, limitLength, position) {
    var children = labelGroup.getChildren();
    var ellipsisFlag = false;
    (0,esm/* each */.S6)(children, function (label) {
        var rst = ellipsisLabel(isVertical, label, limitLength, position);
        ellipsisFlag = ellipsisFlag || rst;
    });
    return ellipsisFlag;
}
function getDefault() {
    return ellipsisTail;
}
function ellipsisHead(isVertical, labelGroup, limitLength) {
    return ellipseLabels(isVertical, labelGroup, limitLength, 'head');
}
function ellipsisTail(isVertical, labelGroup, limitLength) {
    return ellipseLabels(isVertical, labelGroup, limitLength, 'tail');
}
function ellipsisMiddle(isVertical, labelGroup, limitLength) {
    return ellipseLabels(isVertical, labelGroup, limitLength, 'middle');
}
//# sourceMappingURL=auto-ellipsis.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/overlap/auto-hide.js



// \u6587\u672C\u662F\u5426\u65CB\u8F6C
function isRotate(label) {
    var matrix = label.attr('matrix');
    return matrix && matrix[0] !== 1; // \u4EC5\u5728\u8FD9\u4E2A\u573A\u666F\u4E0B\u5224\u5B9A
}
function getRotateAngle(label) {
    var angle = isRotate(label) ? getAngleByMatrix(label.attr('matrix')) : 0;
    return angle % 360;
}
// autohide \u4E0D\u518D\u8003\u8651\u8D85\u51FA\u9650\u5236
// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {
//   if (!limitLength) {
//     // \u5982\u679C\u6CA1\u9650\u5236 limitLength \u5219\u76F4\u63A5\u8FD4\u56DE false
//     return false;
//   }
//   const canvasBBox = label.getCanvasBBox();
//   let isOut = false;
//   if (isVertical) {
//     isOut = canvasBBox.width > limitLength;
//   } else {
//     isOut = canvasBBox.height > limitLength;
//   }
//   return isOut;
// }
// \u662F\u5426\u91CD\u53E0
function isOverlap(isVertical, first, second, minGap) {
    var overlap = false;
    var angle = getRotateAngle(first);
    var distance = isVertical
        ? Math.abs(second.attr('y') - first.attr('y'))
        : Math.abs(second.attr('x') - first.attr('x'));
    var prevBBox = (isVertical
        ? second.attr('y') > first.attr('y')
        : second.attr('x') > first.attr('x'))
        ? first.getBBox()
        : second.getBBox();
    if (isVertical) {
        var ratio = Math.abs(Math.cos(angle));
        if (near(ratio, 0, Math.PI / 180)) {
            overlap = prevBBox.width + minGap > distance;
        }
        else {
            overlap = prevBBox.height / ratio + minGap > distance;
        }
    }
    else {
        var ratio = Math.abs(Math.sin(angle));
        if (near(ratio, 0, Math.PI / 180)) {
            overlap = prevBBox.width + minGap > distance;
        }
        else {
            overlap = prevBBox.height / ratio + minGap > distance;
        }
    }
    return overlap;
}
// \u4FDD\u7559\u7B2C\u4E00\u4E2A\u6216\u8005\u6700\u540E\u4E00\u4E2A
function reserveOne(isVertical, labelsGroup, reversed, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup
        .getChildren()
        .slice() // \u590D\u5236\u6570\u7EC4
        .filter(function (item) { return item.get('visible'); });
    if (!labels.length) {
        return false;
    }
    var hasHide = false;
    if (reversed) {
        // \u7FFB\u8F6C
        labels.reverse();
    }
    var count = labels.length;
    var first = labels[0];
    var prev = first;
    for (var i = 1; i < count; i++) {
        var label = labels[i];
        var curBBox = label.getBBox();
        // \u4E0D\u518D\u8003\u8651\u8D85\u51FA\u9650\u5236\uFF0C\u800C\u4EC5\u4EC5\u6839\u636E\u662F\u5426\u91CD\u53E0\u8FDB\u884C\u9690\u85CF isOutLimit(isVertical, label, limitLength) ||
        var isHide = isOverlap(isVertical, prev, label, minGap);
        if (isHide) {
            label.hide();
            hasHide = true;
        }
        else {
            prev = label;
        }
    }
    return hasHide;
}
// \u5747\u5300\u62BD\u6837\u9690\u85CF\u6807\u7B7E\uFF0C\u6CE8\u610F\u8FD9\u91CC\u5047\u8BBE label/tick \u662F\u5747\u5300\u7684
function parityHide(isVertical, labelsGroup, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice(); // \u590D\u5236\u6570\u7EC4
    if (labels.length < 2) {
        // \u5982\u679C\u6570\u91CF\u5C0F\u4E8E 2 \u5219\u76F4\u63A5\u8FD4\u56DE\uFF0C\u7B49\u4E8E 2 \u65F6\u53EF\u80FD\u4E5F\u4F1A\u91CD\u5408
        return false;
    }
    var hasHide = false;
    var first = labels[0];
    var firstBBox = first.getBBox();
    var second = labels[1];
    var count = labels.length;
    var angle = getRotateAngle(first);
    var distance = isVertical
        ? Math.abs(second.attr('y') - first.attr('y'))
        : Math.abs(second.attr('x') - first.attr('x'));
    var interval = 0; // \u4E0D\u91CD\u53E0\u7684\u5750\u6807\u6587\u672C\u95F4\u8DDD\u4E2A\u6570
    if (isVertical) {
        // \u5782\u76F4\u7684\u5750\u6807\u8F74\u8BA1\u7B97\u5782\u76F4\u65B9\u5411\u7684\u95F4\u8DDD
        var ratio = Math.abs(Math.cos(angle));
        if (near(ratio, 0, Math.PI / 180)) {
            var maxWidth = getMaxLabelWidth(labels);
            interval = (maxWidth + minGap) / distance;
        }
        else {
            interval = (firstBBox.height / ratio + minGap) / distance;
        }
    }
    else {
        // \u6C34\u5E73\u5750\u6807\u8F74
        var ratio = Math.abs(Math.sin(angle));
        if (near(ratio, 0, Math.PI / 180)) {
            var maxWidth = getMaxLabelWidth(labels);
            interval = (maxWidth + minGap) / distance;
        }
        else {
            interval = (firstBBox.height / ratio + minGap) / distance;
        }
    }
    // interval > 1 \u65F6\u9700\u8981\u5BF9 label \u8FDB\u884C\u9690\u85CF
    if (interval > 1) {
        interval = Math.ceil(interval);
        for (var i = 0; i < count; i++) {
            if (i % interval !== 0) {
                // \u4EC5\u4FDD\u7559\u88AB\u6574\u9664\u7684 label
                labels[i].hide();
                hasHide = true;
            }
        }
    }
    return hasHide;
}
function auto_hide_getDefault() {
    return equidistance;
}
/**
 * \u4FDD\u8BC1\u9996\u4E2A label \u53EF\u89C1\uFF0C\u5373\u4F7F\u8D85\u8FC7 limitLength \u4E5F\u4E0D\u9690\u85CF
 * @param {boolean} isVertical  \u662F\u5426\u5782\u76F4
 * @param {IGroup}  labelsGroup label \u7684\u5206\u7EC4
 * @param {number} limitLength \u53E6\u4E00\u4E2A\u65B9\u5411\u7684\u957F\u5EA6\u9650\u5236\uFF0CautoHide \u4E0D\u5173\u5FC3
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap \u7684\u53EF\u9009\u914D\u7F6E\u53C2\u6570
 */
function reserveFirst(isVertical, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical, labelsGroup, false, autoHideCfg);
}
/**
 * \u4FDD\u8BC1\u6700\u540E\u4E00\u4E2A label \u53EF\u89C1\uFF0C\u5373\u4F7F\u8D85\u8FC7 limitLength \u4E5F\u4E0D\u9690\u85CF
 * @param {boolean} isVertical  \u662F\u5426\u5782\u76F4
 * @param {IGroup}  labelsGroup label \u7684\u5206\u7EC4
 * @param {number} limitLength \u53E6\u4E00\u4E2A\u65B9\u5411\u7684\u957F\u5EA6\u9650\u5236\uFF0CautoHide \u4E0D\u5173\u5FC3
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap \u7684\u53EF\u9009\u914D\u7F6E\u53C2\u6570
 */
function reserveLast(isVertical, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical, labelsGroup, true, autoHideCfg);
}
/**
 * \u4FDD\u8BC1\u7B2C\u4E00\u4E2A\u6700\u540E\u4E00\u4E2A label \u53EF\u89C1\uFF0C\u5373\u4F7F\u8D85\u8FC7 limitLength \u4E5F\u4E0D\u9690\u85CF
 * @param {boolean} isVertical  \u662F\u5426\u5782\u76F4
 * @param {IGroup}  labelsGroup label \u7684\u5206\u7EC4
 * @param {number} limitLength \u53E6\u4E00\u4E2A\u65B9\u5411\u7684\u957F\u5EA6\u9650\u5236\uFF0CautoHide \u4E0D\u5173\u5FC3
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap \u7684\u53EF\u9009\u914D\u7F6E\u53C2\u6570
 */
function reserveBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice(); // \u590D\u5236\u6570\u7EC4
    if (labels.length <= 2) {
        // \u5982\u679C\u6570\u91CF\u5C0F\u4E8E\u6216\u7B49\u4E8E 2 \u5219\u76F4\u63A5\u8FD4\u56DE
        return false;
    }
    var hasHide = false;
    var count = labels.length;
    var first = labels[0];
    var last = labels[count - 1];
    var preLabel = first;
    // \u6309\u7167\u5148\u4FDD\u5B58\u7B2C\u4E00\u4E2A\u7684\u903B\u8F91\u5FAA\u73AF\u4E00\u904D\uFF0C\u6700\u540E\u4E00\u4E2A\u4E0D\u53C2\u4E0E\u5FAA\u73AF
    for (var i = 1; i < count - 1; i++) {
        var label = labels[i];
        var curBBox = label.getBBox();
        // \u5E9F\u5F03 isOutLimit(isVertical, label, limitLength) ||
        var isHide = isOverlap(isVertical, preLabel, label, minGap);
        if (isHide) {
            label.hide();
            hasHide = true;
        }
        else {
            preLabel = label;
        }
    }
    var overlap = isOverlap(isVertical, preLabel, last, minGap);
    if (overlap) {
        // \u53D1\u751F\u51B2\u7A81\uFF0C\u5219\u9690\u85CF\u524D\u4E00\u4E2A\u4FDD\u7559\u540E\u4E00\u4E2A
        preLabel.hide();
        hasHide = true;
    }
    return hasHide;
}
/**
 * \u4FDD\u8BC1 label \u5747\u5300\u663E\u793A \u548C \u4E0D\u51FA\u73B0\u91CD\u53E0\uFF0C\u4E3B\u8981\u89E3\u51B3\u6587\u672C\u5C42\u53E0\u7684\u95EE\u9898\uFF0C\u5BF9\u4E8E limitLength \u4E0D\u5904\u7406
 * @param {boolean} isVertical  \u662F\u5426\u5782\u76F4
 * @param {IGroup}  labelsGroup label \u7684\u5206\u7EC4
 * @param {number} limitLength \u53E6\u4E00\u4E2A\u65B9\u5411\u7684\u957F\u5EA6\u9650\u5236\uFF0CautoHide \u4E0D\u5173\u5FC3
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap \u7684\u53EF\u9009\u914D\u7F6E\u53C2\u6570
 */
function equidistance(isVertical, labelsGroup, limitLength, autoHideCfg) {
    var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);
    // \u5904\u7406  timeCat \u7C7B\u578B\u7684 tick\uFF0C\u5728\u5747\u5300\u7684\u57FA\u7840\u4E0A\uFF0C\u518D\u6B21\u68C0\u67E5\u51FA\u73B0\u91CD\u53E0\u7684\u8FDB\u884C\u9690\u85CF
    if (reserveOne(isVertical, labelsGroup, false)) {
        hasHide = true;
    }
    return hasHide;
}
/**
 * \u540C equidistance\uFF0C \u9996\u5148\u4F1A\u4FDD\u8BC1 labels \u5747\u5300\u663E\u793A\uFF0C\u7136\u540E\u4F1A\u4FDD\u7559\u9996\u5C3E
 * @param isVertical
 * @param labelsGroup
 * @param {number} limitLength \u53E6\u4E00\u4E2A\u65B9\u5411\u7684\u957F\u5EA6\u9650\u5236\uFF0CautoHide \u4E0D\u5173\u5FC3
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap \u7684\u53EF\u9009\u914D\u7F6E\u53C2\u6570
 */
function equidistanceWithReverseBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {
    var labels = labelsGroup.getChildren().slice(); // \u590D\u5236\u6570\u7EC4
    var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);
    if (labels.length > 2) {
        var first = labels[0];
        var last = labels[labels.length - 1];
        // \u5982\u679C\u7B2C\u4E00\u4E2A\u88AB\u9690\u85CF\u4E86
        if (!first.get('visible')) {
            first.show();
            if (reserveOne(isVertical, labelsGroup, false, autoHideCfg)) {
                hasHide = true;
            }
        }
        // \u5982\u679C\u6700\u540E\u4E00\u4E2A\u88AB\u9690\u85CF\u4E86
        if (!last.get('visible')) {
            last.show();
            if (reserveOne(isVertical, labelsGroup, true, autoHideCfg)) {
                hasHide = true;
            }
        }
    }
    return hasHide;
}
//# sourceMappingURL=auto-hide.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/overlap/auto-rotate.js




// \u7EDF\u4E00\u8BBE\u7F6E\u6587\u672C\u7684\u89D2\u5EA6
function setLabelsAngle(labels, angle) {
    (0,esm/* each */.S6)(labels, function (label) {
        var x = label.attr('x');
        var y = label.attr('y');
        var matrix = getMatrixByAngle({ x: x, y: y }, angle);
        label.attr('matrix', matrix);
    });
}
// \u65CB\u8F6C\u6587\u672C
function labelRotate(isVertical, labelsGroup, limitLength, getAngle) {
    var labels = labelsGroup.getChildren();
    if (!labels.length) {
        return false;
    }
    if (!isVertical && labels.length < 2) {
        // \u6C34\u5E73\u65F6\u81F3\u5C11\u6709\u4E24\u4E2A\u65F6\u624D\u65CB\u8F6C
        return false;
    }
    var maxWidth = getMaxLabelWidth(labels);
    var isOverlap = false;
    if (isVertical) {
        // limitLength \u4E3A 0 \u6216\u8005 null \u65F6\u4E0D\u751F\u6548
        isOverlap = !!limitLength && maxWidth > limitLength;
    }
    else {
        // \u540C limitLength \u65E0\u5173
        var tickWidth = Math.abs(labels[1].attr('x') - labels[0].attr('x'));
        isOverlap = maxWidth > tickWidth;
    }
    if (isOverlap) {
        var angle = getAngle(limitLength, maxWidth);
        setLabelsAngle(labels, angle);
    }
    return isOverlap;
}
function auto_rotate_getDefault() {
    return fixedAngle;
}
/**
 * \u56FA\u5B9A\u89D2\u5EA6\u65CB\u8F6C\u6587\u672C
 * @param  {boolean} isVertical  \u662F\u5426\u5782\u76F4\u65B9\u5411
 * @param  {IGroup}  labelsGroup \u6587\u672C\u7684 group
 * @param  {number}  limitLength \u9650\u5B9A\u957F\u5EA6
 * @param  {number}  customRotate \u81EA\u5B9A\u4E49\u65CB\u8F6C\u89D2\u5EA6
 * @return {boolean}             \u662F\u5426\u53D1\u751F\u4E86\u65CB\u8F6C
 */
function fixedAngle(isVertical, labelsGroup, limitLength, customRotate) {
    return labelRotate(isVertical, labelsGroup, limitLength, function () {
        if ((0,esm/* isNumber */.hj)(customRotate)) {
            return customRotate;
        }
        return isVertical ? theme.verticalAxisRotate : theme.horizontalAxisRotate;
    });
}
/**
 * \u975E\u56FA\u5B9A\u89D2\u5EA6\u65CB\u8F6C\u6587\u672C
 * @param  {boolean} isVertical  \u662F\u5426\u5782\u76F4\u65B9\u5411
 * @param  {IGroup}  labelsGroup \u6587\u672C\u7684 group
 * @param  {number}  limitLength \u9650\u5B9A\u957F\u5EA6
 * @return {boolean}             \u662F\u5426\u53D1\u751F\u4E86\u65CB\u8F6C
 */
function unfixedAngle(isVertical, labelsGroup, limitLength) {
    return labelRotate(isVertical, labelsGroup, limitLength, function (length, maxWidth) {
        if (!length) {
            // \u5982\u679C\u6CA1\u6709\u8BBE\u7F6E limitLength\uFF0C\u5219\u4F7F\u7528\u56FA\u5B9A\u7684\u89D2\u5EA6\u65CB\u8F6C
            return isVertical ? theme.verticalAxisRotate : theme.horizontalAxisRotate;
        }
        if (isVertical) {
            // \u5782\u76F4\u65F6\u4E0D\u9700\u8981\u5224\u5B9A limitLength > maxWidth \uFF0C\u56E0\u4E3A\u6B64\u65F6\u4E0D\u4F1A overlap
            return -Math.acos(length / maxWidth);
        }
        else {
            var angle = 0;
            if (length > maxWidth) {
                // \u9700\u8981\u5224\u5B9A\uFF0Casin \u7684\u53C2\u6570 -1\uFF0C 1
                angle = Math.PI / 4;
            }
            else {
                angle = Math.asin(length / maxWidth);
                if (angle > Math.PI / 4) {
                    // \u5927\u4E8E Math.PI / 4 \u65F6\u6CA1\u610F\u4E49
                    angle = Math.PI / 4;
                }
            }
            return angle;
        }
    });
}
//# sourceMappingURL=auto-rotate.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/overlap/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/line.js





var Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Line.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'line', locationType: 'region', 
            /**
             * \u8D77\u59CB\u70B9, x, y
             * @type {object}
             */
            start: null, 
            /**
             * \u7ED3\u675F\u70B9, x, y
             * @type {object}
             */
            end: null });
    };
    // \u83B7\u53D6\u5750\u6807\u8F74\u7EBF\u7684 path
    Line.prototype.getLinePath = function () {
        var start = this.get('start');
        var end = this.get('end');
        var path = [];
        path.push(['M', start.x, start.y]);
        path.push(['L', end.x, end.y]);
        return path;
    };
    // \u91CD\u65B0\u8BA1\u7B97 layout bbox\uFF0C\u8003\u8651\u5230 line \u4E0D\u663E\u793A
    Line.prototype.getInnerLayoutBBox = function () {
        var start = this.get('start');
        var end = this.get('end');
        var bbox = _super.prototype.getInnerLayoutBBox.call(this);
        var minX = Math.min(start.x, end.x, bbox.x);
        var minY = Math.min(start.y, end.y, bbox.y);
        var maxX = Math.max(start.x, end.x, bbox.maxX);
        var maxY = Math.max(start.y, end.y, bbox.maxY);
        return {
            x: minX,
            y: minY,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };
    };
    Line.prototype.isVertical = function () {
        var start = this.get('start');
        var end = this.get('end');
        return (0,esm/* isNumberEqual */.vQ)(start.x, end.x);
    };
    Line.prototype.isHorizontal = function () {
        var start = this.get('start');
        var end = this.get('end');
        return (0,esm/* isNumberEqual */.vQ)(start.y, end.y);
    };
    Line.prototype.getTickPoint = function (tickValue) {
        var self = this;
        var start = self.get('start');
        var end = self.get('end');
        var regionX = end.x - start.x;
        var regionY = end.y - start.y;
        return {
            x: start.x + regionX * tickValue,
            y: start.y + regionY * tickValue,
        };
    };
    // \u76F4\u7EBF\u5750\u6807\u8F74\u4E0B\u4EFB\u4E00\u70B9\u7684\u5411\u91CF\u65B9\u5411\u90FD\u76F8\u540C
    Line.prototype.getSideVector = function (offset) {
        var axisVector = this.getAxisVector();
        var normal = vec2/* normalize */.Fv([0, 0], axisVector);
        var factor = this.get('verticalFactor');
        var verticalVector = [normal[1], normal[0] * -1]; // \u5782\u76F4\u65B9\u5411\uFF0C\u9006\u65F6\u9488\u65B9\u5411
        return vec2/* scale */.bA([0, 0], verticalVector, offset * factor);
    };
    // \u83B7\u53D6\u5750\u6807\u8F74\u7684\u5411\u91CF
    Line.prototype.getAxisVector = function () {
        var start = this.get('start');
        var end = this.get('end');
        return [end.x - start.x, end.y - start.y];
    };
    Line.prototype.processOverlap = function (labelGroup) {
        var _this = this;
        var isVertical = this.isVertical();
        var isHorizontal = this.isHorizontal();
        // \u975E\u5782\u76F4\uFF0C\u6216\u8005\u975E\u6C34\u5E73\u65F6\u4E0D\u5904\u7406\u906E\u6321\u95EE\u9898
        if (!isVertical && !isHorizontal) {
            return;
        }
        var labelCfg = this.get('label');
        var titleCfg = this.get('title');
        var verticalLimitLength = this.get('verticalLimitLength');
        var labelOffset = labelCfg.offset;
        var limitLength = verticalLimitLength;
        var titleHeight = 0;
        var titleSpacing = 0;
        if (titleCfg) {
            titleHeight = titleCfg.style.fontSize;
            titleSpacing = titleCfg.spacing;
        }
        if (limitLength) {
            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
        }
        var overlapOrder = this.get('overlapOrder');
        (0,esm/* each */.S6)(overlapOrder, function (name) {
            if (labelCfg[name] && _this.canProcessOverlap(name)) {
                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
            }
        });
        if (titleCfg) {
            if ((0,esm/* isNil */.UM)(titleCfg.offset)) {
                // \u8C03\u6574 title \u7684 offset
                var bbox = labelGroup.getCanvasBBox();
                var length_1 = isVertical ? bbox.width : bbox.height;
                // \u5982\u679C\u7528\u6237\u6CA1\u6709\u8BBE\u7F6E offset\uFF0C\u5219\u81EA\u52A8\u8BA1\u7B97
                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
            }
        }
    };
    /**
     * \u662F\u5426\u53EF\u4EE5\u6267\u884C\u67D0\u4E00 overlap
     * @param name
     */
    Line.prototype.canProcessOverlap = function (name) {
        var labelCfg = this.get('label');
        // \u5BF9 autoRotate\uFF0C\u5982\u679C\u914D\u7F6E\u4E86\u65CB\u8F6C\u89D2\u5EA6\uFF0C\u76F4\u63A5\u8FDB\u884C\u56FA\u5B9A\u89D2\u5EA6\u65CB\u8F6C
        if (name === 'autoRotate') {
            return (0,esm/* isNil */.UM)(labelCfg.rotate);
        }
        // \u9ED8\u8BA4\u6240\u6709 overlap \u90FD\u53EF\u6267\u884C
        return true;
    };
    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {
        var _this = this;
        var isVertical = this.isVertical();
        var hasAdjusted = false;
        var util = overlap_namespaceObject[name];
        if (value === true) {
            var labelCfg = this.get('label');
            // true \u5F62\u5F0F\u7684\u914D\u7F6E\uFF1A\u4F7F\u7528 overlap \u9ED8\u8BA4\u7684\u7684\u5904\u7406\u65B9\u6CD5\u8FDB\u884C\u5904\u7406
            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);
        }
        else if ((0,esm/* isFunction */.mf)(value)) {
            // \u56DE\u8C03\u51FD\u6570\u5F62\u5F0F\u7684\u914D\u7F6E\uFF1A \u7528\u6237\u53EF\u4EE5\u4F20\u5165\u56DE\u8C03\u51FD\u6570
            hasAdjusted = value(isVertical, labelGroup, limitLength);
        }
        else if ((0,esm/* isObject */.Kn)(value)) {
            // object \u5F62\u5F0F\u7684\u914D\u7F6E\u65B9\u5F0F\uFF1A\u5305\u62EC \u5904\u7406\u65B9\u6CD5 type\uFF0C \u548C\u53EF\u9009\u53C2\u6570\u914D\u7F6E cfg
            var overlapCfg = value;
            if (util[overlapCfg.type]) {
                hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);
            }
        }
        else if (util[value]) {
            // \u5B57\u7B26\u4E32\u7C7B\u578B\u7684\u914D\u7F6E\uFF1A\u6309\u7167\u540D\u79F0\u6267\u884C overlap \u5904\u7406\u65B9\u6CD5
            hasAdjusted = util[value](isVertical, labelGroup, limitLength);
        }
        if (name === 'autoRotate') {
            // \u6587\u672C\u65CB\u8F6C\u540E\uFF0C\u6587\u672C\u7684\u5BF9\u9F50\u65B9\u5F0F\u53EF\u80FD\u5C31\u4E0D\u5408\u9002\u4E86
            if (hasAdjusted) {
                var labels = labelGroup.getChildren();
                var verticalFactor_1 = this.get('verticalFactor');
                (0,esm/* each */.S6)(labels, function (label) {
                    var textAlign = label.attr('textAlign');
                    if (textAlign === 'center') {
                        // \u5C45\u4E2D\u7684\u6587\u672C\u9700\u8981\u8C03\u6574\u65CB\u8F6C\u5EA6
                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';
                        label.attr('textAlign', newAlign);
                    }
                });
            }
        }
        else if (name === 'autoHide') {
            var children = labelGroup.getChildren().slice(0); // \u590D\u5236\u6570\u7EC4\uFF0C\u5220\u9664\u65F6\u4E0D\u4F1A\u51FA\u9519
            (0,esm/* each */.S6)(children, function (label) {
                if (!label.get('visible')) {
                    if (_this.get('isRegister')) {
                        // \u5DF2\u7ECF\u6CE8\u518C\u8FC7\u4E86\uFF0C\u5219\u5220\u9664
                        _this.unregisterElement(label);
                    }
                    label.remove(); // \u9632\u6B62 label \u6570\u91CF\u592A\u591A\uFF0C\u6240\u4EE5\u7EDF\u4E00\u5220\u9664
                }
            });
        }
    };
    return Line;
}(axis_base));
/* harmony default export */ var axis_line = (Line);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/circle.js





var Circle = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: null, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });
    };
    Circle.prototype.getLinePath = function () {
        var center = this.get('center');
        var x = center.x;
        var y = center.y;
        var rx = this.get('radius');
        var ry = rx;
        var startAngle = this.get('startAngle');
        var endAngle = this.get('endAngle');
        var path = [];
        if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
            path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];
        }
        else {
            var startPoint = this.getCirclePoint(startAngle);
            var endPoint = this.getCirclePoint(endAngle);
            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
            var sweep = startAngle > endAngle ? 0 : 1;
            path = [
                ['M', x, y],
                ['L', startPoint.x, startPoint.y],
                ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
                ['L', x, y],
            ];
        }
        return path;
    };
    Circle.prototype.getTickPoint = function (tickValue) {
        var startAngle = this.get('startAngle');
        var endAngle = this.get('endAngle');
        var angle = startAngle + (endAngle - startAngle) * tickValue;
        return this.getCirclePoint(angle);
    };
    // \u83B7\u53D6\u5782\u76F4\u4E8E\u5750\u6807\u8F74\u7684\u5411\u91CF
    Circle.prototype.getSideVector = function (offset, point) {
        var center = this.get('center');
        var vector = [point.x - center.x, point.y - center.y];
        var factor = this.get('verticalFactor');
        var vecLen = vec2/* length */.kE(vector);
        vec2/* scale */.bA(vector, vector, (factor * offset) / vecLen);
        return vector;
    };
    // \u83B7\u53D6\u6CBF\u5750\u6807\u8F74\u65B9\u5411\u7684\u5411\u91CF
    Circle.prototype.getAxisVector = function (point) {
        var center = this.get('center');
        var vector = [point.x - center.x, point.y - center.y];
        return [vector[1], -1 * vector[0]]; // \u83B7\u53D6\u987A\u65F6\u9488\u65B9\u5411\u7684\u5411\u91CF
    };
    // \u6839\u636E\u5706\u5FC3\u548C\u534A\u5F84\u83B7\u53D6\u70B9
    Circle.prototype.getCirclePoint = function (angle, radius) {
        var center = this.get('center');
        radius = radius || this.get('radius');
        return {
            x: center.x + Math.cos(angle) * radius,
            y: center.y + Math.sin(angle) * radius,
        };
    };
    /**
     * \u662F\u5426\u53EF\u4EE5\u6267\u884C\u67D0\u4E00 overlap
     * @param name
     */
    Circle.prototype.canProcessOverlap = function (name) {
        var labelCfg = this.get('label');
        // \u5BF9 autoRotate\uFF0C\u5982\u679C\u914D\u7F6E\u4E86\u65CB\u8F6C\u89D2\u5EA6\uFF0C\u76F4\u63A5\u8FDB\u884C\u56FA\u5B9A\u89D2\u5EA6\u65CB\u8F6C
        if (name === 'autoRotate') {
            return (0,esm/* isNil */.UM)(labelCfg.rotate);
        }
        // \u9ED8\u8BA4\u6240\u6709 overlap \u90FD\u53EF\u6267\u884C
        return true;
    };
    Circle.prototype.processOverlap = function (labelGroup) {
        var _this = this;
        var labelCfg = this.get('label');
        var titleCfg = this.get('title');
        var verticalLimitLength = this.get('verticalLimitLength');
        var labelOffset = labelCfg.offset;
        var limitLength = verticalLimitLength;
        var titleHeight = 0;
        var titleSpacing = 0;
        if (titleCfg) {
            titleHeight = titleCfg.style.fontSize;
            titleSpacing = titleCfg.spacing;
        }
        if (limitLength) {
            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
        }
        var overlapOrder = this.get('overlapOrder');
        (0,esm/* each */.S6)(overlapOrder, function (name) {
            if (labelCfg[name] && _this.canProcessOverlap(name)) {
                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
            }
        });
        if (titleCfg) {
            if ((0,esm/* isNil */.UM)(titleCfg.offset)) {
                // \u8C03\u6574 title \u7684 offset
                var length_1 = labelGroup.getCanvasBBox().height;
                // \u5982\u679C\u7528\u6237\u6CA1\u6709\u8BBE\u7F6E offset\uFF0C\u5219\u81EA\u52A8\u8BA1\u7B97
                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
            }
        }
    };
    Circle.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {
        var _this = this;
        var hasAdjusted = false;
        var util = overlap_namespaceObject[name];
        if (limitLength > 0) {
            if (value === true) {
                // true \u5F62\u5F0F\u7684\u914D\u7F6E\uFF1A\u4F7F\u7528 overlap \u9ED8\u8BA4\u7684\u7684\u5904\u7406\u65B9\u6CD5\u8FDB\u884C\u5904\u7406
                hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
            }
            else if ((0,esm/* isFunction */.mf)(value)) {
                // \u56DE\u8C03\u51FD\u6570\u5F62\u5F0F\u7684\u914D\u7F6E\uFF1A \u7528\u6237\u53EF\u4EE5\u4F20\u5165\u56DE\u8C03\u51FD\u6570
                hasAdjusted = value(false, labelGroup, limitLength);
            }
            else if ((0,esm/* isObject */.Kn)(value)) {
                // object \u5F62\u5F0F\u7684\u914D\u7F6E\u65B9\u5F0F\uFF1A\u5305\u62EC \u5904\u7406\u65B9\u6CD5 type\uFF0C \u548C\u53EF\u9009\u53C2\u6570\u914D\u7F6E cfg
                var overlapCfg = value;
                if (util[overlapCfg.type]) {
                    hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
                }
            }
            else if (util[value]) {
                // \u5B57\u7B26\u4E32\u7C7B\u578B\u7684\u914D\u7F6E\uFF1A\u6309\u7167\u540D\u79F0\u6267\u884C overlap \u5904\u7406\u65B9\u6CD5
                hasAdjusted = util[value](false, labelGroup, limitLength);
            }
        }
        if (name === 'autoRotate') {
            // \u6587\u672C\u65CB\u8F6C\u540E\uFF0C\u6587\u672C\u7684\u5BF9\u9F50\u65B9\u5F0F\u53EF\u80FD\u5C31\u4E0D\u5408\u9002\u4E86
            if (hasAdjusted) {
                var labels = labelGroup.getChildren();
                var verticalFactor_1 = this.get('verticalFactor');
                (0,esm/* each */.S6)(labels, function (label) {
                    var textAlign = label.attr('textAlign');
                    if (textAlign === 'center') {
                        // \u5C45\u4E2D\u7684\u6587\u672C\u9700\u8981\u8C03\u6574\u65CB\u8F6C\u5EA6
                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';
                        label.attr('textAlign', newAlign);
                    }
                });
            }
        }
        else if (name === 'autoHide') {
            var children = labelGroup.getChildren().slice(0); // \u590D\u5236\u6570\u7EC4\uFF0C\u5220\u9664\u65F6\u4E0D\u4F1A\u51FA\u9519
            (0,esm/* each */.S6)(children, function (label) {
                if (!label.get('visible')) {
                    if (_this.get('isRegister')) {
                        // \u5DF2\u7ECF\u6CE8\u518C\u8FC7\u4E86\uFF0C\u5219\u5220\u9664
                        _this.unregisterElement(label);
                    }
                    label.remove(); // \u9632\u6B62 label \u6570\u91CF\u592A\u591A\uFF0C\u6240\u4EE5\u7EDF\u4E00\u5220\u9664
                }
            });
        }
    };
    return Circle;
}(axis_base));
/* harmony default export */ var circle = (Circle);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/axis/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/base.js






var CrosshairBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CrosshairBase, _super);
    function CrosshairBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairBase.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'crosshair', type: 'base', line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
                line: {
                    style: {
                        lineWidth: 1,
                        stroke: theme.lineColor,
                    },
                },
                text: {
                    position: 'start',
                    offset: 10,
                    autoRotate: false,
                    content: null,
                    style: {
                        fill: theme.textColor,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        fontFamily: theme.fontFamily,
                    },
                },
                textBackground: {
                    padding: 5,
                    style: {
                        stroke: theme.lineColor,
                    },
                },
            } });
    };
    CrosshairBase.prototype.renderInner = function (group) {
        if (this.get('line')) {
            this.renderLine(group);
        }
        if (this.get('text')) {
            this.renderText(group);
            this.renderBackground(group);
        }
    };
    CrosshairBase.prototype.renderText = function (group) {
        var text = this.get('text');
        var style = text.style, autoRotate = text.autoRotate, content = text.content;
        if (!(0,esm/* isNil */.UM)(content)) {
            var textPoint = this.getTextPoint();
            var matrix = null;
            if (autoRotate) {
                var angle = this.getRotateAngle();
                matrix = getMatrixByAngle(textPoint, angle);
            }
            this.addShape(group, {
                type: 'text',
                name: 'crosshair-text',
                id: this.getElementId('text'),
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, textPoint), { text: content, matrix: matrix }), style),
            });
        }
    };
    CrosshairBase.prototype.renderLine = function (group) {
        var path = this.getLinePath();
        var line = this.get('line');
        var style = line.style;
        this.addShape(group, {
            type: 'path',
            name: 'crosshair-line',
            id: this.getElementId('line'),
            attrs: (0,tslib_es6/* __assign */.pi)({ path: path }, style),
        });
    };
    // \u7ED8\u5236\u6587\u672C\u7684\u80CC\u666F
    CrosshairBase.prototype.renderBackground = function (group) {
        var textId = this.getElementId('text');
        var textShape = group.findById(textId); // \u67E5\u627E\u6587\u672C
        var textBackground = this.get('textBackground');
        if (textBackground && textShape) {
            var textBBox = textShape.getBBox();
            var padding = formatPadding(textBackground.padding); // \u7528\u6237\u4F20\u5165\u7684 padding \u683C\u5F0F\u4E0D\u5B9A
            var style = textBackground.style;
            var backgroundShape = this.addShape(group, {
                type: 'rect',
                name: 'crosshair-text-background',
                id: this.getElementId('text-background'),
                attrs: (0,tslib_es6/* __assign */.pi)({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2], matrix: textShape.attr('matrix') }, style),
            });
            backgroundShape.toBack();
        }
    };
    return CrosshairBase;
}(group_component));
/* harmony default export */ var crosshair_base = (CrosshairBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/line.js



var LineCrosshair = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(LineCrosshair, _super);
    function LineCrosshair() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'line', locationType: 'region', start: null, end: null });
    };
    // \u76F4\u7EBF\u7684\u6587\u672C\u9700\u8981\u540C\u76F4\u7EBF\u5782\u76F4
    LineCrosshair.prototype.getRotateAngle = function () {
        var _a = this.getLocation(), start = _a.start, end = _a.end;
        var position = this.get('text').position;
        var angle = Math.atan2(end.y - start.y, end.x - start.x);
        var tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;
        return tangentAngle;
    };
    LineCrosshair.prototype.getTextPoint = function () {
        var _a = this.getLocation(), start = _a.start, end = _a.end;
        var _b = this.get('text'), position = _b.position, offset = _b.offset;
        return getTextPoint(start, end, position, offset);
    };
    LineCrosshair.prototype.getLinePath = function () {
        var _a = this.getLocation(), start = _a.start, end = _a.end;
        return [
            ['M', start.x, start.y],
            ['L', end.x, end.y],
        ];
    };
    return LineCrosshair;
}(crosshair_base));
/* harmony default export */ var crosshair_line = (LineCrosshair);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/circle.js



var circle_LineCrosshair = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(LineCrosshair, _super);
    function LineCrosshair() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });
    };
    LineCrosshair.prototype.getRotateAngle = function () {
        var _a = this.getLocation(), startAngle = _a.startAngle, endAngle = _a.endAngle;
        var position = this.get('text').position;
        var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
        return tangentAngle;
    };
    LineCrosshair.prototype.getTextPoint = function () {
        var text = this.get('text');
        var position = text.position, offset = text.offset;
        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;
        var angle = position === 'start' ? startAngle : endAngle;
        var tangentAngle = this.getRotateAngle() - Math.PI;
        var point = getCirclePoint(center, radius, angle);
        // \u8FD9\u4E2A\u5730\u65B9\u5176\u5B9E\u5E94\u8BE5\u6C42\u5207\u7EBF\u5411\u91CF\u7136\u540E\u5728\u4E58\u4EE5 offset\uFF0C\u4F46\u662F\u592A\u5570\u55E6\u4E86\uFF0C\u76F4\u63A5\u7ED9\u51FA\u7ED3\u679C
        // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];
        // const offsetVector = vec2.scale([], tangent, offset);
        var offsetX = Math.cos(tangentAngle) * offset;
        var offsetY = Math.sin(tangentAngle) * offset;
        return {
            x: point.x + offsetX,
            y: point.y + offsetY,
        };
    };
    LineCrosshair.prototype.getLinePath = function () {
        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;
        var path = null;
        if (endAngle - startAngle === Math.PI * 2) {
            // \u6574\u5706
            var x = center.x, y = center.y;
            path = [
                ['M', x, y - radius],
                ['A', radius, radius, 0, 1, 1, x, y + radius],
                ['A', radius, radius, 0, 1, 1, x, y - radius],
                ['Z'],
            ];
        }
        else {
            var startPoint = getCirclePoint(center, radius, startAngle);
            var endPoint = getCirclePoint(center, radius, endAngle);
            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
            var sweep = startAngle > endAngle ? 0 : 1;
            path = [
                ['M', startPoint.x, startPoint.y],
                ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],
            ];
        }
        return path;
    };
    return LineCrosshair;
}(crosshair_base));
/* harmony default export */ var crosshair_circle = (circle_LineCrosshair);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/css-const.js
var CONTAINER_CLASS = 'g2-crosshair';
var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";
//# sourceMappingURL=css-const.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/html-theme.js
var _a;

// tooltip \u76F8\u5173 dom \u7684 css \u7C7B\u540D

/* harmony default export */ var html_theme = (_a = {},
    // css style for tooltip
    _a["" + CONTAINER_CLASS] = {
        position: 'relative'
    },
    _a["" + CROSSHAIR_LINE] = {
        position: 'absolute',
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
    },
    _a["" + CROSSHAIR_TEXT] = {
        position: 'absolute',
        color: theme.textColor,
        fontFamily: theme.fontFamily,
    },
    _a);
//# sourceMappingURL=html-theme.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/html.js







var HtmlCrosshair = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(HtmlCrosshair, _super);
    function HtmlCrosshair() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlCrosshair.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'crosshair', type: 'html', locationType: 'region', start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: "<div class=\\"" + CONTAINER_CLASS + "\\"></div>", crosshairTpl: "<div class=\\"" + CROSSHAIR_LINE + "\\"></div>", textTpl: "<span class=\\"" + CROSSHAIR_TEXT + "\\">{content}</span>", domStyles: null, containerClassName: CONTAINER_CLASS, defaultStyles: html_theme, defaultCfg: {
                text: {
                    position: 'start',
                    content: null,
                    align: 'center',
                    offset: 10
                }
            } });
    };
    HtmlCrosshair.prototype.render = function () {
        this.resetText();
        this.resetPosition();
    };
    // \u7ED8\u5236 crosshair
    HtmlCrosshair.prototype.initCrossHair = function () {
        var container = this.getContainer();
        var crosshairTpl = this.get('crosshairTpl');
        var crosshairEl = createDom(crosshairTpl);
        container.appendChild(crosshairEl);
        this.applyStyle(CROSSHAIR_LINE, crosshairEl);
        this.set('crosshairEl', crosshairEl);
    };
    // \u83B7\u53D6\u6587\u672C\u7684\u4F4D\u7F6E
    HtmlCrosshair.prototype.getTextPoint = function () {
        var _a = this.getLocation(), start = _a.start, end = _a.end;
        var _b = this.get('text'), position = _b.position, offset = _b.offset;
        return getTextPoint(start, end, position, offset);
    };
    // \u8BBE\u7F6E text
    HtmlCrosshair.prototype.resetText = function () {
        var text = this.get('text');
        var textEl = this.get('textEl');
        if (text) {
            var content = text.content;
            if (!textEl) {
                var container = this.getContainer();
                var textTpl = (0,esm/* substitute */.ng)(this.get('textTpl'), text);
                textEl = createDom(textTpl);
                container.appendChild(textEl);
                this.applyStyle(CROSSHAIR_TEXT, textEl);
                this.set('textEl', textEl);
            }
            textEl.innerHTML = content;
        }
        else if (textEl) {
            textEl.remove();
        }
    };
    // \u662F\u5426\u5782\u76F4
    HtmlCrosshair.prototype.isVertical = function (start, end) {
        return start.x === end.x;
    };
    // \u91CD\u65B0\u8C03\u6574\u4F4D\u7F6E
    HtmlCrosshair.prototype.resetPosition = function () {
        var crosshairEl = this.get('crosshairEl');
        if (!crosshairEl) {
            this.initCrossHair();
            crosshairEl = this.get('crosshairEl');
        }
        var start = this.get('start');
        var end = this.get('end');
        var minX = Math.min(start.x, end.x);
        var minY = Math.min(start.y, end.y);
        if (this.isVertical(start, end)) {
            modifyCSS(crosshairEl, {
                width: '1px',
                height: toPx(Math.abs(end.y - start.y))
            });
        }
        else {
            modifyCSS(crosshairEl, {
                height: '1px',
                width: toPx(Math.abs(end.x - start.x))
            });
        }
        modifyCSS(crosshairEl, {
            top: toPx(minY),
            left: toPx(minX)
        });
        this.alignText();
    };
    HtmlCrosshair.prototype.alignText = function () {
        // \u91CD\u65B0\u8BBE\u7F6E text \u4F4D\u7F6E
        var textEl = this.get('textEl');
        if (textEl) {
            var align = this.get('text').align;
            var clientWidth = textEl.clientWidth;
            var point = this.getTextPoint();
            switch (align) {
                case 'center':
                    point.x = point.x - clientWidth / 2;
                    break;
                case 'right':
                    point.x = point.x - clientWidth;
                case 'left':
                    break;
            }
            modifyCSS(textEl, {
                top: toPx(point.y),
                left: toPx(point.x)
            });
        }
    };
    HtmlCrosshair.prototype.updateInner = function (cfg) {
        if ((0,esm/* hasKey */.wH)(cfg, 'text')) {
            this.resetText();
        }
        _super.prototype.updateInner.call(this, cfg);
    };
    return HtmlCrosshair;
}(html_component));
/* harmony default export */ var crosshair_html = (HtmlCrosshair);
//# sourceMappingURL=html.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/crosshair/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/grid/base.js




var GridBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(GridBase, _super);
    function GridBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GridBase.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'grid', line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
                line: {
                    type: 'line',
                    style: {
                        lineWidth: 1,
                        stroke: theme.lineColor,
                    },
                },
            } });
    };
    /**
     * \u83B7\u53D6\u6805\u683C\u7EBF\u7684\u7C7B\u578B
     * @return {string} \u6805\u683C\u7EBF\u7C7B\u578B
     */
    GridBase.prototype.getLineType = function () {
        var line = this.get('line') || this.get('defaultCfg').line;
        return line.type;
    };
    GridBase.prototype.renderInner = function (group) {
        this.drawGrid(group);
    };
    GridBase.prototype.getAlternatePath = function (prePoints, points) {
        var regionPath = this.getGridPath(prePoints);
        var reversePoints = points.slice(0).reverse();
        var nextPath = this.getGridPath(reversePoints, true);
        var closed = this.get('closed');
        if (closed) {
            regionPath = regionPath.concat(nextPath);
        }
        else {
            nextPath[0][0] = 'L'; // \u66F4\u65B0\u7B2C\u4E00\u4E2A\u8282\u70B9
            regionPath = regionPath.concat(nextPath);
            regionPath.push(['Z']);
        }
        return regionPath;
    };
    // \u83B7\u53D6\u8DEF\u5F84\u7684\u914D\u7F6E\u9879
    GridBase.prototype.getPathStyle = function () {
        return this.get('line').style;
    };
    // \u7ED8\u5236\u6805\u683C
    GridBase.prototype.drawGrid = function (group) {
        var _this = this;
        var line = this.get('line');
        var items = this.get('items');
        var alternateColor = this.get('alternateColor');
        var preItem = null;
        (0,esm/* each */.S6)(items, function (item, index) {
            var id = item.id || index;
            // \u7ED8\u5236\u6805\u683C\u7EBF
            if (line) {
                var style = _this.getPathStyle();
                style = (0,esm/* isFunction */.mf)(style) ? style(item, index, items) : style;
                var lineId = _this.getElementId("line-" + id);
                var gridPath = _this.getGridPath(item.points);
                _this.addShape(group, {
                    type: 'path',
                    name: 'grid-line',
                    id: lineId,
                    attrs: (0,esm/* mix */.CD)({
                        path: gridPath,
                    }, style),
                });
            }
            // \u5982\u679C\u5B58\u5728 alternateColor \u5219\u7ED8\u5236\u77E9\u5F62
            // \u4ECE\u7B2C\u4E8C\u4E2A\u6805\u683C\u7EBF\u5F00\u59CB\u7ED8\u5236
            if (alternateColor && index > 0) {
                var regionId = _this.getElementId("region-" + id);
                var isEven = index % 2 === 0;
                if ((0,esm/* isString */.HD)(alternateColor)) {
                    // \u5982\u679C\u989C\u8272\u662F\u5355\u503C\uFF0C\u5219\u662F\u4EC5\u7ED8\u5236\u5076\u6570\u65F6\u7684\u533A\u57DF
                    if (isEven) {
                        _this.drawAlternateRegion(regionId, group, preItem.points, item.points, alternateColor);
                    }
                }
                else {
                    var color = isEven ? alternateColor[1] : alternateColor[0];
                    _this.drawAlternateRegion(regionId, group, preItem.points, item.points, color);
                }
            }
            preItem = item;
        });
    };
    // \u7ED8\u5236\u6805\u683C\u7EBF\u95F4\u7684\u95F4\u9694
    GridBase.prototype.drawAlternateRegion = function (id, group, prePoints, points, color) {
        var regionPath = this.getAlternatePath(prePoints, points);
        this.addShape(group, {
            type: 'path',
            id: id,
            name: 'grid-region',
            attrs: {
                path: regionPath,
                fill: color,
            },
        });
    };
    return GridBase;
}(group_component));
/* harmony default export */ var grid_base = (GridBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/grid/circle.js



function circle_distance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}
var circle_Circle = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'circle', 
            /**
             * \u4E2D\u5FC3\u70B9
             * @type {object}
             */
            center: null, 
            /**
             * \u6805\u683C\u7EBF\u662F\u5426\u5C01\u95ED
             * @type {true}
             */
            closed: true });
    };
    Circle.prototype.getGridPath = function (points, reversed) {
        var lineType = this.getLineType();
        var closed = this.get('closed');
        var path = [];
        if (points.length) {
            // \u9632\u6B62\u51FA\u9519
            if (lineType === 'circle') {
                var center = this.get('center');
                var firstPoint = points[0];
                var radius_1 = circle_distance(center.x, center.y, firstPoint.x, firstPoint.y);
                var sweepFlag_1 = reversed ? 0 : 1; // \u987A\u65F6\u9488\u8FD8\u662F\u9006\u65F6\u9488
                if (closed) {
                    // \u5C01\u95ED\u65F6\uFF0C\u7ED8\u5236\u6574\u4E2A\u5706
                    path.push(['M', center.x, center.y - radius_1]);
                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);
                    path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);
                    path.push(['Z']);
                }
                else {
                    (0,esm/* each */.S6)(points, function (point, index) {
                        if (index === 0) {
                            path.push(['M', point.x, point.y]);
                        }
                        else {
                            path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);
                        }
                    });
                }
            }
            else {
                (0,esm/* each */.S6)(points, function (point, index) {
                    if (index === 0) {
                        path.push(['M', point.x, point.y]);
                    }
                    else {
                        path.push(['L', point.x, point.y]);
                    }
                });
                if (closed) {
                    path.push(['Z']);
                }
            }
        }
        return path;
    };
    return Circle;
}(grid_base));
/* harmony default export */ var grid_circle = (circle_Circle);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/grid/line.js



var line_Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Line.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'line' });
    };
    Line.prototype.getGridPath = function (points) {
        var path = [];
        (0,esm/* each */.S6)(points, function (point, index) {
            if (index === 0) {
                path.push(['M', point.x, point.y]);
            }
            else {
                path.push(['L', point.x, point.y]);
            }
        });
        return path;
    };
    return Line;
}(grid_base));
/* harmony default export */ var grid_line = (line_Line);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/grid/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/legend/base.js



var LegendBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(LegendBase, _super);
    function LegendBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LegendBase.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'legend', 
            /**
             * \u5E03\u5C40\u65B9\u5F0F\uFF1A horizontal\uFF0Cvertical
             * @type {String}
             */
            layout: 'horizontal', locationType: 'point', x: 0, y: 0, offsetX: 0, offsetY: 0, title: null, background: null });
    };
    LegendBase.prototype.getLayoutBBox = function () {
        var bbox = _super.prototype.getLayoutBBox.call(this);
        var maxWidth = this.get('maxWidth');
        var maxHeight = this.get('maxHeight');
        var width = bbox.width, height = bbox.height;
        if (maxWidth) {
            width = Math.min(width, maxWidth);
        }
        if (maxHeight) {
            height = Math.min(height, maxHeight);
        }
        return createBBox(bbox.minX, bbox.minY, width, height);
    };
    LegendBase.prototype.setLocation = function (cfg) {
        this.set('x', cfg.x);
        this.set('y', cfg.y);
        this.resetLocation();
    };
    LegendBase.prototype.resetLocation = function () {
        var x = this.get('x');
        var y = this.get('y');
        var offsetX = this.get('offsetX');
        var offsetY = this.get('offsetY');
        this.moveElementTo(this.get('group'), {
            x: x + offsetX,
            y: y + offsetY,
        });
    };
    LegendBase.prototype.applyOffset = function () {
        this.resetLocation();
    };
    // \u83B7\u53D6\u5F53\u524D\u7ED8\u5236\u7684\u70B9
    LegendBase.prototype.getDrawPoint = function () {
        return this.get('currentPoint');
    };
    LegendBase.prototype.setDrawPoint = function (point) {
        return this.set('currentPoint', point);
    };
    // \u590D\u5199\u7236\u7C7B\u5B9A\u4E49\u7684\u7ED8\u5236\u65B9\u6CD5
    LegendBase.prototype.renderInner = function (group) {
        this.resetDraw();
        if (this.get('title')) {
            this.drawTitle(group);
        }
        this.drawLegendContent(group);
        if (this.get('background')) {
            this.drawBackground(group);
        }
        // this.resetLocation(); // \u5728\u9876\u5C42\u5DF2\u7ECF\u5728\u5904\u7406\u504F\u79FB\u65F6\u4E00\u8D77\u5904\u7406\u4E86
    };
    // \u7ED8\u5236\u80CC\u666F
    LegendBase.prototype.drawBackground = function (group) {
        var background = this.get('background');
        var bbox = group.getBBox();
        var padding = formatPadding(background.padding);
        var attrs = (0,tslib_es6/* __assign */.pi)({ 
            // \u80CC\u666F\u4ECE (0,0) \u5F00\u59CB\u7ED8\u5236
            x: 0, y: 0, width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, background.style);
        var backgroundShape = this.addShape(group, {
            type: 'rect',
            id: this.getElementId('background'),
            name: 'legend-background',
            attrs: attrs,
        });
        backgroundShape.toBack();
    };
    // \u7ED8\u5236\u6807\u9898\uFF0C\u6807\u9898\u5728\u56FE\u4F8B\u9879\u7684\u4E0A\u9762
    LegendBase.prototype.drawTitle = function (group) {
        var currentPoint = this.get('currentPoint');
        var titleCfg = this.get('title');
        var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
        var shape = this.addShape(group, {
            type: 'text',
            id: this.getElementId('title'),
            name: 'legend-title',
            attrs: (0,tslib_es6/* __assign */.pi)({ text: text, x: currentPoint.x, y: currentPoint.y }, style),
        });
        var bbox = shape.getBBox();
        // \u6807\u9898\u5355\u72EC\u5728\u4E00\u884C
        this.set('currentPoint', { x: currentPoint.x, y: bbox.maxY + spacing });
    };
    // \u91CD\u7F6E\u7ED8\u5236\u65F6\u5F00\u59CB\u7684\u4F4D\u7F6E\uFF0C\u5982\u679C\u7ED8\u5236\u8FB9\u6846\uFF0C\u8003\u8651\u8FB9\u6846\u7684 padding
    LegendBase.prototype.resetDraw = function () {
        var background = this.get('background');
        var currentPoint = { x: 0, y: 0 };
        if (background) {
            var padding = formatPadding(background.padding);
            currentPoint.x = padding[3]; // \u5DE6\u8FB9 padding
            currentPoint.y = padding[0]; // \u4E0A\u9762 padding
        }
        this.set('currentPoint', currentPoint); // \u8BBE\u7F6E\u7ED8\u5236\u7684\u521D\u59CB\u4F4D\u7F6E
    };
    return LegendBase;
}(group_component));
/* harmony default export */ var legend_base = (LegendBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/legend/category.js







/**
 * \u5206\u9875\u5668 \u9ED8\u8BA4\u914D\u7F6E
 */
var DEFAULT_PAGE_NAVIGATOR = {
    marker: {
        style: {
            inactiveFill: '#000',
            inactiveOpacity: 0.45,
            fill: '#000',
            opacity: 1,
            size: 12,
        },
    },
    text: {
        style: {
            fill: '#ccc',
            fontSize: 12,
        },
    },
};
// \u9ED8\u8BA4 \u6587\u672Cstyle
var textStyle = {
    fill: theme.textColor,
    fontSize: 12,
    textAlign: 'start',
    textBaseline: 'middle',
    fontFamily: theme.fontFamily,
    fontWeight: 'normal',
    lineHeight: 12,
};
var RIGHT_ARROW_NAME = 'navigation-arrow-right';
var LEFT_ARROW_NAME = 'navigation-arrow-left';
var ROTATE_MAP = {
    right: (90 * Math.PI) / 180,
    left: ((360 - 90) * Math.PI) / 180,
    up: 0,
    down: (180 * Math.PI) / 180,
};
var category_Category = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Category, _super);
    function Category() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.currentPageIndex = 1;
        _this.totalPagesCnt = 1;
        _this.pageWidth = 0;
        _this.pageHeight = 0;
        _this.startX = 0;
        _this.startY = 0;
        _this.onNavigationBack = function () {
            var itemGroup = _this.getElementByLocalId('item-group');
            if (_this.currentPageIndex > 1) {
                _this.currentPageIndex -= 1;
                _this.updateNavigation();
                var matrix = _this.getCurrentNavigationMatrix();
                if (_this.get('animate')) {
                    itemGroup.animate({
                        matrix: matrix,
                    }, 100);
                }
                else {
                    itemGroup.attr({ matrix: matrix });
                }
            }
        };
        _this.onNavigationAfter = function () {
            var itemGroup = _this.getElementByLocalId('item-group');
            if (_this.currentPageIndex < _this.totalPagesCnt) {
                _this.currentPageIndex += 1;
                _this.updateNavigation();
                var matrix = _this.getCurrentNavigationMatrix();
                if (_this.get('animate')) {
                    itemGroup.animate({
                        matrix: matrix,
                    }, 100);
                }
                else {
                    itemGroup.attr({ matrix: matrix });
                }
            }
        };
        return _this;
    }
    Category.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'legend', type: 'category', itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, radio: null, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
                title: {
                    spacing: 5,
                    style: {
                        fill: theme.textColor,
                        fontSize: 12,
                        textAlign: 'start',
                        textBaseline: 'top',
                    },
                },
                background: {
                    padding: 5,
                    style: {
                        stroke: theme.lineColor,
                    },
                },
                itemBackground: {
                    style: {
                        opacity: 0,
                        fill: '#fff',
                    },
                },
                pageNavigator: DEFAULT_PAGE_NAVIGATOR,
                itemName: {
                    spacing: 16,
                    style: textStyle,
                },
                marker: {
                    spacing: 8,
                    style: {
                        r: 6,
                        symbol: 'circle',
                    },
                },
                itemValue: {
                    alignRight: false,
                    formatter: null,
                    style: textStyle,
                    spacing: 6,
                },
                itemStates: {
                    active: {
                        nameStyle: {
                            opacity: 0.8,
                        },
                    },
                    unchecked: {
                        nameStyle: {
                            fill: theme.uncheckedColor,
                        },
                        markerStyle: {
                            fill: theme.uncheckedColor,
                            stroke: theme.uncheckedColor,
                        },
                    },
                    inactive: {
                        nameStyle: {
                            fill: theme.uncheckedColor,
                        },
                        markerStyle: {
                            opacity: 0.2,
                        },
                    },
                },
            } });
    };
    // \u5B9E\u73B0 IList \u63A5\u53E3
    Category.prototype.isList = function () {
        return true;
    };
    /**
     * \u83B7\u53D6\u56FE\u4F8B\u9879
     * @return {ListItem[]} \u5217\u8868\u9879\u96C6\u5408
     */
    Category.prototype.getItems = function () {
        return this.get('items');
    };
    /**
     * \u8BBE\u7F6E\u5217\u8868\u9879
     * @param {ListItem[]} items \u5217\u8868\u9879\u96C6\u5408
     */
    Category.prototype.setItems = function (items) {
        this.update({
            items: items,
        });
    };
    /**
     * \u66F4\u65B0\u5217\u8868\u9879
     * @param {ListItem} item \u5217\u8868\u9879
     * @param {object}   cfg  \u5217\u8868\u9879
     */
    Category.prototype.updateItem = function (item, cfg) {
        (0,esm/* mix */.CD)(item, cfg);
        this.clear(); // \u7531\u4E8E\u5355\u4E2A\u56FE\u4F8B\u9879\u53D8\u5316\uFF0C\u4F1A\u5F15\u8D77\u5168\u5C40\u53D8\u5316\uFF0C\u6240\u4EE5\u5168\u90E8\u66F4\u65B0
        this.render();
    };
    /**
     * \u6E05\u7A7A\u5217\u8868
     */
    Category.prototype.clearItems = function () {
        var itemGroup = this.getElementByLocalId('item-group');
        itemGroup && itemGroup.clear();
    };
    /**
     * \u8BBE\u7F6E\u5217\u8868\u9879\u7684\u72B6\u6001
     * @param {ListItem} item  \u5217\u8868\u9879
     * @param {string}   state \u72B6\u6001\u540D
     * @param {boolean}  value \u72B6\u6001\u503C, true, false
     */
    Category.prototype.setItemState = function (item, state, value) {
        item[state] = value;
        var itemElement = this.getElementByLocalId("item-" + item.id);
        if (itemElement) {
            var items = this.getItems();
            var index = items.indexOf(item);
            var offsetGroup = this.createOffScreenGroup(); // \u79BB\u5C4F\u7684 group
            var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
            this.updateElements(newElement, itemElement); // \u66F4\u65B0\u6574\u4E2A\u5206\u7EC4
            this.clearUpdateStatus(itemElement); // \u6E05\u7406\u66F4\u65B0\u72B6\u6001\uFF0C\u9632\u6B62\u51FA\u73B0 bug
        }
    };
    /**
     * \u662F\u5426\u5B58\u5728\u6307\u5B9A\u7684\u72B6\u6001
     * @param {ListItem} item  \u5217\u8868\u9879
     * @param {boolean} state \u72B6\u6001\u540D
     */
    Category.prototype.hasState = function (item, state) {
        return !!item[state];
    };
    Category.prototype.getItemStates = function (item) {
        var itemStates = this.get('itemStates');
        var rst = [];
        (0,esm/* each */.S6)(itemStates, function (v, k) {
            if (item[k]) {
                // item.selected
                rst.push(k);
            }
        });
        return rst;
    };
    /**
     * \u6E05\u695A\u6240\u6709\u5217\u8868\u9879\u7684\u72B6\u6001
     * @param {string} state \u72B6\u6001\u503C
     */
    Category.prototype.clearItemsState = function (state) {
        var _this = this;
        var items = this.getItemsByState(state);
        (0,esm/* each */.S6)(items, function (item) {
            _this.setItemState(item, state, false);
        });
    };
    /**
     * \u6839\u636E\u72B6\u6001\u83B7\u53D6\u56FE\u4F8B\u9879
     * @param  {string}     state [description]
     * @return {ListItem[]}       [description]
     */
    Category.prototype.getItemsByState = function (state) {
        var _this = this;
        var items = this.getItems();
        return (0,esm/* filter */.hX)(items, function (item) {
            return _this.hasState(item, state);
        });
    };
    // \u7ED8\u5236 legend \u7684\u9009\u9879
    Category.prototype.drawLegendContent = function (group) {
        this.processItems();
        this.drawItems(group);
    };
    // \u9632\u6B62\u672A\u8BBE\u7F6E id
    Category.prototype.processItems = function () {
        var items = this.get('items');
        (0,esm/* each */.S6)(items, function (item) {
            if (!item.id) {
                // \u5982\u679C\u6CA1\u6709\u8BBE\u7F6E id\uFF0C\u9ED8\u8BA4\u4F7F\u7528 name
                item.id = item.name;
            }
        });
    };
    // \u7ED8\u5236\u6240\u6709\u7684\u56FE\u4F8B\u9009\u9879
    Category.prototype.drawItems = function (group) {
        var _this = this;
        var itemContainerGroup = this.addGroup(group, {
            id: this.getElementId('item-container-group'),
            name: 'legend-item-container-group',
        });
        var itemGroup = this.addGroup(itemContainerGroup, {
            id: this.getElementId('item-group'),
            name: 'legend-item-group',
        });
        var itemHeight = this.getItemHeight();
        var itemWidth = this.get('itemWidth');
        var itemSpacing = this.get('itemSpacing');
        var itemMarginBottom = this.get('itemMarginBottom');
        var currentPoint = this.get('currentPoint');
        var startX = currentPoint.x;
        var startY = currentPoint.y;
        var layout = this.get('layout');
        var items = this.get('items');
        var wrapped = false;
        var pageWidth = 0;
        var maxWidth = this.get('maxWidth'); // \u6700\u5927\u5BBD\u5EA6\uFF0C\u4F1A\u5BFC\u81F4 layout : 'horizontal' \u65F6\u81EA\u52A8\u6362\u884C
        var maxHeight = this.get('maxHeight'); // \u6700\u5927\u9AD8\u5EA6\uFF0C\u4F1A\u5BFC\u81F4\u51FA\u73B0\u5206\u9875
        // \u6682\u65F6\u4E0D\u8003\u8651\u5206\u9875
        (0,esm/* each */.S6)(items, function (item, index) {
            var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
            var bbox = subGroup.getBBox();
            var width = itemWidth || bbox.width;
            if (width > pageWidth) {
                pageWidth = width;
            }
            if (layout === 'horizontal') {
                // \u5982\u679C\u6C34\u5E73\u5E03\u5C40
                if (maxWidth && maxWidth < currentPoint.x + width - startX) {
                    // \u68C0\u6D4B\u662F\u5426\u6362\u884C
                    wrapped = true;
                    currentPoint.x = startX;
                    currentPoint.y += itemHeight + itemMarginBottom;
                }
                _this.moveElementTo(subGroup, currentPoint);
                currentPoint.x += width + itemSpacing;
            }
            else {
                // \u5982\u679C\u5782\u76F4\u5E03\u5C40
                if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
                    // \u6362\u884C
                    wrapped = true;
                    currentPoint.x += pageWidth + itemSpacing;
                    currentPoint.y = startY;
                    pageWidth = 0;
                }
                _this.moveElementTo(subGroup, currentPoint);
                currentPoint.y += itemHeight + itemMarginBottom; // itemSpacing \u4EC5\u5F71\u54CD\u6C34\u5E73\u95F4\u8DDD
            }
        });
        if (wrapped && this.get('flipPage')) {
            this.pageHeight = 0;
            this.pageWidth = 0;
            this.totalPagesCnt = 1;
            this.startX = startX;
            this.startY = startY;
            this.adjustNavigation(group, itemGroup);
        }
    };
    // \u83B7\u53D6\u56FE\u4F8B\u9879\u7684\u9AD8\u5EA6\uFF0C\u5982\u679C\u672A\u5B9A\u4E49\uFF0C\u5219\u6309\u7167 name \u7684\u9AD8\u5EA6\u8BA1\u7B97
    Category.prototype.getItemHeight = function () {
        var itemHeight = this.get('itemHeight');
        if (!itemHeight) {
            var style_1 = (this.get('itemName') || {}).style;
            if ((0,esm/* isFunction */.mf)(style_1)) {
                var items_1 = this.getItems();
                items_1.forEach(function (item, index) {
                    var fontSize = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, textStyle), style_1(item, index, items_1)).fontSize;
                    if (itemHeight < fontSize) {
                        itemHeight = fontSize;
                    }
                });
            }
            else if (style_1) {
                itemHeight = style_1.fontSize;
            }
        }
        return itemHeight;
    };
    // \u7ED8\u5236 marker
    Category.prototype.drawMarker = function (container, markerCfg, item, itemHeight) {
        var markerAttrs = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: (0,esm/* get */.U2)(item.marker, 'symbol', 'circle') }), (0,esm/* get */.U2)(item.marker, 'style', {}));
        var shape = this.addShape(container, {
            type: 'marker',
            id: this.getElementId("item-" + item.id + "-marker"),
            name: 'legend-item-marker',
            attrs: markerAttrs,
        });
        var bbox = shape.getBBox();
        shape.attr('x', bbox.width / 2); // marker \u9700\u8981\u5DE6\u5BF9\u9F50\uFF0C\u6240\u4EE5\u4E0D\u80FD\u5360\u7528\u5DE6\u4FA7\u7684\u7A7A\u95F4
        var _a = shape.attr(), stroke = _a.stroke, fill = _a.fill;
        if (stroke) {
            shape.set('isStroke', true);
        }
        if (fill) {
            shape.set('isFill', true);
        }
        return shape;
    };
    // \u7ED8\u5236\u6587\u672C
    Category.prototype.drawItemText = function (container, textName, cfg, item, itemHeight, xPosition, index) {
        var formatter = cfg.formatter;
        var style = cfg.style;
        var attrs = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index) : item[textName] }, textStyle), ((0,esm/* isFunction */.mf)(style) ? style(item, index, this.getItems()) : style));
        return this.addShape(container, {
            type: 'text',
            id: this.getElementId("item-" + item.id + "-" + textName),
            name: "legend-item-" + textName,
            attrs: attrs,
        });
    };
    Category.prototype.drawRadio = function (container, radioCfg, item, itemHeight, x) {
        var _a, _b;
        var style = radioCfg.style || {};
        // \u4EE5\u7528\u6237\u8BBE\u7F6E\u7684 r \u4E3A\u4E3B
        var r = (_a = style.r) !== null && _a !== void 0 ? _a : itemHeight / 2;
        var lineWidth = (r * 3.6) / 8;
        var _c = [x + r, itemHeight / 2 - r], x0 = _c[0], y0 = _c[1];
        var _d = [x0 + r, y0 + r], x1 = _d[0], y1 = _d[1];
        var _e = [x0, y1 + r], x2 = _e[0], y2 = _e[1];
        var _f = [x, y0 + r], x3 = _f[0], y3 = _f[1];
        var showRadio = item.showRadio;
        var attrs = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ path: [
                ['M', x0, y0],
                ['A', r, r, 0, 0, 1, x1, y1],
                ['L', x1 - lineWidth, y1],
                ['L', x1, y1],
                ['A', r, r, 0, 0, 1, x2, y2],
                ['L', x2, y2 - lineWidth],
                ['L', x2, y2],
                ['A', r, r, 0, 0, 1, x3, y3],
                ['L', x3 + lineWidth, y3],
                ['L', x3, y3],
                ['A', r, r, 0, 0, 1, x0, y0],
                ['L', x0, y0 + lineWidth],
            ], stroke: '#000000', fill: '#ffffff' }, style), { opacity: showRadio ? ((_b = style === null || style === void 0 ? void 0 : style.opacity) !== null && _b !== void 0 ? _b : 0.45) : 0 });
        var radioShape = this.addShape(container, {
            type: 'path',
            id: this.getElementId("item-" + item.id + "-radio"),
            name: 'legend-item-radio',
            attrs: attrs,
        });
        radioShape.set('tip', radioCfg.tip);
        return radioShape;
    };
    // \u7ED8\u5236\u56FE\u4F8B\u9879
    Category.prototype.drawItem = function (item, index, itemHeight, itemGroup) {
        var groupId = "item-" + item.id;
        // \u8BBE\u7F6E\u5355\u72EC\u7684 Group \u7528\u4E8E setClip
        var subContainer = this.addGroup(itemGroup, {
            name: 'legend-item-container',
            id: this.getElementId("item-container-" + groupId),
            delegateObject: {
                item: item,
                index: index,
            },
        });
        var subGroup = this.addGroup(subContainer, {
            name: 'legend-item',
            id: this.getElementId(groupId),
            delegateObject: {
                item: item,
                index: index,
            },
        });
        var marker = this.get('marker');
        var itemName = this.get('itemName');
        var itemValue = this.get('itemValue');
        var itemBackground = this.get('itemBackground');
        var radio = this.get('radio');
        var itemWidth = this.getLimitItemWidth();
        var curX = 0; // \u8BB0\u5F55\u5F53\u524D x \u7684\u4F4D\u7F6E
        if (marker) {
            var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
            var spacing = marker.spacing;
            var itemMarkerSpacing = (0,esm/* get */.U2)(item, ['marker', 'spacing']);
            if ((0,esm/* isNumber */.hj)(itemMarkerSpacing)) {
                // \u5982\u679C item \u6709\u914D\u7F6E marker.spacing\uFF0C\u91C7\u7528 item \u7684\u914D\u7F6E
                spacing = itemMarkerSpacing;
            }
            curX = markerShape.getBBox().maxX + spacing;
        }
        if (itemName) {
            var nameShape = this.drawItemText(subGroup, 'name', itemName, item, itemHeight, curX, index);
            if (itemWidth) {
                // \u8BBE\u7F6E\u4E86 item \u7684\u6700\u5927\u5BBD\u5EA6\u9650\u5236\uFF0C\u5E76\u4E14\u8D85\u51FA\u4E86\uFF0C\u8FDB\u884C\u7701\u7565\u5904\u7406
                ellipsisLabel(true, nameShape, (0,esm/* clamp */.uZ)(itemWidth - curX, 0, itemWidth));
            }
            curX = nameShape.getBBox().maxX + itemName.spacing;
        }
        if (itemValue) {
            var valueShape = this.drawItemText(subGroup, 'value', itemValue, item, itemHeight, curX, index);
            if (itemWidth) {
                if (itemValue.alignRight) {
                    valueShape.attr({
                        textAlign: 'right',
                        x: itemWidth,
                    });
                    ellipsisLabel(true, valueShape, (0,esm/* clamp */.uZ)(itemWidth - curX, 0, itemWidth), 'head');
                }
                else {
                    ellipsisLabel(true, valueShape, (0,esm/* clamp */.uZ)(itemWidth - curX, 0, itemWidth));
                }
            }
            curX = valueShape.getBBox().maxX + itemValue.spacing;
        }
        if (radio) {
            this.drawRadio(subGroup, radio, item, itemHeight, curX);
        }
        // \u6DFB\u52A0\u900F\u660E\u7684\u80CC\u666F\uFF0C\u4FBF\u4E8E\u62FE\u53D6\u548C\u5305\u56F4\u76D2\u8BA1\u7B97
        if (itemBackground) {
            var bbox = subGroup.getBBox();
            var backShape = this.addShape(subGroup, {
                type: 'rect',
                name: 'legend-item-background',
                id: this.getElementId(groupId + "-background"),
                attrs: (0,tslib_es6/* __assign */.pi)({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style),
            });
            backShape.toBack();
        }
        this.applyItemStates(item, subGroup);
        return subGroup;
    };
    // \u52A0\u4E0A\u5206\u9875\u5668\u5E76\u91CD\u65B0\u6392\u5E8F items
    Category.prototype.adjustNavigation = function (container, itemGroup) {
        var _this = this;
        var startX = this.startX;
        var startY = this.startY;
        var layout = this.get('layout');
        var subGroups = itemGroup.findAll(function (item) { return item.get('name') === 'legend-item'; });
        var maxWidth = this.get('maxWidth');
        var maxHeight = this.get('maxHeight');
        var itemWidth = this.get('itemWidth');
        var itemSpacing = this.get('itemSpacing');
        var itemHeight = this.getItemHeight();
        var pageNavigator = (0,esm/* deepMix */.b$)({}, DEFAULT_PAGE_NAVIGATOR, this.get('pageNavigator'));
        var navigation = this.drawNavigation(container, layout, '00/00', pageNavigator);
        var navigationBBox = navigation.getBBox();
        var currentPoint = { x: startX, y: startY };
        var pages = 1;
        var widthLimit = 0;
        var pageWidth = 0;
        var maxItemWidth = 0;
        var itemMarginBottom = this.get('itemMarginBottom');
        /**  \u5224\u65AD\u5F53\u524D item \u662F\u5426\u6EA2\u51FA\u5F53\u524D\u9875\u3002\u662F\u7684\u8BDD\uFF0C\u9700\u8981\u6362\u884C */
        function shouldWrap(item, currentPoint) {
            var bbox = item.getBBox();
            var width = itemWidth || bbox.width;
            var newItemXPos = currentPoint.x + width + itemSpacing + navigationBBox.width;
            return newItemXPos > maxWidth;
        }
        if (layout === 'horizontal') {
            var maxRow = this.get('maxRow') || 1;
            var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
            // \u5206\u9875\u5668\u4E00\u76F4\u9760\u53F3\u4E0A\u89D2
            var navigationX_1 = maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX; // \u7406\u8BBA\u4E0A\u4E0D\u9700\u8981\u51CF navigationBBox.minX
            this.pageHeight = maxRowHeight_1 * maxRow;
            this.pageWidth = navigationX_1;
            (0,esm/* each */.S6)(subGroups, function (item) {
                var bbox = item.getBBox();
                var width = itemWidth || bbox.width;
                if ((widthLimit && widthLimit < currentPoint.x + width + itemSpacing) ||
                    shouldWrap(item, currentPoint)) {
                    if (pages === 1) {
                        widthLimit = currentPoint.x + itemSpacing;
                        _this.moveElementTo(navigation, {
                            x: navigationX_1,
                            y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY,
                        });
                    }
                    pages += 1;
                    currentPoint.x = startX;
                    currentPoint.y += maxRowHeight_1;
                }
                _this.moveElementTo(item, currentPoint);
                item.getParent().setClip({
                    type: 'rect',
                    attrs: {
                        x: currentPoint.x,
                        y: currentPoint.y,
                        width: width + itemSpacing,
                        height: itemHeight,
                    },
                });
                currentPoint.x += width + itemSpacing;
            });
        }
        else {
            (0,esm/* each */.S6)(subGroups, function (item) {
                var bbox = item.getBBox();
                if (bbox.width > pageWidth) {
                    pageWidth = bbox.width;
                }
            });
            maxItemWidth = pageWidth;
            pageWidth += itemSpacing;
            if (maxWidth) {
                // maxWidth \u9650\u5236\u52A0\u4E0A
                pageWidth = Math.min(maxWidth, pageWidth);
                maxItemWidth = Math.min(maxWidth, maxItemWidth);
            }
            this.pageWidth = pageWidth;
            this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
            var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
            (0,esm/* each */.S6)(subGroups, function (item, index) {
                if (index !== 0 && index % cntPerPage_1 === 0) {
                    pages += 1;
                    currentPoint.x += pageWidth;
                    currentPoint.y = startY;
                }
                _this.moveElementTo(item, currentPoint);
                item.getParent().setClip({
                    type: 'rect',
                    attrs: {
                        x: currentPoint.x,
                        y: currentPoint.y,
                        width: pageWidth,
                        height: itemHeight,
                    },
                });
                currentPoint.y += itemHeight + itemMarginBottom;
            });
            this.totalPagesCnt = pages;
            this.moveElementTo(navigation, {
                x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
                y: maxHeight - navigationBBox.height - navigationBBox.minY,
            });
        }
        if (this.pageHeight && this.pageWidth) {
            // \u4E3A\u4E86\u4F7F\u56FA\u5B9A\u7684 clip \u751F\u6548\uFF0Cclip \u8BBE\u7F6E\u5728 itemContainerGroup \u4E0A\uFF0CitemGroup \u9700\u8981\u5728\u7FFB\u9875\u65F6\u4F1A\u8BBE\u7F6E matrix
            itemGroup.getParent().setClip({
                type: 'rect',
                attrs: {
                    x: this.startX,
                    y: this.startY,
                    width: this.pageWidth,
                    height: this.pageHeight,
                },
            });
        }
        // \u91CD\u65B0\u8BA1\u7B97 totalPagesCnt
        if (layout === 'horizontal' && this.get('maxRow')) {
            this.totalPagesCnt = Math.ceil(pages / this.get('maxRow'));
        }
        else {
            this.totalPagesCnt = pages;
        }
        if (this.currentPageIndex > this.totalPagesCnt) {
            this.currentPageIndex = 1;
        }
        this.updateNavigation(navigation);
        // update initial matrix
        itemGroup.attr('matrix', this.getCurrentNavigationMatrix());
    };
    /**
     * \u7ED8\u5236\u5206\u9875\u5668
     */
    Category.prototype.drawNavigation = function (group, layout, text, styleCfg) {
        var currentPoint = { x: 0, y: 0 };
        var subGroup = this.addGroup(group, {
            id: this.getElementId('navigation-group'),
            name: 'legend-navigation',
        });
        var _a = (0,esm/* get */.U2)(styleCfg.marker, 'style', {}), _b = _a.size, size = _b === void 0 ? 12 : _b, arrowStyle = (0,tslib_es6/* __rest */._T)(_a, ["size"]);
        var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout === 'horizontal' ? 'up' : 'left', size, arrowStyle);
        leftArrow.on('click', this.onNavigationBack);
        var leftArrowBBox = leftArrow.getBBox();
        currentPoint.x += leftArrowBBox.width + 2;
        var textShape = this.addShape(subGroup, {
            type: 'text',
            id: this.getElementId('navigation-text'),
            name: 'navigation-text',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: currentPoint.x, y: currentPoint.y + size / 2, text: text, textBaseline: 'middle' }, (0,esm/* get */.U2)(styleCfg.text, 'style')),
        });
        var textBBox = textShape.getBBox();
        currentPoint.x += textBBox.width + 2;
        var rightArrow = this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout === 'horizontal' ? 'down' : 'right', size, arrowStyle);
        rightArrow.on('click', this.onNavigationAfter);
        return subGroup;
    };
    Category.prototype.updateNavigation = function (navigation) {
        var pageNavigator = (0,esm/* deepMix */.b$)({}, DEFAULT_PAGE_NAVIGATOR, this.get('pageNavigator'));
        var _a = pageNavigator.marker.style, fill = _a.fill, opacity = _a.opacity, inactiveFill = _a.inactiveFill, inactiveOpacity = _a.inactiveOpacity;
        var text = this.currentPageIndex + "/" + this.totalPagesCnt;
        var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId('navigation-text');
        var leftArrow = navigation
            ? navigation.findById(this.getElementId(LEFT_ARROW_NAME))
            : this.getElementByLocalId(LEFT_ARROW_NAME);
        var rightArrow = navigation
            ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME))
            : this.getElementByLocalId(RIGHT_ARROW_NAME);
        textShape.attr('text', text);
        // \u66F4\u65B0 left-arrow marker
        leftArrow.attr('opacity', this.currentPageIndex === 1 ? inactiveOpacity : opacity);
        leftArrow.attr('fill', this.currentPageIndex === 1 ? inactiveFill : fill);
        leftArrow.attr('cursor', this.currentPageIndex === 1 ? 'not-allowed' : 'pointer');
        // \u66F4\u65B0 right-arrow marker
        rightArrow.attr('opacity', this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
        rightArrow.attr('fill', this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
        rightArrow.attr('cursor', this.currentPageIndex === this.totalPagesCnt ? 'not-allowed' : 'pointer');
        // \u66F4\u65B0\u4F4D\u7F6E
        var cursorX = leftArrow.getBBox().maxX + 2;
        textShape.attr('x', cursorX);
        cursorX += textShape.getBBox().width + 2;
        this.updateArrowPath(rightArrow, { x: cursorX, y: 0 });
    };
    Category.prototype.drawArrow = function (group, currentPoint, name, direction, size, style) {
        var x = currentPoint.x, y = currentPoint.y;
        var shape = this.addShape(group, {
            type: 'path',
            id: this.getElementId(name),
            name: name,
            attrs: (0,tslib_es6/* __assign */.pi)({ size: size,
                direction: direction, path: [['M', x + size / 2, y], ['L', x, y + size], ['L', x + size, y + size], ['Z']], cursor: 'pointer' }, style),
        });
        shape.attr('matrix', getMatrixByAngle({ x: x + size / 2, y: y + size / 2 }, ROTATE_MAP[direction]));
        return shape;
    };
    /**
     * \u66F4\u65B0\u5206\u9875\u5668 arrow \u7EC4\u4EF6
     */
    Category.prototype.updateArrowPath = function (arrow, point) {
        var x = point.x, y = point.y;
        var _a = arrow.attr(), size = _a.size, direction = _a.direction;
        var matrix = getMatrixByAngle({ x: x + size / 2, y: y + size / 2 }, ROTATE_MAP[direction]);
        arrow.attr('path', [['M', x + size / 2, y], ['L', x, y + size], ['L', x + size, y + size], ['Z']]);
        arrow.attr('matrix', matrix);
    };
    Category.prototype.getCurrentNavigationMatrix = function () {
        var _a = this, currentPageIndex = _a.currentPageIndex, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        var layout = this.get('layout');
        var translate = layout === 'horizontal'
            ? {
                x: 0,
                y: pageHeight * (1 - currentPageIndex),
            }
            : {
                x: pageWidth * (1 - currentPageIndex),
                y: 0,
            };
        return getMatrixByTranslate(translate);
    };
    // \u9644\u52A0\u72B6\u6001\u5BF9\u5E94\u7684\u6837\u5F0F
    Category.prototype.applyItemStates = function (item, subGroup) {
        var states = this.getItemStates(item);
        var hasStates = states.length > 0;
        if (hasStates) {
            var children = subGroup.getChildren();
            var itemStates_1 = this.get('itemStates');
            (0,esm/* each */.S6)(children, function (element) {
                var name = element.get('name');
                var elName = name.split('-')[2]; // marker, name, value
                var statesStyle = getStatesStyle(item, elName, itemStates_1);
                if (statesStyle) {
                    element.attr(statesStyle);
                    if (elName === 'marker' && !(element.get('isStroke') && element.get('isFill'))) {
                        // \u5982\u679C marker \u662F\u5355\u586B\u5145\u6216\u8005\u5355\u63CF\u8FB9\u7684\u8BDD\uFF0C\u5C31\u4E0D\u8981\u989D\u5916\u6DFB\u52A0 stroke \u6216\u8FD9 fill \u5C5E\u6027\uFF0C\u5426\u5219\u4F1A\u5F71\u54CD unchecked \u540E\u7684\u663E\u793A
                        if (element.get('isStroke')) {
                            element.attr('fill', null);
                        }
                        if (element.get('isFill')) {
                            element.attr('stroke', null);
                        }
                    }
                }
            });
        }
    };
    // \u83B7\u53D6 itemWidth \u7684\u6700\u7EC8\u8BBE\u7F6E
    Category.prototype.getLimitItemWidth = function () {
        var itemWidth = this.get('itemWidth');
        var maxItemWidth = this.get('maxItemWidth');
        if (maxItemWidth) {
            // \u8BBE\u7F6E\u4E86\u6700\u5927\u5BBD\u5EA6
            if (itemWidth) {
                maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
            }
        }
        else if (itemWidth) {
            maxItemWidth = itemWidth;
        }
        return maxItemWidth;
    };
    return Category;
}(legend_base));
/* harmony default export */ var category = (category_Category);
//# sourceMappingURL=category.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/legend/continuous.js





var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ContinueLegend, _super);
    function ContinueLegend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ContinueLegend.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: 'continue', min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
                label: {
                    align: 'rail',
                    spacing: 5,
                    formatter: null,
                    style: {
                        fontSize: 12,
                        fill: theme.textColor,
                        textBaseline: 'middle',
                        fontFamily: theme.fontFamily,
                    },
                },
                handler: {
                    size: 10,
                    style: {
                        fill: '#fff',
                        stroke: '#333',
                    },
                },
                track: {},
                rail: {
                    type: 'color',
                    size: 20,
                    defaultLength: 100,
                    style: {
                        fill: '#DCDEE2',
                    },
                },
                title: {
                    spacing: 5,
                    style: {
                        fill: theme.textColor,
                        fontSize: 12,
                        textAlign: 'start',
                        textBaseline: 'top',
                    },
                },
            } });
    };
    ContinueLegend.prototype.isSlider = function () {
        return true;
    };
    // \u5B9E\u73B0 IList \u63A5\u53E3
    ContinueLegend.prototype.getValue = function () {
        return this.getCurrentValue();
    };
    ContinueLegend.prototype.getRange = function () {
        return {
            min: this.get('min'),
            max: this.get('max'),
        };
    };
    // \u6539\u53D8 range
    ContinueLegend.prototype.setRange = function (min, max) {
        this.update({
            min: min,
            max: max,
        });
    };
    ContinueLegend.prototype.setValue = function (value) {
        var originValue = this.getValue();
        this.set('value', value);
        var group = this.get('group');
        this.resetTrackClip();
        if (this.get('slidable')) {
            this.resetHandlers(group);
        }
        this.delegateEmit('valuechanged', {
            originValue: originValue,
            value: value,
        });
    };
    ContinueLegend.prototype.initEvent = function () {
        var group = this.get('group');
        this.bindSliderEvent(group);
        this.bindRailEvent(group);
        this.bindTrackEvent(group);
    };
    ContinueLegend.prototype.drawLegendContent = function (group) {
        this.drawRail(group);
        this.drawLabels(group);
        this.fixedElements(group); // \u8C03\u6574\u5404\u4E2A\u56FE\u5F62\u4F4D\u7F6E\uFF0C\u9002\u5E94\u5BBD\u9AD8\u7684\u9650\u5236
        this.resetTrack(group);
        this.resetTrackClip(group);
        if (this.get('slidable')) {
            this.resetHandlers(group);
        }
    };
    ContinueLegend.prototype.bindSliderEvent = function (group) {
        this.bindHandlersEvent(group);
    };
    ContinueLegend.prototype.bindHandlersEvent = function (group) {
        var _this = this;
        group.on('legend-handler-min:drag', function (ev) {
            var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
            var currentValue = _this.getCurrentValue();
            var maxValue = currentValue[1];
            if (maxValue < minValue) {
                // \u5982\u679C\u5C0F\u4E8E\u6700\u5C0F\u503C\uFF0C\u5219\u8C03\u6574\u6700\u5C0F\u503C
                maxValue = minValue;
            }
            _this.setValue([minValue, maxValue]);
        });
        group.on('legend-handler-max:drag', function (ev) {
            var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
            var currentValue = _this.getCurrentValue();
            var minValue = currentValue[0];
            if (minValue > maxValue) {
                // \u5982\u679C\u5C0F\u4E8E\u6700\u5C0F\u503C\uFF0C\u5219\u8C03\u6574\u6700\u5C0F\u503C
                minValue = maxValue;
            }
            _this.setValue([minValue, maxValue]);
        });
    };
    ContinueLegend.prototype.bindRailEvent = function (group) { };
    ContinueLegend.prototype.bindTrackEvent = function (group) {
        var _this = this;
        var prePoint = null;
        group.on('legend-track:dragstart', function (ev) {
            prePoint = {
                x: ev.x,
                y: ev.y,
            };
        });
        group.on('legend-track:drag', function (ev) {
            if (!prePoint) {
                return;
            }
            var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
            var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
            var currentValue = _this.getCurrentValue();
            var curDiff = currentValue[1] - currentValue[0];
            var range = _this.getRange();
            var dValue = curValue - preValue;
            if (dValue < 0) {
                // \u51CF\u5C0F, \u540C\u65F6\u672A\u51FA\u8FB9\u754C
                if (currentValue[0] + dValue > range.min) {
                    _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
                }
                else {
                    _this.setValue([range.min, range.min + curDiff]);
                }
                //  && ||
            }
            else if (dValue > 0) {
                if (dValue > 0 && currentValue[1] + dValue < range.max) {
                    _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
                }
                else {
                    _this.setValue([range.max - curDiff, range.max]);
                }
            }
            prePoint = {
                x: ev.x,
                y: ev.y,
            };
        });
        group.on('legend-track:dragend', function (ev) {
            prePoint = null;
        });
    };
    ContinueLegend.prototype.drawLabels = function (group) {
        this.drawLabel('min', group);
        this.drawLabel('max', group);
    };
    ContinueLegend.prototype.drawLabel = function (name, group) {
        var labelCfg = this.get('label');
        var style = labelCfg.style;
        var labelAlign = labelCfg.align;
        var labelFormatter = labelCfg.formatter;
        var value = this.get(name);
        var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
        var localId = "label-" + name;
        this.addShape(group, {
            type: 'text',
            id: this.getElementId(localId),
            name: "legend-label-" + name,
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: 0, y: 0, text: (0,esm/* isFunction */.mf)(labelFormatter) ? labelFormatter(value) : value }, style), alignAttrs),
        });
    };
    // \u83B7\u53D6\u6587\u672C\u7684\u5BF9\u9F50\u65B9\u5F0F\uFF0C\u4E3A\u4E86\u81EA\u9002\u5E94\u771F\u5B9E\u64CD\u788E\u4E86\u5FC3
    ContinueLegend.prototype.getLabelAlignAttrs = function (name, align) {
        var isVertical = this.isVertical();
        var textAlign = 'center';
        var textBaseline = 'middle';
        if (isVertical) {
            // \u5782\u76F4\u5E03\u5C40\u7684\u6240\u6709\u7684\u6587\u672C\u90FD\u5DE6\u5BF9\u9F50
            textAlign = 'start';
            if (align !== 'rail') {
                if (name === 'min') {
                    textBaseline = 'top';
                }
                else {
                    textBaseline = 'bottom';
                }
            }
            else {
                textBaseline = 'top';
            }
        }
        else {
            if (align !== 'rail') {
                textBaseline = 'top';
                if (name === 'min') {
                    textAlign = 'start';
                }
                else {
                    textAlign = 'end';
                }
            }
            else {
                textAlign = 'start';
                textBaseline = 'middle';
            }
        }
        return {
            textAlign: textAlign,
            textBaseline: textBaseline,
        };
    };
    ContinueLegend.prototype.getRailPath = function (x, y, w, h) {
        var railCfg = this.get('rail');
        var size = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
        var isVertical = this.isVertical();
        var length = defaultLength;
        var width = w;
        var height = h;
        if (!width) {
            width = isVertical ? size : length;
        }
        if (!height) {
            height = isVertical ? length : size;
        }
        var path = [];
        if (type === 'color') {
            path.push(['M', x, y]);
            path.push(['L', x + width, y]);
            path.push(['L', x + width, y + height]);
            path.push(['L', x, y + height]);
            path.push(['Z']);
        }
        else {
            path.push(['M', x + width, y]);
            path.push(['L', x + width, y + height]);
            path.push(['L', x, y + height]);
            path.push(['Z']);
        }
        return path;
    };
    ContinueLegend.prototype.drawRail = function (group) {
        var railCfg = this.get('rail');
        var style = railCfg.style;
        this.addShape(group, {
            type: 'path',
            id: this.getElementId('rail'),
            name: 'legend-rail',
            attrs: (0,tslib_es6/* __assign */.pi)({ path: this.getRailPath(0, 0) }, style),
        });
    };
    // \u5C06\u4F20\u5165\u7684\u989C\u8272\u8F6C\u6362\u6210\u6E10\u53D8\u8272
    ContinueLegend.prototype.getTrackColor = function (colors) {
        var count = colors.length;
        if (!count) {
            return null;
        }
        if (count === 1) {
            return colors[0];
        }
        var color; // \u6700\u7EC8\u5F62\u6001 l(0) 0:colors[0] 0.5:colors[1] 1:colors[2];
        if (this.isVertical()) {
            // \u6839\u636E\u65B9\u5411\u8BBE\u7F6E\u6E10\u53D8\u65B9\u5411
            color = 'l(90)';
        }
        else {
            color = 'l(0)';
        }
        for (var i = 0; i < count; i++) {
            var percent = i / (count - 1);
            color += " " + percent + ":" + colors[i];
        }
        return color;
    };
    ContinueLegend.prototype.getTrackPath = function (group) {
        var railShape = this.getRailShape(group);
        var path = railShape.attr('path');
        return (0,esm/* clone */.d9)(path);
    };
    ContinueLegend.prototype.getClipTrackAttrs = function (group) {
        var value = this.getCurrentValue();
        var min = value[0], max = value[1];
        var railBBox = this.getRailBBox(group);
        var startPoint = this.getPointByValue(min, group);
        var endPoint = this.getPointByValue(max, group);
        var isVertical = this.isVertical();
        var x;
        var y;
        var width;
        var height;
        if (isVertical) {
            x = railBBox.minX;
            y = startPoint.y;
            width = railBBox.width;
            height = endPoint.y - startPoint.y;
        }
        else {
            x = startPoint.x;
            y = railBBox.minY;
            width = endPoint.x - startPoint.x;
            height = railBBox.height;
        }
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    };
    // \u83B7\u53D6 track \u7684\u5C5E\u6027\uFF0C\u7531 path \u548C \u989C\u8272\u6784\u6210
    ContinueLegend.prototype.getTrackAttrs = function (group) {
        var trackCfg = this.get('track');
        var colors = this.get('colors');
        var path = this.getTrackPath(group);
        return (0,esm/* mix */.CD)({
            path: path,
            fill: this.getTrackColor(colors),
        }, trackCfg.style);
    };
    ContinueLegend.prototype.resetTrackClip = function (group) {
        var container = group || this.get('group');
        var trackId = this.getElementId('track');
        var trackShape = container.findById(trackId);
        var clipShape = trackShape.getClip();
        var attrs = this.getClipTrackAttrs(group);
        if (!clipShape) {
            trackShape.setClip({
                type: 'rect',
                attrs: attrs,
            });
        }
        else {
            clipShape.attr(attrs);
        }
    };
    ContinueLegend.prototype.resetTrack = function (group) {
        var trackId = this.getElementId('track');
        var trackShape = group.findById(trackId);
        var trackAttrs = this.getTrackAttrs(group);
        if (trackShape) {
            trackShape.attr(trackAttrs);
        }
        else {
            this.addShape(group, {
                type: 'path',
                id: trackId,
                draggable: this.get('slidable'),
                name: 'legend-track',
                attrs: trackAttrs,
            });
        }
    };
    ContinueLegend.prototype.getPointByValue = function (value, group) {
        var _a = this.getRange(), min = _a.min, max = _a.max;
        var percent = (value - min) / (max - min);
        var bbox = this.getRailBBox(group);
        var isVertcal = this.isVertical();
        var point = { x: 0, y: 0 };
        if (isVertcal) {
            point.x = bbox.minX + bbox.width / 2;
            point.y = getValueByPercent(bbox.minY, bbox.maxY, percent);
        }
        else {
            point.x = getValueByPercent(bbox.minX, bbox.maxX, percent);
            point.y = bbox.minY + bbox.height / 2;
        }
        return point;
    };
    ContinueLegend.prototype.getRailShape = function (group) {
        var container = group || this.get('group');
        return container.findById(this.getElementId('rail'));
    };
    // \u83B7\u53D6\u6ED1\u8F68\u7684\u5BBD\u9AD8\u4FE1\u606F
    ContinueLegend.prototype.getRailBBox = function (group) {
        var railShape = this.getRailShape(group);
        var bbox = railShape.getBBox();
        return bbox;
    };
    ContinueLegend.prototype.getRailCanvasBBox = function () {
        var container = this.get('group');
        var railShape = container.findById(this.getElementId('rail'));
        var bbox = railShape.getCanvasBBox();
        return bbox;
    };
    // \u662F\u5426\u5782\u76F4
    ContinueLegend.prototype.isVertical = function () {
        return this.get('layout') === 'vertical';
    };
    // \u7528\u4E8E\u4EA4\u4E92\u65F6
    ContinueLegend.prototype.getValueByCanvasPoint = function (x, y) {
        var _a = this.getRange(), min = _a.min, max = _a.max;
        var bbox = this.getRailCanvasBBox(); // \u56E0\u4E3A x, y \u662F\u753B\u5E03\u5750\u6807
        var isVertcal = this.isVertical();
        var step = this.get('step');
        var percent;
        if (isVertcal) {
            // \u5782\u76F4\u65F6\u8BA1\u7B97 y
            percent = (y - bbox.minY) / bbox.height;
        }
        else {
            // \u6C34\u5E73\u65F6\u8BA1\u7B97 x
            percent = (x - bbox.minX) / bbox.width;
        }
        var value = getValueByPercent(min, max, percent);
        if (step) {
            var count = Math.round((value - min) / step);
            value = min + count * step; // \u79FB\u52A8\u5230\u6700\u8FD1\u7684
        }
        if (value > max) {
            value = max;
        }
        if (value < min) {
            value = min;
        }
        return value;
    };
    // \u5F53\u524D\u9009\u4E2D\u7684\u8303\u56F4
    ContinueLegend.prototype.getCurrentValue = function () {
        var value = this.get('value');
        if (!value) {
            var values = this.get('values');
            if (!values) {
                return [this.get('min'), this.get('max')];
            }
            // \u5982\u679C\u6CA1\u6709\u5B9A\u4E49\uFF0C\u53D6\u6700\u5927\u8303\u56F4  \u6700\u5C0F\u503C \u4E3A values \u4E2D\u7684\u6700\u5C0F\u503C\uFF0C \u5982\u679C\u6700\u5C0F\u503C \u8D85\u8FC7\u4E86 \u5B9A\u4E49\u7684\u6700\u5927\u503C \u5219 \u505A\u9650\u5236  \u6700\u5927\u503C \u53CD\u4E4B
            return [Math.max(Math.min.apply(Math, (0,tslib_es6/* __spreadArrays */.pr)(values, [this.get('max')])), this.get('min')), Math.min(Math.max.apply(Math, (0,tslib_es6/* __spreadArrays */.pr)(values, [this.get('min')])), this.get('max'))];
        }
        return value;
    };
    // \u91CD\u7F6E\u6ED1\u5757 handler
    ContinueLegend.prototype.resetHandlers = function (group) {
        var currentValue = this.getCurrentValue();
        var min = currentValue[0], max = currentValue[1];
        this.resetHandler(group, 'min', min);
        this.resetHandler(group, 'max', max);
    };
    // \u83B7\u53D6\u6ED1\u5757\u7684 path
    ContinueLegend.prototype.getHandlerPath = function (handlerCfg, point) {
        var isVertical = this.isVertical();
        var path = [];
        var width = handlerCfg.size;
        var x = point.x, y = point.y;
        var height = width * HANDLER_HEIGHT_RATIO;
        var halfWidth = width / 2;
        var oneSixthWidth = width / 6;
        if (isVertical) {
            /**
             * \u7AD6\u76F4\u60C5\u51B5\u4E0B\u7684\u6ED1\u5757 handler\uFF0C\u5DE6\u4FA7\u9876\u70B9\u662F x,y
             *  /----|
             *    -- |
             *    -- |
             *  \\----|
             */
            var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
            path.push(['M', x, y]);
            path.push(['L', triangleX, y + halfWidth]);
            path.push(['L', x + height, y + halfWidth]);
            path.push(['L', x + height, y - halfWidth]);
            path.push(['L', triangleX, y - halfWidth]);
            path.push(['Z']);
            // \u7ED8\u5236\u4E24\u6761\u6A2A\u7EBF
            path.push(['M', triangleX, y + oneSixthWidth]);
            path.push(['L', x + height - 2, y + oneSixthWidth]);
            path.push(['M', triangleX, y - oneSixthWidth]);
            path.push(['L', x + height - 2, y - oneSixthWidth]);
        }
        else {
            /**
             * \u6C34\u5E73\u60C5\u51B5\u4E0B\u7684\u6ED1\u5757\uFF0C\u4E0A\u9762\u9876\u70B9\u5904\u662F x,y
             *  /   \\
             * | | | |
             * | | | |
             *  -----
             */
            var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
            path.push(['M', x, y]);
            path.push(['L', x - halfWidth, triangleY]);
            path.push(['L', x - halfWidth, y + height]);
            path.push(['L', x + halfWidth, y + height]);
            path.push(['L', x + halfWidth, triangleY]);
            path.push(['Z']);
            // \u7ED8\u5236\u4E24\u6761\u7AD6\u7EBF
            path.push(['M', x - oneSixthWidth, triangleY]);
            path.push(['L', x - oneSixthWidth, y + height - 2]);
            path.push(['M', x + oneSixthWidth, triangleY]);
            path.push(['L', x + oneSixthWidth, y + height - 2]);
        }
        return path;
    };
    // \u8C03\u6574 handler \u7684\u4F4D\u7F6E\uFF0C\u5982\u679C\u672A\u5B58\u5728\u5219\u7ED8\u5236
    ContinueLegend.prototype.resetHandler = function (group, name, value) {
        var point = this.getPointByValue(value, group);
        var handlerCfg = this.get('handler');
        var path = this.getHandlerPath(handlerCfg, point);
        var id = this.getElementId("handler-" + name);
        var handlerShape = group.findById(id);
        var isVertical = this.isVertical();
        if (handlerShape) {
            handlerShape.attr('path', path);
        }
        else {
            this.addShape(group, {
                type: 'path',
                name: "legend-handler-" + name,
                draggable: true,
                id: id,
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ path: path }, handlerCfg.style), { cursor: isVertical ? 'ns-resize' : 'ew-resize' }),
            });
        }
    };
    // \u5F53\u8BBE\u7F6E\u4E86 maxWidth, maxHeight \u65F6\u8C03\u6574 rail \u7684\u5BBD\u5EA6\uFF0C
    // \u6587\u672C\u7684\u4F4D\u7F6E
    ContinueLegend.prototype.fixedElements = function (group) {
        var railShape = group.findById(this.getElementId('rail'));
        var minLabel = group.findById(this.getElementId('label-min'));
        var maxLabel = group.findById(this.getElementId('label-max'));
        var startPoint = this.getDrawPoint();
        if (this.isVertical()) {
            // \u6A2A\u5411\u5E03\u5C40
            this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
        }
        else {
            // \u6C34\u5E73\u5E03\u5C40
            this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
        }
    };
    ContinueLegend.prototype.fitRailLength = function (minLabelBBox, maxLabelBBox, railBBox, railShape) {
        var isVertical = this.isVertical();
        var lengthField = isVertical ? 'height' : 'width';
        var labelCfg = this.get('label');
        var labelAlign = labelCfg.align;
        var spacing = labelCfg.spacing;
        var maxLength = this.get("max" + (0,esm/* upperFirst */.jC)(lengthField)); // get('maxWidth')
        if (maxLength) {
            var elementsLength = labelAlign === 'rail'
                ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2
                : railBBox[lengthField];
            var diff = elementsLength - maxLength;
            if (diff > 0) {
                // \u5927\u4E8E\u9650\u5236\u7684\u957F\u5EA6
                this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff);
            }
        }
    };
    ContinueLegend.prototype.changeRailLength = function (railShape, lengthField, length) {
        var bbox = railShape.getBBox();
        var path;
        if (lengthField === 'height') {
            path = this.getRailPath(bbox.x, bbox.y, bbox.width, length);
        }
        else {
            path = this.getRailPath(bbox.x, bbox.y, length, bbox.height);
        }
        railShape.attr('path', path);
    };
    ContinueLegend.prototype.changeRailPosition = function (railShape, x, y) {
        var bbox = railShape.getBBox();
        var path = this.getRailPath(x, y, bbox.width, bbox.height);
        railShape.attr('path', path);
    };
    ContinueLegend.prototype.fixedHorizontal = function (minLabel, maxLabel, railShape, startPoint) {
        var labelCfg = this.get('label');
        var labelAlign = labelCfg.align;
        var spacing = labelCfg.spacing;
        var railBBox = railShape.getBBox();
        var minLabelBBox = minLabel.getBBox();
        var maxLabelBBox = maxLabel.getBBox();
        var railHeight = railBBox.height; // \u53D6 rail \u7684\u9AD8\u5EA6\uFF0C\u4F5C\u4E3A\u9AD8\u5EA6
        this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
        railBBox = railShape.getBBox();
        if (labelAlign === 'rail') {
            // \u6CBF\u7740 rail \u65B9\u5411
            minLabel.attr({
                x: startPoint.x,
                y: startPoint.y + railHeight / 2,
            });
            this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
            maxLabel.attr({
                x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
                y: startPoint.y + railHeight / 2,
            });
        }
        else if (labelAlign === 'top') {
            minLabel.attr({
                x: startPoint.x,
                y: startPoint.y,
            });
            maxLabel.attr({
                x: startPoint.x + railBBox.width,
                y: startPoint.y,
            });
            this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
        }
        else {
            this.changeRailPosition(railShape, startPoint.x, startPoint.y);
            minLabel.attr({
                x: startPoint.x,
                y: startPoint.y + railBBox.height + spacing,
            });
            maxLabel.attr({
                x: startPoint.x + railBBox.width,
                y: startPoint.y + railBBox.height + spacing,
            });
        }
    };
    ContinueLegend.prototype.fixedVertail = function (minLabel, maxLabel, railShape, startPoint) {
        var labelCfg = this.get('label');
        var labelAlign = labelCfg.align;
        var spacing = labelCfg.spacing;
        var railBBox = railShape.getBBox();
        var minLabelBBox = minLabel.getBBox();
        var maxLabelBBox = maxLabel.getBBox();
        this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
        railBBox = railShape.getBBox();
        if (labelAlign === 'rail') {
            // \u6CBF\u7740 rail \u65B9\u5411
            minLabel.attr({
                x: startPoint.x,
                y: startPoint.y,
            });
            this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
            maxLabel.attr({
                x: startPoint.x,
                y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2,
            });
        }
        else if (labelAlign === 'right') {
            minLabel.attr({
                x: startPoint.x + railBBox.width + spacing,
                y: startPoint.y,
            });
            this.changeRailPosition(railShape, startPoint.x, startPoint.y);
            maxLabel.attr({
                x: startPoint.x + railBBox.width + spacing,
                y: startPoint.y + railBBox.height,
            });
        }
        else {
            // left
            var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
            minLabel.attr({
                x: startPoint.x,
                y: startPoint.y,
            });
            this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
            maxLabel.attr({
                x: startPoint.x,
                y: startPoint.y + railBBox.height,
            });
        }
    };
    return ContinueLegend;
}(legend_base));
/* harmony default export */ var continuous = (ContinueLegend);
//# sourceMappingURL=continuous.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/legend/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/tooltip/css-const.js
var css_const_CONTAINER_CLASS = 'g2-tooltip';
var TITLE_CLASS = 'g2-tooltip-title';
var LIST_CLASS = 'g2-tooltip-list';
var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
var MARKER_CLASS = 'g2-tooltip-marker';
var VALUE_CLASS = 'g2-tooltip-value';
var NAME_CLASS = 'g2-tooltip-name';
var CROSSHAIR_X = 'g2-tooltip-crosshair-x';
var CROSSHAIR_Y = 'g2-tooltip-crosshair-y';
//# sourceMappingURL=css-const.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/tooltip/html-theme.js
var html_theme_a;

// tooltip \u76F8\u5173 dom \u7684 css \u7C7B\u540D

/* harmony default export */ var tooltip_html_theme = (html_theme_a = {},
    // css style for tooltip
    html_theme_a["" + css_const_CONTAINER_CLASS] = {
        position: 'absolute',
        visibility: 'visible',
        // @2018-07-25 by blue.lb \u8FD9\u91CC\u53BB\u6389\u6D6E\u52A8\uFF0C\u706B\u72D0\u4E0A\u5B58\u5728\u6837\u5F0F\u9519\u4F4D
        // whiteSpace: 'nowrap',
        zIndex: 8,
        transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), ' +
            'left 0.4s cubic-bezier(0.23, 1, 0.32, 1), ' +
            'top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
        backgroundColor: 'rgba(255, 255, 255, 0.9)',
        boxShadow: '0px 0px 10px #aeaeae',
        borderRadius: '3px',
        color: 'rgb(87, 87, 87)',
        fontSize: '12px',
        fontFamily: theme.fontFamily,
        lineHeight: '20px',
        padding: '10px 10px 6px 10px',
    },
    html_theme_a["" + TITLE_CLASS] = {
        marginBottom: '4px',
    },
    html_theme_a["" + LIST_CLASS] = {
        margin: '0px',
        listStyleType: 'none',
        padding: '0px',
    },
    html_theme_a["" + LIST_ITEM_CLASS] = {
        listStyleType: 'none',
        marginBottom: '4px',
    },
    html_theme_a["" + MARKER_CLASS] = {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        display: 'inline-block',
        marginRight: '8px',
    },
    html_theme_a["" + VALUE_CLASS] = {
        display: 'inline-block',
        float: 'right',
        marginLeft: '30px',
    },
    html_theme_a["" + CROSSHAIR_X] = {
        position: 'absolute',
        width: '1px',
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
    },
    html_theme_a["" + CROSSHAIR_Y] = {
        position: 'absolute',
        height: '1px',
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
    },
    html_theme_a);
//# sourceMappingURL=html-theme.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/util/align.js
// \u68C0\u6D4B\u5404\u8FB9\u662F\u5426\u8D85\u51FA
function getOutSides(x, y, width, height, limitBox) {
    var hits = {
        left: x < limitBox.x,
        right: x + width > limitBox.x + limitBox.width,
        top: y < limitBox.y,
        bottom: y + height > limitBox.y + limitBox.height,
    };
    return hits;
}
function getPointByPosition(x, y, offset, width, height, position) {
    var px = x;
    var py = y;
    switch (position) {
        case 'left': // left center
            px = x - width - offset;
            py = y - height / 2;
            break;
        case 'right':
            px = x + offset;
            py = y - height / 2;
            break;
        case 'top':
            px = x - width / 2;
            py = y - height - offset;
            break;
        case 'bottom':
            // bottom
            px = x - width / 2;
            py = y + offset;
            break;
        default:
            // auto, \u5728 top-right
            px = x + offset;
            py = y - height - offset;
            break;
    }
    return {
        x: px,
        y: py,
    };
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
    var point = getPointByPosition(x, y, offset, width, height, position);
    if (limitBox) {
        var outSides = getOutSides(point.x, point.y, width, height, limitBox);
        if (position === 'auto') {
            // \u5982\u679C\u662F auto\uFF0C\u9ED8\u8BA4 tooltip \u5728\u53F3\u4E0A\u89D2\uFF0C\u4EC5\u9700\u8981\u5224\u5B9A\u53F3\u4FA7\u548C\u4E0A\u6D4B\u51B2\u7A81\u5373\u53EF
            if (outSides.right) {
                point.x = Math.max(0, x - width - offset);
            }
            if (outSides.top) {
                point.y = Math.max(0, y - height - offset);
            }
        }
        else if (position === 'top' || position === 'bottom') {
            if (outSides.left) {
                // \u5DE6\u4FA7\u8EB2\u907F
                point.x = limitBox.x;
            }
            if (outSides.right) {
                // \u53F3\u4FA7\u8EB2\u907F
                point.x = limitBox.x + limitBox.width - width;
            }
            if (position === 'top' && outSides.top) {
                // \u5982\u679C\u4E0A\u9762\u5BF9\u9F50\u68C0\u6D4B\u4E0A\u9762\uFF0C\u4E0D\u68C0\u6D4B\u4E0B\u9762
                point.y = y + offset;
            }
            if (position === 'bottom' && outSides.bottom) {
                point.y = y - height - offset;
            }
        }
        else {
            // \u68C0\u6D4B\u5DE6\u53F3\u4F4D\u7F6E
            if (outSides.top) {
                point.y = limitBox.y;
            }
            if (outSides.bottom) {
                point.y = limitBox.y + limitBox.height - height;
            }
            if (position === 'left' && outSides.left) {
                point.x = x + offset;
            }
            if (position === 'right' && outSides.right) {
                point.x = x - width - offset;
            }
        }
    }
    return point;
}
//# sourceMappingURL=align.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/tooltip/html.js









function hasOneKey(obj, keys) {
    var result = false;
    (0,esm/* each */.S6)(keys, function (key) {
        if ((0,esm/* hasKey */.wH)(obj, key)) {
            result = true;
            return false;
        }
    });
    return result;
}
var Tooltip = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Tooltip, _super);
    function Tooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'tooltip', type: 'html', x: 0, y: 0, items: [], customContent: null, containerTpl: "<div class=\\"" + css_const_CONTAINER_CLASS + "\\"><div class=\\"" + TITLE_CLASS + "\\"></div><ul class=\\"" + LIST_CLASS + "\\"></ul></div>", itemTpl: "<li class=\\"" + LIST_ITEM_CLASS + "\\" data-index={index}>\\n          <span class=\\"" + MARKER_CLASS + "\\" style=\\"background:{color}\\"></span>\\n          <span class=\\"" + NAME_CLASS + "\\">{name}</span>:\\n          <span class=\\"" + VALUE_CLASS + "\\">{value}</span>\\n        </li>", xCrosshairTpl: "<div class=\\"" + CROSSHAIR_X + "\\"></div>", yCrosshairTpl: "<div class=\\"" + CROSSHAIR_Y + "\\"></div>", title: null, showTitle: true, 
            /**
             * tooltip \u9650\u5236\u7684\u533A\u57DF
             * @type {Region}
             */
            region: null, 
            // crosshair \u7684\u9650\u5236\u533A\u57DF
            crosshairsRegion: null, containerClassName: css_const_CONTAINER_CLASS, 
            // x, y, xy
            crosshairs: null, offset: 10, position: 'right', domStyles: null, defaultStyles: tooltip_html_theme });
    };
    // tooltip \u6E32\u67D3\u65F6\uFF0C\u6E32\u67D3 title\uFF0Citems \u548C corosshairs
    Tooltip.prototype.render = function () {
        if (this.get('customContent')) {
            this.renderCustomContent();
        }
        else {
            this.resetTitle();
            this.renderItems();
        }
        // \u7ED8\u5236\u5B8C\u6210\u540E\uFF0C\u518D\u5B9A\u4F4D
        this.resetPosition();
    };
    // \u590D\u5199\u6E05\u7A7A\u51FD\u6570\uFF0C\u56E0\u4E3A\u6709\u6A21\u677F\u7684\u5B58\u5728\uFF0C\u6240\u4EE5\u9ED8\u8BA4\u7684\u5199\u6CD5\u4E0D\u5408\u9002
    Tooltip.prototype.clear = function () {
        // \u7531\u4E8E crosshair \u6CA1\u6709\u5728 container \u5185\uFF0C\u6240\u4EE5\u9700\u8981\u5355\u72EC\u6E05\u7406
        this.clearCrosshairs();
        this.setTitle(''); // \u6E05\u7A7A\u6807\u9898
        this.clearItemDoms();
    };
    Tooltip.prototype.show = function () {
        var container = this.getContainer();
        if (!container || this.destroyed) {
            // \u9632\u6B62\u5BB9\u5668\u4E0D\u5B58\u5728\u6216\u8005\u88AB\u9500\u6BC1\u65F6\u62A5\u9519
            return;
        }
        this.set('visible', true);
        modifyCSS(container, {
            visibility: 'visible',
        });
        this.setCrossHairsVisible(true);
    };
    Tooltip.prototype.hide = function () {
        var container = this.getContainer();
        // relative: https://github.com/antvis/g2/issues/1221
        if (!container || this.destroyed) {
            return;
        }
        this.set('visible', false);
        modifyCSS(container, {
            visibility: 'hidden',
        });
        this.setCrossHairsVisible(false);
    };
    // \u5B9E\u73B0 IPointLocation \u7684\u63A5\u53E3
    Tooltip.prototype.getLocation = function () {
        return { x: this.get('x'), y: this.get('y') };
    };
    // \u5B9E\u73B0 IPointLocation \u7684\u63A5\u53E3
    Tooltip.prototype.setLocation = function (point) {
        this.set('x', point.x);
        this.set('y', point.y);
        this.resetPosition();
    };
    Tooltip.prototype.setCrossHairsVisible = function (visible) {
        var display = visible ? '' : 'none';
        var xCrosshairDom = this.get('xCrosshairDom');
        var yCrosshairDom = this.get('yCrosshairDom');
        xCrosshairDom &&
            modifyCSS(xCrosshairDom, {
                display: display,
            });
        yCrosshairDom &&
            modifyCSS(yCrosshairDom, {
                display: display,
            });
    };
    // \u5982\u6709 customContent \u5219\u6839\u636E customContent \u8BBE\u7F6E container
    Tooltip.prototype.initContainer = function () {
        _super.prototype.initContainer.call(this);
        if (this.get('customContent')) {
            if (this.get('container')) {
                this.get('container').remove();
            }
            var container = this.getHtmlContentNode();
            this.get('parent').appendChild(container);
            this.set('container', container);
            this.resetStyles();
            this.applyStyles();
        }
    };
    // \u66F4\u65B0\u5C5E\u6027\u7684\u540C\u65F6\uFF0C\u53EF\u80FD\u4F1A\u5F15\u8D77 DOM \u7684\u53D8\u5316\uFF0C\u8FD9\u91CC\u5BF9\u53EF\u80FD\u5F15\u8D77 DOM \u53D8\u5316\u7684\u573A\u666F\u505A\u4E86\u5904\u7406
    Tooltip.prototype.updateInner = function (cfg) {
        if (this.get('customContent')) {
            this.renderCustomContent();
        }
        else {
            // \u66F4\u65B0\u6807\u9898
            if (hasOneKey(cfg, ['title', 'showTitle'])) {
                this.resetTitle();
            }
            // \u66F4\u65B0\u5185\u5BB9
            if ((0,esm/* hasKey */.wH)(cfg, 'items')) {
                this.renderItems();
            }
        }
        _super.prototype.updateInner.call(this, cfg);
    };
    Tooltip.prototype.initDom = function () {
        this.cacheDoms();
    };
    // \u6E05\u7406 DOM
    Tooltip.prototype.removeDom = function () {
        _super.prototype.removeDom.call(this);
        this.clearCrosshairs();
    };
    // \u8C03\u6574\u4F4D\u7F6E
    Tooltip.prototype.resetPosition = function () {
        var x = this.get('x');
        var y = this.get('y');
        var offset = this.get('offset');
        var _a = this.getOffset(), offsetX = _a.offsetX, offsetY = _a.offsetY;
        var position = this.get('position');
        var region = this.get('region');
        var container = this.getContainer();
        var bbox = this.getBBox();
        var width = bbox.width, height = bbox.height;
        var limitBox;
        if (region) {
            // \u4E0D\u9650\u5236\u4F4D\u7F6E
            limitBox = regionToBBox(region);
        }
        var point = getAlignPoint(x, y, offset, width, height, position, limitBox);
        modifyCSS(container, {
            left: toPx(point.x + offsetX),
            top: toPx(point.y + offsetY),
        });
        this.resetCrosshairs();
    };
    // \u6839\u636E customContent \u6E32\u67D3
    Tooltip.prototype.renderCustomContent = function () {
        var node = this.getHtmlContentNode();
        var parent = this.get('parent');
        var curContainer = this.get('container');
        if (curContainer && curContainer.parentNode === parent) {
            parent.replaceChild(node, curContainer);
        }
        else {
            parent.appendChild(node);
        }
        this.set('container', node);
        this.resetStyles();
        this.applyStyles();
    };
    Tooltip.prototype.getHtmlContentNode = function () {
        var node;
        var customContent = this.get('customContent');
        if (customContent) {
            var elem = customContent(this.get('title'), this.get('items'));
            if ((0,esm/* isElement */.kK)(elem)) {
                node = elem;
            }
            else {
                node = createDom(elem);
            }
        }
        return node;
    };
    // \u7F13\u5B58\u6A21\u677F\u8BBE\u7F6E\u7684\u5404\u79CD DOM
    Tooltip.prototype.cacheDoms = function () {
        var container = this.getContainer();
        var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
        var listDom = container.getElementsByClassName(LIST_CLASS)[0];
        this.set('titleDom', titleDom);
        this.set('listDom', listDom);
    };
    // \u91CD\u7F6E title
    Tooltip.prototype.resetTitle = function () {
        var title = this.get('title');
        var showTitle = this.get('showTitle');
        if (showTitle && title) {
            this.setTitle(title);
        }
        else {
            this.setTitle('');
        }
    };
    // \u8BBE\u7F6E title \u6587\u672C
    Tooltip.prototype.setTitle = function (text) {
        var titleDom = this.get('titleDom');
        if (titleDom) {
            titleDom.innerText = text;
        }
    };
    // \u7EC8\u6B62 crosshair
    Tooltip.prototype.resetCrosshairs = function () {
        var crosshairsRegion = this.get('crosshairsRegion');
        var crosshairs = this.get('crosshairs');
        if (!crosshairsRegion || !crosshairs) {
            // \u4E0D\u663E\u793A crosshair\uFF0C\u90FD\u79FB\u9664\uFF0C\u6CA1\u6709\u8BBE\u5B9A region \u4E5F\u90FD\u79FB\u9664\u6389
            this.clearCrosshairs();
        }
        else {
            var crosshairBox = regionToBBox(crosshairsRegion);
            var xCrosshairDom = this.get('xCrosshairDom');
            var yCrosshairDom = this.get('yCrosshairDom');
            if (crosshairs === 'x') {
                this.resetCrosshair('x', crosshairBox);
                // \u4EC5\u663E\u793A x \u7684 crosshair\uFF0Cy \u79FB\u9664
                if (yCrosshairDom) {
                    yCrosshairDom.remove();
                    this.set('yCrosshairDom', null);
                }
            }
            else if (crosshairs === 'y') {
                this.resetCrosshair('y', crosshairBox);
                // \u4EC5\u663E\u793A y \u7684 crosshair\uFF0Cx \u79FB\u9664
                if (xCrosshairDom) {
                    xCrosshairDom.remove();
                    this.set('xCrosshairDom', null);
                }
            }
            else {
                this.resetCrosshair('x', crosshairBox);
                this.resetCrosshair('y', crosshairBox);
            }
            this.setCrossHairsVisible(this.get('visible'));
        }
    };
    // \u8BBE\u5B9A crosshair \u7684\u4F4D\u7F6E\uFF0C\u9700\u8981\u533A\u5206 x,y
    Tooltip.prototype.resetCrosshair = function (name, bbox) {
        var croshairDom = this.checkCrosshair(name);
        var value = this.get(name);
        if (name === 'x') {
            modifyCSS(croshairDom, {
                left: toPx(value),
                top: toPx(bbox.y),
                height: toPx(bbox.height),
            });
        }
        else {
            modifyCSS(croshairDom, {
                top: toPx(value),
                left: toPx(bbox.x),
                width: toPx(bbox.width),
            });
        }
    };
    // \u5982\u679C crosshair \u5BF9\u5E94\u7684 dom \u4E0D\u5B58\u5728\uFF0C\u5219\u521B\u5EFA
    Tooltip.prototype.checkCrosshair = function (name) {
        var domName = name + "CrosshairDom";
        var tplName = name + "CrosshairTpl";
        var constName = "CROSSHAIR_" + name.toUpperCase();
        var styleName = tooltip_css_const_namespaceObject[constName];
        var croshairDom = this.get(domName);
        var parent = this.get('parent');
        if (!croshairDom) {
            croshairDom = createDom(this.get(tplName)); // \u521B\u5EFA
            this.applyStyle(styleName, croshairDom); // \u8BBE\u7F6E\u521D\u59CB\u6837\u5F0F
            parent.appendChild(croshairDom); // \u6DFB\u52A0\u5230\u8DDF tooltip \u540C\u7EA7\u7684\u76EE\u5F55\u4E0B
            this.set(domName, croshairDom);
        }
        return croshairDom;
    };
    Tooltip.prototype.renderItems = function () {
        this.clearItemDoms();
        var items = this.get('items');
        var itemTpl = this.get('itemTpl');
        var listDom = this.get('listDom');
        if (listDom) {
            (0,esm/* each */.S6)(items, function (item) {
                var color = color_util_esm.toCSSGradient(item.color);
                var substituteObj = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { color: color });
                var domStr = (0,esm/* substitute */.ng)(itemTpl, substituteObj);
                var itemDom = createDom(domStr);
                listDom.appendChild(itemDom);
            });
            this.applyChildrenStyles(listDom, this.get('domStyles'));
        }
    };
    Tooltip.prototype.clearItemDoms = function () {
        if (this.get('listDom')) {
            clearDom(this.get('listDom'));
        }
    };
    Tooltip.prototype.clearCrosshairs = function () {
        var xCrosshairDom = this.get('xCrosshairDom');
        var yCrosshairDom = this.get('yCrosshairDom');
        xCrosshairDom && xCrosshairDom.remove();
        yCrosshairDom && yCrosshairDom.remove();
        this.set('xCrosshairDom', null);
        this.set('yCrosshairDom', null);
    };
    return Tooltip;
}(html_component));
/* harmony default export */ var tooltip_html = (Tooltip);
//# sourceMappingURL=html.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/tooltip/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/trend/constant.js
var BACKGROUND_STYLE = {
    // fill: 'red',
    opacity: 0,
};
var LINE_STYLE = {
    stroke: '#C5C5C5',
    strokeOpacity: 0.85,
};
var AREA_STYLE = {
    fill: '#CACED4',
    opacity: 0.85,
};
//# sourceMappingURL=constant.js.map
// EXTERNAL MODULE: ./node_modules/@antv/path-util/esm/index.js + 14 modules
var path_util_esm = __webpack_require__(59665);
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/trend/path.js




/**
 * \u70B9\u6570\u7EC4\u8F6C path
 * @param points
 */
function pointsToPath(points) {
    return (0,esm/* map */.UI)(points, function (p, idx) {
        var command = idx === 0 ? 'M' : 'L';
        var x = p[0], y = p[1];
        return [command, x, y];
    });
}
/**
 * \u5C06\u70B9\u8FDE\u63A5\u6210\u8DEF\u5F84 path
 * @param points
 */
function getLinePath(points) {
    return pointsToPath(points);
}
/**
 * \u5C06\u70B9\u8FDE\u6210\u5E73\u6ED1\u7684\u66F2\u7EBF
 * @param points
 */
function getSmoothLinePath(points) {
    if (points.length <= 2) {
        // \u4E24\u70B9\u4EE5\u5185\u76F4\u63A5\u7ED8\u5236\u6210\u8DEF\u5F84
        return getLinePath(points);
    }
    var data = [];
    (0,esm/* each */.S6)(points, function (p) {
        // \u5F53\u524D\u70B9\u548C\u4E0A\u4E00\u4E2A\u70B9\u4E00\u6837\u7684\u65F6\u5019\uFF0C\u5FFD\u7565\u6389
        if (!(0,esm/* isEqual */.Xy)(p, data.slice(data.length - 2))) {
            data.push(p[0], p[1]);
        }
    });
    // const constraint = [ // \u8303\u56F4
    //   [ 0, 0 ],
    //   [ 1, 1 ],
    // ];
    var path = (0,path_util_esm/* catmullRom2Bezier */.e9)(data, false);
    var _a = (0,esm/* head */.YM)(points), x = _a[0], y = _a[1];
    path.unshift(['M', x, y]);
    return path;
}
/**
 * \u5C06\u6570\u636E\u8F6C\u6210 path\uFF0C\u5229\u7528 scale \u7684\u5F52\u4E00\u5316\u80FD\u529B
 * @param data
 * @param width
 * @param height
 * @param smooth
 */
function dataToPath(data, width, height, smooth) {
    if (smooth === void 0) { smooth = true; }
    // \u5229\u7528 scale \u6765\u83B7\u53D6 y \u4E0A\u7684\u6620\u5C04
    var y = new linear({
        values: data,
    });
    var x = new category_base({
        values: (0,esm/* map */.UI)(data, function (v, idx) { return idx; }),
    });
    var points = (0,esm/* map */.UI)(data, function (v, idx) {
        return [x.scale(idx) * width, height - y.scale(v) * height];
    });
    return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
/**
 * \u83B7\u5F97 area \u9762\u79EF\u7684\u6A2A\u5411\u8FDE\u63A5\u7EBF\u7684 px \u4F4D\u7F6E
 * @param data
 * @param width
 * @param height
 */
function getAreaLineY(data, height) {
    var y = new linear({
        values: data,
    });
    // \u5F53\u66F2\u7EBF\u5168\u90E8\u4E3A\u8D1F\u6570\u65F6\uFF0C\u53D6\u6700\u5927\u503C\uFF0C\u5F53\u66F2\u7EBF\u5168\u90E8\u4E3A\u6B63\u6570\u65F6\uFF0C\u53D6\u6700\u5C0F\u503C\uFF0C\u5F53\u66F2\u7EBF\u6709\u6B63\u6709\u8D1F\uFF0C\u5219\u53D6\u96F6\u70B9
    var lineY = y.max < 0 ? y.max : Math.max(0, y.min);
    return height - y.scale(lineY) * height;
}
/**
 * \u7EBF path \u8F6C area path
 * @param path
 * @param width
 * @param height
 */
function linePathToAreaPath(path, width, height, data) {
    var areaPath = (0,tslib_es6/* __spreadArrays */.pr)(path);
    var lineYPx = getAreaLineY(data, height);
    areaPath.push(['L', width, lineYPx]);
    areaPath.push(['L', 0, lineYPx]);
    areaPath.push(['Z']);
    return areaPath;
}
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/trend/trend.js




var Trend = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Trend, _super);
    function Trend() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Trend.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'trend', x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
    };
    Trend.prototype.renderInner = function (group) {
        var _a = this.cfg, width = _a.width, height = _a.height, data = _a.data, smooth = _a.smooth, isArea = _a.isArea, backgroundStyle = _a.backgroundStyle, lineStyle = _a.lineStyle, areaStyle = _a.areaStyle;
        // \u80CC\u666F
        this.addShape(group, {
            id: this.getElementId('background'),
            type: 'rect',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: 0, y: 0, width: width,
                height: height }, backgroundStyle),
        });
        var path = dataToPath(data, width, height, smooth);
        // \u7EBF
        this.addShape(group, {
            id: this.getElementId('line'),
            type: 'path',
            attrs: (0,tslib_es6/* __assign */.pi)({ path: path }, lineStyle),
        });
        // area
        // \u5728 path \u7684\u57FA\u7840\u4E0A\uFF0C\u589E\u52A0\u4E24\u4E2A\u5750\u6807\u70B9
        if (isArea) {
            var areaPath = linePathToAreaPath(path, width, height, data);
            this.addShape(group, {
                id: this.getElementId('area'),
                type: 'path',
                attrs: (0,tslib_es6/* __assign */.pi)({ path: areaPath }, areaStyle),
            });
        }
    };
    Trend.prototype.applyOffset = function () {
        var _a = this.cfg, x = _a.x, y = _a.y;
        // \u7EDF\u4E00\u79FB\u52A8\u5230\u5BF9\u5E94\u7684\u4F4D\u7F6E
        this.moveElementTo(this.get('group'), {
            x: x,
            y: y,
        });
    };
    return Trend;
}(group_component));

/* harmony default export */ var trend = ((/* unused pure expression or super */ null && (Trend)));
//# sourceMappingURL=trend.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/slider/handler.js


var DEFAULT_HANDLER_STYLE = {
    fill: '#F7F7F7',
    stroke: '#BFBFBF',
    radius: 2,
    opacity: 1,
    cursor: 'ew-resize',
    // \u9AD8\u4EAE\u7684\u989C\u8272
    highLightFill: '#FFF',
};
var Handler = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Handler, _super);
    function Handler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Handler.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'handler', x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
    };
    Handler.prototype.renderInner = function (group) {
        var _a = this.cfg, width = _a.width, height = _a.height, style = _a.style;
        var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
        // \u6309\u94AE\u6846\u6846
        this.addShape(group, {
            type: 'rect',
            id: this.getElementId('background'),
            attrs: {
                x: 0,
                y: 0,
                width: width,
                height: height,
                fill: fill,
                stroke: stroke,
                radius: radius,
                opacity: opacity,
                cursor: cursor,
            },
        });
        // \u4E24\u6839\u7AD6\u7EBF
        var x1 = (1 / 3) * width;
        var x2 = (2 / 3) * width;
        var y1 = (1 / 4) * height;
        var y2 = (3 / 4) * height;
        this.addShape(group, {
            id: this.getElementId('line-left'),
            type: 'line',
            attrs: {
                x1: x1,
                y1: y1,
                x2: x1,
                y2: y2,
                stroke: stroke,
                cursor: cursor,
            },
        });
        this.addShape(group, {
            id: this.getElementId('line-right'),
            type: 'line',
            attrs: {
                x1: x2,
                y1: y1,
                x2: x2,
                y2: y2,
                stroke: stroke,
                cursor: cursor,
            },
        });
    };
    Handler.prototype.applyOffset = function () {
        this.moveElementTo(this.get('group'), {
            x: this.get('x'),
            y: this.get('y'),
        });
    };
    Handler.prototype.initEvent = function () {
        this.bindEvents();
    };
    Handler.prototype.bindEvents = function () {
        var _this = this;
        this.get('group').on('mouseenter', function () {
            var highLightFill = _this.get('style').highLightFill;
            _this.getElementByLocalId('background').attr('fill', highLightFill);
            _this.draw();
        });
        this.get('group').on('mouseleave', function () {
            var fill = _this.get('style').fill;
            _this.getElementByLocalId('background').attr('fill', fill);
            _this.draw();
        });
    };
    Handler.prototype.draw = function () {
        var canvas = this.get('container').get('canvas');
        if (canvas) {
            canvas.draw();
        }
    };
    return Handler;
}(group_component));

/* harmony default export */ var handler = ((/* unused pure expression or super */ null && (Handler)));
//# sourceMappingURL=handler.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/slider/constant.js
/**
 * \u4E00\u4E9B\u9ED8\u8BA4\u7684\u6837\u5F0F\u914D\u7F6E
 */
var constant_BACKGROUND_STYLE = {
    fill: '#416180',
    opacity: 0.05,
};
var FOREGROUND_STYLE = {
    fill: '#5B8FF9',
    opacity: 0.15,
    cursor: 'move',
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
    width: DEFAULT_HANDLER_WIDTH,
    height: 24,
};
var TEXT_STYLE = {
    textBaseline: 'middle',
    fill: '#000',
    opacity: 0.45,
};
var SLIDER_CHANGE = 'sliderchange';
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/slider/slider.js






var slider_Slider = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Slider, _super);
    function Slider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onMouseDown = function (target) { return function (e) {
            _this.currentTarget = target;
            // \u53D6\u51FA\u539F\u751F\u4E8B\u4EF6
            var event = e.originalEvent;
            // 2. \u5B58\u50A8\u5F53\u524D\u70B9\u51FB\u4F4D\u7F6E
            event.stopPropagation();
            event.preventDefault();
            // \u517C\u5BB9\u79FB\u52A8\u7AEF\u83B7\u53D6\u6570\u636E
            _this.prevX = (0,esm/* get */.U2)(event, 'touches.0.pageX', event.pageX);
            _this.prevY = (0,esm/* get */.U2)(event, 'touches.0.pageY', event.pageY);
            // 3. \u5F00\u59CB\u6ED1\u52A8\u7684\u65F6\u5019\uFF0C\u7ED1\u5B9A move \u548C up \u4E8B\u4EF6
            var containerDOM = _this.getContainerDOM();
            containerDOM.addEventListener('mousemove', _this.onMouseMove);
            containerDOM.addEventListener('mouseup', _this.onMouseUp);
            containerDOM.addEventListener('mouseleave', _this.onMouseUp);
            // \u79FB\u52A8\u7AEF\u4E8B\u4EF6
            containerDOM.addEventListener('touchmove', _this.onMouseMove);
            containerDOM.addEventListener('touchend', _this.onMouseUp);
            containerDOM.addEventListener('touchcancel', _this.onMouseUp);
        }; };
        _this.onMouseMove = function (event) {
            var width = _this.cfg.width;
            var originValue = [_this.get('start'), _this.get('end')];
            // \u6ED1\u52A8\u8FC7\u7A0B\u4E2D\uFF0C\u8BA1\u7B97\u504F\u79FB\uFF0C\u66F4\u65B0\u6ED1\u5757\uFF0C\u7136\u540E emit \u6570\u636E\u51FA\u53BB
            event.stopPropagation();
            event.preventDefault();
            var x = (0,esm/* get */.U2)(event, 'touches.0.pageX', event.pageX);
            var y = (0,esm/* get */.U2)(event, 'touches.0.pageY', event.pageY);
            // \u6A2A\u5411\u7684 slider \u53EA\u5904\u7406 x
            var offsetX = x - _this.prevX;
            var offsetXRange = _this.adjustOffsetRange(offsetX / width);
            // \u66F4\u65B0 start end range \u8303\u56F4
            _this.updateStartEnd(offsetXRange);
            // \u66F4\u65B0 ui
            _this.updateUI(_this.getElementByLocalId('foreground'), _this.getElementByLocalId('minText'), _this.getElementByLocalId('maxText'));
            _this.prevX = x;
            _this.prevY = y;
            _this.draw();
            // \u56E0\u4E3A\u5B58\u50A8\u7684 start\u3001end \u53EF\u80FD\u4E0D\u4E00\u5B9A\u662F\u6309\u5927\u5C0F\u5B58\u50A8\u7684\uFF0C\u6240\u4EE5\u6392\u5E8F\u4E00\u4E0B\uFF0C\u5BF9\u5916\u662F end >= start
            _this.emit(SLIDER_CHANGE, [_this.get('start'), _this.get('end')].sort());
            _this.delegateEmit('valuechanged', {
                originValue: originValue,
                value: [_this.get('start'), _this.get('end')],
            });
        };
        _this.onMouseUp = function () {
            // \u7ED3\u675F\u4E4B\u540E\uFF0C\u53D6\u6D88\u7ED1\u5B9A\u7684\u4E8B\u4EF6
            if (_this.currentTarget) {
                _this.currentTarget = undefined;
            }
            var containerDOM = _this.getContainerDOM();
            if (containerDOM) {
                containerDOM.removeEventListener('mousemove', _this.onMouseMove);
                containerDOM.removeEventListener('mouseup', _this.onMouseUp);
                // \u9632\u6B62\u6ED1\u52A8\u5230 canvas \u5916\u90E8\u4E4B\u540E\uFF0C\u72B6\u6001\u4E22\u5931
                containerDOM.removeEventListener('mouseleave', _this.onMouseUp);
                // \u79FB\u52A8\u7AEF\u4E8B\u4EF6
                containerDOM.removeEventListener('touchmove', _this.onMouseMove);
                containerDOM.removeEventListener('touchend', _this.onMouseUp);
                containerDOM.removeEventListener('touchcancel', _this.onMouseUp);
            }
        };
        return _this;
    }
    Slider.prototype.setRange = function (min, max) {
        this.set('minLimit', min);
        this.set('maxLimit', max);
        var oldStart = this.get('start');
        var oldEnd = this.get('end');
        var newStart = (0,esm/* clamp */.uZ)(oldStart, min, max);
        var newEnd = (0,esm/* clamp */.uZ)(oldEnd, min, max);
        if (!this.get('isInit') && (oldStart !== newStart || oldEnd !== newEnd)) {
            this.setValue([newStart, newEnd]);
        }
    };
    Slider.prototype.getRange = function () {
        return {
            min: this.get('minLimit') || 0,
            max: this.get('maxLimit') || 1,
        };
    };
    Slider.prototype.setValue = function (value) {
        var range = this.getRange();
        if ((0,esm/* isArray */.kJ)(value) && value.length === 2) {
            var originValue = [this.get('start'), this.get('end')];
            this.update({
                start: (0,esm/* clamp */.uZ)(value[0], range.min, range.max),
                end: (0,esm/* clamp */.uZ)(value[1], range.min, range.max),
            });
            if (!this.get('updateAutoRender')) {
                this.render();
            }
            this.delegateEmit('valuechanged', {
                originValue: originValue,
                value: value,
            });
        }
    };
    Slider.prototype.getValue = function () {
        return [this.get('start'), this.get('end')];
    };
    Slider.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'slider', x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
                backgroundStyle: constant_BACKGROUND_STYLE,
                foregroundStyle: FOREGROUND_STYLE,
                handlerStyle: HANDLER_STYLE,
                textStyle: TEXT_STYLE,
            } });
    };
    Slider.prototype.update = function (cfg) {
        var start = cfg.start, end = cfg.end;
        var validCfg = (0,tslib_es6/* __assign */.pi)({}, cfg);
        if (!(0,esm/* isNil */.UM)(start)) {
            validCfg.start = (0,esm/* clamp */.uZ)(start, 0, 1);
        }
        if (!(0,esm/* isNil */.UM)(end)) {
            validCfg.end = (0,esm/* clamp */.uZ)(end, 0, 1);
        }
        _super.prototype.update.call(this, validCfg);
        this.minHandler = this.getChildComponentById(this.getElementId('minHandler'));
        this.maxHandler = this.getChildComponentById(this.getElementId('maxHandler'));
        this.trend = this.getChildComponentById(this.getElementId('trend'));
    };
    Slider.prototype.init = function () {
        this.set('start', (0,esm/* clamp */.uZ)(this.get('start'), 0, 1));
        this.set('end', (0,esm/* clamp */.uZ)(this.get('end'), 0, 1));
        _super.prototype.init.call(this);
    };
    Slider.prototype.render = function () {
        _super.prototype.render.call(this);
        this.updateUI(this.getElementByLocalId('foreground'), this.getElementByLocalId('minText'), this.getElementByLocalId('maxText'));
    };
    Slider.prototype.renderInner = function (group) {
        var _a = this.cfg, start = _a.start, end = _a.end, width = _a.width, height = _a.height, _b = _a.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a.minText, maxText = _a.maxText, _c = _a.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a.textStyle, textStyle = _e === void 0 ? {} : _e;
        var handlerStyle = (0,esm/* deepMix */.b$)({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
        var min = start * width;
        var max = end * width;
        // \u8D8B\u52BF\u56FE\u6570\u636E
        if ((0,esm/* size */.dp)((0,esm/* get */.U2)(trendCfg, 'data'))) {
            this.trend = this.addComponent(group, (0,tslib_es6/* __assign */.pi)({ component: Trend, id: this.getElementId('trend'), x: 0, y: 0, width: width,
                height: height }, trendCfg));
        }
        // 1. \u80CC\u666F
        this.addShape(group, {
            id: this.getElementId('background'),
            type: 'rect',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: 0, y: 0, width: width,
                height: height }, backgroundStyle),
        });
        // 2. \u5DE6\u53F3\u6587\u5B57
        var minTextShape = this.addShape(group, {
            id: this.getElementId('minText'),
            type: 'text',
            attrs: (0,tslib_es6/* __assign */.pi)({ 
                // x: 0,
                y: height / 2, textAlign: 'right', text: minText, silent: false }, textStyle),
        });
        var maxTextShape = this.addShape(group, {
            id: this.getElementId('maxText'),
            type: 'text',
            attrs: (0,tslib_es6/* __assign */.pi)({ 
                // x: 0,
                y: height / 2, textAlign: 'left', text: maxText, silent: false }, textStyle),
        });
        // 3. \u524D\u666F \u9009\u4E2D\u80CC\u666F\u6846
        var foregroundShape = this.addShape(group, {
            id: this.getElementId('foreground'),
            name: 'foreground',
            type: 'rect',
            attrs: (0,tslib_es6/* __assign */.pi)({ 
                // x: 0,
                y: 0, 
                // width: 0,
                height: height }, foregroundStyle),
        });
        // \u6ED1\u5757\u76F8\u5173\u7684\u5927\u5C0F\u4FE1\u606F
        var handlerWidth = (0,esm/* get */.U2)(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);
        var handlerHeight = (0,esm/* get */.U2)(handlerStyle, 'height', 24);
        // 4. \u5DE6\u53F3\u6ED1\u5757
        this.minHandler = this.addComponent(group, {
            component: Handler,
            id: this.getElementId('minHandler'),
            name: 'handler-min',
            x: 0,
            y: (height - handlerHeight) / 2,
            width: handlerWidth,
            height: handlerHeight,
            cursor: 'ew-resize',
            style: handlerStyle,
        });
        this.maxHandler = this.addComponent(group, {
            component: Handler,
            id: this.getElementId('maxHandler'),
            name: 'handler-max',
            x: 0,
            y: (height - handlerHeight) / 2,
            width: handlerWidth,
            height: handlerHeight,
            cursor: 'ew-resize',
            style: handlerStyle,
        });
    };
    Slider.prototype.applyOffset = function () {
        this.moveElementTo(this.get('group'), {
            x: this.get('x'),
            y: this.get('y'),
        });
    };
    Slider.prototype.initEvent = function () {
        this.bindEvents();
    };
    Slider.prototype.updateUI = function (foregroundShape, minTextShape, maxTextShape) {
        var _a = this.cfg, start = _a.start, end = _a.end, width = _a.width, minText = _a.minText, maxText = _a.maxText, handlerStyle = _a.handlerStyle, height = _a.height;
        var min = start * width;
        var max = end * width;
        if (this.trend) {
            this.trend.update({
                width: width,
                height: height,
            });
            if (!this.get('updateAutoRender')) {
                this.trend.render();
            }
        }
        // 1. foreground
        foregroundShape.attr('x', min);
        foregroundShape.attr('width', max - min);
        // \u6ED1\u5757\u76F8\u5173\u7684\u5927\u5C0F\u4FE1\u606F
        var handlerWidth = (0,esm/* get */.U2)(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);
        // \u8BBE\u7F6E\u6587\u672C
        minTextShape.attr('text', minText);
        maxTextShape.attr('text', maxText);
        var _b = this._dodgeText([min, max], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
        // 2. \u5DE6\u4FA7\u6ED1\u5757\u548C\u6587\u5B57\u4F4D\u7F6E
        if (this.minHandler) {
            this.minHandler.update({
                x: min - handlerWidth / 2,
            });
            if (!this.get('updateAutoRender')) {
                this.minHandler.render();
            }
        }
        (0,esm/* each */.S6)(minAttrs, function (v, k) { return minTextShape.attr(k, v); });
        // 3. \u53F3\u4FA7\u6ED1\u5757\u548C\u6587\u5B57\u4F4D\u7F6E
        if (this.maxHandler) {
            this.maxHandler.update({
                x: max - handlerWidth / 2,
            });
            if (!this.get('updateAutoRender')) {
                this.maxHandler.render();
            }
        }
        (0,esm/* each */.S6)(maxAttrs, function (v, k) { return maxTextShape.attr(k, v); });
    };
    Slider.prototype.bindEvents = function () {
        var group = this.get('group');
        group.on('handler-min:mousedown', this.onMouseDown('minHandler'));
        group.on('handler-min:touchstart', this.onMouseDown('minHandler'));
        // 2. \u53F3\u6ED1\u5757\u7684\u6ED1\u52A8
        group.on('handler-max:mousedown', this.onMouseDown('maxHandler'));
        group.on('handler-max:touchstart', this.onMouseDown('maxHandler'));
        // 3. \u524D\u666F\u9009\u4E2D\u533A\u57DF
        var foreground = group.findById(this.getElementId('foreground'));
        foreground.on('mousedown', this.onMouseDown('foreground'));
        foreground.on('touchstart', this.onMouseDown('foreground'));
    };
    /**
     * \u8C03\u6574 offsetRange\uFF0C\u56E0\u4E3A\u4E00\u4E9B\u8303\u56F4\u7684\u9650\u5236
     * @param offsetRange
     */
    Slider.prototype.adjustOffsetRange = function (offsetRange) {
        var _a = this.cfg, start = _a.start, end = _a.end;
        // \u9488\u5BF9\u4E0D\u540C\u7684\u6ED1\u52A8\u7EC4\u4EF6\uFF0C\u5904\u7406\u7684\u65B9\u5F0F\u4E0D\u540C
        switch (this.currentTarget) {
            case 'minHandler': {
                var min = 0 - start;
                var max = 1 - start;
                return Math.min(max, Math.max(min, offsetRange));
            }
            case 'maxHandler': {
                var min = 0 - end;
                var max = 1 - end;
                return Math.min(max, Math.max(min, offsetRange));
            }
            case 'foreground': {
                var min = 0 - start;
                var max = 1 - end;
                return Math.min(max, Math.max(min, offsetRange));
            }
        }
    };
    Slider.prototype.updateStartEnd = function (offsetRange) {
        var _a = this.cfg, start = _a.start, end = _a.end;
        // \u64CD\u4F5C\u4E0D\u540C\u7684\u7EC4\u4EF6\uFF0C\u53CD\u9988\u4E0D\u4E00\u6837
        switch (this.currentTarget) {
            case 'minHandler':
                start += offsetRange;
                break;
            case 'maxHandler':
                end += offsetRange;
                break;
            case 'foreground':
                start += offsetRange;
                end += offsetRange;
                break;
        }
        this.set('start', start);
        this.set('end', end);
    };
    /**
     * \u8C03\u6574 text \u7684\u4F4D\u7F6E\uFF0C\u81EA\u52A8\u8EB2\u907F
     * \u6839\u636E\u4F4D\u7F6E\uFF0C\u8C03\u6574\u8FD4\u56DE\u65B0\u7684\u4F4D\u7F6E
     * @param range
     */
    Slider.prototype._dodgeText = function (range, minTextShape, maxTextShape) {
        var _a, _b;
        var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
        var PADDING = 2;
        var handlerWidth = (0,esm/* get */.U2)(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);
        var min = range[0], max = range[1];
        var sorted = false;
        // \u5982\u679C\u4EA4\u6362\u4E86\u4F4D\u7F6E\uFF0C\u5219\u5BF9\u5E94\u7684 min max \u4E5F\u4EA4\u4E92
        if (min > max) {
            _a = [max, min], min = _a[0], max = _a[1];
            _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
            sorted = true;
        }
        // \u907F\u8BA9\u89C4\u5219\uFF0C\u4F18\u5148\u663E\u793A\u5728\u4E24\u4FA7\uFF0C\u53EA\u6709\u663E\u793A\u4E0D\u4E0B\u7684\u65F6\u5019\uFF0C\u624D\u663E\u793A\u5728\u4E2D\u95F4
        var minBBox = minTextShape.getBBox();
        var maxBBox = maxTextShape.getBBox();
        var minAttrs = minBBox.width > min - PADDING
            ? { x: min + handlerWidth / 2 + PADDING, textAlign: 'left' }
            : { x: min - handlerWidth / 2 - PADDING, textAlign: 'right' };
        var maxAttrs = maxBBox.width > width - max - PADDING
            ? { x: max - handlerWidth / 2 - PADDING, textAlign: 'right' }
            : { x: max + handlerWidth / 2 + PADDING, textAlign: 'left' };
        return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    Slider.prototype.draw = function () {
        var container = this.get('container');
        var canvas = container && container.get('canvas');
        if (canvas) {
            canvas.draw();
        }
    };
    Slider.prototype.getContainerDOM = function () {
        var container = this.get('container');
        var canvas = container && container.get('canvas');
        return canvas && canvas.get('container');
    };
    return Slider;
}(group_component));

/* harmony default export */ var slider = ((/* unused pure expression or super */ null && (slider_Slider)));
//# sourceMappingURL=slider.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/slider/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
    if (target) {
        if (typeof target.addEventListener === 'function') {
            target.addEventListener(eventType, callback, false);
            return {
                remove: function () {
                    target.removeEventListener(eventType, callback, false);
                },
            };
            // @ts-ignore
        }
        if (typeof target.attachEvent === 'function') {
            // @ts-ignore
            target.attachEvent('on' + eventType, callback);
            return {
                remove: function () {
                    // @ts-ignore
                    target.detachEvent('on' + eventType, callback);
                },
            };
        }
    }
}
//# sourceMappingURL=add-event-listener.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/scrollbar/scrollbar.js




var DEFAULT_STYLE = {
    trackColor: 'rgba(0,0,0,0)',
    thumbColor: 'rgba(0,0,0,0.15)',
    size: 8,
    lineCap: 'round',
};
var DEFAULT_THEME = {
    // \u9ED8\u8BA4\u6837\u5F0F
    default: DEFAULT_STYLE,
    // \u9F20\u6807 hover \u7684\u6837\u5F0F
    hover: {
        thumbColor: 'rgba(0,0,0,0.2)',
    },
};
var scrollbar_Scrollbar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Scrollbar, _super);
    function Scrollbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.clearEvents = esm/* noop */.ZT;
        _this.onStartEvent = function (isMobile) { return function (e) {
            _this.isMobile = isMobile;
            e.originalEvent.preventDefault();
            var clientX = isMobile ? (0,esm/* get */.U2)(e.originalEvent, 'touches.0.clientX') : e.clientX;
            var clientY = isMobile ? (0,esm/* get */.U2)(e.originalEvent, 'touches.0.clientY') : e.clientY;
            // \u5C06\u5F00\u59CB\u7684\u70B9\u8BB0\u5F55\u4E0B\u6765
            _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
            _this.bindLaterEvent();
        }; };
        _this.bindLaterEvent = function () {
            var containerDOM = _this.getContainerDOM();
            var events = [];
            if (_this.isMobile) {
                events = [
                    addEventListener(containerDOM, 'touchmove', _this.onMouseMove),
                    addEventListener(containerDOM, 'touchend', _this.onMouseUp),
                    addEventListener(containerDOM, 'touchcancel', _this.onMouseUp),
                ];
            }
            else {
                events = [
                    addEventListener(containerDOM, 'mousemove', _this.onMouseMove),
                    addEventListener(containerDOM, 'mouseup', _this.onMouseUp),
                    // \u4E3A\u4E86\u4FDD\u8BC1\u5212\u51FA canvas containerDom \u65F6\u8FD8\u6CA1\u89E6\u53D1 mouseup
                    addEventListener(containerDOM, 'mouseleave', _this.onMouseUp),
                ];
            }
            _this.clearEvents = function () {
                events.forEach(function (e) {
                    e.remove();
                });
            };
        };
        // \u62D6\u62FD\u6ED1\u5757\u7684\u4E8B\u4EF6\u56DE\u8C03
        // \u8FD9\u91CC\u662F dom \u539F\u751F\u4E8B\u4EF6\uFF0C\u7ED1\u5B9A\u5728 dom \u5143\u7D20\u4E0A\u7684
        _this.onMouseMove = function (e) {
            var _a = _this.cfg, isHorizontal = _a.isHorizontal, thumbOffset = _a.thumbOffset;
            e.preventDefault();
            var clientX = _this.isMobile ? (0,esm/* get */.U2)(e, 'touches.0.clientX') : e.clientX;
            var clientY = _this.isMobile ? (0,esm/* get */.U2)(e, 'touches.0.clientY') : e.clientY;
            // \u9F20\u6807\u677E\u5F00\u7684\u4F4D\u7F6E
            var endPos = isHorizontal ? clientX : clientY;
            // \u6ED1\u5757\u9700\u8981\u79FB\u52A8\u7684\u8DDD\u79BB, \u7531\u4E8E\u8FD9\u91CC\u662F\u5BF9\u6ED1\u5757\u76D1\u542C\uFF0C\u6240\u4EE5\u79FB\u52A8\u7684\u8DDD\u79BB\u5C31\u662F diffDis, \u5982\u679C\u76D1\u542C\u5BF9\u8C61\u662F container dom\uFF0C\u5219\u9700\u8981\u7B97\u6BD4\u4F8B
            var diff = endPos - _this.startPos;
            // \u66F4\u65B0 _startPos
            _this.startPos = endPos;
            _this.updateThumbOffset(thumbOffset + diff);
        };
        _this.onMouseUp = function (e) {
            e.preventDefault();
            _this.clearEvents();
        };
        // \u70B9\u51FB\u6ED1\u9053\u7684\u4E8B\u4EF6\u56DE\u8C03,\u79FB\u52A8\u6ED1\u5757\u4F4D\u7F6E
        _this.onTrackClick = function (e) {
            var _a = _this.cfg, isHorizontal = _a.isHorizontal, x = _a.x, y = _a.y, thumbLen = _a.thumbLen;
            var containerDOM = _this.getContainerDOM();
            var rect = containerDOM.getBoundingClientRect();
            var clientX = e.clientX, clientY = e.clientY;
            var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;
            var newOffset = _this.validateRange(offset);
            _this.updateThumbOffset(newOffset);
        };
        _this.onThumbMouseOver = function () {
            var thumbColor = _this.cfg.theme.hover.thumbColor;
            _this.getElementByLocalId('thumb').attr('stroke', thumbColor);
            _this.draw();
        };
        _this.onThumbMouseOut = function () {
            var thumbColor = _this.cfg.theme.default.thumbColor;
            _this.getElementByLocalId('thumb').attr('stroke', thumbColor);
            _this.draw();
        };
        return _this;
    }
    Scrollbar.prototype.setRange = function (min, max) {
        this.set('minLimit', min);
        this.set('maxLimit', max);
        var curValue = this.getValue();
        var newValue = (0,esm/* clamp */.uZ)(curValue, min, max);
        if (curValue !== newValue && !this.get('isInit')) {
            this.setValue(newValue);
        }
    };
    Scrollbar.prototype.getRange = function () {
        var min = this.get('minLimit') || 0;
        var max = this.get('maxLimit') || 1;
        return { min: min, max: max };
    };
    Scrollbar.prototype.setValue = function (value) {
        var range = this.getRange();
        var originalValue = this.getValue();
        this.update({
            thumbOffset: (this.get('trackLen') - this.get('thumbLen')) * (0,esm/* clamp */.uZ)(value, range.min, range.max),
        });
        this.delegateEmit('valuechange', {
            originalValue: originalValue,
            value: this.getValue(),
        });
    };
    Scrollbar.prototype.getValue = function () {
        return (0,esm/* clamp */.uZ)(this.get('thumbOffset') / (this.get('trackLen') - this.get('thumbLen')), 0, 1);
    };
    Scrollbar.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { name: 'scrollbar', isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
    };
    Scrollbar.prototype.renderInner = function (group) {
        this.renderTrackShape(group);
        this.renderThumbShape(group);
    };
    Scrollbar.prototype.applyOffset = function () {
        this.moveElementTo(this.get('group'), {
            x: this.get('x'),
            y: this.get('y'),
        });
    };
    Scrollbar.prototype.initEvent = function () {
        this.bindEvents();
    };
    // \u521B\u5EFA\u6ED1\u9053\u7684 shape
    Scrollbar.prototype.renderTrackShape = function (group) {
        var _a = this.cfg, trackLen = _a.trackLen, _b = _a.theme, theme = _b === void 0 ? { default: {} } : _b;
        var _c = (0,esm/* deepMix */.b$)({}, DEFAULT_THEME, theme).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
        var size = (0,esm/* get */.U2)(this.cfg, 'size', themeSize);
        var attrs = this.get('isHorizontal')
            ? {
                x1: 0 + size / 2,
                y1: size / 2,
                x2: trackLen - size / 2,
                y2: size / 2,
                lineWidth: size,
                stroke: trackColor,
                lineCap: lineCap,
            }
            : {
                x1: size / 2,
                y1: 0 + size / 2,
                x2: size / 2,
                y2: trackLen - size / 2,
                lineWidth: size,
                stroke: trackColor,
                lineCap: lineCap,
            };
        return this.addShape(group, {
            id: this.getElementId('track'),
            name: 'track',
            type: 'line',
            attrs: attrs,
        });
    };
    // \u521B\u5EFA\u6ED1\u5757\u7684 shape
    Scrollbar.prototype.renderThumbShape = function (group) {
        var _a = this.cfg, thumbOffset = _a.thumbOffset, thumbLen = _a.thumbLen, theme = _a.theme;
        var _b = (0,esm/* deepMix */.b$)({}, DEFAULT_THEME, theme).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
        var size = (0,esm/* get */.U2)(this.cfg, 'size', themeSize);
        var attrs = this.get('isHorizontal')
            ? {
                x1: thumbOffset + size / 2,
                y1: size / 2,
                x2: thumbOffset + thumbLen - size / 2,
                y2: size / 2,
                lineWidth: size,
                stroke: thumbColor,
                lineCap: lineCap,
                cursor: 'default',
            }
            : {
                x1: size / 2,
                y1: thumbOffset + size / 2,
                x2: size / 2,
                y2: thumbOffset + thumbLen - size / 2,
                lineWidth: size,
                stroke: thumbColor,
                lineCap: lineCap,
                cursor: 'default',
            };
        return this.addShape(group, {
            id: this.getElementId('thumb'),
            name: 'thumb',
            type: 'line',
            attrs: attrs,
        });
    };
    Scrollbar.prototype.bindEvents = function () {
        var group = this.get('group');
        group.on('mousedown', this.onStartEvent(false));
        group.on('mouseup', this.onMouseUp);
        group.on('touchstart', this.onStartEvent(true));
        group.on('touchend', this.onMouseUp);
        var trackShape = group.findById(this.getElementId('track'));
        trackShape.on('click', this.onTrackClick);
        var thumbShape = group.findById(this.getElementId('thumb'));
        thumbShape.on('mouseover', this.onThumbMouseOver);
        thumbShape.on('mouseout', this.onThumbMouseOut);
    };
    Scrollbar.prototype.getContainerDOM = function () {
        var container = this.get('container');
        var canvas = container && container.get('canvas');
        return canvas && canvas.get('container');
    };
    Scrollbar.prototype.validateRange = function (offset) {
        var _a = this.cfg, thumbLen = _a.thumbLen, trackLen = _a.trackLen;
        var newOffset = offset;
        if (offset + thumbLen > trackLen) {
            newOffset = trackLen - thumbLen;
        }
        else if (offset + thumbLen < thumbLen) {
            newOffset = 0;
        }
        return newOffset;
    };
    Scrollbar.prototype.draw = function () {
        var container = this.get('container');
        var canvas = container && container.get('canvas');
        if (canvas) {
            canvas.draw();
        }
    };
    Scrollbar.prototype.updateThumbOffset = function (offset) {
        var _a = this.cfg, thumbOffset = _a.thumbOffset, isHorizontal = _a.isHorizontal, thumbLen = _a.thumbLen, size = _a.size;
        var newOffset = this.validateRange(offset);
        if (newOffset === thumbOffset) {
            // \u5982\u679C\u66F4\u65B0\u540E\u7684 offset \u4E0E\u539F\u503C\u76F8\u540C\uFF0C\u5219\u4E0D\u6539\u53D8
            return;
        }
        var thumbShape = this.getElementByLocalId('thumb');
        if (isHorizontal) {
            thumbShape.attr({
                x1: newOffset + size / 2,
                x2: newOffset + thumbLen - size / 2,
            });
        }
        else {
            thumbShape.attr({
                y1: newOffset + size / 2,
                y2: newOffset + thumbLen - size / 2,
            });
        }
        this.emitOffsetChange(newOffset);
    };
    Scrollbar.prototype.emitOffsetChange = function (offset) {
        var _a = this.cfg, originalValue = _a.thumbOffset, trackLen = _a.trackLen, thumbLen = _a.thumbLen;
        this.cfg.thumbOffset = offset;
        // \u53D1\u9001\u4E8B\u4EF6
        this.emit('scrollchange', {
            thumbOffset: offset,
            ratio: (0,esm/* clamp */.uZ)(offset / (trackLen - thumbLen), 0, 1),
        });
        this.delegateEmit('valuechange', {
            originalValue: originalValue,
            value: offset,
        });
    };
    return Scrollbar;
}(group_component));

//# sourceMappingURL=scrollbar.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/scrollbar/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/component/esm/index.js

















//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/dependents.js
/* \u4F9D\u8D56\u7684\u6A21\u5757\uFF0C\u5728\u8FD9\u91CC\u7EDF\u4E00\u5F15\u5165\uFF0C\u65B9\u4FBF\u6253\u5305\u4F18\u5316 */
// G

// adjust

// attr


// coordinate

// scale

// component



// axis
var LineAxis = axis_line, CircleAxis = circle;

// grid
var LineGrid = grid_line, CircleGrid = grid_circle;

// legend
var CategoryLegend = category, ContinuousLegend = continuous;

// Tooltip
var HtmlTooltip = tooltip_html;

// Slider

// Scrollbar

//# sourceMappingURL=dependents.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/graphics.js

// \u83B7\u53D6\u56FE\u5F62\u7684\u5305\u56F4\u76D2
function getPointsBox(points) {
    if ((0,esm/* isEmpty */.xb)(points)) {
        return null;
    }
    var minX = points[0].x;
    var maxX = points[0].x;
    var minY = points[0].y;
    var maxY = points[0].y;
    (0,esm/* each */.S6)(points, function (point) {
        minX = minX > point.x ? point.x : minX;
        maxX = maxX < point.x ? point.x : maxX;
        minY = minY > point.y ? point.y : minY;
        maxY = maxY < point.y ? point.y : maxY;
    });
    return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2,
    };
}
function uniqueValues(array) {
    return Array.from(new Set(array)).length === 1;
}
function mid(array) {
    return ((0,esm/* min */.VV)(array) + (0,esm/* max */.Fp)(array)) / 2;
}
/**
 * @ignore
 * \u6839\u636E\u5F27\u5EA6\u8BA1\u7B97\u6781\u5750\u6807\u7CFB\u4E0B\u7684\u5750\u6807\u70B9
 * @param centerX
 * @param centerY
 * @param radius
 * @param angleInRadian
 * @returns
 */
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
    return {
        x: centerX + radius * Math.cos(angleInRadian),
        y: centerY + radius * Math.sin(angleInRadian),
    };
}
/**
 * @ignore
 * \u6839\u636E\u8D77\u59CB\u89D2\u5EA6\u8BA1\u7B97\u7ED8\u5236\u6247\u5F62\u7684 path
 * @param centerX
 * @param centerY
 * @param radius
 * @param startAngleInRadian
 * @param endAngleInRadian
 * @returns
 */
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
    if (innerRadius === void 0) { innerRadius = 0; }
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
        // \u6574\u4E2A\u5706\u662F\u5206\u5272\u6210\u4E24\u4E2A\u5706
        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
        var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
        var circlePathCommands = [
            ['M', start.x, start.y],
            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
            ['A', radius, radius, 0, 1, 1, end.x, end.y],
            ['M', innerStart.x, innerStart.y],
        ];
        if (innerRadius) {
            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
        }
        circlePathCommands.push(['M', start.x, start.y]);
        circlePathCommands.push(['Z']);
        return circlePathCommands;
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    var sectorPathCommands = [
        ['M', start.x, start.y],
        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],
        ['L', innerEnd.x, innerEnd.y],
    ];
    if (innerRadius) {
        sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
    }
    sectorPathCommands.push(['L', start.x, start.y]);
    sectorPathCommands.push(['Z']);
    return sectorPathCommands;
}
/**
 * @ignore
 * Gets arc path
 * @param centerX
 * @param centerY
 * @param radius
 * @param startAngleInRadian
 * @param endAngleInRadian
 * @returns
 */
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    if ((0,esm/* isNumberEqual */.vQ)(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
        return [
            ['M', start.x, start.y],
            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
            ['A', radius, radius, 0, 1, 1, start.x, start.y],
            ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
            ['A', radius, radius, 0, 1, 0, start.x, start.y],
            ['Z'],
        ];
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    return [
        ['M', start.x, start.y],
        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],
    ];
}
/**
 * @ignore
 * \u4ECE\u6570\u636E\u6A21\u578B\u4E2D\u7684 points \u6362\u7B97\u89D2\u5EA6
 * @param shapeModel
 * @param coordinate
 * @returns
 */
function getAngle(shapeModel, coordinate) {
    var points = shapeModel.points;
    var box = getPointsBox(points);
    var endAngle;
    var startAngle;
    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;
    var diffAngle = coordEndAngle - coordStartAngle;
    if (coordinate.isTransposed) {
        endAngle = box.maxY * diffAngle;
        startAngle = box.minY * diffAngle;
    }
    else {
        endAngle = box.maxX * diffAngle;
        startAngle = box.minX * diffAngle;
    }
    endAngle += coordStartAngle;
    startAngle += coordStartAngle;
    return {
        startAngle: startAngle,
        endAngle: endAngle,
    };
}
/**
 * @ignore
 * \u8BA1\u7B97\u591A\u8FB9\u5F62\u91CD\u5FC3: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon
 */
function getPolygonCentroid(xs, ys) {
    if ((0,esm/* isNumber */.hj)(xs) && (0,esm/* isNumber */.hj)(ys)) {
        // \u666E\u901A\u8272\u5757\u56FE\uFF0Cxs \u548C ys \u662F\u6570\u503C
        return [xs, ys];
    }
    xs = xs;
    ys = ys;
    // \u5F53\u8FD9\u4E2A polygon \u7684\u70B9\u5728\u4E00\u6761\u7EBF\u4E0A\u7684\u65F6\u5019
    // \u4E5F\u5C31\u662F\u8BF4 xs \u91CC\u9762\u7684\u503C\u90FD\u76F8\u540C\uFF0C\u6BD4\u5982\uFF1A[1, 1, 1, 1]
    // \u6216\u8005\u8BF4 ys \u91CC\u9762\u7684\u503C\u90FD\u76F8\u540C\uFF0C\u6BD4\u5982\uFF1A[0, 0, 0, 0]
    // \u4E0B\u9762\u8BA1\u7B97\u5F97\u5230\u7684 k = 0
    // \u5BFC\u81F4\u8FD4\u56DE\u7684\u503C\u662F [NaN, NaN]
    // \u6240\u4EE5\u8FD9\u91CC\u505A\u76F8\u5E94\u7684\u5904\u7406
    if (uniqueValues(xs) || uniqueValues(ys))
        return [mid(xs), mid(ys)];
    var i = -1;
    var x = 0;
    var y = 0;
    var former;
    var current = xs.length - 1;
    var diff;
    var k = 0;
    while (++i < xs.length) {
        former = current;
        current = i;
        k += diff = xs[former] * ys[current] - xs[current] * ys[former];
        x += (xs[former] + xs[current]) * diff;
        y += (ys[former] + ys[current]) * diff;
    }
    k *= 3;
    return [x / k, y / k];
}
/**
 * @ignore
 * \u83B7\u53D6\u9700\u8981\u66FF\u6362\u7684\u5C5E\u6027\uFF0C\u5982\u679C\u539F\u5148\u56FE\u5F62\u5143\u7D20\u5B58\u5728\uFF0C\u800C\u65B0\u56FE\u5F62\u4E0D\u5B58\u5728\uFF0C\u5219\u8BBE\u7F6E undefined
 */
function getReplaceAttrs(sourceShape, targetShape) {
    var originAttrs = sourceShape.attr();
    var newAttrs = targetShape.attr();
    (0,esm/* each */.S6)(originAttrs, function (v, k) {
        if (newAttrs[k] === undefined) {
            newAttrs[k] = undefined;
        }
    });
    return newAttrs;
}
//# sourceMappingURL=graphics.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/helper.js


/**
 * @ignore
 * Determines whether between is
 * @param value
 * @param start
 * @param end
 * @returns true if between
 */
function isBetween(value, start, end) {
    var min = Math.min(start, end);
    var max = Math.max(start, end);
    return value >= min && value <= max;
}
/**
 * @ignore
 * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.
 * The padding is applied from the end of the current value.
 *
 * @param source
 * @param targetLength
 * @param padValue
 * @returns
 */
function padEnd(source, targetLength, padValue) {
    if ((0,esm/* isString */.HD)(source)) {
        return source.padEnd(targetLength, padValue);
    }
    else if ((0,esm/* isArray */.kJ)(source)) {
        var sourceLength = source.length;
        if (sourceLength < targetLength) {
            var diff = targetLength - sourceLength;
            for (var i = 0; i < diff; i++) {
                source.push(padValue);
            }
        }
    }
    return source;
}
/**
 * @ignore
 * omit keys of an object.
 * @param obj
 * @param keys
 */
function omit(obj, keys) {
    if (typeof obj === 'object') {
        keys.forEach(function (key) {
            delete obj[key];
        });
    }
    return obj;
}
/**
 * @ignore
 * @param sourceArray
 * @param targetArray
 * @param map
 */
function uniq(sourceArray, targetArray, map) {
    var e_1, _a;
    if (targetArray === void 0) { targetArray = []; }
    if (map === void 0) { map = new Map(); }
    try {
        for (var sourceArray_1 = (0,tslib_es6/* __values */.XA)(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
            var source = sourceArray_1_1.value;
            if (!map.has(source)) {
                targetArray.push(source);
                map.set(source, true);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return targetArray;
}
//# sourceMappingURL=helper.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/bbox.js



/**
 * \u7528\u4E8E\u5305\u56F4\u76D2\u8BA1\u7B97\u3002
 */
var BBox = /** @class */ (function () {
    function BBox(x, y, width, height) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        this.x = x;
        this.y = y;
        this.height = height;
        this.width = width;
    }
    BBox.fromRange = function (minX, minY, maxX, maxY) {
        return new BBox(minX, minY, maxX - minX, maxY - minY);
    };
    BBox.fromObject = function (bbox) {
        return new BBox(bbox.minX, bbox.minY, bbox.width, bbox.height);
    };
    Object.defineProperty(BBox.prototype, "minX", {
        get: function () {
            return this.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "maxX", {
        get: function () {
            return this.x + this.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "minY", {
        get: function () {
            return this.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "maxY", {
        get: function () {
            return this.y + this.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "tl", {
        get: function () {
            return { x: this.x, y: this.y };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "tr", {
        get: function () {
            return { x: this.maxX, y: this.y };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "bl", {
        get: function () {
            return { x: this.x, y: this.maxY };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "br", {
        get: function () {
            return { x: this.maxX, y: this.maxY };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "top", {
        get: function () {
            return {
                x: this.x + this.width / 2,
                y: this.minY,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "right", {
        get: function () {
            return {
                x: this.maxX,
                y: this.y + this.height / 2,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "bottom", {
        get: function () {
            return {
                x: this.x + this.width / 2,
                y: this.maxY,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BBox.prototype, "left", {
        get: function () {
            return {
                x: this.minX,
                y: this.y + this.height / 2,
            };
        },
        enumerable: false,
        configurable: true
    });
    // end \u8BA1\u7B97\u5C5E\u6027
    /**
     * \u5305\u56F4\u76D2\u662F\u5426\u76F8\u7B49
     * @param {BBox} bbox \u5305\u56F4\u76D2
     * @returns      \u5305\u56F4\u76D2\u662F\u5426\u76F8\u7B49
     */
    BBox.prototype.isEqual = function (bbox) {
        return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
    };
    /**
     * \u662F\u5426\u5305\u542B\u4E86\u53E6\u4E00\u4E2A\u5305\u56F4\u76D2
     * @param child
     */
    BBox.prototype.contains = function (child) {
        return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
    };
    /**
     * \u514B\u9686\u5305\u56F4\u76D2
     * @returns \u5305\u56F4\u76D2
     */
    BBox.prototype.clone = function () {
        return new BBox(this.x, this.y, this.width, this.height);
    };
    /**
     * \u53D6\u5E76\u96C6
     * @param subBBox
     */
    BBox.prototype.add = function () {
        var subBBox = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            subBBox[_i] = arguments[_i];
        }
        var bbox = this.clone();
        (0,esm/* each */.S6)(subBBox, function (b) {
            bbox.x = Math.min(b.x, bbox.x);
            bbox.y = Math.min(b.y, bbox.y);
            bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
            bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
        });
        return bbox;
    };
    /**
     * \u53D6\u4EA4\u96C6
     * @param subBBox
     */
    BBox.prototype.merge = function () {
        var subBBox = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            subBBox[_i] = arguments[_i];
        }
        var bbox = this.clone();
        (0,esm/* each */.S6)(subBBox, function (b) {
            bbox.x = Math.max(b.x, bbox.x);
            bbox.y = Math.max(b.y, bbox.y);
            bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
            bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
        });
        return bbox;
    };
    /**
     * bbox \u526A\u88C1
     * @param subBBox
     * @param direction
     */
    BBox.prototype.cut = function (subBBox, direction) {
        var width = subBBox.width;
        var height = subBBox.height;
        switch (direction) {
            case constant_DIRECTION.TOP:
            case constant_DIRECTION.TOP_LEFT:
            case constant_DIRECTION.TOP_RIGHT:
                return BBox.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
            case constant_DIRECTION.RIGHT:
            case constant_DIRECTION.RIGHT_TOP:
            case constant_DIRECTION.RIGHT_BOTTOM:
                return BBox.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
            case constant_DIRECTION.BOTTOM:
            case constant_DIRECTION.BOTTOM_LEFT:
            case constant_DIRECTION.BOTTOM_RIGHT:
                return BBox.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
            case constant_DIRECTION.LEFT:
            case constant_DIRECTION.LEFT_TOP:
            case constant_DIRECTION.LEFT_BOTTOM:
                return BBox.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
            default:
                // \u5176\u4ED6\u60C5\u51B5\u4E0D\u88C1\u526A\uFF0C\u539F\u6837\u8FD4\u56DE
                return this;
        }
    };
    /**
     * \u6536\u7F29\u5F62\u6210\u65B0\u7684
     * @param gap
     */
    BBox.prototype.shrink = function (gap) {
        var _a = (0,tslib_es6/* __read */.CR)(gap, 4), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
        return new BBox(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
    };
    /**
     * \u6269\u5F20\u5F62\u6210\u65B0\u7684
     * @param gap
     */
    BBox.prototype.expand = function (gap) {
        var _a = (0,tslib_es6/* __read */.CR)(gap, 4), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
        return new BBox(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
    };
    /**
     * get the gap of two bbox, if not exceed, then 0
     * @param bbox
     * @returns [top, right, bottom, left]
     */
    BBox.prototype.exceed = function (bbox) {
        return [
            Math.max(-this.minY + bbox.minY, 0),
            Math.max(this.maxX - bbox.maxX, 0),
            Math.max(this.maxY - bbox.maxY, 0),
            Math.max(-this.minX + bbox.minX, 0),
        ];
    };
    /**
     * \u662F\u5426\u78B0\u649E
     * @param bbox
     */
    BBox.prototype.collide = function (bbox) {
        return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
    };
    /**
     * \u83B7\u53D6\u5305\u56F4\u76D2\u5927\u5C0F
     * @returns \u5305\u56F4\u76D2\u5927\u5C0F
     */
    BBox.prototype.size = function () {
        return this.width * this.height;
    };
    /**
     * \u70B9\u662F\u5426\u5728 bbox \u4E2D
     * @param p
     */
    BBox.prototype.isPointIn = function (p) {
        return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
    };
    return BBox;
}());

/**
 * \u4ECE\u4E00\u4E2A bbox \u7684 region \u83B7\u53D6 bbox
 * @param bbox
 * @param region
 */
var getRegionBBox = function (bbox, region) {
    var start = region.start, end = region.end;
    return new BBox(bbox.x + bbox.width * start.x, bbox.y + bbox.height * start.y, bbox.width * Math.abs(end.x - start.x), bbox.height * Math.abs(end.y - start.y));
};
/**
 * \u5C06 bbox \u8F6C\u6362\u6210 points
 * @param bbox
 */
function toPoints(bbox) {
    return [
        [bbox.minX, bbox.minY],
        [bbox.maxX, bbox.minY],
        [bbox.maxX, bbox.maxY],
        [bbox.minX, bbox.maxY],
    ];
}
//# sourceMappingURL=bbox.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/coordinate.js



/**
 * @ignore
 * Gets x dimension length
 * @param coordinate
 * @returns x dimension length
 */
function getXDimensionLength(coordinate) {
    if (coordinate.isPolar && !coordinate.isTransposed) {
        // \u6781\u5750\u6807\u7CFB\u4E0B width \u4E3A\u5F27\u957F
        return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
    }
    // \u76F4\u89D2\u5750\u6807\u7CFB
    var start = coordinate.convert({ x: 0, y: 0 });
    var end = coordinate.convert({ x: 1, y: 0 });
    // \u5750\u6807\u7CFB\u6709\u53EF\u80FD\u53D1\u751F transpose \u7B49\u53D8\u6362\uFF0C\u6240\u6709\u901A\u8FC7\u4E24\u70B9\u4E4B\u95F4\u7684\u8DDD\u79BB\u8FDB\u884C\u8BA1\u7B97
    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
/**
 * @ignore
 * Determines whether full circle is
 * @param coordinate
 * @returns true if full circle
 */
function isFullCircle(coordinate) {
    if (coordinate.isPolar) {
        var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;
        return endAngle - startAngle === Math.PI * 2;
    }
    return false;
}
/**
 * @ignore
 * \u83B7\u53D6\u5F53\u524D\u70B9\u5230\u5750\u6807\u7CFB\u5706\u5FC3\u7684\u8DDD\u79BB
 * @param coordinate \u5750\u6807\u7CFB
 * @param point \u5F53\u524D\u70B9
 * @returns distance to center
 */
function getDistanceToCenter(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.sqrt(Math.pow((point.x - center.x), 2) + Math.pow((point.y - center.y), 2));
}
/**
 * @ignore
 * \u5750\u6807\u70B9\u662F\u5426\u5728\u5750\u6807\u7CFB\u4E2D
 * @param coordinate
 * @param point
 */
function isPointInCoordinate(coordinate, point) {
    var result = false;
    if (coordinate) {
        if (coordinate.type === 'theta') {
            var start = coordinate.start, end = coordinate.end;
            result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);
        }
        else {
            var invertPoint = coordinate.invert(point);
            result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);
        }
    }
    return result;
}
/**
 * @ignore
 * \u83B7\u53D6\u70B9\u5230\u5706\u5FC3\u7684\u8FDE\u7EBF\u4E0E\u6C34\u5E73\u65B9\u5411\u7684\u5939\u89D2
 */
function getAngleByPoint(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.atan2(point.y - center.y, point.x - center.x);
}
/**
 * @ignore
 * \u83B7\u53D6\u540C\u5750\u6807\u7CFB\u8303\u56F4\u76F8\u540C\u7684\u526A\u5207\u533A\u57DF
 * @param coordinate
 * @returns
 */
function getCoordinateClipCfg(coordinate, margin) {
    if (margin === void 0) { margin = 0; }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    if (coordinate.isPolar) {
        var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;
        var center_1 = coordinate.getCenter();
        var radius_1 = coordinate.getRadius();
        return {
            type: 'path',
            startState: {
                path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1),
            },
            endState: function (ratio) {
                var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
                var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);
                return {
                    path: path,
                };
            },
            attrs: {
                path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1),
            },
        };
    }
    var endState;
    if (coordinate.isTransposed) {
        endState = {
            height: height + margin * 2,
        };
    }
    else {
        endState = {
            width: width + margin * 2,
        };
    }
    return {
        type: 'rect',
        startState: {
            x: start.x - margin,
            y: end.y - margin,
            width: coordinate.isTransposed ? width + margin * 2 : 0,
            height: coordinate.isTransposed ? 0 : height + margin * 2,
        },
        endState: endState,
        attrs: {
            x: start.x - margin,
            y: end.y - margin,
            width: width + margin * 2,
            height: height + margin * 2,
        },
    };
}
/**
 * \u83B7\u53D6\u5750\u6807\u7CFB\u8303\u56F4\u7684 BBox
 * @param coordinate
 * @param margin
 */
function getCoordinateBBox(coordinate, margin) {
    if (margin === void 0) { margin = 0; }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}
//# sourceMappingURL=coordinate.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/scale.js





var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\\2(?:29))(\\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
/**
 * \u83B7\u53D6\u5B57\u6BB5\u5BF9\u5E94\u6570\u636E\u7684\u7C7B\u578B
 * @param field \u6570\u636E\u5B57\u6BB5\u540D
 * @param data \u6570\u636E\u6E90
 * @returns default type \u8FD4\u56DE\u5BF9\u5E94\u7684\u6570\u636E\u7C7B\u578B
 */
function getDefaultType(value) {
    var type = 'linear';
    if (dateRegex.test(value)) {
        type = 'timeCat';
    }
    else if ((0,esm/* isString */.HD)(value)) {
        type = 'cat';
    }
    return type;
}
/**
 * using the scale type if user specified, otherwise infer the type
 */
function inferScaleType(scale, scaleDef, attrType, geometryType) {
    if (scaleDef === void 0) { scaleDef = {}; }
    if (scaleDef.type)
        return scaleDef.type;
    // identity scale \u76F4\u63A5\u8FD4\u56DE
    // geometry \u7C7B\u578B\u6709: edge,heatmap,interval,line,path,point,polygon,schema,voilin\u7B49\uFF1B\u7406\u8BBA\u4E0A\uFF0Cinterval \u4E0B\uFF0C\u53EF\u4EE5\u7528 linear scale \u4F5C\u4E3A\u5206\u7EC4\u5B57\u6BB5
    if (scale.type !== 'identity' && GROUP_ATTRS.includes(attrType) && ['interval'].includes(geometryType)) {
        return 'cat';
    }
    return scale.isCategory ? 'cat' : scale.type;
}
/**
 * @ignore
 * \u4E3A\u6307\u5B9A\u7684 \`field\` \u5B57\u6BB5\u6570\u636E\u521B\u5EFA scale
 * @param field \u5B57\u6BB5\u540D
 * @param [data] \u6570\u636E\u96C6\uFF0C\u53EF\u4E3A\u7A7A
 * @param [scaleDef] \u5217\u5B9A\u4E49\uFF0C\u53EF\u4E3A\u7A7A
 * @returns scale \u8FD4\u56DE\u521B\u5EFA\u7684 Scale \u5B9E\u4F8B
 */
function createScaleByField(field, data, scaleDef) {
    var validData = data || [];
    if ((0,esm/* isNumber */.hj)(field) || ((0,esm/* isNil */.UM)((0,esm/* firstValue */.Wx)(validData, field)) && (0,esm/* isEmpty */.xb)(scaleDef))) {
        var Identity = getClass('identity');
        return new Identity({
            field: field.toString(),
            values: [field],
        });
    }
    var values = (0,esm/* valuesOfKey */.I)(validData, field);
    // \u5982\u679C\u5DF2\u7ECF\u5B9A\u4E49\u8FC7\u8FD9\u4E2A\u5EA6\u91CF (fix-later \u5355\u7EAF\u4ECE\u6570\u636E\u4E2D\uFF0C\u63A8\u65AD scale type \u662F\u4E0D\u7CBE\u786E\u7684)
    var type = (0,esm/* get */.U2)(scaleDef, 'type', getDefaultType(values[0]));
    var ScaleCtor = getClass(type);
    return new ScaleCtor((0,tslib_es6/* __assign */.pi)({ field: field, values: values }, scaleDef));
}
/**
 * @ignore
 * \u540C\u6B65 scale
 * @todo \u662F\u5426\u53EF\u4EE5\u901A\u8FC7 scale.update() \u65B9\u6CD5\u8FDB\u884C\u66F4\u65B0
 * @param scale \u9700\u8981\u540C\u6B65\u7684 scale \u5B9E\u4F8B
 * @param newScale \u540C\u6B65\u6E90 Scale
 */
function syncScale(scale, newScale) {
    if (scale.type !== 'identity' && newScale.type !== 'identity') {
        var obj = {};
        for (var k in newScale) {
            if (Object.prototype.hasOwnProperty.call(newScale, k)) {
                obj[k] = newScale[k];
            }
        }
        scale.change(obj);
    }
}
/**
 * @ignore
 * get the scale name, if alias exist, return alias, or else field
 * @param scale
 * @returns the name of field
 */
function getName(scale) {
    return scale.alias || scale.field;
}
/**
 * \u6839\u636E scale values \u548C coordinate \u83B7\u53D6\u5206\u7C7B\u9ED8\u8BA4 range
 * @param scale \u9700\u8981\u83B7\u53D6\u7684 scale \u5B9E\u4F8B
 * @param coordinate coordinate \u5B9E\u4F8B
 * @param theme theme
 */
function getDefaultCategoryScaleRange(scale, coordinate, theme) {
    var values = scale.values;
    var count = values.length;
    var range;
    if (count === 1) {
        range = [0.5, 1]; // \u53EA\u6709\u4E00\u4E2A\u5206\u7C7B\u65F6,\u9632\u6B62\u8BA1\u7B97\u51FA\u73B0 [0.5,0.5] \u7684\u72B6\u6001
    }
    else {
        var widthRatio = 1;
        var offset = 0;
        if (isFullCircle(coordinate)) {
            if (!coordinate.isTransposed) {
                range = [0, 1 - 1 / count];
            }
            else {
                widthRatio = (0,esm/* get */.U2)(theme, 'widthRatio.multiplePie', 1 / 1.3);
                offset = (1 / count) * widthRatio;
                range = [offset / 2, 1 - offset / 2];
            }
        }
        else {
            offset = 1 / count / 2; // \u4E24\u8FB9\u7559\u4E0B\u5206\u7C7B\u7A7A\u95F4\u7684\u4E00\u534A
            range = [offset, 1 - offset]; // \u5750\u6807\u8F74\u6700\u524D\u9762\u548C\u6700\u540E\u9762\u7559\u4E0B\u7A7A\u767D\u9632\u6B62\u7ED8\u5236\u67F1\u72B6\u56FE\u65F6
        }
    }
    return range;
}
/**
 * @function y\u8F74scale\u7684max
 * @param {yScale}
 */
function getMaxScale(scale) {
    // \u8FC7\u6EE4values[]\u4E2D NaN/undefined/null \u7B49
    var values = scale.values.filter(function (item) { return !(0,esm/* isNil */.UM)(item) && !isNaN(item); });
    return Math.max.apply(Math, (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(values), false), [(0,esm/* isNil */.UM)(scale.max) ? -Infinity : scale.max], false));
}
//# sourceMappingURL=scale.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/axis.js




/**
 * @ignore
 * get axis relative region ( 0 ~ 1) by direction when coordinate is rect
 * @param direction
 * @returns axis coordinate region
 */
function getLineAxisRelativeRegion(direction) {
    var start;
    var end;
    switch (direction) {
        case constant_DIRECTION.TOP:
            start = { x: 0, y: 1 };
            end = { x: 1, y: 1 };
            break;
        case constant_DIRECTION.RIGHT:
            start = { x: 1, y: 0 };
            end = { x: 1, y: 1 };
            break;
        case constant_DIRECTION.BOTTOM:
            start = { x: 0, y: 0 };
            end = { x: 1, y: 0 };
            break;
        case constant_DIRECTION.LEFT:
            start = { x: 0, y: 0 };
            end = { x: 0, y: 1 };
            break;
        default:
            start = end = { x: 0, y: 0 };
    }
    return { start: start, end: end };
}
/**
 * @ignore
 * get axis relative region ( 0 ~ 1) by direction when coordinate is polar
 * @param coordinate
 * @returns axis coordinate region
 */
function getCircleAxisRelativeRegion(coordinate) {
    var start;
    var end;
    if (coordinate.isTransposed) {
        start = {
            x: 0,
            y: 0,
        };
        end = {
            x: 1,
            y: 0,
        };
    }
    else {
        start = {
            x: 0,
            y: 0,
        };
        end = {
            x: 0,
            y: 1,
        };
    }
    return { start: start, end: end };
}
/**
 * @ignore
 * get the axis region from coordinate
 * @param coordinate
 * @param direction
 * @returns the axis region (start point, end point)
 */
function getAxisRegion(coordinate, direction) {
    var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
    if (coordinate.isRect) {
        region = getLineAxisRelativeRegion(direction);
    }
    else if (coordinate.isPolar) {
        region = getCircleAxisRelativeRegion(coordinate);
    }
    var start = region.start, end = region.end;
    return {
        start: coordinate.convert(start),
        end: coordinate.convert(end),
    };
}
/**
 * @ignore
 * get axis factor
 * @param coordinate
 * @param direction
 * @returns factor
 */
function getAxisFactor(coordinate, direction) {
    // rect coordinate, by direction
    if (coordinate.isRect) {
        return coordinate.isTransposed
            ? [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(direction)
                ? 1
                : -1
            : [DIRECTION.BOTTOM, DIRECTION.RIGHT].includes(direction)
                ? -1
                : 1;
    }
    // polar y axis, by angle
    if (coordinate.isPolar) {
        var startAngle = coordinate.x.start;
        return startAngle < 0 ? -1 : 1;
    }
    return 1;
}
/**
 * @ignore
 * whether the axis isVertical
 * @param region
 * @returns isVertical
 */
function isVertical(region) {
    var start = region.start, end = region.end;
    return start.x === end.x;
}
/**
 * @ignore
 * get factor by region (real position)
 * @param region
 * @param center
 * @returns factor
 */
function getAxisFactorByRegion(region, center) {
    var start = region.start, end = region.end;
    var isAxisVertical = isVertical(region);
    // \u5782\u76F4
    if (isAxisVertical) {
        // \u5DE6\u65B9,\u4ECE\u4E0B\u5230\u4E0A\u3001\u53F3\u65B9,\u4ECE\u4E0A\u5230\u4E0B
        if ((start.y - end.y) * (center.x - start.x) > 0) {
            return 1;
        }
        else {
            return -1;
        }
    }
    else {
        // \u4E0B\u65B9,\u4ECE\u5DE6\u5230\u53F3\u3001\u4E0A\u65B9,\u4ECE\u53F3\u5230\u505A
        if ((end.x - start.x) * (start.y - center.y) > 0) {
            return -1;
        }
        else {
            return 1;
        }
    }
}
/**
 * @ignore
 * get the axis cfg from theme, will mix the common cfg of legend theme
 *
 * @param theme view theme object
 * @param direction axis direction
 * @returns axis theme cfg
 */
function getAxisThemeCfg(theme, direction) {
    var axisTheme = (0,esm/* get */.U2)(theme, ['components', 'axis'], {});
    return (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(axisTheme, ['common'], {}), (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(axisTheme, [direction], {})));
}
/**
 * get the options of axis title\uFF0Cmix the cfg from theme, avoid common themeCfg not work
 * @param theme
 * @param direction
 * @param axisOptions
 * @returns axis title options
 */
function getAxisTitleOptions(theme, direction, axisOptions) {
    var axisTheme = (0,esm/* get */.U2)(theme, ['components', 'axis'], {});
    return (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(axisTheme, ['common', 'title'], {}), (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(axisTheme, [direction, 'title'], {})), axisOptions);
}
/**
 * @ignore
 * get circle axis center and radius
 * @param coordinate
 */
function getCircleAxisCenterRadius(coordinate) {
    // @ts-ignore
    var x = coordinate.x, y = coordinate.y, center = coordinate.circleCenter;
    var isReflectY = y.start > y.end;
    var start = coordinate.isTransposed
        ? coordinate.convert({
            x: isReflectY ? 0 : 1,
            y: 0,
        })
        : coordinate.convert({
            x: 0,
            y: isReflectY ? 0 : 1,
        });
    var startVector = [start.x - center.x, start.y - center.y];
    var normalVector = [1, 0];
    var startAngle = start.y > center.y ? vec2/* angle */.EU(startVector, normalVector) : vec2/* angle */.EU(startVector, normalVector) * -1;
    var endAngle = startAngle + (x.end - x.start);
    var radius = Math.sqrt(Math.pow((start.x - center.x), 2) + Math.pow((start.y - center.y), 2));
    return {
        center: center,
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle,
    };
}
/**
 * @ignore
 * \u4ECE\u914D\u7F6E\u4E2D\u83B7\u53D6\u5355\u4E2A\u5B57\u6BB5\u7684 axis \u914D\u7F6E
 * @param axes
 * @param field
 * @returns the axis option of field
 */
function getAxisOption(axes, field) {
    if ((0,esm/* isBoolean */.jn)(axes)) {
        return axes === false ? false : {};
    }
    return (0,esm/* get */.U2)(axes, [field]);
}
/**
 * @ignore
 * \u5982\u679C\u914D\u7F6E\u4E86 position\uFF0C\u5219\u4F7F\u7528\u914D\u7F6E
 * @param axisOption
 * @param def
 */
function getAxisDirection(axisOption, def) {
    return (0,esm/* get */.U2)(axisOption, 'position', def);
}
/**
 * \u83B7\u53D6 axis \u7684 title \u6587\u672C
 * @param scale
 * @param axisOption
 */
function getAxisTitleText(scale, axisOption) {
    return (0,esm/* get */.U2)(axisOption, ['title', 'text'], getName(scale));
}
//# sourceMappingURL=axis.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/facet.js




/**
 * facet \u57FA\u7C7B
 *  - \u5B9A\u4E49\u751F\u547D\u5468\u671F\uFF0C\u65B9\u4FBF\u81EA\u5B9A\u4E49 facet
 *  - \u63D0\u4F9B\u57FA\u7840\u7684\u751F\u547D\u6D41\u7A0B\u65B9\u6CD5
 *
 * \u751F\u547D\u5468\u671F\uFF1A
 *
 * \u521D\u59CB\u5316 init
 * 1. \u521D\u59CB\u5316\u5BB9\u5668
 * 2. \u6570\u636E\u5206\u9762\uFF0C\u751F\u6210\u5206\u9762\u5E03\u5C40\u4FE1\u606F
 *
 * \u6E32\u67D3\u9636\u6BB5 render
 * 1. view \u521B\u5EFA
 * 2. title
 * 3. axis
 *
 * \u6E05\u9664\u9636\u6BB5 clear
 * 1. \u6E05\u9664 view
 *
 * \u9500\u6BC1\u9636\u6BB5 destroy
 * 1. clear
 * 2. \u6E05\u9664\u4E8B\u4EF6
 * 3. \u6E05\u9664 group
 */
var Facet = /** @class */ (function () {
    function Facet(view, cfg) {
        /** \u662F\u5426\u9500\u6BC1 */
        this.destroyed = false;
        /** \u5206\u9762\u4E4B\u540E\u7684\u6240\u6709\u5206\u9762\u6570\u636E\u7ED3\u6784 */
        this.facets = [];
        this.view = view;
        this.cfg = (0,esm/* deepMix */.b$)({}, this.getDefaultCfg(), cfg);
    }
    /**
     * \u521D\u59CB\u5316\u8FC7\u7A0B
     */
    Facet.prototype.init = function () {
        // \u521D\u59CB\u5316\u5BB9\u5668
        if (!this.container) {
            this.container = this.createContainer();
        }
        // \u751F\u6210\u5206\u9762\u5E03\u5C40\u4FE1\u606F
        var data = this.view.getData();
        this.facets = this.generateFacets(data);
    };
    /**
     * \u6E32\u67D3\u5206\u9762\uFF0C\u7531\u4E0A\u5C42 view \u8C03\u7528\u3002\u5305\u62EC\uFF1A
     *  - \u5206\u9762 view
     *  - \u8F74
     *  - title
     *
     *  \u5B50\u7C7B\u53EF\u4EE5\u590D\u5199\uFF0C\u6DFB\u52A0\u4E00\u4E9B\u5176\u4ED6\u7EC4\u4EF6\uFF0C\u6BD4\u5982\u6EDA\u52A8\u6761\u7B49
     */
    Facet.prototype.render = function () {
        this.renderViews();
    };
    /**
     * \u66F4\u65B0 facet
     */
    Facet.prototype.update = function () {
        // \u5176\u5B9E\u4E0D\u7528\u505A\u4EFB\u4F55\u4E8B\u60C5\uFF0C\u56E0\u4E3A facet \u6700\u7EC8\u751F\u6210\u7684 View \u548C Geometry \u90FD\u5728\u7236 view \u7684\u66F4\u65B0\u4E2D\u5904\u7406\u4E86
    };
    /**
     * \u6E05\u7A7A\uFF0Cclear \u4E4B\u540E\u5982\u679C\u8FD8\u9700\u8981\u4F7F\u7528\uFF0C\u9700\u8981\u91CD\u65B0\u8C03\u7528 init \u521D\u59CB\u5316\u8FC7\u7A0B
     * \u4E00\u822C\u5728\u6570\u636E\u6709\u53D8\u66F4\u7684\u65F6\u5019\u8C03\u7528\uFF0C\u91CD\u65B0\u8FDB\u884C\u6570\u636E\u7684\u5206\u9762\u903B\u8F91
     */
    Facet.prototype.clear = function () {
        this.clearFacetViews();
    };
    /**
     * \u9500\u6BC1
     */
    Facet.prototype.destroy = function () {
        this.clear();
        if (this.container) {
            this.container.remove(true);
            this.container = undefined;
        }
        this.destroyed = true;
        this.view = undefined;
        this.facets = [];
    };
    /**
     * \u6839\u636E facet \u751F\u6210 view\uFF0C\u53EF\u4EE5\u7ED9\u4E0A\u5C42\u81EA\u5B9A\u4E49\u4F7F\u7528
     * @param facet
     */
    Facet.prototype.facetToView = function (facet) {
        var region = facet.region, data = facet.data, _a = facet.padding, padding = _a === void 0 ? this.cfg.padding : _a;
        var view = this.view.createView({
            region: region,
            padding: padding,
        });
        // \u8BBE\u7F6E\u5206\u9762\u7684\u6570\u636E
        view.data(data || []);
        facet.view = view;
        // \u524D\u7F6E\u94A9\u5B50
        this.beforeEachView(view, facet);
        var eachView = this.cfg.eachView;
        if (eachView) {
            eachView(view, facet);
        }
        // \u540E\u7F6E\u94A9\u5B50
        this.afterEachView(view, facet);
        return view;
    };
    // \u521B\u5EFA\u5BB9\u5668
    Facet.prototype.createContainer = function () {
        var foregroundGroup = this.view.getLayer(LAYER.FORE);
        return foregroundGroup.addGroup();
    };
    /**
     * \u521D\u59CB\u5316 view
     */
    Facet.prototype.renderViews = function () {
        this.createFacetViews();
    };
    /**
     * \u521B\u5EFA \u5206\u9762 view
     */
    Facet.prototype.createFacetViews = function () {
        var _this = this;
        // \u4F7F\u7528\u5206\u9762\u6570\u636E \u521B\u5EFA\u5206\u9762 view
        return this.facets.map(function (facet) {
            return _this.facetToView(facet);
        });
    };
    /**
     * \u4ECE view \u4E2D\u6E05\u9664 facetView
     */
    Facet.prototype.clearFacetViews = function () {
        var _this = this;
        // \u4ECE view \u4E2D\u79FB\u9664\u5206\u9762 view
        (0,esm/* each */.S6)(this.facets, function (facet) {
            if (facet.view) {
                _this.view.removeView(facet.view);
                facet.view = undefined;
            }
        });
    };
    /**
     * \u89E3\u6790 spacing
     */
    Facet.prototype.parseSpacing = function () {
        /**
         * @example
         *
         * // \u4EC5\u4F7F\u7528\u767E\u5206\u6BD4\u6216\u50CF\u7D20\u503C
         * // \u6A2A\u5411\u95F4\u9694\u4E3A 10%\uFF0C\u7EB5\u5411\u95F4\u9694\u4E3A 10%
         * ['10%', '10%']
         * // \u6A2A\u5411\u95F4\u9694\u4E3A 10px\uFF0C\u7EB5\u5411\u95F4\u9694\u4E3A 10px
         * [10, 10]
         *
         * // \u540C\u65F6\u4F7F\u7528\u767E\u5206\u6BD4\u548C\u50CF\u7D20\u503C
         * ['10%', 10]
         * // \u6A2A\u5411\u95F4\u9694\u4E3A 10%\uFF0C\u7EB5\u5411\u95F4\u9694\u4E3A 10px
         */
        var _a = this.view.viewBBox, width = _a.width, height = _a.height;
        var spacing = this.cfg.spacing;
        return spacing.map(function (s, idx) {
            if ((0,esm/* isNumber */.hj)(s))
                return s / (idx === 0 ? width : height);
            else
                return parseFloat(s) / 100;
        });
    };
    // \u5176\u4ED6\u4E00\u4E9B\u63D0\u4F9B\u7ED9\u5B50\u7C7B\u4F7F\u7528\u7684\u65B9\u6CD5
    /**
     * \u83B7\u53D6\u8FD9\u4E2A\u5B57\u6BB5\u5BF9\u5E94\u7684\u6240\u6709\u503C\uFF0C\u6570\u7EC4
     * @protected
     * @param data \u6570\u636E
     * @param field \u5B57\u6BB5\u540D
     * @return \u5B57\u6BB5\u5BF9\u5E94\u7684\u503C
     */
    Facet.prototype.getFieldValues = function (data, field) {
        var rst = [];
        var cache = {};
        // \u53BB\u91CD\u3001\u53BB\u9664 Nil \u503C
        (0,esm/* each */.S6)(data, function (d) {
            var value = d[field];
            if (!(0,esm/* isNil */.UM)(value) && !cache[value]) {
                rst.push(value);
                cache[value] = true;
            }
        });
        return rst;
    };
    /**
     * \u83B7\u5F97\u6BCF\u4E2A\u5206\u9762\u7684 region\uFF0C\u5E73\u5206\u533A\u57DF
     * @param rows row \u603B\u6570
     * @param cols col \u603B\u6570
     * @param xIndex x \u65B9\u5411 index
     * @param yIndex y \u65B9\u5411 index
     */
    Facet.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
        var _a = (0,tslib_es6/* __read */.CR)(this.parseSpacing(), 2), xSpacing = _a[0], ySpacing = _a[1];
        // \u6BCF\u4E24\u4E2A\u5206\u9762\u533A\u57DF\u6A2A\u5411\u95F4\u9694xSPacing, \u7EB5\u5411\u95F4\u9694ySpacing
        // \u6BCF\u4E2A\u5206\u9762\u533A\u57DF\u7684\u6A2A\u7EB5\u5360\u6BD4
        /**
         * ratio * num + spacing * (num - 1) = 1
         * => ratio = (1 - (spacing * (num - 1))) / num
         *          = (1 + spacing) / num - spacing
         *
         * num \u5BF9\u5E94 cols/rows
         * spacing \u5BF9\u5E94 xSpacing/ySpacing
         */
        var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
        var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
        // \u5F97\u5230\u7B2C index \u4E2A\u5206\u9762\u533A\u57DF\u767E\u5206\u6BD4\u4F4D\u7F6E
        var start = {
            x: (xRatio + xSpacing) * xIndex,
            y: (yRatio + ySpacing) * yIndex,
        };
        var end = {
            x: start.x + xRatio,
            y: start.y + yRatio,
        };
        return { start: start, end: end };
    };
    Facet.prototype.getDefaultCfg = function () {
        return {
            eachView: undefined,
            showTitle: true,
            spacing: [0, 0],
            padding: 10,
            fields: [],
        };
    };
    /**
     * \u9ED8\u8BA4\u7684 title \u6837\u5F0F\uFF0C\u56E0\u4E3A\u6709\u7684\u5206\u9762\u662F title\uFF0C\u6709\u7684\u5206\u9762\u914D\u7F6E\u662F columnTitle\u3001rowTitle
     */
    Facet.prototype.getDefaultTitleCfg = function () {
        // @ts-ignore
        var fontFamily = this.view.getTheme().fontFamily;
        return {
            style: {
                fontSize: 14,
                fill: '#666',
                fontFamily: fontFamily,
            },
        };
    };
    /**
     * \u5904\u7406 axis \u7684\u9ED8\u8BA4\u914D\u7F6E
     * @param view
     * @param facet
     */
    Facet.prototype.processAxis = function (view, facet) {
        var options = view.getOptions();
        var coordinateOption = options.coordinate;
        var geometries = view.geometries;
        var coordinateType = (0,esm/* get */.U2)(coordinateOption, 'type', 'rect');
        if (coordinateType === 'rect' && geometries.length) {
            if ((0,esm/* isNil */.UM)(options.axes)) {
                // @ts-ignore
                options.axes = {};
            }
            var axes = options.axes;
            var _a = (0,tslib_es6/* __read */.CR)(geometries[0].getXYFields(), 2), x = _a[0], y = _a[1];
            var xOption = getAxisOption(axes, x);
            var yOption = getAxisOption(axes, y);
            if (xOption !== false) {
                options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
            }
            if (yOption !== false) {
                options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
            }
        }
    };
    /**
     * \u83B7\u53D6\u5206\u9762\u6570\u636E
     * @param conditions
     */
    Facet.prototype.getFacetDataFilter = function (conditions) {
        return function (datum) {
            // \u8FC7\u6EE4\u51FA\u5168\u90E8\u6EE1\u8DB3\u6761\u4EF6\u7684\u6570\u636E
            return (0,esm/* every */.yW)(conditions, function (condition) {
                var field = condition.field, value = condition.value;
                if (!(0,esm/* isNil */.UM)(value) && field) {
                    return datum[field] === value;
                }
                return true;
            });
        };
    };
    return Facet;
}());

//# sourceMappingURL=facet.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/index.js


/**
 * \u6240\u6709\u7684 Facet \u7C7B
 */
var Facets = {};
/**
 * \u6839\u636E type \u83B7\u53D6 facet \u7C7B
 * @param type \u5206\u9762\u7C7B\u578B
 */
var getFacet = function (type) {
    return Facets[(0,esm/* lowerCase */.vl)(type)];
};
/**
 * \u6CE8\u518C\u4E00\u4E2A Facet \u7C7B
 * @param type \u5206\u9762\u7C7B\u578B
 * @param ctor \u5206\u9762\u7C7B
 */
var registerFacet = function (type, ctor) {
    Facets[(0,esm/* lowerCase */.vl)(type)] = ctor;
};
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/base.js

/**
 * Action \u7684\u57FA\u7C7B
 */
var Action = /** @class */ (function () {
    function Action(context, cfg) {
        this.context = context;
        this.cfg = cfg;
        context.addAction(this);
    }
    /**
     * \u8BBE\u7F6E\u914D\u7F6E\u9879\u4F20\u5165\u7684\u503C
     * @param cfg
     */
    Action.prototype.applyCfg = function (cfg) {
        (0,esm/* assign */.f0)(this, cfg);
    };
    /**
     * Inits action\uFF0C\u63D0\u4F9B\u7ED9\u5B50\u7C7B\u7528\u4E8E\u7EE7\u627F
     */
    Action.prototype.init = function () {
        this.applyCfg(this.cfg);
    };
    /**
     * Destroys action
     */
    Action.prototype.destroy = function () {
        // \u79FB\u9664 action
        this.context.removeAction(this);
        // \u6E05\u7A7A
        this.context = null;
    };
    return Action;
}());
/* harmony default export */ var action_base = (Action);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/callback.js


/** \u56DE\u8C03\u51FD\u6570\u6784\u5EFA\u7684 Action */
var CallbackAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CallbackAction, _super);
    function CallbackAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u6267\u884C
     */
    CallbackAction.prototype.execute = function () {
        if (this.callback) {
            this.callback(this.context);
        }
    };
    /**
     * \u9500\u6BC1
     */
    CallbackAction.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.callback = null;
    };
    return CallbackAction;
}(action_base));
/* harmony default export */ var action_callback = (CallbackAction);
//# sourceMappingURL=callback.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/register.js


// Action \u7C7B\u7684\u7F13\u5B58
var ActionCache = {};
/**
 * \u6839\u636E\u540D\u79F0\u83B7\u53D6 Action \u5B9E\u4F8B
 * @param actionName - action \u7684\u540D\u79F0
 * @param context \u4E0A\u4E0B\u6587
 * @returns Action \u5B9E\u4F8B
 */
function createAction(actionName, context) {
    var actionOption = ActionCache[actionName];
    var action = null;
    if (actionOption) {
        var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
        action = new ActionClass(context, cfg);
        action.name = actionName;
        action.init();
    }
    return action;
}
/**
 * \u6839\u636E action \u7684 name \u83B7\u53D6\u5B9A\u4E49\u7684\u7C7B
 * @param actionName action \u7684 name
 */
function getActionClass(actionName) {
    var actionOption = ActionCache[actionName];
    return (0,esm/* get */.U2)(actionOption, 'ActionClass');
}
/**
 * \u6CE8\u518C Action
 * @param actionName - action \u7684\u540D\u79F0
 * @param ActionClass - \u7EE7\u627F\u81EA action \u7684\u7C7B
 */
function registerAction(actionName, ActionClass, cfg) {
    ActionCache[actionName] = {
        ActionClass: ActionClass,
        cfg: cfg,
    };
}
/**
 * \u53D6\u6D88\u6CE8\u518C Action
 * @param actionName action \u540D\u79F0
 */
function unregisterAction(actionName) {
    delete ActionCache[actionName];
}
/**
 * \u6839\u636E\u56DE\u8C03\u51FD\u6570\u83B7\u53D6 Action \u5B9E\u4F8B
 * @param callback - action \u7684\u56DE\u8C03\u51FD\u6570
 * @param context \u4E0A\u4E0B\u6587
 * @returns Action \u5B9E\u4F8B
 */
function createCallbackAction(callback, context) {
    var action = new action_callback(context);
    action.callback = callback;
    action.name = 'callback';
    return action;
}
//# sourceMappingURL=register.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/util/path.js




function _points2path(points, isInCircle) {
    var path = [];
    if (points.length) {
        path.push(['M', points[0].x, points[0].y]);
        for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
            var item = points[i];
            path.push(['L', item.x, item.y]);
        }
        if (isInCircle) {
            path.push(['Z']);
        }
    }
    return path;
}
function _convertArr(arr, coord) {
    var tmp = [arr[0]];
    for (var i = 1, len = arr.length; i < len; i = i + 2) {
        var point = coord.convert({
            x: arr[i],
            y: arr[i + 1],
        });
        tmp.push(point.x, point.y);
    }
    return tmp;
}
function _convertArcPath(path, coord) {
    var isTransposed = coord.isTransposed;
    var r = path[1];
    var x = path[6];
    var y = path[7];
    var point = coord.convert({ x: x, y: y });
    var direction = isTransposed ? 0 : 1;
    return ['A', r, r, 0, 0, direction, point.x, point.y];
}
function _convertPolarPath(pre, cur, coord) {
    var isTransposed = coord.isTransposed, startAngle = coord.startAngle, endAngle = coord.endAngle;
    var prePoint = pre[0].toLowerCase() === 'a'
        ? {
            x: pre[6],
            y: pre[7],
        }
        : {
            x: pre[1],
            y: pre[2],
        };
    var curPoint = {
        x: cur[1],
        y: cur[2],
    };
    var rst = [];
    var xDim = isTransposed ? 'y' : 'x';
    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
    var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // \u5706\u5F27\u7684\u65B9\u5411
    var flag = angleRange > Math.PI ? 1 : 0; // \u5927\u5F27\u8FD8\u662F\u5C0F\u5F27\u6807\u5FD7\u4F4D
    var convertPoint = coord.convert(curPoint);
    var r = getDistanceToCenter(coord, convertPoint);
    if (r >= 0.5) {
        // \u5C0F\u4E8E1\u50CF\u7D20\u7684\u5706\u5728\u56FE\u50CF\u4E0A\u65E0\u6CD5\u8BC6\u522B
        if (angleRange === Math.PI * 2) {
            var middlePoint = {
                x: (curPoint.x + prePoint.x) / 2,
                y: (curPoint.y + prePoint.y) / 2,
            };
            var middleConvertPoint = coord.convert(middlePoint);
            rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);
            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
        }
        else {
            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
        }
    }
    return rst;
}
// \u5F53\u5B58\u5728\u6574\u4F53\u7684\u5706\u65F6\uFF0C\u53BB\u9664\u5706\u524D\u9762\u548C\u540E\u9762\u7684\u7EBF\uFF0C\u9632\u6B62\u51FA\u73B0\u76F4\u7EBF\u7A7F\u8FC7\u6574\u4E2A\u5706\u7684\u60C5\u5F62
function _filterFullCirleLine(path) {
    (0,esm/* each */.S6)(path, function (subPath, index) {
        var cur = subPath;
        if (cur[0].toLowerCase() === 'a') {
            var pre = path[index - 1];
            var next = path[index + 1];
            if (next && next[0].toLowerCase() === 'a') {
                if (pre && pre[0].toLowerCase() === 'l') {
                    pre[0] = 'M';
                }
            }
            else if (pre && pre[0].toLowerCase() === 'a') {
                if (next && next[0].toLowerCase() === 'l') {
                    next[0] = 'M';
                }
            }
        }
    });
}
/**
 * @ignore
 * \u8BA1\u7B97\u5149\u6ED1\u7684\u8D1D\u585E\u5C14\u66F2\u7EBF
 */
var smoothBezier = function (points, smooth, isLoop, constraint) {
    var _a;
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min;
    var max;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
        _a = (0,tslib_es6/* __read */.CR)(constraint, 2), min = _a[0], max = _a[1];
        for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            min = vec2/* min */.VV([0, 0], min, point);
            max = vec2/* max */.Fp([0, 0], max, point);
        }
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (i === 0 && !isLoop) {
            cp0 = point;
        }
        else if (i === len - 1 && !isLoop) {
            cp1 = point;
            cps.push(cp0);
            cps.push(cp1);
        }
        else {
            prevPoint = points[isLoop ? (i ? i - 1 : len - 1) : i - 1];
            nextPoint = points[isLoop ? (i + 1) % len : i + 1];
            var v = [0, 0];
            v = vec2/* sub */.lu(v, nextPoint, prevPoint);
            v = vec2/* scale */.bA(v, v, smooth);
            var d0 = vec2/* distance */.TE(point, prevPoint);
            var d1 = vec2/* distance */.TE(point, nextPoint);
            var sum = d0 + d1;
            if (sum !== 0) {
                d0 /= sum;
                d1 /= sum;
            }
            var v1 = vec2/* scale */.bA([0, 0], v, -d0);
            var v2 = vec2/* scale */.bA([0, 0], v, d1);
            cp1 = vec2/* add */.IH([0, 0], point, v1);
            nextCp0 = vec2/* add */.IH([0, 0], point, v2);
            // \u4E0B\u4E00\u4E2A\u63A7\u5236\u70B9\u5FC5\u987B\u5728\u8FD9\u4E2A\u70B9\u548C\u4E0B\u4E00\u4E2A\u70B9\u4E4B\u95F4
            nextCp0 = vec2/* min */.VV([0, 0], nextCp0, vec2/* max */.Fp([0, 0], nextPoint, point));
            nextCp0 = vec2/* max */.Fp([0, 0], nextCp0, vec2/* min */.VV([0, 0], nextPoint, point));
            // \u91CD\u65B0\u8BA1\u7B97 cp1 \u7684\u503C
            v1 = vec2/* sub */.lu([0, 0], nextCp0, point);
            v1 = vec2/* scale */.bA([0, 0], v1, -d0 / d1);
            cp1 = vec2/* add */.IH([0, 0], point, v1);
            // \u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\u5FC5\u987B\u8981\u5728\u4E0A\u4E00\u4E2A\u70B9\u548C\u8FD9\u4E00\u4E2A\u70B9\u4E4B\u95F4
            cp1 = vec2/* min */.VV([0, 0], cp1, vec2/* max */.Fp([0, 0], prevPoint, point));
            cp1 = vec2/* max */.Fp([0, 0], cp1, vec2/* min */.VV([0, 0], prevPoint, point));
            // \u91CD\u65B0\u8BA1\u7B97 nextCp0 \u7684\u503C
            v2 = vec2/* sub */.lu([0, 0], point, cp1);
            v2 = vec2/* scale */.bA([0, 0], v2, d1 / d0);
            nextCp0 = vec2/* add */.IH([0, 0], point, v2);
            if (hasConstraint) {
                cp1 = vec2/* max */.Fp([0, 0], cp1, min);
                cp1 = vec2/* min */.VV([0, 0], cp1, max);
                nextCp0 = vec2/* max */.Fp([0, 0], nextCp0, min);
                nextCp0 = vec2/* min */.VV([0, 0], nextCp0, max);
            }
            cps.push(cp0);
            cps.push(cp1);
            cp0 = nextCp0;
        }
    }
    if (isLoop) {
        cps.push(cps.shift());
    }
    return cps;
};
/**
 * @ignore
 * \u8D1D\u585E\u5C14\u66F2\u7EBF
 */
function catmullRom2bezier(crp, z, constraint) {
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
        pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p;
    for (var i = 0; i < len - 1; i++) {
        cp1 = controlPointList[i * 2];
        cp2 = controlPointList[i * 2 + 1];
        p = pointList[i + 1];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    if (isLoop) {
        cp1 = controlPointList[len];
        cp2 = controlPointList[len + 1];
        p = pointList[0];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    return d1;
}
/**
 * @ignore
 * \u5C06\u70B9\u8FDE\u63A5\u6210\u8DEF\u5F84 path
 */
function path_getLinePath(points, isInCircle) {
    return _points2path(points, isInCircle);
}
/**
 * @ignore
 * \u6839\u636E\u5173\u952E\u70B9\u83B7\u53D6\u9650\u5B9A\u4E86\u8303\u56F4\u7684\u5E73\u6ED1\u7EBF
 */
function getSplinePath(points, isInCircle, constaint) {
    var data = [];
    var first = points[0];
    var prePoint = null;
    if (points.length <= 2) {
        // \u4E24\u70B9\u4EE5\u5185\u76F4\u63A5\u7ED8\u5236\u6210\u8DEF\u5F84
        return path_getLinePath(points, isInCircle);
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
            data.push(point.x);
            data.push(point.y);
            prePoint = point;
        }
    }
    var constraint = constaint || [
        // \u8303\u56F4
        [0, 0],
        [1, 1],
    ];
    var splinePath = catmullRom2bezier(data, isInCircle, constraint);
    splinePath.unshift(['M', first.x, first.y]);
    return splinePath;
}
/**
 * @ignore
 * \u5C06\u5F52\u4E00\u5316\u540E\u7684\u8DEF\u5F84\u6570\u636E\u8F6C\u6362\u6210\u5750\u6807
 */
function convertNormalPath(coord, path) {
    var tmp = [];
    (0,esm/* each */.S6)(path, function (subPath) {
        var action = subPath[0];
        switch (action.toLowerCase()) {
            case 'm':
            case 'l':
            case 'c':
                tmp.push(_convertArr(subPath, coord));
                break;
            case 'a':
                tmp.push(_convertArcPath(subPath, coord));
                break;
            case 'z':
            default:
                tmp.push(subPath);
                break;
        }
    });
    return tmp;
}
/**
 * @ignore
 * \u5C06\u8DEF\u5F84\u8F6C\u6362\u4E3A\u6781\u5750\u6807\u4E0B\u7684\u771F\u5B9E\u8DEF\u5F84
 */
function convertPolarPath(coord, path) {
    var tmp = [];
    var pre;
    var cur;
    var transposed;
    var equals;
    (0,esm/* each */.S6)(path, function (subPath, index) {
        var action = subPath[0];
        switch (action.toLowerCase()) {
            case 'm':
            case 'c':
            case 'q':
                tmp.push(_convertArr(subPath, coord));
                break;
            case 'l':
                pre = path[index - 1];
                cur = subPath;
                transposed = coord.isTransposed;
                // \u662F\u5426\u534A\u5F84\u76F8\u540C\uFF0C\u8F6C\u6362\u6210\u5706\u5F27
                equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
                if (equals) {
                    tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
                }
                else {
                    // y \u4E0D\u76F8\u7B49\uFF0C\u6240\u4EE5\u76F4\u63A5\u8F6C\u6362
                    tmp.push(_convertArr(subPath, coord));
                }
                break;
            case 'a':
                tmp.push(_convertArcPath(subPath, coord));
                break;
            case 'z':
            default:
                tmp.push(subPath);
                break;
        }
    });
    _filterFullCirleLine(tmp); // \u8FC7\u6EE4\u591A\u4F59\u7684\u76F4\u7EBF
    return tmp;
}
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/util.js




function getMaskBBox(context, tolerance) {
    var event = context.event;
    var maskShape = event.target;
    return getMaskBBoxByShape(maskShape, tolerance);
}
/**
 * \u5982\u679C mask BBox \u8FC7\u5C0F\u5219\u4E0D\u8FD4\u56DE
 */
function isValidMaskBBox(maskShape, tolerance) {
    var maskBBox = maskShape.getCanvasBBox();
    var width = maskBBox.width, height = maskBBox.height;
    return width > 0 && height > 0 && (width >= tolerance || height >= tolerance);
}
/**
 * \u901A\u8FC7 maskShape \u83B7\u53D6 mask \u7684 canvasBBox
 * @param maskShape
 * @param tolerance
 * @returns
 */
function getMaskBBoxByShape(maskShape, tolerance) {
    var maskBBox = maskShape.getCanvasBBox();
    return isValidMaskBBox(maskShape, tolerance) ? maskBBox : null;
}
/**
 * \u83B7\u53D6 multiple \u6A21\u5F0F\u4E0B mask \u7684 canvasBBox \u6570\u7EC4
 * @param context \u4E0A\u4E0B\u6587
 * @param tolerance box \u5BBD\u9AD8\u5C0F\u4E8E\u5219\u4E0D\u8FD4\u56DE
 * @returns
 */
function getMultiMaskBBoxList(context, tolerance) {
    var maskShapes = context.event.maskShapes;
    return maskShapes.map(function (maskShape) { return getMaskBBoxByShape(maskShape, tolerance); }).filter(function (bBox) { return !!bBox; });
}
function getMaskPath(context, tolerance) {
    var event = context.event;
    var maskShape = event.target;
    return getMaskPathByMaskShape(maskShape, tolerance);
}
/**
 * \u901A\u8FC7 maskShape \u83B7\u53D6 mask path
 * @param maskShape
 * @param tolerance box \u5BBD\u9AD8\u5C0F\u4E8E\u5219\u4E0D\u8FD4\u56DE
 * @returns
 */
function getMaskPathByMaskShape(maskShape, tolerance) {
    return isValidMaskBBox(maskShape, tolerance) ? maskShape.attr('path') : null;
}
/**
 * \u83B7\u53D6 multiple \u6A21\u5F0F\u4E0B mask path \u6570\u7EC4
 * @param context \u4E0A\u4E0B\u6587
 * @param tolerance box \u5BBD\u9AD8\u5C0F\u4E8E\u5219\u4E0D\u8FD4\u56DE
 * @returns
 */
function getMultiMaskPathList(context, tolerance) {
    var maskShapes = context.event.maskShapes;
    return maskShapes.map(function (maskShape) { return getMaskPathByMaskShape(maskShape, tolerance); });
}
/**
 * \u83B7\u53D6\u5F53\u524D\u4E8B\u4EF6\u76F8\u5173\u7684\u56FE\u8868\u5143\u7D20
 * @param context \u4EA4\u4E92\u7684\u4E0A\u4E0B\u6587
 * @ignore
 */
function getCurrentElement(context) {
    var event = context.event;
    var element;
    var target = event.target;
    if (target) {
        element = target.get('element');
    }
    return element;
}
/**
 * \u83B7\u53D6\u59D4\u6258\u5BF9\u8C61
 * @param context \u4E0A\u4E0B\u6587
 * @ignore
 */
function getDelegationObject(context) {
    var event = context.event;
    var target = event.target;
    var delegateObject;
    if (target) {
        delegateObject = target.get('delegateObject');
    }
    return delegateObject;
}
function isElementChange(context) {
    var event = context.event.gEvent;
    // \u5728\u540C\u4E00\u4E2A element \u5185\u90E8\u79FB\u52A8\uFF0Clabel \u548C shape \u4E4B\u95F4
    if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {
        return false;
    }
    return true;
}
/**
 * \u662F\u5426\u662F\u5217\u8868\u7EC4\u4EF6
 * @param delegateObject \u59D4\u6258\u5BF9\u8C61
 * @ignore
 */
function isList(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isList();
}
/**
 * \u662F\u5426\u662F\u6ED1\u5757\u7EC4\u4EF6
 * @param delegateObject \u59D4\u6258\u5BF9\u8C61
 * @ignore
 */
function isSlider(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
/**
 * \u662F\u5426\u7531 mask \u89E6\u53D1
 * @param context \u4E0A\u4E0B\u6587
 * @ignore
 */
function isMask(context) {
    var event = context.event;
    var target = event.target;
    return (target && (target === null || target === void 0 ? void 0 : target.get('name')) === 'mask') || isMultipleMask(context);
}
/**
 * \u662F\u5426\u7531 multiple mask \u89E6\u53D1
 * @param context
 * @returns
 */
function isMultipleMask(context) {
    var _a;
    return ((_a = context.event.target) === null || _a === void 0 ? void 0 : _a.get('name')) === 'multi-mask';
}
/**
 * \u83B7\u53D6\u88AB\u906E\u6321\u7684 elements
 * @param context \u4E0A\u4E0B\u6587
 * @ignore
 */
function getMaskedElements(context, tolerance) {
    var target = context.event.target;
    // multiple \u6A21\u5F0F\u4E0B
    if (isMultipleMask(context)) {
        return getMultiMaskedElements(context, tolerance);
    }
    // \u6B63\u5E38\u6A21\u5F0F\u4E0B
    if (target.get('type') === 'path') {
        var maskPath = getMaskPath(context, tolerance);
        if (!maskPath) {
            return;
        }
        return getElementsByPath(context.view, maskPath);
    }
    var maskBBox = getMaskBBox(context, tolerance);
    // \u5982\u679C bbox \u8FC7\u5C0F\u5219\u4E0D\u8FD4\u56DE
    if (!maskBBox) {
        return null;
    }
    return getIntersectElements(context.view, maskBBox);
}
/**
 * \u83B7\u53D6 multiple \u6A21\u5F0F\u4E0B\u88AB mask \u906E\u6321\u7684 elements
 * @param context \u4E0A\u4E0B\u6587
 * @returns
 */
function getMultiMaskedElements(context, tolerance) {
    var target = context.event.target;
    if (target.get('type') === 'path') {
        var maskPathList = getMultiMaskPathList(context, tolerance);
        if (maskPathList.length > 0) {
            return maskPathList.flatMap(function (maskPath) { return getElementsByPath(context.view, maskPath); });
        }
        return null;
    }
    var maskBBoxList = getMultiMaskBBoxList(context, tolerance);
    if (maskBBoxList.length > 0) {
        return maskBBoxList.flatMap(function (maskBBox) { return getIntersectElements(context.view, maskBBox); });
    }
    return null;
}
/**
 * @ignore
 */
function getSiblingMaskElements(context, sibling, tolerance) {
    // multiple \u6A21\u5F0F\u4E0B
    if (isMultipleMask(context)) {
        return getSiblingMultiMaskedElements(context, sibling, tolerance);
    }
    // \u6B63\u5E38\u6A21\u5F0F\u4E0B
    var maskBBox = getMaskBBox(context, tolerance);
    // \u5982\u679C bbox \u8FC7\u5C0F\u5219\u4E0D\u8FD4\u56DE
    if (!maskBBox) {
        return null;
    }
    return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
}
/**
 * \u901A\u8FC7 mashBBox \u83B7\u53D6 sibling \u6A21\u5F0F\u4E0B\u88AB mask \u906E\u6321\u7684 elements
 * @param maskBBox
 * @param context \u4E0A\u4E0B\u6587
 * @param sibling sibling view
 * @returns
 */
function getSiblingMaskElementsByBBox(maskBBox, context, sibling) {
    var view = context.view;
    var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
    var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
    var box = {
        minX: start.x,
        minY: start.y,
        maxX: end.x,
        maxY: end.y,
    };
    return getIntersectElements(sibling, box);
}
/**
 * \u83B7\u53D6 sibling \u6A21\u5F0F\u4E0B\u88AB multiple mask \u906E\u6321\u7684 elements
 * @param context \u4E0A\u4E0B\u6587
 * @param sibling sibling view
 * @param tolerance box \u5BBD\u9AD8\u5C0F\u4E8E\u5219\u4E0D\u8FD4\u56DE
 * @returns
 */
function getSiblingMultiMaskedElements(context, sibling, tolerance) {
    var maskBBoxList = getMultiMaskBBoxList(context, tolerance);
    if (maskBBoxList.length > 0) {
        return maskBBoxList.flatMap(function (maskBBox) { return getSiblingMaskElementsByBBox(maskBBox, context, sibling); });
    }
    return null;
}
/**
 * \u83B7\u53D6\u6240\u6709\u7684\u56FE\u8868\u5143\u7D20
 * @param view View/Chart
 * @ignore
 */
function getElements(view) {
    var geometries = view.geometries;
    var rst = [];
    (0,esm/* each */.S6)(geometries, function (geom) {
        var elements = geom.elements;
        rst = rst.concat(elements);
    });
    if (view.views && view.views.length) {
        (0,esm/* each */.S6)(view.views, function (subView) {
            rst = rst.concat(getElements(subView));
        });
    }
    return rst;
}
/**
 * \u83B7\u53D6\u6240\u6709\u7684\u56FE\u8868\u5143\u7D20
 * @param view View/Chart
 * @param field \u5B57\u6BB5\u540D
 * @param value \u5B57\u6BB5\u503C
 * @ignore
 */
function getElementsByField(view, field, value) {
    var elements = getElements(view);
    return elements.filter(function (el) {
        return getElementValue(el, field) === value;
    });
}
/**
 * \u6839\u636E\u72B6\u6001\u540D\u83B7\u53D6\u56FE\u8868\u5143\u7D20
 * @param view View/Chart
 * @param stateName \u72B6\u6001\u540D
 * @ignore
 */
function getElementsByState(view, stateName) {
    var geometries = view.geometries;
    var rst = [];
    (0,esm/* each */.S6)(geometries, function (geom) {
        var elements = geom.getElementsBy(function (el) { return el.hasState(stateName); });
        rst = rst.concat(elements);
    });
    return rst;
}
/**
 * \u83B7\u53D6\u56FE\u8868\u5143\u7D20\u5BF9\u5E94\u5B57\u6BB5\u7684\u503C
 * @param element \u56FE\u8868\u5143\u7D20
 * @param field \u5B57\u6BB5\u540D
 * @ignore
 */
function getElementValue(element, field) {
    var model = element.getModel();
    var record = model.data;
    var value;
    if ((0,esm/* isArray */.kJ)(record)) {
        value = record[0][field];
    }
    else {
        value = record[field];
    }
    return value;
}
/**
 * \u4E24\u4E2A\u5305\u56F4\u76D2\u662F\u5426\u76F8\u4EA4
 * @param box1 \u5305\u56F4\u76D21
 * @param box2 \u5305\u56F4\u76D22
 * @ignore
 */
function intersectRect(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
/**
 * \u83B7\u53D6\u5305\u56F4\u76D2\u5185\u7684\u56FE\u8868\u5143\u7D20
 * @param view View/Chart
 * @param box \u5305\u56F4\u76D2
 * @ignore
 */
function getIntersectElements(view, box) {
    var elements = getElements(view);
    var rst = [];
    (0,esm/* each */.S6)(elements, function (el) {
        var shape = el.shape;
        var shapeBBox = shape.getCanvasBBox();
        if (intersectRect(box, shapeBBox)) {
            rst.push(el);
        }
    });
    return rst;
}
function pathToPoints(path) {
    var points = [];
    (0,esm/* each */.S6)(path, function (seg) {
        var command = seg[0];
        if (command !== 'A') {
            for (var i = 1; i < seg.length; i = i + 2) {
                points.push([seg[i], seg[i + 1]]);
            }
        }
        else {
            var length_1 = seg.length;
            points.push([seg[length_1 - 2], seg[length_1 - 1]]);
        }
    });
    return points;
}
/**
 * \u83B7\u53D6\u5305\u56F4\u76D2\u5185\u7684\u56FE\u8868\u5143\u7D20
 * @param view View/Chart
 * @param path \u8DEF\u5F84
 * @ignore
 */
function getElementsByPath(view, path) {
    var elements = getElements(view);
    var points = pathToPoints(path);
    var rst = elements.filter(function (el) {
        var shape = el.shape;
        var shapePoints;
        if (shape.get('type') === 'path') {
            shapePoints = pathToPoints(shape.attr('path'));
        }
        else {
            var shapeBBox = shape.getCanvasBBox();
            shapePoints = toPoints(shapeBBox);
        }
        return (0,path_util_esm/* isPolygonsIntersect */.Wq)(points, shapePoints);
    });
    return rst;
}
/**
 * \u83B7\u53D6\u5F53\u524D View \u7684\u6240\u6709\u7EC4\u4EF6
 * @param view View/Chart
 * @ignore
 */
function getComponents(view) {
    return view.getComponents().map(function (co) { return co.component; });
}
/** @ignore */
function action_util_distance(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
}
/** @ignore */
function getSpline(points, z) {
    if (points.length <= 2) {
        return path_getLinePath(points, false);
    }
    var first = points[0];
    var arr = [];
    (0,esm/* each */.S6)(points, function (point) {
        arr.push(point.x);
        arr.push(point.y);
    });
    var path = catmullRom2bezier(arr, z, null);
    path.unshift(['M', first.x, first.y]);
    return path;
}
/**
 * \u68C0\u6D4B\u70B9\u662F\u5426\u5728\u5305\u56F4\u76D2\u5185
 * @param box \u5305\u56F4\u76D2
 * @param point \u70B9
 * @ignore
 */
function isInBox(box, point) {
    return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;
}
/**
 * \u83B7\u53D6\u540C view \u540C\u4E00\u7EA7\u7684 views
 * @param view \u5F53\u524D view
 * @returns \u540C\u4E00\u7EA7\u7684 views
 * @ignore
 */
function getSilbings(view) {
    var parent = view.parent;
    var siblings = null;
    if (parent) {
        siblings = parent.views.filter(function (sub) { return sub !== view; });
    }
    return siblings;
}
function point2Normalize(view, point) {
    var coord = view.getCoordinate();
    return coord.invert(point);
}
/**
 * \u5C06 view \u4E0A\u7684\u4E00\u70B9\u8F6C\u6362\u6210\u53E6\u4E00\u4E2A view \u7684\u70B9
 * @param view \u5F53\u524D\u7684 view
 * @param sibling \u540C\u4E00\u5C42\u7EA7\u7684 view
 * @param point \u6307\u5B9A\u70B9
 * @ignore
 */
function getSiblingPoint(view, sibling, point) {
    var normalPoint = point2Normalize(view, point);
    return sibling.getCoordinate().convert(normalPoint);
}
/**
 * \u662F\u5426\u5728\u8BB0\u5F55\u4E2D\uFF0C\u4E34\u65F6\u56E0\u4E3A\u6240\u6709\u7684 view \u4E2D\u7684\u6570\u636E\u4E0D\u662F\u5F15\u7528\uFF0C\u800C\u4F7F\u7528\u7684\u65B9\u6CD5
 * \u4E0D\u540C view \u4E0A\u5BF9\u6570\u636E\u7684\u5F15\u7528\u4E0D\u76F8\u7B49\uFF0C\u5BFC\u81F4\u65E0\u6CD5\u76F4\u63A5\u7528 includes
 * \u5047\u8BBE x, y \u503C\u76F8\u7B49\u65F6\u662F\u540C\u4E00\u6761\u6570\u636E\uFF0C\u8FD9\u4E2A\u5047\u8BBE\u4E0D\u5B8C\u5168\u6B63\u786E\uFF0C\u800C\u6539\u6210 isEqual \u5219\u6210\u672C\u592A\u9AD8
 * \u540E\u9762\u6539\u6210\u540C\u4E00\u4E2A\u5F15\u7528\u65F6\u53EF\u4EE5\u4FEE\u6539\u56DE\u6765
 * @param records
 * @param record
 * @param xFiled
 * @param yField
 * @returns
 * @ignore
 */
function isInRecords(records, record, xFiled, yField) {
    var isIn = false;
    (0,esm/* each */.S6)(records, function (r) {
        if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
            isIn = true;
            return false;
        }
    });
    return isIn;
}
// \u7EA7\u8054\u83B7\u53D6 field \u5BF9\u5E94\u7684 scale\uFF0C\u5982\u679C view \u4E0A\u6CA1\u6709\uFF0C\u904D\u5386\u5B50 view
function getScaleByField(view, field) {
    var scale = view.getScaleByField(field);
    if (!scale && view.views) {
        (0,esm/* each */.S6)(view.views, function (subView) {
            scale = getScaleByField(subView, field);
            if (scale) {
                return false; // \u7EC8\u6B62\u5FAA\u73AF
            }
        });
    }
    return scale;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/context.js


/**
 * \u4EA4\u4E92\u7684\u4E0A\u4E0B\u6587
 */
var Context = /** @class */ (function () {
    function Context(view) {
        /** \u5F53\u524D\u6240\u6709\u7684 Action */
        this.actions = [];
        /** \u5F53\u524D\u4E8B\u4EF6\u5BF9\u8C61 */
        this.event = null;
        this.cacheMap = {};
        this.view = view;
    }
    /**
     * \u7F13\u5B58\u4FE1\u606F
     * @param params \u7F13\u5B58\u7684\u5B57\u6BB5
     *  - \u5982\u679C\u4E00\u4E2A\u5B57\u6BB5\u5219\u83B7\u53D6\u7F13\u5B58
     *  - \u4E24\u4E2A\u5B57\u6BB5\u5219\u8BBE\u7F6E\u7F13\u5B58
     */
    Context.prototype.cache = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        if (params.length === 1) {
            return this.cacheMap[params[0]];
        }
        else if (params.length === 2) {
            this.cacheMap[params[0]] = params[1];
        }
    };
    /**
     * \u83B7\u53D6 Action
     * @param name Action \u7684\u540D\u79F0
     */
    Context.prototype.getAction = function (name) {
        return this.actions.find(function (action) { return action.name === name; });
    };
    /**
     * \u83B7\u53D6 Action
     * @param action Action \u5BF9\u8C61
     */
    Context.prototype.addAction = function (action) {
        this.actions.push(action);
    };
    /**
     * \u79FB\u9664 Action
     * @param action Action \u5BF9\u8C61
     */
    Context.prototype.removeAction = function (action) {
        var actions = this.actions;
        var index = this.actions.indexOf(action);
        if (index >= 0) {
            actions.splice(index, 1);
        }
    };
    /**
     * \u83B7\u53D6\u5F53\u524D\u7684\u70B9
     */
    Context.prototype.getCurrentPoint = function () {
        var event = this.event;
        if (event) {
            if (event.target instanceof HTMLElement) {
                var canvas = this.view.getCanvas();
                var point = canvas.getPointByClient(event.clientX, event.clientY);
                return point;
            }
            else {
                return {
                    x: event.x,
                    y: event.y,
                };
            }
        }
        return null;
    };
    /**
     * \u83B7\u53D6\u5F53\u524D shape
     * @returns current shape
     */
    Context.prototype.getCurrentShape = function () {
        return (0,esm/* get */.U2)(this.event, ['gEvent', 'shape']);
    };
    /**
     * \u5F53\u524D\u7684\u89E6\u53D1\u662F\u5426\u5728 View \u5185
     */
    Context.prototype.isInPlot = function () {
        var point = this.getCurrentPoint();
        if (point) {
            return this.view.isPointInPlot(point);
        }
        return false;
    };
    /**
     * \u662F\u5426\u5728\u6307\u5B9A\u7684\u56FE\u5F62\u5185
     * @param name shape \u7684 name
     */
    Context.prototype.isInShape = function (name) {
        var shape = this.getCurrentShape(); // \u4E0D\u518D\u8003\u8651\u5728 shape \u7684 parent \u5185\u7684\u60C5\u51B5
        if (shape) {
            return shape.get('name') === name;
        }
        return false;
    };
    /**
     * \u5F53\u524D\u7684\u89E6\u53D1\u662F\u7EC4\u4EF6\u5185\u90E8
     * @param name \u7EC4\u4EF6\u540D\uFF0C\u53EF\u4EE5\u4E3A\u7A7A
     */
    Context.prototype.isInComponent = function (name) {
        var components = getComponents(this.view);
        var point = this.getCurrentPoint();
        if (point) {
            return !!components.find(function (component) {
                var bbox = component.getBBox();
                if (name) {
                    return component.get('name') === name && isInBox(bbox, point);
                }
                else {
                    return isInBox(bbox, point);
                }
            });
        }
        return false;
    };
    /**
     * \u9500\u6BC1
     */
    Context.prototype.destroy = function () {
        // \u5148\u9500\u6BC1 action \u518D\u6E05\u7A7A\uFF0C\u4E00\u8FB9\u904D\u5386\uFF0C\u4E00\u8FB9\u5220\u9664\uFF0C\u6240\u4EE5\u6570\u7EC4\u9700\u8981\u66F4\u65B0\u5F15\u7528
        (0,esm/* each */.S6)(this.actions.slice(), function (action) {
            action.destroy();
        });
        this.view = null;
        this.event = null;
        this.actions = null;
        this.cacheMap = null;
    };
    return Context;
}());
/* harmony default export */ var interaction_context = (Context);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/interaction.js
/**
 * \u4EA4\u4E92\u7684\u57FA\u7C7B\u3002
 */
var Interaction = /** @class */ (function () {
    function Interaction(view, cfg) {
        this.view = view;
        this.cfg = cfg;
    }
    /**
     * \u521D\u59CB\u5316\u3002
     */
    Interaction.prototype.init = function () {
        this.initEvents();
    };
    /**
     * \u7ED1\u5B9A\u4E8B\u4EF6
     */
    Interaction.prototype.initEvents = function () { };
    /**
     * \u9500\u6BC1\u4E8B\u4EF6
     */
    Interaction.prototype.clearEvents = function () { };
    /**
     * \u9500\u6BC1\u3002
     */
    Interaction.prototype.destroy = function () {
        this.clearEvents();
    };
    return Interaction;
}());
/* harmony default export */ var interaction = (Interaction);
//# sourceMappingURL=interaction.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/grammar-interaction.js





// \u5C06\u5B57\u7B26\u4E32\u8F6C\u6362\u6210 action
function parseAction(actionStr, context, arg) {
    var arr = actionStr.split(':');
    var actionName = arr[0];
    // \u5982\u679C\u5DF2\u7ECF\u521D\u59CB\u5316\u8FC7 action \uFF0C\u5219\u76F4\u63A5\u5F15\u7528\u4E4B\u524D\u7684 action
    var action = context.getAction(actionName) || createAction(actionName, context);
    if (!action) {
        throw new Error("There is no action named ".concat(actionName));
    }
    var methodName = arr[1];
    return {
        action: action,
        methodName: methodName,
        arg: arg,
    };
}
// \u6267\u884C Action
function executeAction(actionObject) {
    var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
    if (action[methodName]) {
        action[methodName](arg);
    }
    else {
        throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
    }
}
var STEP_NAMES = {
    START: 'start',
    SHOW_ENABLE: 'showEnable',
    END: 'end',
    ROLLBACK: 'rollback',
    PROCESSING: 'processing',
};
/**
 * \u652F\u6301\u8BED\u6CD5\u7684\u4EA4\u4E92\u7C7B
 */
var GrammarInteraction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(GrammarInteraction, _super);
    function GrammarInteraction(view, steps) {
        var _this = _super.call(this, view, steps) || this;
        _this.callbackCaches = {};
        // \u67D0\u4E2A\u89E6\u53D1\u548C\u53CD\u9988\u5728\u672C\u73AF\u8282\u662F\u5426\u6267\u884C\u6216
        _this.emitCaches = {};
        _this.steps = steps;
        return _this;
    }
    /**
     * \u521D\u59CB\u5316
     */
    GrammarInteraction.prototype.init = function () {
        this.initContext();
        _super.prototype.init.call(this);
    };
    /**
     * \u6E05\u7406\u8D44\u6E90
     */
    GrammarInteraction.prototype.destroy = function () {
        _super.prototype.destroy.call(this); // \u5148\u6E05\u7406\u4E8B\u4EF6
        this.steps = null;
        if (this.context) {
            this.context.destroy();
            this.context = null;
        }
        this.callbackCaches = null;
        this.view = null;
    };
    /**
     * \u7ED1\u5B9A\u4E8B\u4EF6
     */
    GrammarInteraction.prototype.initEvents = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.steps, function (stepArr, stepName) {
            (0,esm/* each */.S6)(stepArr, function (step) {
                var callback = _this.getActionCallback(stepName, step);
                if (callback) {
                    // \u5982\u679C\u5B58\u5728 callback\uFF0C\u624D\u7ED1\u5B9A\uFF0C\u6709\u65F6\u5019\u4F1A\u51FA\u73B0\u65E0 callback \u7684\u60C5\u51B5
                    _this.bindEvent(step.trigger, callback);
                }
            });
        });
    };
    /**
     * \u6E05\u7406\u7ED1\u5B9A\u7684\u4E8B\u4EF6
     */
    GrammarInteraction.prototype.clearEvents = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.steps, function (stepArr, stepName) {
            (0,esm/* each */.S6)(stepArr, function (step) {
                var callback = _this.getActionCallback(stepName, step);
                if (callback) {
                    _this.offEvent(step.trigger, callback);
                }
            });
        });
    };
    // \u521D\u59CB\u5316\u4E0A\u4E0B\u6587\uFF0C\u5E76\u521D\u59CB\u5316 action
    GrammarInteraction.prototype.initContext = function () {
        var view = this.view;
        var context = new interaction_context(view);
        this.context = context;
        var steps = this.steps;
        // \u751F\u6210\u5177\u4F53\u7684 Action
        (0,esm/* each */.S6)(steps, function (subSteps) {
            (0,esm/* each */.S6)(subSteps, function (step) {
                if ((0,esm/* isFunction */.mf)(step.action)) {
                    // \u5982\u679C\u4F20\u5165\u56DE\u8C03\u51FD\u6570\uFF0C\u5219\u76F4\u63A5\u751F\u6210 CallbackAction
                    step.actionObject = {
                        action: createCallbackAction(step.action, context),
                        methodName: 'execute',
                    };
                }
                else if ((0,esm/* isString */.HD)(step.action)) {
                    // \u5982\u679C\u662F\u5B57\u7B26\u4E32
                    step.actionObject = parseAction(step.action, context, step.arg);
                }
                else if ((0,esm/* isArray */.kJ)(step.action)) {
                    // \u5982\u679C\u662F\u6570\u7EC4
                    var actionArr = step.action;
                    var argArr_1 = (0,esm/* isArray */.kJ)(step.arg) ? step.arg : [step.arg];
                    step.actionObject = [];
                    (0,esm/* each */.S6)(actionArr, function (actionStr, idx) {
                        step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
                    });
                }
                // \u5982\u679C action \u65E2\u4E0D\u662F\u5B57\u7B26\u4E32\uFF0C\u4E5F\u4E0D\u662F\u51FD\u6570\uFF0C\u5219\u4E0D\u4F1A\u751F\u6210 actionObject
            });
        });
    };
    // \u662F\u5426\u5141\u8BB8\u6307\u5B9A\u9636\u6BB5\u540D\u79F0\u6267\u884C
    GrammarInteraction.prototype.isAllowStep = function (stepName) {
        var currentStepName = this.currentStepName;
        var steps = this.steps;
        // \u76F8\u540C\u7684\u9636\u6BB5\u5141\u8BB8\u540C\u65F6\u6267\u884C
        if (currentStepName === stepName) {
            return true;
        }
        if (stepName === STEP_NAMES.SHOW_ENABLE) {
            // \u793A\u80FD\u5728\u6574\u4E2A\u8FC7\u7A0B\u4E2D\u90FD\u53EF\u7528
            return true;
        }
        if (stepName === STEP_NAMES.PROCESSING) {
            // \u53EA\u6709\u5F53\u524D\u662F start \u65F6\uFF0C\u624D\u5141\u8BB8 processing
            return currentStepName === STEP_NAMES.START;
        }
        if (stepName === STEP_NAMES.START) {
            // \u5982\u679C\u5F53\u524D\u662F processing\uFF0C\u5219\u65E0\u6CD5 start\uFF0C\u5FC5\u987B\u7B49\u5F85 end \u540E\u624D\u80FD\u6267\u884C
            return currentStepName !== STEP_NAMES.PROCESSING;
        }
        if (stepName === STEP_NAMES.END) {
            return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
        }
        if (stepName === STEP_NAMES.ROLLBACK) {
            if (steps[STEP_NAMES.END]) {
                // \u5982\u679C\u5B9A\u4E49\u4E86 end, \u53EA\u6709 end \u65F6\u624D\u5141\u8BB8\u56DE\u6EDA
                return currentStepName === STEP_NAMES.END;
            }
            else if (currentStepName === STEP_NAMES.START) {
                // \u5982\u679C\u672A\u5B9A\u4E49 end, \u5219\u5224\u65AD\u662F\u5426\u662F\u5F00\u59CB
                return true;
            }
        }
        return false;
    };
    // \u5177\u4F53\u7684\u6307\u5B9A\u9636\u6BB5\u662F\u5426\u5141\u8BB8\u6267\u884C
    GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {
        if (this.isAllowStep(stepName)) {
            var key = this.getKey(stepName, step);
            // \u5982\u679C\u662F\u5728\u672C\u73AF\u8282\u5185\u4EC5\u5141\u8BB8\u89E6\u53D1\u4E00\u6B21\uFF0C\u540C\u65F6\u5DF2\u7ECF\u89E6\u53D1\u8FC7\uFF0C\u5219\u4E0D\u5141\u8BB8\u518D\u89E6\u53D1
            if (step.once && this.emitCaches[key]) {
                return false;
            }
            // \u5982\u679C\u662F\u5141\u8BB8\u7684\u9636\u6BB5\uFF0C\u5219\u9A8C\u8BC1 isEnable \u65B9\u6CD5
            if (step.isEnable) {
                return step.isEnable(this.context);
            }
            return true; // \u5982\u679C\u6CA1\u6709 isEnable \u5219\u5141\u8BB8\u6267\u884C
        }
        return false;
    };
    GrammarInteraction.prototype.enterStep = function (stepName) {
        this.currentStepName = stepName;
        this.emitCaches = {}; // \u6E05\u9664\u6240\u6709\u672C\u73AF\u8282\u89E6\u53D1\u7684\u7F13\u5B58
    };
    // \u6267\u884C\u5B8C\u67D0\u4E2A\u89E6\u53D1\u548C\u53CD\u9988\uFF08\u5B50\u73AF\u8282\uFF09
    GrammarInteraction.prototype.afterExecute = function (stepName, step) {
        // show enable \u4E0D\u8BA1\u5165\u6B63\u5E38\u7684\u6D41\u7A0B\uFF0C\u5176\u4ED6\u60C5\u51B5\u5219\u8BBE\u7F6E\u5F53\u524D\u7684 step
        if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
            this.enterStep(stepName);
        }
        var key = this.getKey(stepName, step);
        // \u4E00\u65E6\u6267\u884C\uFF0C\u5219\u7F13\u5B58\u6807\u8BB0\u4E3A\uFF0C\u4E00\u76F4\u4FDD\u6301\u5230\u8DF3\u51FA\u6539\u73AF\u8282
        this.emitCaches[key] = true;
    };
    // \u83B7\u53D6\u67D0\u4E2A\u73AF\u8282\u7684\u552F\u4E00\u7684\u952E\u503C
    GrammarInteraction.prototype.getKey = function (stepName, step) {
        return stepName + step.trigger + step.action;
    };
    // \u83B7\u53D6 step \u7684\u56DE\u8C03\u51FD\u6570\uFF0C\u5982\u679C\u5DF2\u7ECF\u751F\u6210\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE\uFF0C\u5982\u679C\u672A\u751F\u6210\uFF0C\u5219\u521B\u5EFA
    GrammarInteraction.prototype.getActionCallback = function (stepName, step) {
        var _this = this;
        var context = this.context;
        var callbackCaches = this.callbackCaches;
        var actionObject = step.actionObject;
        if (step.action && actionObject) {
            var key = this.getKey(stepName, step);
            if (!callbackCaches[key]) {
                // \u52A8\u6001\u751F\u6210\u6267\u884C\u7684\u65B9\u6CD5\uFF0C\u6267\u884C\u5BF9\u5E94 action \u7684\u540D\u79F0
                var actionCallback = function (event) {
                    context.event = event; // \u4FDD\u8BC1\u68C0\u6D4B\u65F6\u7684 event
                    if (_this.isAllowExecute(stepName, step)) {
                        // \u5982\u679C\u662F\u6570\u7EC4\u65F6\uFF0C\u5219\u4F9D\u6B21\u6267\u884C
                        if ((0,esm/* isArray */.kJ)(actionObject)) {
                            (0,esm/* each */.S6)(actionObject, function (obj) {
                                context.event = event; // \u53EF\u80FD\u89E6\u53D1\u65B0\u7684\u4E8B\u4EF6\uFF0C\u4FDD\u8BC1\u6267\u884C\u524D\u7684 context.event \u662F\u6B63\u786E\u7684
                                executeAction(obj);
                            });
                        }
                        else {
                            context.event = event; // \u4FDD\u8BC1\u6267\u884C\u524D\u7684 context.event \u662F\u6B63\u786E\u7684
                            executeAction(actionObject);
                        }
                        _this.afterExecute(stepName, step);
                        if (step.callback) {
                            context.event = event; // \u4FDD\u8BC1\u6267\u884C\u524D\u7684 context.event \u662F\u6B63\u786E\u7684
                            step.callback(context);
                        }
                    }
                    else {
                        // \u5982\u679C\u672A\u901A\u8FC7\u9A8C\u8BC1\uFF0C\u5219\u4E8B\u4EF6\u4E0D\u8981\u7ED1\u5B9A\u5728\u4E0A\u9762
                        context.event = null;
                    }
                };
                // \u5982\u679C\u8BBE\u7F6E\u4E86 debounce
                if (step.debounce) {
                    callbackCaches[key] = (0,esm/* debounce */.Ds)(actionCallback, step.debounce.wait, step.debounce.immediate);
                }
                else if (step.throttle) {
                    // \u8BBE\u7F6E throttle
                    callbackCaches[key] = (0,esm/* throttle */.P2)(actionCallback, step.throttle.wait, {
                        leading: step.throttle.leading,
                        trailing: step.throttle.trailing,
                    });
                }
                else {
                    // \u76F4\u63A5\u8BBE\u7F6E
                    callbackCaches[key] = actionCallback;
                }
            }
            return callbackCaches[key];
        }
        return null;
    };
    GrammarInteraction.prototype.bindEvent = function (eventName, callback) {
        var nameArr = eventName.split(':');
        if (nameArr[0] === 'window') {
            window.addEventListener(nameArr[1], callback);
        }
        else if (nameArr[0] === 'document') {
            document.addEventListener(nameArr[1], callback);
        }
        else {
            this.view.on(eventName, callback);
        }
    };
    GrammarInteraction.prototype.offEvent = function (eventName, callback) {
        var nameArr = eventName.split(':');
        if (nameArr[0] === 'window') {
            window.removeEventListener(nameArr[1], callback);
        }
        else if (nameArr[0] === 'document') {
            document.removeEventListener(nameArr[1], callback);
        }
        else {
            this.view.off(eventName, callback);
        }
    };
    return GrammarInteraction;
}(interaction));
/* harmony default export */ var grammar_interaction = (GrammarInteraction);
//# sourceMappingURL=grammar-interaction.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/index.js
 // \u5BFC\u51FA Action \u57FA\u7C7B

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/index.js


var Interactions = {};
/**
 * \u6839\u636E\u4EA4\u4E92\u884C\u4E3A\u540D\u5B57\u83B7\u53D6\u5BF9\u5E94\u7684\u4EA4\u4E92\u7C7B
 * @param name \u4EA4\u4E92\u540D\u5B57
 * @returns \u4EA4\u4E92\u7C7B
 */
function getInteraction(name) {
    return Interactions[(0,esm/* lowerCase */.vl)(name)];
}
/**
 * \u6CE8\u518C\u4EA4\u4E92\u884C\u4E3A
 * @param name \u4EA4\u4E92\u884C\u4E3A\u540D\u5B57
 * @param interaction \u4EA4\u4E92\u7C7B
 */
function registerInteraction(name, interaction) {
    Interactions[(0,esm/* lowerCase */.vl)(name)] = interaction;
}
/**
 * \u521B\u5EFA\u4EA4\u4E92\u5B9E\u4F8B
 * @param name \u4EA4\u4E92\u540D
 * @param view \u4EA4\u4E92\u5E94\u7528\u7684 View \u5B9E\u4F8B
 * @param cfg \u4EA4\u4E92\u884C\u4E3A\u914D\u7F6E
 */
function createInteraction(name, view, cfg) {
    var interaciton = getInteraction(name);
    if (!interaciton) {
        return null;
    }
    if ((0,esm/* isPlainObject */.PO)(interaciton)) {
        // \u5982\u679C\u4E0D clone \u5219\u4F1A\u591A\u4E2A interaction \u5B9E\u4F8B\u5171\u4EAB step \u7684\u5B9A\u4E49
        var steps = (0,esm/* mix */.CD)((0,esm/* clone */.d9)(interaciton), cfg);
        return new grammar_interaction(view, steps);
    }
    else {
        var cls = interaciton;
        return new cls(view, cfg);
    }
}


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js





/**
 * \u6839\u636E\u6837\u5F0F\u8868\u521B\u5EFA axis \u7EC4\u4EF6\u4E3B\u9898\u6837\u5F0F
 * @param styleSheet
 */
function createAxisStyles(styleSheet) {
    return {
        title: {
            autoRotate: true,
            position: 'center',
            spacing: styleSheet.axisTitleSpacing,
            style: {
                fill: styleSheet.axisTitleTextFillColor,
                fontSize: styleSheet.axisTitleTextFontSize,
                lineHeight: styleSheet.axisTitleTextLineHeight,
                textBaseline: 'middle',
                fontFamily: styleSheet.fontFamily,
            },
            iconStyle: {
                fill: styleSheet.axisDescriptionIconFillColor
            }
        },
        label: {
            autoRotate: false,
            autoEllipsis: false,
            autoHide: { type: 'equidistance', cfg: { minGap: 6 } },
            offset: styleSheet.axisLabelOffset,
            style: {
                fill: styleSheet.axisLabelFillColor,
                fontSize: styleSheet.axisLabelFontSize,
                lineHeight: styleSheet.axisLabelLineHeight,
                fontFamily: styleSheet.fontFamily,
            },
        },
        line: {
            style: {
                lineWidth: styleSheet.axisLineBorder,
                stroke: styleSheet.axisLineBorderColor,
            },
        },
        grid: {
            line: {
                type: 'line',
                style: {
                    stroke: styleSheet.axisGridBorderColor,
                    lineWidth: styleSheet.axisGridBorder,
                    lineDash: styleSheet.axisGridLineDash,
                },
            },
            alignTick: true,
            animate: true,
        },
        tickLine: {
            style: {
                lineWidth: styleSheet.axisTickLineBorder,
                stroke: styleSheet.axisTickLineBorderColor,
            },
            alignTick: true,
            length: styleSheet.axisTickLineLength,
        },
        subTickLine: null,
        animate: true,
    };
}
/**
 *
 * @param styleSheet
 */
// export function
/**
 * \u6839\u636E\u6837\u5F0F\u8868\u521B\u5EFA legend \u7EC4\u4EF6\u4E3B\u9898\u6837\u5F0F
 * @param styleSheet
 */
function createLegendStyles(styleSheet) {
    return {
        title: null,
        marker: {
            symbol: 'circle',
            spacing: styleSheet.legendMarkerSpacing,
            style: {
                r: styleSheet.legendCircleMarkerSize,
                fill: styleSheet.legendMarkerColor,
            },
        },
        itemName: {
            spacing: 5,
            style: {
                fill: styleSheet.legendItemNameFillColor,
                fontFamily: styleSheet.fontFamily,
                fontSize: styleSheet.legendItemNameFontSize,
                lineHeight: styleSheet.legendItemNameLineHeight,
                fontWeight: styleSheet.legendItemNameFontWeight,
                textAlign: 'start',
                textBaseline: 'middle',
            },
        },
        itemStates: {
            active: {
                nameStyle: {
                    opacity: 0.8,
                },
            },
            unchecked: {
                nameStyle: {
                    fill: '#D8D8D8',
                },
                markerStyle: {
                    fill: '#D8D8D8',
                    stroke: '#D8D8D8',
                },
            },
            inactive: {
                nameStyle: {
                    fill: '#D8D8D8',
                },
                markerStyle: {
                    opacity: 0.2,
                },
            },
        },
        flipPage: true,
        pageNavigator: {
            marker: {
                style: {
                    size: styleSheet.legendPageNavigatorMarkerSize,
                    inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
                    inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
                    fill: styleSheet.legendPageNavigatorMarkerFillColor,
                    opacity: styleSheet.legendPageNavigatorMarkerFillOpacity,
                },
            },
            text: {
                style: {
                    fill: styleSheet.legendPageNavigatorTextFillColor,
                    fontSize: styleSheet.legendPageNavigatorTextFontSize,
                },
            },
        },
        animate: false,
        maxItemWidth: 200,
        itemSpacing: styleSheet.legendItemSpacing,
        itemMarginBottom: styleSheet.legendItemMarginBottom,
        padding: styleSheet.legendPadding, // \u56FE\u4F8B\u7EC4\u4EF6\u81EA\u5DF1\u7684\u5916\u8FB9\u8DDD
    };
}
/**
 * \u6839\u636E\u4E3B\u9898\u6837\u5F0F\u8868\u751F\u6210\u4E3B\u9898\u7ED3\u6784
 * @param styleSheet \u4E3B\u9898\u6837\u5F0F\u8868
 */
function createThemeByStyleSheet(styleSheet) {
    var _a;
    var shapeStyles = {
        point: {
            default: {
                fill: styleSheet.pointFillColor,
                r: styleSheet.pointSize,
                stroke: styleSheet.pointBorderColor,
                lineWidth: styleSheet.pointBorder,
                fillOpacity: styleSheet.pointFillOpacity,
            },
            active: {
                stroke: styleSheet.pointActiveBorderColor,
                lineWidth: styleSheet.pointActiveBorder,
            },
            selected: {
                stroke: styleSheet.pointSelectedBorderColor,
                lineWidth: styleSheet.pointSelectedBorder,
            },
            inactive: {
                fillOpacity: styleSheet.pointInactiveFillOpacity,
                strokeOpacity: styleSheet.pointInactiveBorderOpacity,
            },
        },
        hollowPoint: {
            default: {
                fill: styleSheet.hollowPointFillColor,
                lineWidth: styleSheet.hollowPointBorder,
                stroke: styleSheet.hollowPointBorderColor,
                strokeOpacity: styleSheet.hollowPointBorderOpacity,
                r: styleSheet.hollowPointSize,
            },
            active: {
                stroke: styleSheet.hollowPointActiveBorderColor,
                strokeOpacity: styleSheet.hollowPointActiveBorderOpacity,
            },
            selected: {
                lineWidth: styleSheet.hollowPointSelectedBorder,
                stroke: styleSheet.hollowPointSelectedBorderColor,
                strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity,
            },
            inactive: {
                strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity,
            },
        },
        area: {
            default: {
                fill: styleSheet.areaFillColor,
                fillOpacity: styleSheet.areaFillOpacity,
                stroke: null,
            },
            active: {
                fillOpacity: styleSheet.areaActiveFillOpacity,
            },
            selected: {
                fillOpacity: styleSheet.areaSelectedFillOpacity,
            },
            inactive: {
                fillOpacity: styleSheet.areaInactiveFillOpacity,
            },
        },
        hollowArea: {
            default: {
                fill: null,
                stroke: styleSheet.hollowAreaBorderColor,
                lineWidth: styleSheet.hollowAreaBorder,
                strokeOpacity: styleSheet.hollowAreaBorderOpacity,
            },
            active: {
                fill: null,
                lineWidth: styleSheet.hollowAreaActiveBorder,
            },
            selected: {
                fill: null,
                lineWidth: styleSheet.hollowAreaSelectedBorder,
            },
            inactive: {
                strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity,
            },
        },
        interval: {
            default: {
                fill: styleSheet.intervalFillColor,
                fillOpacity: styleSheet.intervalFillOpacity,
            },
            active: {
                stroke: styleSheet.intervalActiveBorderColor,
                lineWidth: styleSheet.intervalActiveBorder,
            },
            selected: {
                stroke: styleSheet.intervalSelectedBorderColor,
                lineWidth: styleSheet.intervalSelectedBorder,
            },
            inactive: {
                fillOpacity: styleSheet.intervalInactiveFillOpacity,
                strokeOpacity: styleSheet.intervalInactiveBorderOpacity,
            },
        },
        hollowInterval: {
            default: {
                fill: styleSheet.hollowIntervalFillColor,
                stroke: styleSheet.hollowIntervalBorderColor,
                lineWidth: styleSheet.hollowIntervalBorder,
                strokeOpacity: styleSheet.hollowIntervalBorderOpacity,
            },
            active: {
                stroke: styleSheet.hollowIntervalActiveBorderColor,
                lineWidth: styleSheet.hollowIntervalActiveBorder,
                strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity,
            },
            selected: {
                stroke: styleSheet.hollowIntervalSelectedBorderColor,
                lineWidth: styleSheet.hollowIntervalSelectedBorder,
                strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity,
            },
            inactive: {
                stroke: styleSheet.hollowIntervalInactiveBorderColor,
                lineWidth: styleSheet.hollowIntervalInactiveBorder,
                strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity,
            },
        },
        line: {
            default: {
                stroke: styleSheet.lineBorderColor,
                lineWidth: styleSheet.lineBorder,
                strokeOpacity: styleSheet.lineBorderOpacity,
                fill: null,
                lineAppendWidth: 10,
                lineCap: 'round',
                lineJoin: 'round',
            },
            active: {
                lineWidth: styleSheet.lineActiveBorder,
            },
            selected: {
                lineWidth: styleSheet.lineSelectedBorder,
            },
            inactive: {
                strokeOpacity: styleSheet.lineInactiveBorderOpacity,
            },
        },
    };
    var axisStyles = createAxisStyles(styleSheet);
    var legendStyles = createLegendStyles(styleSheet);
    return {
        background: styleSheet.backgroundColor,
        defaultColor: styleSheet.brandColor,
        subColor: styleSheet.subColor,
        semanticRed: styleSheet.paletteSemanticRed,
        semanticGreen: styleSheet.paletteSemanticGreen,
        padding: 'auto',
        fontFamily: styleSheet.fontFamily,
        // \u517C\u5BB9Theme\u914D\u7F6E
        /** \u4E00\u822C\u67F1\u72B6\u56FE\u5BBD\u5EA6\u5360\u6BD4\uFF0Cgeometry\u4E2D\u5DF2\u6DFB\u52A0\u9ED8\u8BA4\u503C\uFF0C\u4E3A\u4E86geometry\u914D\u7F6E\u751F\u6548\u9ED8\u8BA4\u503C\u4E3Anull */
        columnWidthRatio: 1 / 2,
        /** \u67F1\u72B6\u56FE\u6700\u5927\u5BBD\u5EA6 */
        maxColumnWidth: null,
        /** \u67F1\u72B6\u56FE\u6700\u5C0F\u5BBD\u5EA6 */
        minColumnWidth: null,
        /** \u73AB\u7470\u56FE\u5360\u6BD4 */
        roseWidthRatio: 0.9999999,
        /** \u591A\u5C42\u997C\u56FE/\u73AF\u56FE\u5360\u6BD4 */
        multiplePieWidthRatio: 1 / 1.3,
        colors10: styleSheet.paletteQualitative10,
        colors20: styleSheet.paletteQualitative20,
        sequenceColors: styleSheet.paletteSequence,
        shapes: {
            point: [
                'hollow-circle',
                'hollow-square',
                'hollow-bowtie',
                'hollow-diamond',
                'hollow-hexagon',
                'hollow-triangle',
                'hollow-triangle-down',
                'circle',
                'square',
                'bowtie',
                'diamond',
                'hexagon',
                'triangle',
                'triangle-down',
                'cross',
                'tick',
                'plus',
                'hyphen',
                'line',
            ],
            line: ['line', 'dash', 'dot', 'smooth'],
            area: ['area', 'smooth', 'line', 'smooth-line'],
            interval: ['rect', 'hollow-rect', 'line', 'tick'],
        },
        sizes: [1, 10],
        geometries: {
            interval: {
                rect: {
                    default: {
                        style: shapeStyles.interval.default,
                    },
                    active: {
                        style: shapeStyles.interval.active,
                    },
                    inactive: {
                        style: shapeStyles.interval.inactive,
                    },
                    selected: {
                        style: function (element) {
                            var coordinate = element.geometry.coordinate;
                            if (coordinate.isPolar && coordinate.isTransposed) {
                                var _a = getAngle(element.getModel(), coordinate), startAngle = _a.startAngle, endAngle = _a.endAngle;
                                var middleAngle = (startAngle + endAngle) / 2;
                                var r = 7.5;
                                var x = r * Math.cos(middleAngle);
                                var y = r * Math.sin(middleAngle);
                                return {
                                    matrix: ext/* transform */.vs(null, [['t', x, y]]),
                                };
                            }
                            return shapeStyles.interval.selected;
                        },
                    },
                },
                'hollow-rect': {
                    default: {
                        style: shapeStyles.hollowInterval.default,
                    },
                    active: {
                        style: shapeStyles.hollowInterval.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowInterval.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowInterval.selected,
                    },
                },
                line: {
                    default: {
                        style: shapeStyles.hollowInterval.default,
                    },
                    active: {
                        style: shapeStyles.hollowInterval.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowInterval.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowInterval.selected,
                    },
                },
                tick: {
                    default: {
                        style: shapeStyles.hollowInterval.default,
                    },
                    active: {
                        style: shapeStyles.hollowInterval.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowInterval.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowInterval.selected,
                    },
                },
                funnel: {
                    default: {
                        style: shapeStyles.interval.default,
                    },
                    active: {
                        style: shapeStyles.interval.active,
                    },
                    inactive: {
                        style: shapeStyles.interval.inactive,
                    },
                    selected: {
                        style: shapeStyles.interval.selected,
                    },
                },
                pyramid: {
                    default: {
                        style: shapeStyles.interval.default,
                    },
                    active: {
                        style: shapeStyles.interval.active,
                    },
                    inactive: {
                        style: shapeStyles.interval.inactive,
                    },
                    selected: {
                        style: shapeStyles.interval.selected,
                    },
                },
            },
            line: {
                line: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                dot: {
                    default: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] }),
                    },
                    active: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] }),
                    },
                    inactive: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] }),
                    },
                    selected: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] }),
                    },
                },
                dash: {
                    default: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] }),
                    },
                    active: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] }),
                    },
                    inactive: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] }),
                    },
                    selected: {
                        style: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] }),
                    },
                },
                smooth: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                hv: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                vh: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                hvh: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                vhv: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
            },
            polygon: {
                polygon: {
                    default: {
                        style: shapeStyles.interval.default,
                    },
                    active: {
                        style: shapeStyles.interval.active,
                    },
                    inactive: {
                        style: shapeStyles.interval.inactive,
                    },
                    selected: {
                        style: shapeStyles.interval.selected,
                    },
                },
            },
            point: {
                circle: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                square: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                bowtie: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                diamond: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                hexagon: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                triangle: {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                'triangle-down': {
                    default: {
                        style: shapeStyles.point.default,
                    },
                    active: {
                        style: shapeStyles.point.active,
                    },
                    inactive: {
                        style: shapeStyles.point.inactive,
                    },
                    selected: {
                        style: shapeStyles.point.selected,
                    },
                },
                'hollow-circle': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-square': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-bowtie': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-diamond': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-hexagon': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-triangle': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                'hollow-triangle-down': {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                cross: {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                tick: {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                plus: {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                hyphen: {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
                line: {
                    default: {
                        style: shapeStyles.hollowPoint.default,
                    },
                    active: {
                        style: shapeStyles.hollowPoint.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowPoint.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowPoint.selected,
                    },
                },
            },
            area: {
                area: {
                    default: {
                        style: shapeStyles.area.default,
                    },
                    active: {
                        style: shapeStyles.area.active,
                    },
                    inactive: {
                        style: shapeStyles.area.inactive,
                    },
                    selected: {
                        style: shapeStyles.area.selected,
                    },
                },
                smooth: {
                    default: {
                        style: shapeStyles.area.default,
                    },
                    active: {
                        style: shapeStyles.area.active,
                    },
                    inactive: {
                        style: shapeStyles.area.inactive,
                    },
                    selected: {
                        style: shapeStyles.area.selected,
                    },
                },
                line: {
                    default: {
                        style: shapeStyles.hollowArea.default,
                    },
                    active: {
                        style: shapeStyles.hollowArea.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowArea.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowArea.selected,
                    },
                },
                'smooth-line': {
                    default: {
                        style: shapeStyles.hollowArea.default,
                    },
                    active: {
                        style: shapeStyles.hollowArea.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowArea.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowArea.selected,
                    },
                },
            },
            schema: {
                candle: {
                    default: {
                        style: shapeStyles.hollowInterval.default,
                    },
                    active: {
                        style: shapeStyles.hollowInterval.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowInterval.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowInterval.selected,
                    },
                },
                box: {
                    default: {
                        style: shapeStyles.hollowInterval.default,
                    },
                    active: {
                        style: shapeStyles.hollowInterval.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowInterval.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowInterval.selected,
                    },
                },
            },
            edge: {
                line: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                vhv: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                smooth: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                arc: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
            },
            violin: {
                violin: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                smooth: {
                    default: {
                        style: shapeStyles.line.default,
                    },
                    active: {
                        style: shapeStyles.line.active,
                    },
                    inactive: {
                        style: shapeStyles.line.inactive,
                    },
                    selected: {
                        style: shapeStyles.line.selected,
                    },
                },
                hollow: {
                    default: {
                        style: shapeStyles.hollowArea.default,
                    },
                    active: {
                        style: shapeStyles.hollowArea.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowArea.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowArea.selected,
                    },
                },
                'hollow-smooth': {
                    default: {
                        style: shapeStyles.hollowArea.default,
                    },
                    active: {
                        style: shapeStyles.hollowArea.active,
                    },
                    inactive: {
                        style: shapeStyles.hollowArea.inactive,
                    },
                    selected: {
                        style: shapeStyles.hollowArea.selected,
                    },
                },
            },
        },
        components: {
            axis: {
                common: axisStyles,
                top: {
                    position: 'top',
                    grid: null,
                    title: null,
                    verticalLimitLength: 1 / 2,
                },
                bottom: {
                    position: 'bottom',
                    grid: null,
                    title: null,
                    verticalLimitLength: 1 / 2,
                },
                left: {
                    position: 'left',
                    title: null,
                    line: null,
                    tickLine: null,
                    verticalLimitLength: 1 / 3,
                },
                right: {
                    position: 'right',
                    title: null,
                    line: null,
                    tickLine: null,
                    verticalLimitLength: 1 / 3,
                },
                circle: {
                    title: null,
                    grid: (0,esm/* deepMix */.b$)({}, axisStyles.grid, { line: { type: 'line' } }),
                },
                radius: {
                    title: null,
                    grid: (0,esm/* deepMix */.b$)({}, axisStyles.grid, { line: { type: 'circle' } }),
                },
            },
            legend: {
                common: legendStyles,
                right: {
                    layout: 'vertical',
                    padding: styleSheet.legendVerticalPadding,
                },
                left: {
                    layout: 'vertical',
                    padding: styleSheet.legendVerticalPadding,
                },
                top: {
                    layout: 'horizontal',
                    padding: styleSheet.legendHorizontalPadding,
                },
                bottom: {
                    layout: 'horizontal',
                    padding: styleSheet.legendHorizontalPadding,
                },
                continuous: {
                    title: null,
                    background: null,
                    track: {},
                    rail: {
                        type: 'color',
                        size: styleSheet.sliderRailHeight,
                        defaultLength: styleSheet.sliderRailWidth,
                        style: {
                            fill: styleSheet.sliderRailFillColor,
                            stroke: styleSheet.sliderRailBorderColor,
                            lineWidth: styleSheet.sliderRailBorder,
                        },
                    },
                    label: {
                        align: 'rail',
                        spacing: 4,
                        formatter: null,
                        style: {
                            fill: styleSheet.sliderLabelTextFillColor,
                            fontSize: styleSheet.sliderLabelTextFontSize,
                            lineHeight: styleSheet.sliderLabelTextLineHeight,
                            textBaseline: 'middle',
                            fontFamily: styleSheet.fontFamily,
                        },
                    },
                    handler: {
                        size: styleSheet.sliderHandlerWidth,
                        style: {
                            fill: styleSheet.sliderHandlerFillColor,
                            stroke: styleSheet.sliderHandlerBorderColor,
                        },
                    },
                    slidable: true,
                    padding: legendStyles.padding,
                },
            },
            tooltip: {
                showContent: true,
                follow: true,
                showCrosshairs: false,
                showMarkers: true,
                shared: false,
                enterable: false,
                position: 'auto',
                marker: {
                    symbol: 'circle',
                    stroke: '#fff',
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    shadowColor: 'rgba(0,0,0,0.09)',
                    lineWidth: 2,
                    r: 4,
                },
                crosshairs: {
                    line: {
                        style: {
                            stroke: styleSheet.tooltipCrosshairsBorderColor,
                            lineWidth: styleSheet.tooltipCrosshairsBorder,
                        },
                    },
                    text: null,
                    textBackground: {
                        padding: 2,
                        style: {
                            fill: 'rgba(0, 0, 0, 0.25)',
                            lineWidth: 0,
                            stroke: null,
                        },
                    },
                    follow: false,
                },
                // tooltip dom \u6837\u5F0F
                domStyles: (_a = {},
                    _a["".concat(css_const_CONTAINER_CLASS)] = {
                        position: 'absolute',
                        visibility: 'hidden',
                        zIndex: 8,
                        transition: 'left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s',
                        backgroundColor: styleSheet.tooltipContainerFillColor,
                        opacity: styleSheet.tooltipContainerFillOpacity,
                        boxShadow: styleSheet.tooltipContainerShadow,
                        borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
                        color: styleSheet.tooltipTextFillColor,
                        fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
                        fontFamily: styleSheet.fontFamily,
                        lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
                        padding: '0 12px 0 12px',
                    },
                    _a["".concat(TITLE_CLASS)] = {
                        marginBottom: '12px',
                        marginTop: '12px',
                    },
                    _a["".concat(LIST_CLASS)] = {
                        margin: 0,
                        listStyleType: 'none',
                        padding: 0,
                    },
                    _a["".concat(LIST_ITEM_CLASS)] = {
                        listStyleType: 'none',
                        padding: 0,
                        marginBottom: '12px',
                        marginTop: '12px',
                        marginLeft: 0,
                        marginRight: 0,
                    },
                    _a["".concat(MARKER_CLASS)] = {
                        width: '8px',
                        height: '8px',
                        borderRadius: '50%',
                        display: 'inline-block',
                        marginRight: '8px',
                    },
                    _a["".concat(VALUE_CLASS)] = {
                        display: 'inline-block',
                        float: 'right',
                        marginLeft: '30px',
                    },
                    _a),
            },
            annotation: {
                arc: {
                    style: {
                        stroke: styleSheet.annotationArcBorderColor,
                        lineWidth: styleSheet.annotationArcBorder,
                    },
                    animate: true,
                },
                line: {
                    style: {
                        stroke: styleSheet.annotationLineBorderColor,
                        lineDash: styleSheet.annotationLineDash,
                        lineWidth: styleSheet.annotationLineBorder,
                    },
                    text: {
                        position: 'start',
                        autoRotate: true,
                        style: {
                            fill: styleSheet.annotationTextFillColor,
                            stroke: styleSheet.annotationTextBorderColor,
                            lineWidth: styleSheet.annotationTextBorder,
                            fontSize: styleSheet.annotationTextFontSize,
                            textAlign: 'start',
                            fontFamily: styleSheet.fontFamily,
                            textBaseline: 'bottom',
                        },
                    },
                    animate: true,
                },
                text: {
                    style: {
                        fill: styleSheet.annotationTextFillColor,
                        stroke: styleSheet.annotationTextBorderColor,
                        lineWidth: styleSheet.annotationTextBorder,
                        fontSize: styleSheet.annotationTextFontSize,
                        textBaseline: 'middle',
                        textAlign: 'start',
                        fontFamily: styleSheet.fontFamily,
                    },
                    animate: true,
                },
                region: {
                    top: false,
                    style: {
                        lineWidth: styleSheet.annotationRegionBorder,
                        stroke: styleSheet.annotationRegionBorderColor,
                        fill: styleSheet.annotationRegionFillColor,
                        fillOpacity: styleSheet.annotationRegionFillOpacity,
                    },
                    animate: true,
                },
                image: {
                    top: false,
                    animate: true,
                },
                dataMarker: {
                    top: true,
                    point: {
                        style: {
                            r: 3,
                            stroke: styleSheet.brandColor,
                            lineWidth: 2,
                        },
                    },
                    line: {
                        style: {
                            stroke: styleSheet.annotationLineBorderColor,
                            lineWidth: styleSheet.annotationLineBorder,
                        },
                        length: styleSheet.annotationDataMarkerLineLength,
                    },
                    text: {
                        style: {
                            textAlign: 'start',
                            fill: styleSheet.annotationTextFillColor,
                            stroke: styleSheet.annotationTextBorderColor,
                            lineWidth: styleSheet.annotationTextBorder,
                            fontSize: styleSheet.annotationTextFontSize,
                            fontFamily: styleSheet.fontFamily,
                        },
                    },
                    direction: 'upward',
                    autoAdjust: true,
                    animate: true,
                },
                dataRegion: {
                    style: {
                        region: {
                            fill: styleSheet.annotationRegionFillColor,
                            fillOpacity: styleSheet.annotationRegionFillOpacity,
                        },
                        text: {
                            textAlign: 'center',
                            textBaseline: 'bottom',
                            fill: styleSheet.annotationTextFillColor,
                            stroke: styleSheet.annotationTextBorderColor,
                            lineWidth: styleSheet.annotationTextBorder,
                            fontSize: styleSheet.annotationTextFontSize,
                            fontFamily: styleSheet.fontFamily,
                        },
                    },
                    animate: true,
                },
            },
            slider: {
                common: {
                    padding: [8, 8, 8, 8],
                    backgroundStyle: {
                        fill: styleSheet.cSliderBackgroundFillColor,
                        opacity: styleSheet.cSliderBackgroundFillOpacity,
                    },
                    foregroundStyle: {
                        fill: styleSheet.cSliderForegroundFillColor,
                        opacity: styleSheet.cSliderForegroundFillOpacity,
                    },
                    handlerStyle: {
                        width: styleSheet.cSliderHandlerWidth,
                        height: styleSheet.cSliderHandlerHeight,
                        fill: styleSheet.cSliderHandlerFillColor,
                        opacity: styleSheet.cSliderHandlerFillOpacity,
                        stroke: styleSheet.cSliderHandlerBorderColor,
                        lineWidth: styleSheet.cSliderHandlerBorder,
                        radius: styleSheet.cSliderHandlerBorderRadius,
                        // \u9AD8\u4EAE\u7684\u989C\u8272
                        highLightFill: styleSheet.cSliderHandlerHighlightFillColor,
                    },
                    textStyle: {
                        fill: styleSheet.cSliderTextFillColor,
                        opacity: styleSheet.cSliderTextFillOpacity,
                        fontSize: styleSheet.cSliderTextFontSize,
                        lineHeight: styleSheet.cSliderTextLineHeight,
                        fontWeight: styleSheet.cSliderTextFontWeight,
                        stroke: styleSheet.cSliderTextBorderColor,
                        lineWidth: styleSheet.cSliderTextBorder,
                    },
                },
            },
            scrollbar: {
                common: {
                    padding: [8, 8, 8, 8],
                },
                default: {
                    style: {
                        trackColor: styleSheet.scrollbarTrackFillColor,
                        thumbColor: styleSheet.scrollbarThumbFillColor,
                    },
                },
                hover: {
                    style: {
                        thumbColor: styleSheet.scrollbarThumbHighlightFillColor,
                    },
                },
            },
        },
        labels: {
            offset: 12,
            style: {
                fill: styleSheet.labelFillColor,
                fontSize: styleSheet.labelFontSize,
                fontFamily: styleSheet.fontFamily,
                stroke: styleSheet.labelBorderColor,
                lineWidth: styleSheet.labelBorder,
            },
            fillColorDark: styleSheet.labelFillColorDark,
            fillColorLight: styleSheet.labelFillColorLight,
            autoRotate: true,
        },
        innerLabels: {
            style: {
                fill: styleSheet.innerLabelFillColor,
                fontSize: styleSheet.innerLabelFontSize,
                fontFamily: styleSheet.fontFamily,
                stroke: styleSheet.innerLabelBorderColor,
                lineWidth: styleSheet.innerLabelBorder,
            },
            autoRotate: true,
        },
        overflowLabels: {
            style: {
                fill: styleSheet.overflowLabelFillColor,
                fontSize: styleSheet.overflowLabelFontSize,
                fontFamily: styleSheet.fontFamily,
                stroke: styleSheet.overflowLabelBorderColor,
                lineWidth: styleSheet.overflowLabelBorder,
            },
        },
        pieLabels: {
            labelHeight: 14,
            offset: 10,
            labelLine: {
                style: {
                    lineWidth: styleSheet.labelLineBorder,
                },
            },
            autoRotate: true,
        },
    };
}
//# sourceMappingURL=create-by-style-sheet.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/style-sheet/light.js

var BLACK_COLORS = {
    100: '#000',
    95: '#0D0D0D',
    85: '#262626',
    65: '#595959',
    45: '#8C8C8C',
    25: '#BFBFBF',
    15: '#D9D9D9',
    6: '#F0F0F0',
};
var WHITE_COLORS = {
    100: '#FFFFFF',
    95: '#F2F2F2',
    85: '#D9D9D9',
    65: '#A6A6A6',
    45: '#737373',
    25: '#404040',
    15: '#262626',
    6: '#0F0F0F',
};
var QUALITATIVE_10 = [
    '#5B8FF9',
    '#5AD8A6',
    '#5D7092',
    '#F6BD16',
    '#6F5EF9',
    '#6DC8EC',
    '#945FB9',
    '#FF9845',
    '#1E9493',
    '#FF99C3',
];
var QUALITATIVE_20 = [
    '#5B8FF9',
    '#CDDDFD',
    '#5AD8A6',
    '#CDF3E4',
    '#5D7092',
    '#CED4DE',
    '#F6BD16',
    '#FCEBB9',
    '#6F5EF9',
    '#D3CEFD',
    '#6DC8EC',
    '#D3EEF9',
    '#945FB9',
    '#DECFEA',
    '#FF9845',
    '#FFE0C7',
    '#1E9493',
    '#BBDEDE',
    '#FF99C3',
    '#FFE0ED',
];
/** \u5355\u8272\u987A\u5E8F\u8272\u677F */
var SINGLE_SEQUENCE = [
    '#B8E1FF',
    '#9AC5FF',
    '#7DAAFF',
    '#5B8FF9',
    '#3D76DD',
    '#085EC0',
    '#0047A5',
    '#00318A',
    '#001D70',
];
var createLightStyleSheet = function (cfg) {
    if (cfg === void 0) { cfg = {}; }
    var _a = cfg.paletteQualitative10, paletteQualitative10 = _a === void 0 ? QUALITATIVE_10 : _a, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
    var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
    var token = {
        /** \u56FE\u8868\u80CC\u666F\u8272 */
        backgroundColor: 'transparent',
        /** \u4E3B\u9898\u8272 */
        brandColor: brandColor,
        /** \u56FE\u8868\u8F85\u52A9\u8272 */
        subColor: 'rgba(0,0,0,0.05)',
        /** \u5206\u7C7B\u8272\u677F 1\uFF0C\u5728\u6570\u636E\u91CF\u5C0F\u4E8E\u7B49\u4E8E 10 \u65F6\u4F7F\u7528 */
        paletteQualitative10: paletteQualitative10,
        /** \u5206\u7C7B\u8272\u677F 2\uFF0C\u5728\u6570\u636E\u91CF\u5927\u4E8E 10 \u65F6\u4F7F\u7528 */
        paletteQualitative20: paletteQualitative20,
        /** \u8BED\u4E49\u8272 */
        paletteSemanticRed: '#F4664A',
        /** \u8BED\u4E49\u8272 */
        paletteSemanticGreen: '#30BF78',
        /** \u8BED\u4E49\u8272 */
        paletteSemanticYellow: '#FAAD14',
        /** (\u5355\u8272)\u987A\u5E8F\u8272\u677F */
        paletteSequence: SINGLE_SEQUENCE,
        /** \u5B57\u4F53 */
        fontFamily: "\\"Segoe UI\\", Roboto, \\"Helvetica Neue\\", Arial,\\n    \\"Noto Sans\\", sans-serif, \\"Apple Color Emoji\\", \\"Segoe UI Emoji\\", \\"Segoe UI Symbol\\",\\n    \\"Noto Color Emoji\\"",
        // -------------------- \u5750\u6807\u8F74 --------------------
        /** \u5750\u6807\u8F74\u7EBF\u989C\u8272 */
        axisLineBorderColor: BLACK_COLORS[25],
        /** \u5750\u6807\u8F74\u7EBF\u7C97\u7EC6 */
        axisLineBorder: 1,
        /** \u5750\u6807\u8F74\u7EBF lineDash \u8BBE\u7F6E */
        axisLineDash: null,
        /** \u5750\u6807\u8F74\u6807\u9898\u989C\u8272 */
        axisTitleTextFillColor: BLACK_COLORS[65],
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        axisTitleTextFontSize: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u884C\u9AD8 */
        axisTitleTextLineHeight: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        axisTitleTextFontWeight: 'normal',
        /** \u5750\u6807\u8F74\u6807\u9898\u8DDD\u79BB\u5750\u6807\u8F74\u6587\u672C\u7684\u95F4\u8DDD */
        axisTitleSpacing: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u8BE6\u7EC6\u8BF4\u660Eicon\u989C\u8272 */
        axisDescriptionIconFillColor: WHITE_COLORS[85],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u989C\u8272 */
        axisTickLineBorderColor: BLACK_COLORS[25],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u957F\u5EA6 */
        axisTickLineLength: 4,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u7C97\u7EC6 */
        axisTickLineBorder: 1,
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u989C\u8272 */
        axisSubTickLineBorderColor: BLACK_COLORS[15],
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u957F\u5EA6 */
        axisSubTickLineLength: 2,
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u7C97\u7EC6 */
        axisSubTickLineBorder: 1,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u989C\u8272 */
        axisLabelFillColor: BLACK_COLORS[45],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        axisLabelFontSize: 12,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u884C\u9AD8 */
        axisLabelLineHeight: 12,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        axisLabelFontWeight: 'normal',
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u8DDD\u79BB\u5750\u6807\u8F74\u7EBF\u7684\u95F4\u8DDD */
        axisLabelOffset: 8,
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u989C\u8272 */
        axisGridBorderColor: BLACK_COLORS[15],
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u7C97\u7EC6 */
        axisGridBorder: 1,
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u865A\u7EBF\u8BBE\u7F6E */
        axisGridLineDash: null,
        // -------------------- \u56FE\u4F8B --------------------
        /** \u56FE\u4F8B\u6807\u9898\u989C\u8272 */
        legendTitleTextFillColor: BLACK_COLORS[45],
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendTitleTextFontSize: 12,
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u884C\u9AD8 */
        legendTitleTextLineHeight: 21,
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        legendTitleTextFontWeight: 'normal',
        /** \u56FE\u4F8B marker \u989C\u8272 */
        legendMarkerColor: brandColor,
        /** \u56FE\u4F8B marker \u8DDD\u79BB\u56FE\u4F8B\u6587\u672C\u7684\u95F4\u8DDD */
        legendMarkerSpacing: 8,
        /** \u56FE\u4F8B marker \u9ED8\u8BA4\u534A\u5F84\u5927\u5C0F */
        legendMarkerSize: 4,
        /** \u56FE\u4F8B 'circle' marker \u534A\u5F84 */
        legendCircleMarkerSize: 4,
        /** \u56FE\u4F8B 'square' marker \u534A\u5F84 */
        legendSquareMarkerSize: 4,
        /** \u56FE\u4F8B 'line' marker \u534A\u5F84 */
        legendLineMarkerSize: 5,
        /** \u56FE\u4F8B\u9879\u6587\u672C\u989C\u8272 */
        legendItemNameFillColor: BLACK_COLORS[65],
        /** \u56FE\u4F8B\u9879\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendItemNameFontSize: 12,
        /** \u56FE\u4F8B\u9879\u6587\u672C\u884C\u9AD8 */
        legendItemNameLineHeight: 12,
        /** \u56FE\u4F8B\u9879\u7C97\u7EC6 */
        legendItemNameFontWeight: 'normal',
        /** \u56FE\u4F8B\u9879\u4E4B\u95F4\u7684\u6C34\u5E73\u95F4\u8DDD */
        legendItemSpacing: 24,
        /** \u56FE\u4F8B\u9879\u5782\u76F4\u65B9\u5411\u7684\u95F4\u9694 */
        legendItemMarginBottom: 12,
        /** \u56FE\u4F8B\u4E0E\u56FE\u8868\u7ED8\u56FE\u533A\u57DF\u7684\u504F\u79FB\u8DDD\u79BB  */
        legendPadding: [8, 8, 8, 8],
        /** \u6C34\u5E73\u5E03\u5C40\u7684\u56FE\u4F8B\u4E0E\u7ED8\u56FE\u533A\u57DF\u504F\u79FB\u8DDD\u79BB */
        legendHorizontalPadding: [8, 0, 8, 0],
        /** \u5782\u76F4\u5E03\u5C40\u7684\u56FE\u4F8B\u4E0E\u7ED8\u56FE\u533A\u57DF\u504F\u79FB\u8DDD\u79BB */
        legendVerticalPadding: [0, 8, 0, 8],
        // \u56FE\u4F8B\u5206\u9875\u5668
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u5927\u5C0F */
        legendPageNavigatorMarkerSize: 12,
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u975E\u6FC0\u6D3B\u72B6\u6001\u586B\u5145\u8272 */
        legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u975E\u6FC0\u6D3B\u72B6\u6001\u586B\u5145\u8272\u900F\u660E\u5EA6 */
        legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u586B\u5145\u8272 */
        legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u586B\u5145\u8272\u900F\u660E\u5EA6 */
        legendPageNavigatorMarkerFillOpacity: 1,
        /** \u56FE\u4F8B\u5206\u9875\u5668\u6587\u672C\u989C\u8272 */
        legendPageNavigatorTextFillColor: BLACK_COLORS[45],
        /** \u56FE\u4F8B\u5206\u9875\u5668\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendPageNavigatorTextFontSize: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u586B\u5145\u8272 */
        sliderRailFillColor: BLACK_COLORS[15],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u7C97\u7EC6 */
        sliderRailBorder: 0,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u989C\u8272 */
        sliderRailBorderColor: null,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u5BBD\u5EA6 */
        sliderRailWidth: 100,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u9AD8\u5EA6 */
        sliderRailHeight: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u989C\u8272 */
        sliderLabelTextFillColor: BLACK_COLORS[45],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        sliderLabelTextFontSize: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u884C\u9AD8 */
        sliderLabelTextLineHeight: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        sliderLabelTextFontWeight: 'normal',
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u989C\u8272 */
        sliderHandlerFillColor: BLACK_COLORS[6],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u5BBD\u5EA6 */
        sliderHandlerWidth: 10,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u9AD8\u5EA6 */
        sliderHandlerHeight: 14,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u7C97\u7EC6 */
        sliderHandlerBorder: 1,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u989C\u8272 */
        sliderHandlerBorderColor: BLACK_COLORS[25],
        // -------------------- Annotation\uFF0C\u56FE\u5F62\u6807\u6CE8 --------------------
        /** arc \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u989C\u8272 */
        annotationArcBorderColor: BLACK_COLORS[15],
        /** arc \u56FE\u5F62\u6807\u6CE8\u7C97\u7EC6 */
        annotationArcBorder: 1,
        /** line \u56FE\u5F62\u6807\u6CE8\u989C\u8272 */
        annotationLineBorderColor: BLACK_COLORS[25],
        /** line \u56FE\u5F62\u6807\u6CE8\u7C97\u7EC6 */
        annotationLineBorder: 1,
        /** lube \u56FE\u5F62\u6807\u6CE8\u7684\u865A\u7EBF\u95F4\u9694 */
        annotationLineDash: null,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u989C\u8272 */
        annotationTextFillColor: BLACK_COLORS[65],
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        annotationTextFontSize: 12,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u884C\u9AD8 */
        annotationTextLineHeight: 12,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        annotationTextFontWeight: 'normal',
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u8FB9\u6846\u989C\u8272 */
        annotationTextBorderColor: null,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u8FB9\u6846\u7C97\u7EC6 */
        annotationTextBorder: 0,
        /** region \u56FE\u5F62\u6807\u6CE8\u586B\u5145\u989C\u8272 */
        annotationRegionFillColor: BLACK_COLORS[100],
        /** region \u56FE\u5F62\u6807\u6CE8\u586B\u5145\u989C\u8272\u900F\u660E\u8272 */
        annotationRegionFillOpacity: 0.06,
        /** region \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u7C97\u7EC6 */
        annotationRegionBorder: 0,
        /** region \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u989C\u8272 */
        annotationRegionBorderColor: null,
        /** dataMarker \u56FE\u5F62\u6807\u6CE8\u7EBF\u7684\u957F\u5EA6 */
        annotationDataMarkerLineLength: 16,
        // -------------------- Tooltip --------------------
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u989C\u8272 */
        tooltipCrosshairsBorderColor: BLACK_COLORS[25],
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u7C97\u7EC6 */
        tooltipCrosshairsBorder: 1,
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u865A\u7EBF\u95F4\u9694 */
        tooltipCrosshairsLineDash: null,
        /** tooltip \u5185\u5BB9\u6846\u80CC\u666F\u8272 */
        tooltipContainerFillColor: 'rgb(255, 255, 255)',
        tooltipContainerFillOpacity: 0.95,
        /** tooltip \u5185\u5BB9\u6846\u9634\u5F71 */
        tooltipContainerShadow: '0px 0px 10px #aeaeae',
        /** tooltip \u5185\u5BB9\u6846\u5706\u89D2 */
        tooltipContainerBorderRadius: 3,
        /** tooltip \u6587\u672C\u989C\u8272 */
        tooltipTextFillColor: BLACK_COLORS[65],
        /** tooltip \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        tooltipTextFontSize: 12,
        /** tooltip \u6587\u672C\u884C\u9AD8 */
        tooltipTextLineHeight: 12,
        /** tooltip \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        tooltipTextFontWeight: 'bold',
        // -------------------- Geometry labels --------------------
        /** Geometry label \u6587\u672C\u989C\u8272 */
        labelFillColor: BLACK_COLORS[65],
        labelFillColorDark: '#2c3542',
        labelFillColorLight: '#ffffff',
        /** Geometry label \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        labelFontSize: 12,
        /** Geometry label \u6587\u672C\u884C\u9AD8 */
        labelLineHeight: 12,
        /** Geometry label \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        labelFontWeight: 'normal',
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        labelBorderColor: null,
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        labelBorder: 0,
        /** Geometry innerLabel \u6587\u672C\u989C\u8272 */
        innerLabelFillColor: WHITE_COLORS[100],
        /** Geometry innerLabel \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        innerLabelFontSize: 12,
        /** Geometry innerLabel \u6587\u672C\u884C\u9AD8 */
        innerLabelLineHeight: 12,
        /** Geometry innerLabel \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        innerLabelFontWeight: 'normal',
        /** Geometry innerLabel \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        innerLabelBorderColor: null,
        /** Geometry innerLabel \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        innerLabelBorder: 0,
        /** Geometry overflowLabel \u6587\u672C\u989C\u8272 */
        overflowLabelFillColor: BLACK_COLORS[65],
        /** Geometry overflowLabel \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        overflowLabelFontSize: 12,
        /** Geometry overflowLabel \u6587\u672C\u884C\u9AD8 */
        overflowLabelLineHeight: 12,
        /** Geometry overflowLabel \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        overflowLabelFontWeight: 'normal',
        /** Geometry overflowLabel \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        overflowLabelBorderColor: WHITE_COLORS[100],
        /** Geometry overflowLabel \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        overflowLabelBorder: 1,
        /** Geometry label \u6587\u672C\u8FDE\u63A5\u7EBF\u7C97\u7EC6 */
        labelLineBorder: 1,
        /** Geometry label \u6587\u672C\u8FDE\u63A5\u7EBF\u989C\u8272 */
        labelLineBorderColor: BLACK_COLORS[25],
        // -------------------- Slider \u7EC4\u4EF6\u6837\u5F0F--------------------
        /** slider \u6ED1\u9053\u9AD8\u5EA6 */
        cSliderRailHieght: 16,
        /** slider \u6ED1\u9053\u80CC\u666F\u8272 */
        cSliderBackgroundFillColor: '#416180',
        /** slider \u6ED1\u9053\u80CC\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderBackgroundFillOpacity: 0.05,
        /** slider \u6ED1\u9053\u524D\u666F\u8272 */
        cSliderForegroundFillColor: '#5B8FF9',
        /** slider \u6ED1\u9053\u524D\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderForegroundFillOpacity: 0.15,
        // slider handlerStyle \u624B\u67C4\u6837\u5F0F
        /** slider \u624B\u67C4\u9AD8\u5EA6 */
        cSliderHandlerHeight: 24,
        /** Slider \u624B\u67C4\u5BBD\u5EA6 */
        cSliderHandlerWidth: 10,
        /** Slider \u624B\u67C4\u80CC\u666F\u8272 */
        cSliderHandlerFillColor: '#F7F7F7',
        /** Slider \u624B\u67C4\u80CC\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderHandlerFillOpacity: 1,
        /** Slider \u624B\u67C4\u9AD8\u4EAE\u80CC\u666F\u8272 */
        cSliderHandlerHighlightFillColor: '#FFF',
        /** Slider \u624B\u67C4\u8FB9\u6846\u8272 */
        cSliderHandlerBorderColor: '#BFBFBF',
        /** Slider \u624B\u67C4\u8FB9\u6846\u7C97\u7EC6 */
        cSliderHandlerBorder: 1,
        /** Slider \u624B\u67C4\u8FB9\u6846\u5706\u89D2 */
        cSliderHandlerBorderRadius: 2,
        // slider textStyle \u5B57\u4F53\u6807\u7B7E\u6837\u5F0F
        /** Slider \u5B57\u4F53\u6807\u7B7E\u989C\u8272 */
        cSliderTextFillColor: '#000',
        /** Slider \u5B57\u4F53\u6807\u7B7E\u900F\u660E\u5EA6 */
        cSliderTextFillOpacity: 0.45,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u5927\u5C0F */
        cSliderTextFontSize: 12,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u884C\u9AD8 */
        cSliderTextLineHeight: 12,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u5B57\u91CD */
        cSliderTextFontWeight: 'normal',
        /** Slider \u5B57\u4F53\u6807\u7B7E\u63CF\u8FB9\u8272 */
        cSliderTextBorderColor: null,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u63CF\u8FB9\u7C97\u7EC6 */
        cSliderTextBorder: 0,
        // -------------------- Scrollbar \u7EC4\u4EF6\u6837\u5F0F--------------------
        /** \u6EDA\u52A8\u6761 \u6EDA\u9053\u586B\u5145\u8272 */
        scrollbarTrackFillColor: 'rgba(0,0,0,0)',
        /** \u6EDA\u52A8\u6761 \u6ED1\u5757\u586B\u5145\u8272 */
        scrollbarThumbFillColor: 'rgba(0,0,0,0.15)',
        /** \u6EDA\u52A8\u6761 \u6ED1\u5757\u9AD8\u4EAE\u586B\u5145\u8272 */
        scrollbarThumbHighlightFillColor: 'rgba(0,0,0,0.2)',
        // -------------------- Geometry \u56FE\u5F62\u6837\u5F0F--------------------
        /** \u70B9\u56FE\u586B\u5145\u989C\u8272 */
        pointFillColor: brandColor,
        /** \u70B9\u56FE\u586B\u5145\u989C\u8272\u900F\u660E\u5EA6 */
        pointFillOpacity: 0.95,
        /** \u70B9\u56FE\u5927\u5C0F */
        pointSize: 4,
        /** \u70B9\u56FE\u63CF\u8FB9\u7C97\u7EC6 */
        pointBorder: 1,
        /** \u70B9\u56FE\u63CF\u8FB9\u989C\u8272 */
        pointBorderColor: WHITE_COLORS[100],
        /** \u70B9\u56FE\u63CF\u8FB9\u900F\u660E\u5EA6 */
        pointBorderOpacity: 1,
        /** \u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        pointActiveBorderColor: BLACK_COLORS[100],
        /** \u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        pointSelectedBorder: 2,
        /** \u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        pointSelectedBorderColor: BLACK_COLORS[100],
        /** \u70B9\u56FE inactive \u72B6\u6001\u4E0B\u586B\u5145\u989C\u8272\u900F\u660E\u5EA6 */
        pointInactiveFillOpacity: 0.3,
        /** \u70B9\u56FE inactive \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        pointInactiveBorderOpacity: 0.3,
        /** \u7A7A\u5FC3\u70B9\u56FE\u5927\u5C0F */
        hollowPointSize: 4,
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointBorder: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u989C\u8272 */
        hollowPointBorderColor: brandColor,
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointBorderOpacity: 0.95,
        hollowPointFillColor: WHITE_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointActiveBorder: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        hollowPointActiveBorderColor: BLACK_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointActiveBorderOpacity: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointSelectedBorder: 2,
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        hollowPointSelectedBorderColor: BLACK_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointSelectedBorderOpacity: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE inactive \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointInactiveBorderOpacity: 0.3,
        /** \u7EBF\u56FE\u7C97\u7EC6 */
        lineBorder: 2,
        /** \u7EBF\u56FE\u989C\u8272 */
        lineBorderColor: brandColor,
        /** \u7EBF\u56FE\u900F\u660E\u5EA6 */
        lineBorderOpacity: 1,
        /** \u7EBF\u56FE Active \u72B6\u6001\u4E0B\u7C97\u7EC6 */
        lineActiveBorder: 3,
        /** \u7EBF\u56FE selected \u72B6\u6001\u4E0B\u7C97\u7EC6 */
        lineSelectedBorder: 3,
        /** \u7EBF\u56FE inactive \u72B6\u6001\u4E0B\u900F\u660E\u5EA6 */
        lineInactiveBorderOpacity: 0.3,
        /** area \u586B\u5145\u989C\u8272 */
        areaFillColor: brandColor,
        /** area \u586B\u5145\u900F\u660E\u5EA6 */
        areaFillOpacity: 0.25,
        /** area \u5728 active \u72B6\u6001\u4E0B\u7684\u586B\u5145\u900F\u660E\u5EA6 */
        areaActiveFillColor: brandColor,
        areaActiveFillOpacity: 0.5,
        /** area \u5728 selected \u72B6\u6001\u4E0B\u7684\u586B\u5145\u900F\u660E\u5EA6 */
        areaSelectedFillColor: brandColor,
        areaSelectedFillOpacity: 0.5,
        /** area inactive \u72B6\u6001\u4E0B\u586B\u5145\u900F\u660E\u5EA6 */
        areaInactiveFillOpacity: 0.3,
        /** hollowArea \u989C\u8272 */
        hollowAreaBorderColor: brandColor,
        /** hollowArea \u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaBorder: 2,
        /** hollowArea \u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowAreaBorderOpacity: 1,
        /** hollowArea active \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaActiveBorder: 3,
        hollowAreaActiveBorderColor: BLACK_COLORS[100],
        /** hollowArea selected \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaSelectedBorder: 3,
        hollowAreaSelectedBorderColor: BLACK_COLORS[100],
        /** hollowArea inactive \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowAreaInactiveBorderOpacity: 0.3,
        /** interval \u586B\u5145\u989C\u8272 */
        intervalFillColor: brandColor,
        /** interval \u586B\u5145\u900F\u660E\u5EA6 */
        intervalFillOpacity: 0.95,
        /** interval active \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        intervalActiveBorder: 1,
        /** interval active \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        intervalActiveBorderColor: BLACK_COLORS[100],
        intervalActiveBorderOpacity: 1,
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        intervalSelectedBorder: 2,
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        intervalSelectedBorderColor: BLACK_COLORS[100],
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        intervalSelectedBorderOpacity: 1,
        /** interval inactive \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        intervalInactiveBorderOpacity: 0.3,
        /** interval inactive \u72B6\u6001\u4E0B\u586B\u5145\u900F\u660E\u5EA6 */
        intervalInactiveFillOpacity: 0.3,
        /** interval \u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalBorder: 2,
        /** hollowInterval \u8FB9\u6846\u989C\u8272 */
        hollowIntervalBorderColor: brandColor,
        /** hollowInterval \u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalBorderOpacity: 1,
        hollowIntervalFillColor: WHITE_COLORS[100],
        /** hollowInterval active \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalActiveBorder: 2,
        /** hollowInterval active \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        hollowIntervalActiveBorderColor: BLACK_COLORS[100],
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalSelectedBorder: 3,
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalSelectedBorderOpacity: 1,
        /** hollowInterval inactive \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalInactiveBorderOpacity: 0.3,
    };
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, token), cfg);
};
var antvLight = createLightStyleSheet();
//# sourceMappingURL=light.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/util/create-theme.js




function createTheme(themeCfg) {
    var _a = themeCfg.styleSheet, styleSheetCfg = _a === void 0 ? {} : _a, themeObject = (0,tslib_es6/* __rest */._T)(themeCfg, ["styleSheet"]);
    // \u2460 \u521B\u5EFA\u6837\u5F0F\u8868 (\u9ED8\u8BA4\u521B\u5EFA light \u7684\u6837\u5F0F\u8868)
    var styleSheet = createLightStyleSheet(styleSheetCfg);
    // \u2461 \u521B\u5EFA\u4E3B\u9898
    return (0,esm/* deepMix */.b$)({}, createThemeByStyleSheet(styleSheet), themeObject);
}
//# sourceMappingURL=create-theme.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/util/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/index.js


var defaultTheme = createTheme({});
// \u6240\u6709\u5DF2\u7ECF\u5B58\u5728\u7684\u4E3B\u9898
var Themes = {
    default: defaultTheme,
};
/**
 * \u83B7\u53D6\u4E3B\u9898\u914D\u7F6E\u4FE1\u606F\u3002
 * @param theme \u4E3B\u9898\u540D
 */
function getTheme(theme) {
    return (0,esm/* get */.U2)(Themes, (0,esm/* lowerCase */.vl)(theme), Themes.default);
}
/**
 * \u6CE8\u518C\u65B0\u7684\u4E3B\u9898\u914D\u7F6E\u4FE1\u606F\u3002
 * @param theme \u4E3B\u9898\u540D\u3002
 * @param value \u5177\u4F53\u7684\u4E3B\u9898\u914D\u7F6E\u3002
 */
function registerTheme(theme, value) {
    Themes[(0,esm/* lowerCase */.vl)(theme)] = createTheme(value);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/tooltip.js




function snapEqual(v1, v2, scale) {
    var value1 = scale.translate(v1);
    var value2 = scale.translate(v2);
    return (0,esm/* isNumberEqual */.vQ)(value1, value2);
}
function getXValueByPoint(point, geometry) {
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var range = xScale.range;
    var rangeMax = range[range.length - 1];
    var rangeMin = range[0];
    var invertPoint = coordinate.invert(point);
    var xValue = invertPoint.x;
    if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
        xValue = rangeMin; // \u6781\u5750\u6807\u4E0B\uFF0Cscale \u7684 range \u88AB\u505A\u8FC7\u7279\u6B8A\u5904\u7406
    }
    return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data, point, geometry) {
    var coordinate = geometry.coordinate;
    var yScale = geometry.getYScale();
    var yField = yScale.field;
    var invertPoint = coordinate.invert(point);
    var yValue = yScale.invert(invertPoint.y);
    var result = (0,esm/* find */.sE)(data, function (obj) {
        var originData = obj[FIELD_ORIGIN];
        return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
    });
    return result || data[data.length - 1];
}
var getXDistance = (0,esm/* memoize */.HP)(function (scale) {
    if (scale.isCategory) {
        return 1;
    }
    var scaleValues = scale.values; // values \u662F\u65E0\u5E8F\u7684
    var length = scaleValues.length;
    var min = scale.translate(scaleValues[0]);
    var max = min;
    for (var index = 0; index < length; index++) {
        var value = scaleValues[index];
        // \u65F6\u95F4\u7C7B\u578B\u9700\u8981 translate
        var numericValue = scale.translate(value);
        if (numericValue < min) {
            min = numericValue;
        }
        if (numericValue > max) {
            max = numericValue;
        }
    }
    return (max - min) / (length - 1);
});
/**
 * \u83B7\u5F97 tooltip \u7684 title
 * @param originData
 * @param geometry
 * @param title
 */
function getTooltipTitle(originData, geometry, title) {
    var positionAttr = geometry.getAttribute('position');
    var fields = positionAttr.getFields();
    var scales = geometry.scales;
    var titleField = (0,esm/* isFunction */.mf)(title) || !title ? fields[0] : title;
    var titleScale = scales[titleField];
    // \u5982\u679C\u521B\u5EFA\u4E86\u8BE5\u5B57\u6BB5\u5BF9\u5E94\u7684 scale\uFF0C\u5219\u901A\u8FC7 scale.getText() \u65B9\u5F0F\u53D6\u503C\uFF0C\u56E0\u4E3A\u7528\u6237\u53EF\u80FD\u5BF9\u6570\u636E\u8FDB\u884C\u4E86\u683C\u5F0F\u5316
    // \u5982\u679C\u6CA1\u6709\u5BF9\u5E94\u7684 scale\uFF0C\u5219\u4ECE\u539F\u59CB\u6570\u636E\u4E2D\u53D6\u503C\uFF0C\u5982\u679C\u539F\u59CB\u6570\u636E\u4E2D\u4ECD\u4E0D\u5B58\u5728\uFF0C\u5219\u76F4\u63A5\u653E\u56DE title \u503C
    var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
    return (0,esm/* isFunction */.mf)(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry) {
    var attributes = (0,esm/* values */.VO)(geometry.attributes);
    return (0,esm/* filter */.hX)(attributes, function (attribute) { return (0,esm/* contains */.FX)(GROUP_ATTRS, attribute.type); });
}
function getTooltipValueScale(geometry) {
    var e_1, _a;
    var attributes = getAttributesForLegend(geometry);
    var scale;
    try {
        for (var attributes_1 = (0,tslib_es6/* __values */.XA)(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
            var attribute = attributes_1_1.value;
            var tmpScale = attribute.getScale(attribute.type);
            if (tmpScale && tmpScale.isLinear) {
                var tmpScaleDef = (0,esm/* get */.U2)(geometry.scaleDefs, tmpScale.field);
                var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);
                if (inferedScaleType !== 'cat') {
                    // \u5982\u679C\u6307\u5B9A\u5B57\u6BB5\u662F\u975E position \u7684\uFF0C\u540C\u65F6\u662F\u8FDE\u7EED\u7684
                    scale = tmpScale;
                    break;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    return scale || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
    var field = valueScale.field;
    var value = originData[field];
    if ((0,esm/* isArray */.kJ)(value)) {
        var texts = value.map(function (eachValue) {
            return valueScale.getText(eachValue);
        });
        return texts.join('-');
    }
    return valueScale.getText(value);
}
// \u6839\u636E\u539F\u59CB\u6570\u636E\u83B7\u53D6 tooltip item \u4E2D name \u503C
function getTooltipName(originData, geometry) {
    var nameScale;
    var groupScales = geometry.getGroupScales();
    if (groupScales.length) {
        // \u5982\u679C\u5B58\u5728\u5206\u7EC4\u7C7B\u578B\uFF0C\u53D6\u7B2C\u4E00\u4E2A\u5206\u7EC4\u7C7B\u578B
        nameScale = groupScales[0];
    }
    if (nameScale) {
        var field = nameScale.field;
        return nameScale.getText(originData[field]);
    }
    var valueScale = getTooltipValueScale(geometry);
    return getName(valueScale);
}
/**
 * @ignore
 * Finds data from geometry by point
 * @param point canvas point
 * @param data an item of geometry.dataArray
 * @param geometry
 * @returns
 */
function findDataByPoint(point, data, geometry) {
    if (data.length === 0) {
        return null;
    }
    var geometryType = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var xField = xScale.field;
    var yField = yScale.field;
    var rst = null;
    // \u70ED\u529B\u56FE\u91C7\u7528\u6700\u5C0F\u903C\u8FD1\u7B56\u7565\u67E5\u627E point \u51FB\u4E2D\u7684\u6570\u636E
    if (geometryType === 'heatmap' || geometryType === 'point') {
        // \u5C06 point \u753B\u5E03\u5750\u6807\u8F6C\u6362\u4E3A\u539F\u59CB\u6570\u636E\u503C
        var coordinate = geometry.coordinate;
        var invertPoint = coordinate.invert(point); // \u8F6C\u6362\u6210\u5F52\u4E00\u5316\u7684\u6570\u636E
        var x = xScale.invert(invertPoint.x); // \u8F6C\u6362\u4E3A\u539F\u59CB\u503C
        var y = yScale.invert(invertPoint.y); // \u8F6C\u6362\u4E3A\u539F\u59CB\u503C
        var min = Infinity;
        for (var index = 0; index < data.length; index++) {
            var obj = data[index];
            var originData = obj[FIELD_ORIGIN];
            var range = Math.pow((originData[xField] - x), 2) + Math.pow((originData[yField] - y), 2);
            if (range < min) {
                min = range;
                rst = obj;
            }
        }
        return rst;
    }
    // \u5176\u4ED6 Geometry \u7C7B\u578B\u6309\u7167 x \u5B57\u6BB5\u6570\u636E\u8FDB\u884C\u67E5\u627E
    var first = data[0];
    var last = data[data.length - 1];
    var xValue = getXValueByPoint(point, geometry);
    var firstXValue = first[FIELD_ORIGIN][xField];
    var firstYValue = first[FIELD_ORIGIN][yField];
    var lastXValue = last[FIELD_ORIGIN][xField];
    var isYArray = yScale.isLinear && (0,esm/* isArray */.kJ)(firstYValue); // \u8003\u8651 x \u7EF4\u5EA6\u76F8\u540C\uFF0Cy \u662F\u6570\u7EC4\u533A\u95F4\u7684\u60C5\u51B5
    // \u5982\u679C x \u7684\u503C\u662F\u6570\u7EC4
    if ((0,esm/* isArray */.kJ)(firstXValue)) {
        for (var index = 0; index < data.length; index++) {
            var record = data[index];
            var originData = record[FIELD_ORIGIN];
            // xValue \u5728 originData[xField] \u7684\u6570\u503C\u533A\u95F4\u5185
            if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
                if (isYArray) {
                    // \u5C42\u53E0\u76F4\u65B9\u56FE\u573A\u666F\uFF0Cx \u548C y \u90FD\u662F\u6570\u7EC4\u533A\u95F4
                    if (!(0,esm/* isArray */.kJ)(rst)) {
                        rst = [];
                    }
                    rst.push(record);
                }
                else {
                    rst = record;
                    break;
                }
            }
        }
        if ((0,esm/* isArray */.kJ)(rst)) {
            rst = filterYValue(rst, point, geometry);
        }
    }
    else {
        var next = void 0;
        if (!xScale.isLinear && xScale.type !== 'timeCat') {
            // x \u8F74\u5BF9\u5E94\u7684\u6570\u636E\u4E3A\u975E\u7EBF\u6027\u4EE5\u53CA\u975E\u65F6\u95F4\u7C7B\u578B\u7684\u6570\u636E\u91C7\u7528\u904D\u5386\u67E5\u627E
            for (var index = 0; index < data.length; index++) {
                var record = data[index];
                var originData = record[FIELD_ORIGIN];
                if (snapEqual(originData[xField], xValue, xScale)) {
                    if (isYArray) {
                        if (!(0,esm/* isArray */.kJ)(rst)) {
                            rst = [];
                        }
                        rst.push(record);
                    }
                    else {
                        rst = record;
                        break;
                    }
                }
                else if (xScale.translate(originData[xField]) <= xValue) {
                    last = record;
                    next = data[index + 1];
                }
            }
            if ((0,esm/* isArray */.kJ)(rst)) {
                rst = filterYValue(rst, point, geometry);
            }
        }
        else {
            // x \u8F74\u5BF9\u5E94\u7684\u6570\u636E\u4E3A\u7EBF\u6027\u4EE5\u53CA\u65F6\u95F4\u7C7B\u578B\uFF0C\u8FDB\u884C\u4E8C\u5206\u67E5\u627E\uFF0C\u6027\u80FD\u66F4\u597D
            if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&
                (xValue > xScale.max || xValue < xScale.min)) {
                // \u4E0D\u5728\u6570\u636E\u8303\u56F4\u5185
                return null;
            }
            var firstIdx = 0;
            var lastIdx = data.length - 1;
            var middleIdx = void 0;
            while (firstIdx <= lastIdx) {
                middleIdx = Math.floor((firstIdx + lastIdx) / 2);
                var item = data[middleIdx][FIELD_ORIGIN][xField];
                if (snapEqual(item, xValue, xScale)) {
                    return data[middleIdx];
                }
                if (xScale.translate(item) <= xScale.translate(xValue)) {
                    firstIdx = middleIdx + 1;
                    last = data[middleIdx];
                    next = data[middleIdx + 1];
                }
                else {
                    if (lastIdx === 0) {
                        last = data[0];
                    }
                    lastIdx = middleIdx - 1;
                }
            }
        }
        if (last && next) {
            // \u8BA1\u7B97\u6700\u903C\u8FD1\u7684
            if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >
                Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
                last = next;
            }
        }
    }
    var distance = getXDistance(geometry.getXScale()); // \u6BCF\u4E2A\u5206\u7C7B\u95F4\u7684\u5E73\u5747\u95F4\u8DDD
    if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {
        rst = last;
    }
    return rst;
}
/**
 * @ignore
 * Gets tooltip items
 * @param data
 * @param geometry
 * @param [title]
 * @returns
 */
function getTooltipItems(data, geometry, title, showNil) {
    var e_2, _a;
    if (title === void 0) { title = ''; }
    if (showNil === void 0) { showNil = false; }
    var originData = data[FIELD_ORIGIN];
    var tooltipTitle = getTooltipTitle(originData, geometry, title);
    var tooltipOption = geometry.tooltipOption;
    var defaultColor = geometry.theme.defaultColor;
    var items = [];
    var name;
    var value;
    function addItem(itemName, itemValue) {
        if (showNil || (!(0,esm/* isNil */.UM)(itemValue) && itemValue !== '')) {
            // \u503C\u4E3A null\u7684\u65F6\u5019\uFF0C\u5FFD\u89C6
            var item = {
                title: tooltipTitle,
                data: originData,
                mappingData: data,
                name: itemName,
                value: itemValue,
                color: data.color || defaultColor,
                marker: true,
            };
            items.push(item);
        }
    }
    if ((0,esm/* isObject */.Kn)(tooltipOption)) {
        var fields = tooltipOption.fields, callback = tooltipOption.callback;
        if (callback) {
            // \u7528\u6237\u5B9A\u4E49\u4E86\u56DE\u8C03\u51FD\u6570
            var callbackParams = fields.map(function (field) {
                return data[FIELD_ORIGIN][field];
            });
            var cfg = callback.apply(void 0, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(callbackParams), false));
            var itemCfg = (0,tslib_es6/* __assign */.pi)({ data: data[FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);
            items.push(itemCfg);
        }
        else {
            var scales = geometry.scales;
            try {
                for (var fields_1 = (0,tslib_es6/* __values */.XA)(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                    var field = fields_1_1.value;
                    if (!(0,esm/* isNil */.UM)(originData[field])) {
                        // \u5B57\u6BB5\u6570\u636E\u4E3Anull, undefined \u65F6\u4E0D\u663E\u793A
                        var scale = scales[field];
                        name = getName(scale);
                        value = scale.getText(originData[field]);
                        addItem(name, value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    else {
        var valueScale = getTooltipValueScale(geometry);
        // \u5B57\u6BB5\u6570\u636E\u4E3Anull ,undefined\u65F6\u4E0D\u663E\u793A
        value = getTooltipValue(originData, valueScale);
        name = getTooltipName(originData, geometry);
        addItem(name, value);
    }
    return items;
}
function getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {
    var e_3, _a;
    var showNil = tooltipCfg.showNil;
    var result = [];
    var dataArray = geometry.dataArray;
    if (!(0,esm/* isEmpty */.xb)(dataArray)) {
        geometry.sort(dataArray); // \u5148\u8FDB\u884C\u6392\u5E8F\uFF0C\u4FBF\u4E8E tooltip \u67E5\u627E
        try {
            for (var dataArray_1 = (0,tslib_es6/* __values */.XA)(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
                var data = dataArray_1_1.value;
                var record = findDataByPoint(point, data, geometry);
                if (record) {
                    var elementId = geometry.getElementId(record);
                    var element = geometry.elementsMap[elementId];
                    if (geometry.type === 'heatmap' || element.visible) {
                        // Heatmap \u6CA1\u6709 Element
                        // \u5982\u679C\u56FE\u5F62\u5143\u7D20\u9690\u85CF\u4E86\uFF0C\u600E\u4E0D\u518D tooltip \u4E0A\u5C55\u793A\u76F8\u5173\u6570\u636E
                        var items = getTooltipItems(record, geometry, title, showNil);
                        if (items.length) {
                            result.push(items);
                        }
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (dataArray_1_1 && !dataArray_1_1.done && (_a = dataArray_1.return)) _a.call(dataArray_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    return result;
}
function getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {
    var showNil = tooltipCfg.showNil;
    var result = [];
    var container = geometry.container;
    var shape = container.getShape(point.x, point.y);
    if (shape && shape.get('visible') && shape.get('origin')) {
        var mappingData = shape.get('origin').mappingData;
        var items = getTooltipItems(mappingData, geometry, title, showNil);
        if (items.length) {
            result.push(items);
        }
    }
    return result;
}
/**
 * \u4E0D\u8FDB\u884C\u9012\u5F52\u67E5\u627E
 */
function findItemsFromView(view, point, tooltipCfg) {
    var e_4, _a;
    var result = [];
    // \u5148\u4ECE view \u672C\u8EAB\u67E5\u627E
    var geometries = view.geometries;
    var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
    try {
        for (var geometries_1 = (0,tslib_es6/* __values */.XA)(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
            var geometry = geometries_1_1.value;
            if (geometry.visible && geometry.tooltipOption !== false) {
                // geometry \u53EF\u89C1\u540C\u65F6\u672A\u5173\u95ED tooltip
                var geometryType = geometry.type;
                var tooltipItems = void 0;
                if (['point', 'edge', 'polygon'].includes(geometryType)) {
                    // \u59CB\u7EC8\u901A\u8FC7\u56FE\u5F62\u62FE\u53D6
                    tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
                }
                else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {
                    // \u5982\u679C\u662F 'area', 'line', 'path'\uFF0C\u59CB\u7EC8\u901A\u8FC7\u6570\u636E\u67E5\u627E\u65B9\u6CD5\u67E5\u627E tooltip
                    tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
                }
                else {
                    if (shared !== false) {
                        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
                    }
                    else {
                        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
                    }
                }
                if (tooltipItems.length) {
                    if (reversed) {
                        tooltipItems.reverse();
                    }
                    // geometry \u6709\u53EF\u80FD\u4F1A\u6709\u591A\u4E2A item\uFF0C\u56E0\u4E3A\u7528\u6237\u53EF\u4EE5\u8BBE\u7F6E geometry.tooltip('x*y*z')
                    result.push(tooltipItems);
                }
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (geometries_1_1 && !geometries_1_1.done && (_a = geometries_1.return)) _a.call(geometries_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return result;
}
function findItemsFromViewRecurisive(view, point, tooltipCfg) {
    var e_5, _a;
    var result = findItemsFromView(view, point, tooltipCfg);
    try {
        // \u9012\u5F52\u67E5\u627E\uFF0C\u5E76\u5408\u5E76\u7ED3\u679C
        for (var _b = (0,tslib_es6/* __values */.XA)(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
            var childView = _c.value;
            result = result.concat(findItemsFromView(childView, point, tooltipCfg));
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return result;
}
//# sourceMappingURL=tooltip.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/padding.js


/**
 * @ignore
 * \u662F\u5426\u662F\u81EA\u52A8 padding
 * @param padding
 */
function isAutoPadding(padding) {
    return !(0,esm/* isNumber */.hj)(padding) && !(0,esm/* isArray */.kJ)(padding);
}
/**
 * @ignore
 * padding \u7684\u89E3\u6790\u903B\u8F91
 * @param padding
 * @return [ top, right, bottom, left ]
 */
function parsePadding(padding) {
    if (padding === void 0) { padding = 0; }
    var paddingArray = (0,esm/* isArray */.kJ)(padding) ? padding : [padding];
    switch (paddingArray.length) {
        case 0:
            paddingArray = [0, 0, 0, 0];
            break;
        case 1:
            paddingArray = new Array(4).fill(paddingArray[0]);
            break;
        case 2:
            paddingArray = (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(paddingArray), false), (0,tslib_es6/* __read */.CR)(paddingArray), false);
            break;
        case 3:
            paddingArray = (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(paddingArray), false), [paddingArray[1]], false);
            break;
        default:
            // \u5176\u4ED6\u60C5\u51B5\uFF0C\u53EA\u53BB\u56DB\u4E2A
            paddingArray = paddingArray.slice(0, 4);
            break;
    }
    return paddingArray;
}
//# sourceMappingURL=padding.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/index.js
var LOAD_COMPONENT_CONTROLLERS = {};
/**
 * \u5168\u5C40\u6CE8\u518C\u7EC4\u4EF6\u3002
 * @param name \u7EC4\u4EF6\u540D\u79F0
 * @param plugin \u6CE8\u518C\u7684\u7EC4\u4EF6\u7C7B
 * @returns void
 */
function registerComponentController(name, plugin) {
    LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
/**
 * \u5220\u9664\u5168\u5C40\u7EC4\u4EF6\u3002
 * @param name \u7EC4\u4EF6\u540D
 * @returns void
 */
function unregisterComponentController(name) {
    delete LOAD_COMPONENT_CONTROLLERS[name];
}
/**
 * \u83B7\u53D6\u4EE5\u6CE8\u518C\u7684\u7EC4\u4EF6\u540D\u3002
 * @returns string[] \u8FD4\u56DE\u5DF2\u6CE8\u518C\u7684\u7EC4\u4EF6\u540D\u79F0
 */
function getComponentControllerNames() {
    return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
/**
 * \u6839\u636E\u7EC4\u4EF6\u540D\u83B7\u53D6\u7EC4\u4EF6\u7C7B\u3002
 * @param name \u7EC4\u4EF6\u540D
 * @returns \u8FD4\u56DE\u7EC4\u4EF6\u7C7B
 */
function getComponentController(name) {
    return LOAD_COMPONENT_CONTROLLERS[name];
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/coordinate.js



/**
 * coordinate controller\uFF0C\u804C\u8D23\uFF1A
 * 1. \u521B\u5EFA\u5B9E\u4F8B
 * 2. \u6682\u5B58\u914D\u7F6E
 */
var CoordinateController = /** @class */ (function () {
    function CoordinateController(option) {
        // \u8BBE\u7F6E\u9ED8\u8BA4\u503C\uFF0C\u5E76\u5B58\u50A8\u914D\u7F6E
        this.option = this.wrapperOption(option);
    }
    /**
     * \u66F4\u65B0\u914D\u7F6E
     * @param option
     */
    CoordinateController.prototype.update = function (option) {
        this.option = this.wrapperOption(option);
        return this;
    };
    /**
     * \u662F\u5426\u5B58\u5728\u67D0\u4E00\u4E2A action
     * @param actionName
     */
    CoordinateController.prototype.hasAction = function (actionName) {
        var actions = this.option.actions;
        return (0,esm/* some */.G)(actions, function (action) { return action[0] === actionName; });
    };
    /**
     * \u521B\u5EFA\u5750\u6807\u7CFB\u5BF9\u8C61
     * @param start \u8D77\u59CB\u4F4D\u7F6E
     * @param end   \u7ED3\u675F\u4F4D\u7F6E
     * @return \u5750\u6807\u7CFB\u5B9E\u4F8B
     */
    CoordinateController.prototype.create = function (start, end) {
        var _a = this.option, type = _a.type, cfg = _a.cfg;
        var isTheta = type === 'theta';
        // 1. \u8D77\u59CB\u4F4D\u7F6E
        var props = (0,tslib_es6/* __assign */.pi)({ start: start, end: end }, cfg);
        // 2. \u521B\u5EFA\u5B9E\u4F8B
        var C = getCoordinate(isTheta ? 'polar' : type);
        this.coordinate = new C(props);
        // @ts-ignore FIXME coordinate \u5305\u95EE\u9898\u5BFC\u81F4 type \u4E0D\u6B63\u786E
        this.coordinate.type = type;
        // 3. \u6DFB\u52A0\u9ED8\u8BA4 action
        if (isTheta) {
            // \u4E0D\u5B58\u5728 transpose\uFF0C\u4E3A\u5176\u81EA\u52A8\u8BBE\u7F6E\u4E00\u4E2A action
            if (!this.hasAction('transpose')) {
                this.transpose();
            }
        }
        // 4. \u6267\u884C action
        this.execActions();
        return this.coordinate;
    };
    /**
     * \u66F4\u65B0\u5750\u6807\u7CFB\u5BF9\u8C61
     * @param start \u8D77\u59CB\u4F4D\u7F6E
     * @param end   \u7ED3\u675F\u4F4D\u7F6E
     * @return \u5750\u6807\u7CFB\u5B9E\u4F8B
     */
    CoordinateController.prototype.adjust = function (start, end) {
        this.coordinate.update({
            start: start,
            end: end,
        });
        // \u66F4\u65B0\u5750\u6807\u7CFB\u5927\u5C0F\u7684\u65F6\u5019\uFF0C\u9700\u8981\uFF1A
        // 1. \u91CD\u7F6E matrix
        // 2. \u91CD\u65B0\u6267\u884C\u4F5C\u7528\u4E8E matrix \u7684 action
        this.coordinate.resetMatrix();
        this.execActions(['scale', 'rotate', 'translate']);
        return this.coordinate;
    };
    /**
     * \u65CB\u8F6C\u5F27\u5EA6
     * @param angle
     */
    CoordinateController.prototype.rotate = function (angle) {
        this.option.actions.push(['rotate', angle]);
        return this;
    };
    /**
     * \u955C\u50CF
     * @param dim
     */
    CoordinateController.prototype.reflect = function (dim) {
        this.option.actions.push(['reflect', dim]);
        return this;
    };
    /**
     * scale
     * @param sx
     * @param sy
     */
    CoordinateController.prototype.scale = function (sx, sy) {
        this.option.actions.push(['scale', sx, sy]);
        return this;
    };
    /**
     * \u5BF9\u89D2\u53D8\u6362
     */
    CoordinateController.prototype.transpose = function () {
        this.option.actions.push(['transpose']);
        return this;
    };
    /**
     * \u83B7\u53D6\u914D\u7F6E
     */
    CoordinateController.prototype.getOption = function () {
        return this.option;
    };
    /**
     * \u83B7\u5F97 coordinate \u5B9E\u4F8B
     */
    CoordinateController.prototype.getCoordinate = function () {
        return this.coordinate;
    };
    /**
     * \u5305\u88C5\u914D\u7F6E\u7684\u9ED8\u8BA4\u503C
     * @param option
     */
    CoordinateController.prototype.wrapperOption = function (option) {
        return (0,tslib_es6/* __assign */.pi)({ type: 'rect', actions: [], cfg: {} }, option);
    };
    /**
     * coordinate \u5B9E\u4F8B\u6267\u884C actions
     * @params includeActions \u5982\u679C\u6CA1\u6709\u6307\u5B9A\uFF0C\u5219\u6267\u884C\u5168\u90E8\uFF0C\u5426\u5219\uFF0C\u6267\u884C\u6307\u5B9A\u7684 action
     */
    CoordinateController.prototype.execActions = function (includeActions) {
        var _this = this;
        var actions = this.option.actions;
        (0,esm/* each */.S6)(actions, function (action) {
            var _a;
            var _b = (0,tslib_es6/* __read */.CR)(action), actionName = _b[0], args = _b.slice(1);
            var shouldExec = (0,esm/* isNil */.UM)(includeActions) ? true : includeActions.includes(actionName);
            if (shouldExec) {
                (_a = _this.coordinate)[actionName].apply(_a, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(args), false));
            }
        });
    };
    return CoordinateController;
}());
/* harmony default export */ var controller_coordinate = (CoordinateController);
//# sourceMappingURL=coordinate.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/event.js

/**
 * @todo Whether it can(or necessary to) keep consistent with the structure of G.Event or directly use the structure of G.Event
 * G2 \u4E8B\u4EF6\u7684\u4E8B\u4EF6\u5305\u88C5\u7C7B\uFF0C\u57FA\u4E8E G.Event
 */
var Event = /** @class */ (function () {
    function Event(view, gEvent, data) {
        this.view = view;
        this.gEvent = gEvent;
        this.data = data;
        this.type = gEvent.type;
    }
    /**
     * \u975E\u4EA4\u4E92\u4EA7\u751F\u7684\u4E8B\u4EF6
     * @param view
     * @param type
     * @param data
     */
    Event.fromData = function (view, type, data) {
        return new Event(view, new g_base_esm.Event(type, {}), data);
    };
    Object.defineProperty(Event.prototype, "target", {
        // below props are proxy props of G.event convenient
        /** the real trigger shape of the event */
        get: function () {
            // @todo G \u4E2D\u4E8B\u4EF6\u5B9A\u4E49\u4E3A object \u4E0D\u6B63\u786E\uFF0C\u8FD9\u91CC\u5148 ignore
            // @ts-ignore
            return this.gEvent.target;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "event", {
        /** \u83B7\u53D6\u5BF9\u5E94\u7684 dom \u539F\u751F\u65F6\u95F4 */
        get: function () {
            return this.gEvent.originalEvent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "x", {
        /** x \u753B\u5E03\u5750\u6807 */
        get: function () {
            return this.gEvent.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "y", {
        /** y \u753B\u5E03\u5750\u6807 */
        get: function () {
            return this.gEvent.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "clientX", {
        /** x \u7A97\u53E3\u5750\u6807 */
        get: function () {
            return this.gEvent.clientX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "clientY", {
        /** y \u7A97\u53E3\u5750\u6807 */
        get: function () {
            return this.gEvent.clientY;
        },
        enumerable: false,
        configurable: true
    });
    // end for proxy events
    /**
     * event string
     * @returns string
     */
    Event.prototype.toString = function () {
        return "[Event (type=".concat(this.type, ")]");
    };
    /**
     * clone a new event with same attributes
     * @returns [[Event]]
     */
    Event.prototype.clone = function () {
        return new Event(this.view, this.gEvent, this.data);
    };
    return Event;
}());
/* harmony default export */ var chart_event = (Event);
//# sourceMappingURL=event.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/layout/index.js
/**
 * @ignore
 * G2 \u9ED8\u8BA4\u63D0\u4F9B\u7684 layout \u51FD\u6570
 * \u5185\u7F6E\u5E03\u5C40\u51FD\u6570\u5904\u7406\u7684\u903B\u8F91\uFF1A
 *
 * 1. \u5982\u679C padding = 'auto'\uFF0C\u90A3\u4E48\u81EA\u52A8\u6839\u636E\u7EC4\u4EF6\u7684 direction \u6765\u8BA1\u7B97 padding \u6570\u7EC4
 * 2. \u6839\u636E padding \u548C direction \u53BB\u5206\u914D\u5BF9\u5E94\u65B9\u5411\u7684 padding \u6570\u503C
 * 3. \u79FB\u52A8\u7EC4\u4EF6\u4F4D\u7F6E
 *
 * \u524D\u9762 1\uFF0C2 \u6B65\u9AA4\u5728 view \u4E2D\u5DF2\u7ECF\u505A\u6389\u4E86\u3002\u5BF9\u4E8E\u7EC4\u4EF6\u54CD\u5E94\u5F0F\u5E03\u5C40\uFF0C\u53EF\u4EE5\u5C1D\u8BD5\u4F7F\u7528\u7EA6\u675F\u5E03\u5C40\u7684\u65B9\u5F0F\u53BB\u6C42\u89E3\u4F4D\u7F6E\u4FE1\u606F\u3002
 * @param view
 */
function defaultLayout(view) {
    var axis = view.getController('axis');
    var legend = view.getController('legend');
    var annotation = view.getController('annotation');
    var slider = view.getController('slider');
    var scrollbar = view.getController('scrollbar');
    // \u6839\u636E\u6700\u65B0\u7684 coordinate \u91CD\u65B0\u5E03\u5C40\u7EC4\u4EF6
    [axis, slider, scrollbar, legend, annotation].forEach(function (controller) {
        if (controller) {
            controller.layout();
        }
    });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/util/scale-pool.js
/**
 * view \u4E2D\u7F13\u5B58 scale \u7684\u7C7B
 */


/** @ignore */
var ScalePool = /** @class */ (function () {
    function ScalePool() {
        /** \u6240\u6709\u7684 scales */
        this.scales = new Map();
        /** \u9700\u8981\u540C\u6B65\u7684 scale \u5206\u7EC4\uFF0C key: scaleKeyArray */
        this.syncScales = new Map();
    }
    /**
     * \u521B\u5EFA scale
     * @param field
     * @param data
     * @param scaleDef
     * @param key
     */
    ScalePool.prototype.createScale = function (field, data, scaleDef, key) {
        var finalScaleDef = scaleDef;
        var cacheScaleMeta = this.getScaleMeta(key);
        if (data.length === 0 && cacheScaleMeta) {
            // \u5728\u66F4\u65B0\u8FC7\u7A0B\u4E2D\u6570\u636E\u53D8\u4E3A\u7A7A\uFF0C\u540C\u65F6 key \u5BF9\u5E94\u7684 scale \u5DF2\u5B58\u5728\u5219\u4FDD\u6301 scale \u540C\u7C7B\u578B
            var cacheScale = cacheScaleMeta.scale;
            var cacheScaleDef = {
                type: cacheScale.type,
            };
            if (cacheScale.isCategory) {
                // \u5982\u679C\u662F\u5206\u7C7B\u7C7B\u578B\uFF0C\u4FDD\u6301 values
                cacheScaleDef.values = cacheScale.values;
            }
            finalScaleDef = (0,esm/* deepMix */.b$)(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
        }
        var scale = createScaleByField(field, data, finalScaleDef);
        // \u7F13\u5B58\u8D77\u6765
        this.cacheScale(scale, scaleDef, key);
        return scale;
    };
    /**
     * \u540C\u6B65 scale
     */
    ScalePool.prototype.sync = function (coordinate, theme) {
        var _this = this;
        // \u5BF9\u4E8E syncScales \u4E2D\u6BCF\u4E00\u4E2A syncKey \u4E0B\u9762\u7684 scale \u6570\u7EC4\u8FDB\u884C\u540C\u6B65\u5904\u7406
        this.syncScales.forEach(function (scaleKeys, syncKey) {
            // min, max, values, ranges
            var min = Number.MAX_SAFE_INTEGER;
            var max = Number.MIN_SAFE_INTEGER;
            var values = [];
            // 1. \u904D\u5386\u6C42\u5F97\u6700\u5927\u6700\u5C0F\u503C\uFF0Cvalues \u7B49
            (0,esm/* each */.S6)(scaleKeys, function (key) {
                var scale = _this.getScale(key);
                max = (0,esm/* isNumber */.hj)(scale.max) ? Math.max(max, scale.max) : max;
                min = (0,esm/* isNumber */.hj)(scale.min) ? Math.min(min, scale.min) : min;
                // \u53BB\u91CD
                (0,esm/* each */.S6)(scale.values, function (v) {
                    if (!values.includes(v)) {
                        values.push(v);
                    }
                });
            });
            // 2. \u540C\u6B65
            (0,esm/* each */.S6)(scaleKeys, function (key) {
                var scale = _this.getScale(key);
                if (scale.isContinuous) {
                    scale.change({
                        min: min,
                        max: max,
                        values: values,
                    });
                }
                else if (scale.isCategory) {
                    var range = scale.range;
                    var cacheScaleMeta = _this.getScaleMeta(key);
                    // \u5B58\u5728 value \u503C\uFF0C\u4E14\u7528\u6237\u6CA1\u6709\u914D\u7F6E range \u914D\u7F6E to fix https://github.com/antvis/G2/issues/2996
                    if (values && !(0,esm/* get */.U2)(cacheScaleMeta, ['scaleDef', 'range'])) {
                        // \u66F4\u65B0 range
                        range = getDefaultCategoryScaleRange((0,esm/* deepMix */.b$)({}, scale, {
                            values: values,
                        }), coordinate, theme);
                    }
                    scale.change({
                        values: values,
                        range: range,
                    });
                }
            });
        });
    };
    /**
     * \u7F13\u5B58\u4E00\u4E2A scale
     * @param scale
     * @param scaleDef
     * @param key
     */
    ScalePool.prototype.cacheScale = function (scale, scaleDef, key) {
        // 1. \u7F13\u5B58\u5230 scales
        var sm = this.getScaleMeta(key);
        // \u5B58\u5728\u5219\u66F4\u65B0\uFF0C\u540C\u65F6\u68C0\u6D4B\u7C7B\u578B\u662F\u5426\u4E00\u81F4
        if (sm && sm.scale.type === scale.type) {
            syncScale(sm.scale, scale);
            sm.scaleDef = scaleDef;
            // \u66F4\u65B0 scaleDef
        }
        else {
            sm = {
                key: key,
                scale: scale,
                scaleDef: scaleDef,
            };
            this.scales.set(key, sm);
        }
        // 2. \u7F13\u5B58\u5230 syncScales\uFF0C\u6784\u9020 Record<sync, string[]> \u6570\u636E\u7ED3\u6784
        var syncKey = this.getSyncKey(sm);
        sm.syncKey = syncKey; // \u8BBE\u7F6E sync \u540C\u6B65\u7684 key
        // \u56E0\u4E3A\u5B58\u5728\u66F4\u65B0 scale \u673A\u5236\uFF0C\u6240\u4EE5\u5728\u7F13\u5B58\u4E4B\u524D\uFF0C\u5148\u4ECE\u539F syncScales \u4E2D\u53BB\u9664 sync \u7684\u7F13\u5B58\u5F15\u7528
        this.removeFromSyncScales(key);
        // \u5B58\u5728 sync \u6807\u8BB0\u624D\u8FDB\u884C sync
        if (syncKey) {
            // \u4E0D\u5B58\u5728\u8FD9\u4E2A syncKey\uFF0C\u5219\u521B\u5EFA\u4E00\u4E2A\u7A7A\u6570\u7EC4
            var scaleKeys = this.syncScales.get(syncKey);
            if (!scaleKeys) {
                scaleKeys = [];
                this.syncScales.set(syncKey, scaleKeys);
            }
            scaleKeys.push(key);
        }
    };
    /**
     * \u901A\u8FC7 key \u83B7\u53D6 scale
     * @param key
     */
    ScalePool.prototype.getScale = function (key) {
        var scaleMeta = this.getScaleMeta(key);
        if (!scaleMeta) {
            var field = (0,esm/* last */.Z$)(key.split('-'));
            var scaleKeys = this.syncScales.get(field);
            if (scaleKeys && scaleKeys.length) {
                scaleMeta = this.getScaleMeta(scaleKeys[0]);
            }
        }
        return scaleMeta && scaleMeta.scale;
    };
    /**
     * \u5728 view \u9500\u6BC1\u7684\u65F6\u5019\uFF0C\u5220\u9664 scale \u5B9E\u4F8B\uFF0C\u9632\u6B62\u5185\u5B58\u6CC4\u9732
     * @param key
     */
    ScalePool.prototype.deleteScale = function (key) {
        var scaleMeta = this.getScaleMeta(key);
        if (scaleMeta) {
            var syncKey = scaleMeta.syncKey;
            var scaleKeys = this.syncScales.get(syncKey);
            // \u79FB\u9664\u540C\u6B65\u7684\u5173\u7CFB
            if (scaleKeys && scaleKeys.length) {
                var idx = scaleKeys.indexOf(key);
                if (idx !== -1) {
                    scaleKeys.splice(idx, 1);
                }
            }
        }
        // \u5220\u9664 scale \u5B9E\u4F8B
        this.scales.delete(key);
    };
    /**
     * \u6E05\u7A7A
     */
    ScalePool.prototype.clear = function () {
        this.scales.clear();
        this.syncScales.clear();
    };
    /**
     * \u5220\u9664 sync scale \u5F15\u7528
     * @param key
     */
    ScalePool.prototype.removeFromSyncScales = function (key) {
        var _this = this;
        this.syncScales.forEach(function (scaleKeys, syncKey) {
            var idx = scaleKeys.indexOf(key);
            if (idx !== -1) {
                scaleKeys.splice(idx, 1);
                // \u5220\u9664\u7A7A\u6570\u7EC4\u503C
                if (scaleKeys.length === 0) {
                    _this.syncScales.delete(syncKey);
                }
                return false; // \u8DF3\u51FA\u5FAA\u73AF
            }
        });
    };
    /**
     * get sync key
     * @param sm
     */
    ScalePool.prototype.getSyncKey = function (sm) {
        var scale = sm.scale, scaleDef = sm.scaleDef;
        var field = scale.field;
        var sync = (0,esm/* get */.U2)(scaleDef, ['sync']);
        // \u5982\u679C sync = true\uFF0C\u5219\u76F4\u63A5\u4F7F\u7528\u5B57\u6BB5\u540D\u4F5C\u4E3A syncKey
        return sync === true ? field : sync === false ? undefined : sync;
    };
    /**
     * \u901A\u8FC7 key \u83B7\u53D6 scale
     * @param key
     */
    ScalePool.prototype.getScaleMeta = function (key) {
        return this.scales.get(key);
    };
    return ScalePool;
}());

//# sourceMappingURL=scale-pool.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/layout/padding-cal.js


/** @ignore */
var PaddingCal = /** @class */ (function () {
    /**
     * \u521D\u59CB\u7684 padding \u6570\u636E
     * @param top
     * @param right
     * @param bottom
     * @param left
     */
    function PaddingCal(top, right, bottom, left) {
        if (top === void 0) { top = 0; }
        if (right === void 0) { right = 0; }
        if (bottom === void 0) { bottom = 0; }
        if (left === void 0) { left = 0; }
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
    }
    /**
     * \u4F7F\u7528\u9759\u6001\u65B9\u6CD5\u521B\u5EFA\u4E00\u4E2A
     * @param top
     * @param right
     * @param bottom
     * @param left
     */
    PaddingCal.instance = function (top, right, bottom, left) {
        if (top === void 0) { top = 0; }
        if (right === void 0) { right = 0; }
        if (bottom === void 0) { bottom = 0; }
        if (left === void 0) { left = 0; }
        return new PaddingCal(top, right, bottom, left);
    };
    /**
     * \u53D6\u6700\u5927\u533A\u95F4
     * @param padding
     */
    PaddingCal.prototype.max = function (padding) {
        var _a = (0,tslib_es6/* __read */.CR)(padding, 4), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
        this.top = Math.max(this.top, top);
        this.right = Math.max(this.right, right);
        this.bottom = Math.max(this.bottom, bottom);
        this.left = Math.max(this.left, left);
        return this;
    };
    /**
     * \u56DB\u5468\u589E\u52A0 padding
     * @param padding
     */
    PaddingCal.prototype.shrink = function (padding) {
        var _a = (0,tslib_es6/* __read */.CR)(padding, 4), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
        this.top += top;
        this.right += right;
        this.bottom += bottom;
        this.left += left;
        return this;
    };
    /**
     * \u5728\u67D0\u4E00\u4E2A\u65B9\u5411\u589E\u52A0 padding
     * @param bbox
     * @param direction
     */
    PaddingCal.prototype.inc = function (bbox, direction) {
        var width = bbox.width, height = bbox.height;
        switch (direction) {
            case constant_DIRECTION.TOP:
            case constant_DIRECTION.TOP_LEFT:
            case constant_DIRECTION.TOP_RIGHT:
                this.top += height;
                break;
            case constant_DIRECTION.RIGHT:
            case constant_DIRECTION.RIGHT_TOP:
            case constant_DIRECTION.RIGHT_BOTTOM:
                this.right += width;
                break;
            case constant_DIRECTION.BOTTOM:
            case constant_DIRECTION.BOTTOM_LEFT:
            case constant_DIRECTION.BOTTOM_RIGHT:
                this.bottom += height;
                break;
            case constant_DIRECTION.LEFT:
            case constant_DIRECTION.LEFT_TOP:
            case constant_DIRECTION.LEFT_BOTTOM:
                this.left += width;
                break;
            default:
                break;
        }
        return this;
    };
    /**
     * \u83B7\u5F97\u6700\u7EC8\u7684 padding
     */
    PaddingCal.prototype.getPadding = function () {
        return [this.top, this.right, this.bottom, this.left];
    };
    /**
     * clone \u4E00\u4E2A padding cal
     */
    PaddingCal.prototype.clone = function () {
        return new (PaddingCal.bind.apply(PaddingCal, (0,tslib_es6/* __spreadArray */.ev)([void 0], (0,tslib_es6/* __read */.CR)(this.getPadding()), false)))();
    };
    return PaddingCal;
}());

//# sourceMappingURL=padding-cal.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/layout/auto.js






/**
 * @ignore
 * \u6839\u636E view \u4E2D\u7684\u7EC4\u4EF6\uFF0C\u8BA1\u7B97\u5B9E\u9645\u7684 padding \u6570\u503C
 * @param view
 */
function calculatePadding(view) {
    var padding = view.padding;
    // \u5982\u679C\u4E0D\u662F auto padding\uFF0C\u90A3\u4E48\u76F4\u63A5\u89E3\u6790\u4E4B\u540E\u8FD4\u56DE
    if (!isAutoPadding(padding)) {
        return new (PaddingCal.bind.apply(PaddingCal, (0,tslib_es6/* __spreadArray */.ev)([void 0], (0,tslib_es6/* __read */.CR)(parsePadding(padding)), false)))();
    }
    // \u662F auto padding\uFF0C\u6839\u636E\u7EC4\u4EF6\u7684\u60C5\u51B5\uFF0C\u6765\u8BA1\u7B97 padding
    var viewBBox = view.viewBBox;
    var paddingCal = new PaddingCal();
    var axisComponents = [];
    var paddingComponents = [];
    var otherComponents = [];
    (0,esm/* each */.S6)(view.getComponents(), function (co) {
        var type = co.type;
        if (type === COMPONENT_TYPE.AXIS) {
            axisComponents.push(co);
        }
        else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
            paddingComponents.push(co);
        }
        else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
            otherComponents.push(co);
        }
    });
    // \u8FDB\u884C\u5750\u6807\u8F74\u5E03\u5C40\uFF0C\u5E94\u8BE5\u662F\u53D6 padding \u7684\u5E76\u96C6\uFF0C\u800C\u4E0D\u662F\u8FDB\u884C\u76F8\u52A0
    (0,esm/* each */.S6)(axisComponents, function (co) {
        var component = co.component;
        var bboxObject = component.getLayoutBBox();
        var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
        var exceed = componentBBox.exceed(viewBBox);
        // \u5728\u5BF9\u7EC4\u4EF6\u5206\u7EC4\u4E4B\u540E\uFF0C\u5148\u5BF9 axis \u8FDB\u884C\u5904\u7406\uFF0C\u7136\u540E\u53D6\u6700\u5927\u7684\u8D85\u51FA\u5373\u53EF\u3002
        paddingCal.max(exceed);
    });
    // \u6709 padding \u7684\u7EC4\u4EF6\u5E03\u5C40
    (0,esm/* each */.S6)(paddingComponents, function (co) {
        var component = co.component, direction = co.direction;
        var bboxObject = component.getLayoutBBox();
        var componentPadding = component.get('padding');
        var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
        // \u6309\u7167\u65B9\u5411\u8BA1\u7B97 padding
        paddingCal.inc(componentBBox, direction);
    });
    // \u5176\u4ED6\u7EC4\u4EF6\u5E03\u5C40
    (0,esm/* each */.S6)(otherComponents, function (co) {
        var component = co.component, direction = co.direction;
        var bboxObject = component.getLayoutBBox();
        var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
        // \u6309\u7167\u65B9\u5411\u8BA1\u7B97 padding
        paddingCal.inc(componentBBox, direction);
    });
    return paddingCal;
}
//# sourceMappingURL=auto.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
/**
 * \u9ED8\u8BA4\u7684 syncViewPadding \u903B\u8F91
 * @param chart
 * @param views
 * @param PC: PaddingCalCtor
 */
function defaultSyncViewPadding(chart, views, PC) {
    var syncPadding = PC.instance();
    // \u6240\u6709\u7684 view \u7684 autoPadding \u6307\u5411\u540C\u4E00\u4E2A\u5F15\u7528
    views.forEach(function (v) {
        v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
    });
}
//# sourceMappingURL=sync-view-padding.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/view.js






















/**
 * G2 \u89C6\u56FE View \u7C7B
 */
var View = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(View, _super);
    function View(props) {
        var _this = _super.call(this, { visible: props.visible }) || this;
        /** \u6240\u6709\u7684\u5B50 view\u3002 */
        _this.views = [];
        /** \u6240\u6709\u7684 geometry \u5B9E\u4F8B\u3002 */
        _this.geometries = [];
        /** \u6240\u6709\u7684\u7EC4\u4EF6 controllers\u3002 */
        _this.controllers = [];
        /** \u6240\u6709\u7684 Interaction \u5B9E\u4F8B\u3002 */
        _this.interactions = {};
        /** \u662F\u5426\u5BF9\u8D85\u51FA\u5750\u6807\u7CFB\u8303\u56F4\u7684 Geometry \u8FDB\u884C\u526A\u5207 */
        _this.limitInPlot = false;
        // \u914D\u7F6E\u4FE1\u606F\u5B58\u50A8
        _this.options = {
            data: [],
            animate: true, // \u9ED8\u8BA4\u5F00\u542F\u52A8\u753B
        }; // \u521D\u59CB\u5316\u4E3A\u7A7A
        /** \u914D\u7F6E\u5F00\u542F\u7684\u7EC4\u4EF6\u63D2\u4EF6\uFF0C\u9ED8\u8BA4\u4E3A\u5168\u5C40\u914D\u7F6E\u7684\u7EC4\u4EF6\u3002 */
        _this.usedControllers = getComponentControllerNames();
        /** \u6240\u6709\u7684 scales */
        _this.scalePool = new ScalePool();
        /** \u5E03\u5C40\u51FD\u6570 */
        _this.layoutFunc = defaultLayout;
        /** \u5F53\u524D\u9F20\u6807\u662F\u5426\u5728 plot \u5185\uFF08CoordinateBBox\uFF09 */
        _this.isPreMouseInPlot = false;
        /** \u9ED8\u8BA4\u6807\u8BC6\u4F4D\uFF0C\u7528\u4E8E\u5224\u5B9A\u6570\u636E\u662F\u5426\u66F4\u65B0 */
        _this.isDataChanged = false;
        /** \u7528\u4E8E\u5224\u65AD\u5750\u6807\u7CFB\u8303\u56F4\u662F\u5426\u53D1\u751F\u53D8\u5316\u7684\u6807\u5FD7\u4F4D */
        _this.isCoordinateChanged = false;
        /** \u4ECE\u5F53\u524D\u8FD9\u4E2A view \u521B\u5EFA\u7684 scale key */
        _this.createdScaleKeys = new Map();
        _this.onCanvasEvent = function (evt) {
            var name = evt.name;
            if (!name.includes(':')) {
                // \u975E\u59D4\u6258\u4E8B\u4EF6
                var e = _this.createViewEvent(evt);
                // \u5904\u7406 plot \u4E8B\u4EF6
                _this.doPlotEvent(e);
                _this.emit(name, e);
            }
        };
        /**
         * \u89E6\u53D1\u4E8B\u4EF6\u4E4B\u540E
         * @param evt
         */
        _this.onDelegateEvents = function (evt) {
            // \u963B\u6B62\u7EE7\u7EED\u5192\u6CE1\uFF0C\u9632\u6B62\u91CD\u590D\u4E8B\u4EF6\u89E6\u53D1
            // evt.preventDefault();
            var name = evt.name;
            if (!name.includes(':')) {
                return;
            }
            // \u4E8B\u4EF6\u5728 view \u5D4C\u5957\u4E2D\u5192\u6CE1\uFF08\u6682\u4E0D\u63D0\u4F9B\u963B\u6B62\u5192\u6CE1\u7684\u673A\u5236\uFF09
            var e = _this.createViewEvent(evt);
            // \u5305\u542B\u6709\u57FA\u672C\u4E8B\u4EF6\u3001\u7EC4\u5408\u4E8B\u4EF6
            _this.emit(name, e);
            // const currentTarget = evt.currentTarget as IShape;
            // const inheritNames = currentTarget.get('inheritNames');
            // if (evt.delegateObject || inheritNames) {
            //   const events = this.getEvents();
            //   each(inheritNames, (subName) => {
            //     const eventName = \`\${subName}:\${type}\`;
            //     if (events[eventName]) {
            //       this.emit(eventName, e);
            //     }
            //   });
            // }
        };
        var _a = props.id, id = _a === void 0 ? (0,esm/* uniqueId */.EL)('view') : _a, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding = props.padding, appendPadding = props.appendPadding, theme = props.theme, options = props.options, limitInPlot = props.limitInPlot, syncViewPadding = props.syncViewPadding;
        _this.parent = parent;
        _this.canvas = canvas;
        _this.backgroundGroup = backgroundGroup;
        _this.middleGroup = middleGroup;
        _this.foregroundGroup = foregroundGroup;
        _this.region = region;
        _this.padding = padding;
        _this.appendPadding = appendPadding;
        // \u63A5\u53D7\u7236 view \u4F20\u5165\u7684\u53C2\u6570
        _this.options = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, _this.options), options);
        _this.limitInPlot = limitInPlot;
        _this.id = id;
        _this.syncViewPadding = syncViewPadding;
        // \u521D\u59CB\u5316 theme
        _this.themeObject = (0,esm/* isObject */.Kn)(theme) ? (0,esm/* deepMix */.b$)({}, getTheme('default'), createTheme(theme)) : getTheme(theme);
        _this.init();
        return _this;
    }
    /**
     * \u8BBE\u7F6E layout \u5E03\u5C40\u51FD\u6570
     * @param layout \u5E03\u5C40\u51FD\u6570
     * @returns void
     */
    View.prototype.setLayout = function (layout) {
        this.layoutFunc = layout;
    };
    /**
     * \u751F\u547D\u5468\u671F\uFF1A\u521D\u59CB\u5316
     * @returns voids
     */
    View.prototype.init = function () {
        // \u8BA1\u7B97\u753B\u5E03\u7684 viewBBox
        this.calculateViewBBox();
        // \u4E8B\u4EF6\u59D4\u6258\u673A\u5236
        this.initEvents();
        // \u521D\u59CB\u5316\u7EC4\u4EF6 controller
        this.initComponentController();
        this.initOptions();
    };
    /**
     * \u751F\u547D\u5468\u671F\uFF1A\u6E32\u67D3\u6D41\u7A0B\uFF0C\u6E32\u67D3\u8FC7\u7A0B\u9700\u8981\u5904\u7406\u6570\u636E\u66F4\u65B0\u7684\u60C5\u51B5\u3002
     * render \u51FD\u6570\u4EC5\u4EC5\u4F1A\u5904\u7406 view \u548C\u5B50 view\u3002
     * @param isUpdate \u662F\u5426\u89E6\u53D1\u66F4\u65B0\u6D41\u7A0B\u3002
     * @param params render \u4E8B\u4EF6\u53C2\u6570
     */
    View.prototype.render = function (isUpdate, payload) {
        if (isUpdate === void 0) { isUpdate = false; }
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, chart_event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
        // \u9012\u5F52\u6E32\u67D3
        this.paint(isUpdate);
        this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, chart_event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
        if (this.visible === false) {
            // \u7528\u6237\u5728\u521D\u59CB\u5316\u7684\u65F6\u5019\u58F0\u660E visible: false
            this.changeVisible(false);
        }
    };
    /**
     * \u751F\u547D\u5468\u671F\uFF1A\u6E05\u7A7A\u56FE\u8868\u4E0A\u6240\u6709\u7684\u7ED8\u5236\u5185\u5BB9\uFF0C\u4F46\u662F\u4E0D\u9500\u6BC1\u56FE\u8868\uFF0Cchart \u4ECD\u53EF\u4F7F\u7528\u3002
     * @returns void
     */
    View.prototype.clear = function () {
        var _this = this;
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
        // 1. \u6E05\u7A7A\u7F13\u5B58\u548C\u8BA1\u7B97\u6570\u636E
        this.filteredData = [];
        this.coordinateInstance = undefined;
        this.isDataChanged = false; // \u590D\u4F4D
        this.isCoordinateChanged = false; // \u590D\u4F4D
        // 2. \u6E05\u7A7A geometries
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
            geometries[i].clear();
            // view \u4E2D\u4F7F\u7528 geometry \u7684\u65F6\u5019\uFF0C\u8FD8\u9700\u8981\u6E05\u7A7A\u5B83\u7684\u5BB9\u5668\uFF0C\u4E0D\u7136\u4E0B\u4E00\u6B21 chart.geometry() \u7684\u65F6\u5019\uFF0C\u53C8\u521B\u5EFA\u4E86\u4E00\u4E2A\uFF0C\u5BFC\u81F4\u6CC4\u9732\uFF0C #2799\u3002
            geometries[i].container.remove(true);
            geometries[i].labelsContainer.remove(true);
        }
        this.geometries = [];
        // 3. \u6E05\u7A7A controllers
        var controllers = this.controllers;
        for (var i = 0; i < controllers.length; i++) {
            if (controllers[i].name === 'annotation') {
                // \u9700\u8981\u6E05\u7A7A\u914D\u7F6E\u9879
                controllers[i].clear(true);
            }
            else {
                controllers[i].clear();
            }
        }
        // 4. \u5220\u9664 scale \u7F13\u5B58
        this.createdScaleKeys.forEach(function (v, k) {
            _this.getRootView().scalePool.deleteScale(k);
        });
        this.createdScaleKeys.clear();
        // \u9012\u5F52\u5904\u7406\u5B50 view
        var views = this.views;
        for (var i = 0; i < views.length; i++) {
            views[i].clear();
        }
        this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
    };
    /**
     * \u751F\u547D\u5468\u671F\uFF1A\u9500\u6BC1\uFF0C\u5B8C\u5168\u65E0\u6CD5\u4F7F\u7528\u3002
     * @returns void
     */
    View.prototype.destroy = function () {
        // \u9500\u6BC1\u524D\u4E8B\u4EF6\uFF0C\u9500\u6BC1\u4E4B\u540E\u5DF2\u7ECF\u6CA1\u6709\u610F\u4E49\u4E86\uFF0C\u6240\u4EE5\u4E0D\u629B\u51FA\u4E8B\u4EF6
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
        var interactions = this.interactions;
        // \u9500\u6BC1 interactions
        (0,esm/* each */.S6)(interactions, function (interaction) {
            if (interaction) {
                // \u6709\u53EF\u80FD\u5DF2\u7ECF\u9500\u6BC1\uFF0C\u8BBE\u7F6E\u4E86 undefined
                interaction.destroy();
            }
        });
        this.clear();
        // \u9500\u6BC1 controller \u4E2D\u7684\u7EC4\u4EF6
        var controllers = this.controllers;
        for (var i = 0, len = controllers.length; i < len; i++) {
            var controller = controllers[i];
            controller.destroy();
        }
        this.backgroundGroup.remove(true);
        this.middleGroup.remove(true);
        this.foregroundGroup.remove(true);
        _super.prototype.destroy.call(this);
    };
    /* end \u751F\u547D\u5468\u671F\u51FD\u6570 */
    /**
     * \u663E\u793A\u6216\u8005\u9690\u85CF\u6574\u4E2A view\u3002
     * @param visible \u662F\u5426\u53EF\u89C1
     * @returns View
     */
    View.prototype.changeVisible = function (visible) {
        _super.prototype.changeVisible.call(this, visible);
        var geometries = this.geometries;
        for (var i = 0, len = geometries.length; i < len; i++) {
            var geometry = geometries[i];
            geometry.changeVisible(visible);
        }
        var controllers = this.controllers;
        for (var i = 0, len = controllers.length; i < len; i++) {
            var controller = controllers[i];
            controller.changeVisible(visible);
        }
        this.foregroundGroup.set('visible', visible);
        this.middleGroup.set('visible', visible);
        this.backgroundGroup.set('visible', visible);
        // group.set('visible', visible) \u4E0D\u4F1A\u89E6\u53D1\u81EA\u52A8\u5237\u65B0
        this.getCanvas().draw();
        return this;
    };
    /**
     * \u88C5\u8F7D\u6570\u636E\u6E90\u3002
     *
     * \`\`\`ts
     * view.data([{ city: '\u676D\u5DDE', sale: 100 }, { city: '\u4E0A\u6D77', sale: 110 } ]);
     * \`\`\`
     *
     * @param data \u6570\u636E\u6E90\uFF0Cjson \u6570\u7EC4\u3002
     * @returns View
     */
    View.prototype.data = function (data) {
        (0,esm/* set */.t8)(this.options, 'data', data);
        this.isDataChanged = true;
        return this;
    };
    /**
     * @deprecated
     * This method will be removed at G2 V4.1. Replaced by {@link #data(data)}
     */
    View.prototype.source = function (data) {
        console.warn('This method will be removed at G2 V4.1. Please use chart.data() instead.');
        return this.data(data);
    };
    /**
     * \u8BBE\u7F6E\u6570\u636E\u7B5B\u9009\u89C4\u5219\u3002
     *
     * \`\`\`ts
     * view.filter('city', (value: any, datum: Datum) => value !== '\u676D\u5DDE');
     *
     * // \u5220\u9664 'city' \u5B57\u6BB5\u5BF9\u5E94\u7684\u7B5B\u9009\u89C4\u5219\u3002
     * view.filter('city', null);
     * \`\`\`
     *
     * @param field \u6570\u636E\u5B57\u6BB5
     * @param condition \u7B5B\u9009\u89C4\u5219
     * @returns View
     */
    View.prototype.filter = function (field, condition) {
        if ((0,esm/* isFunction */.mf)(condition)) {
            (0,esm/* set */.t8)(this.options, ['filters', field], condition);
            return this;
        }
        // condition \u4E3A\u7A7A\uFF0C\u5219\u8868\u793A\u5220\u9664\u8FC7\u6EE4\u6761\u4EF6
        if (!condition && (0,esm/* get */.U2)(this.options, ['filters', field])) {
            delete this.options.filters[field];
        }
        return this;
    };
    View.prototype.axis = function (field, axisOption) {
        if ((0,esm/* isBoolean */.jn)(field)) {
            (0,esm/* set */.t8)(this.options, ['axes'], field);
        }
        else {
            (0,esm/* set */.t8)(this.options, ['axes', field], axisOption);
        }
        return this;
    };
    View.prototype.legend = function (field, legendOption) {
        if ((0,esm/* isBoolean */.jn)(field)) {
            (0,esm/* set */.t8)(this.options, ['legends'], field);
        }
        else if ((0,esm/* isString */.HD)(field)) {
            (0,esm/* set */.t8)(this.options, ['legends', field], legendOption);
            if ((0,esm/* isPlainObject */.PO)(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
                (0,esm/* set */.t8)(this.options, ['filters', field], function (name) {
                    var _a;
                    return (_a = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a !== void 0 ? _a : true;
                });
            }
        }
        else {
            // \u8BBE\u7F6E\u5168\u5C40\u7684 legend \u914D\u7F6E
            (0,esm/* set */.t8)(this.options, ['legends'], field);
        }
        return this;
    };
    View.prototype.scale = function (field, scaleOption) {
        var _this = this;
        if ((0,esm/* isString */.HD)(field)) {
            (0,esm/* set */.t8)(this.options, ['scales', field], scaleOption);
        }
        else if ((0,esm/* isObject */.Kn)(field)) {
            (0,esm/* each */.S6)(field, function (v, k) {
                (0,esm/* set */.t8)(_this.options, ['scales', k], v);
            });
        }
        return this;
    };
    /**
     * tooltip \u63D0\u793A\u4FE1\u606F\u914D\u7F6E\u3002
     *
     * \`\`\`ts
     * view.tooltip(false); // \u5173\u95ED tooltip
     *
     * view.tooltip({
     *   shared: true
     * });
     * \`\`\`
     *
     * @param cfg Tooltip \u914D\u7F6E\uFF0C\u66F4\u8BE6\u7EC6\u7684\u914D\u7F6E\u9879\u53C2\u8003\uFF1Ahttps://github.com/antvis/component#tooltip
     * @returns View
     */
    View.prototype.tooltip = function (cfg) {
        (0,esm/* set */.t8)(this.options, 'tooltip', cfg);
        return this;
    };
    /**
     * \u8F85\u52A9\u6807\u8BB0\u914D\u7F6E\u3002
     *
     * \`\`\`ts
     * view.annotation().line({
     *   start: ['min', 85],
     *   end: ['max', 85],
     *   style: {
     *     stroke: '#595959',
     *     lineWidth: 1,
     *     lineDash: [3, 3],
     *   },
     * });
     * \`\`\`
     * \u66F4\u8BE6\u7EC6\u7684\u914D\u7F6E\u9879\uFF1Ahttps://github.com/antvis/component#annotation
     * @returns [[Annotation]]
     */
    View.prototype.annotation = function () {
        return this.getController('annotation');
    };
    /**
     * @deprecated
     * This method will be removed at G2 V4.1. Replaced by {@link #guide()}
     */
    View.prototype.guide = function () {
        console.warn('This method will be removed at G2 V4.1. Please use chart.annotation() instead.');
        return this.annotation();
    };
    View.prototype.coordinate = function (type, coordinateCfg) {
        // \u63D0\u4F9B\u8BED\u6CD5\u7CD6\uFF0C\u4F7F\u7528\u66F4\u7B80\u5355
        if ((0,esm/* isString */.HD)(type)) {
            (0,esm/* set */.t8)(this.options, 'coordinate', { type: type, cfg: coordinateCfg });
        }
        else {
            (0,esm/* set */.t8)(this.options, 'coordinate', type);
        }
        // \u66F4\u65B0 coordinate \u914D\u7F6E
        this.coordinateController.update(this.options.coordinate);
        return this.coordinateController;
    };
    /**
     * @deprecated
     * This method will be removed at G2 V4.1. Replaced by {@link #coordinate()}
     */
    View.prototype.coord = function (type, coordinateCfg) {
        console.warn('This method will be removed at G2 V4.1. Please use chart.coordinate() instead.');
        // @ts-ignore
        return this.coordinate(type, coordinateCfg);
    };
    /**
     * view \u5206\u9762\u7ED8\u5236\u3002
     *
     * \`\`\`ts
     * view.facet('rect', {
     *   rowField: 'province',
     *   columnField: 'category',
     *   eachView: (innerView: View, facet?: FacetData) => {
     *     innerView.line().position('city*sale');
     *   },
     * });
     * \`\`\`
     *
     * @param type \u5206\u9762\u7C7B\u578B
     * @param cfg \u5206\u9762\u914D\u7F6E\uFF0C [[FacetCfgMap]]
     * @returns View
     */
    View.prototype.facet = function (type, cfg) {
        // \u5148\u9500\u6BC1\u6389\u4E4B\u524D\u7684\u5206\u9762
        if (this.facetInstance) {
            this.facetInstance.destroy();
        }
        // \u521B\u5EFA\u65B0\u7684\u5206\u9762
        var Ctor = getFacet(type);
        if (!Ctor) {
            throw new Error("facet '".concat(type, "' is not exist!"));
        }
        this.facetInstance = new Ctor(this, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { type: type }));
        return this;
    };
    /*
     * \u5F00\u542F\u6216\u8005\u5173\u95ED\u52A8\u753B\u3002
     *
     * \`\`\`ts
     * view.animate(false);
     * \`\`\`
     *
     * @param status \u52A8\u753B\u72B6\u6001\uFF0Ctrue \u8868\u793A\u5F00\u59CB\uFF0Cfalse \u8868\u793A\u5173\u95ED
     * @returns View
     */
    View.prototype.animate = function (status) {
        (0,esm/* set */.t8)(this.options, 'animate', status);
        return this;
    };
    /**
     * \u66F4\u65B0\u914D\u7F6E\u9879\uFF0C\u7528\u4E8E\u914D\u7F6E\u9879\u5F0F\u58F0\u660E\u3002
     * @param options \u914D\u7F6E\u9879
     */
    View.prototype.updateOptions = function (options) {
        this.clear(); // \u6E05\u7A7A
        (0,esm/* mix */.CD)(this.options, options);
        // \u9700\u8981\u628A\u5DF2\u5B58\u5728\u7684 view \u9500\u6BC1\uFF0C\u5426\u5219\u4F1A\u91CD\u590D\u521B\u5EFA
        // \u76EE\u524D\u9488\u5BF9\u914D\u7F6E\u9879\u8FD8\u6CA1\u6709\u7279\u522B\u597D\u7684 view \u66F4\u65B0\u673A\u5236\uFF0C\u4E3A\u4E86\u4E0D\u5F71\u54CD\u4E3B\u6D41\u6D41\u7A0B\uFF0C\u6240\u4EE5\u5728\u8FD9\u91CC\u76F4\u63A5\u9500\u6BC1
        this.views.forEach(function (view) { return view.destroy(); });
        this.views = [];
        this.initOptions();
        // \u521D\u59CB\u5316\u5750\u6807\u7CFB\u5927\u5C0F\uFF0C\u4FDD\u8BC1 padding \u8BA1\u7B97\u6B63\u786E
        this.coordinateBBox = this.viewBBox;
        return this;
    };
    /**
     * \u5F80 \`view.options\` \u5C5E\u6027\u4E2D\u5B58\u50A8\u914D\u7F6E\u9879\u3002
     * @param name \u5C5E\u6027\u540D\u79F0
     * @param opt \u5C5E\u6027\u503C
     * @returns view
     */
    View.prototype.option = function (name, opt) {
        // \u5BF9\u4E8E\u5185\u7F6E\u7684 option\uFF0C\u907F\u514D\u8986\u76D6\u3002
        // name \u5728\u539F\u578B\u4E0A\uFF0C\u8BF4\u660E\u53EF\u80FD\u662F\u5185\u7F6E API\uFF0C\u5B58\u5728 option \u88AB\u8986\u76D6\u7684\u98CE\u9669\uFF0C\u4E0D\u5904\u7406
        if (View.prototype[name]) {
            throw new Error("Can't use built in variable name \\"".concat(name, "\\", please change another one."));
        }
        // \u5B58\u5165\u5230 option \u4E2D
        (0,esm/* set */.t8)(this.options, name, opt);
        return this;
    };
    /**
     * \u8BBE\u7F6E\u4E3B\u9898\u3002
     *
     * \`\`\`ts
     * view.theme('dark'); // 'dark' \u9700\u8981\u4E8B\u5148\u901A\u8FC7 \`registerTheme()\` \u63A5\u53E3\u6CE8\u518C\u5B8C\u6210
     *
     * view.theme({ defaultColor: 'red' });
     * \`\`\`
     *
     * @param theme \u4E3B\u9898\u540D\u6216\u8005\u4E3B\u9898\u914D\u7F6E
     * @returns View
     */
    View.prototype.theme = function (theme) {
        this.themeObject = (0,esm/* isObject */.Kn)(theme) ? (0,esm/* deepMix */.b$)({}, this.themeObject, createTheme(theme)) : getTheme(theme);
        return this;
    };
    /* end \u4E00\u7CFB\u5217\u4F20\u5165\u914D\u7F6E\u7684 API */
    /**
     * Call the interaction based on the interaction name
     *
     * \`\`\`ts
     * view.interaction('my-interaction', { extra: 'hello world' });
     * \`\`\`
     * \u8BE6\u7EC6\u6587\u6863\u53EF\u4EE5\u53C2\u8003\uFF1Ahttps://g2.antv.vision/zh/docs/api/general/interaction
     * @param name interaction name
     * @param cfg interaction config
     * @returns
     */
    View.prototype.interaction = function (name, cfg) {
        var existInteraction = this.interactions[name];
        // \u5B58\u5728\u5219\u5148\u9500\u6BC1\u5DF2\u6709\u7684
        if (existInteraction) {
            existInteraction.destroy();
        }
        // \u65B0\u5EFA\u4EA4\u4E92\u5B9E\u4F8B
        var interaction = createInteraction(name, this, cfg);
        if (interaction) {
            interaction.init();
            this.interactions[name] = interaction;
        }
        return this;
    };
    /**
     * \u79FB\u9664\u5F53\u524D View \u7684 interaction
     * \`\`\`ts
     * view.removeInteraction('my-interaction');
     * \`\`\`
     * @param name interaction name
     */
    View.prototype.removeInteraction = function (name) {
        var existInteraction = this.interactions[name];
        // \u5B58\u5728\u5219\u5148\u9500\u6BC1\u5DF2\u6709\u7684
        if (existInteraction) {
            existInteraction.destroy();
            this.interactions[name] = undefined;
        }
    };
    /**
     * \u4FEE\u6539\u6570\u636E\uFF0C\u6570\u636E\u66F4\u65B0\u903B\u8F91\uFF0C\u6570\u636E\u66F4\u65B0\u4EC5\u4EC5\u5F71\u54CD\u5F53\u524D\u8FD9\u4E00\u5C42\u7684 view
     *
     * \`\`\`ts
     * view.changeData([{ city: '\u5317\u4EAC', sale: '200' }]);
     * \`\`\`
     *
     * @param data
     * @returns void
     */
    View.prototype.changeData = function (data) {
        this.isDataChanged = true;
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        // 1. \u4FDD\u5B58\u6570\u636E
        this.data(data);
        // 2. \u6E32\u67D3
        this.paint(true);
        // 3. \u904D\u5386\u5B50 view \u8FDB\u884C change data
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            // FIXME \u5B50 view \u6709\u81EA\u5DF1\u7684\u6570\u636E\u7684\u60C5\u51B5\uFF0C\u8BE5\u5982\u4F55\u5904\u7406\uFF1F
            view.changeData(data);
        }
        this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    /* View \u7BA1\u7406\u76F8\u5173\u7684 API */
    /**
     * \u521B\u5EFA\u5B50 view
     *
     * \`\`\`ts
     * const innerView = view.createView({
     *   start: { x: 0, y: 0 },
     *   end: { x: 0.5, y: 0.5 },
     *   padding: 8,
     * });
     * \`\`\`
     *
     * @param cfg
     * @returns View
     */
    View.prototype.createView = function (cfg) {
        // \u5C06\u4F1A\u5728 4.1 \u7248\u672C\u4E2D\u79FB\u9664\u9012\u5F52\u5D4C\u5957 view\uFF0C\u4EC5\u4EC5\u53EA\u5141\u8BB8 chart - view \u4E24\u5C42\u3002
        // \u8FD9\u4E2A API \u7406\u8BBA\u4E0A\u7528\u6237\u91CF\u4E0D\u591A\uFF0C\u6240\u4EE5\u6682\u65F6\u4E0D\u53D1\u5927\u7248\u672C\uFF0C\u6240\u4EE5\u5148\u6682\u65F6\u6253\u4E00\u4E2A warning\u3002
        if (this.parent && this.parent.parent) {
            // \u5B58\u5728 3 \u5C42 \u7ED3\u6784\u4E86
            console.warn('The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.');
        }
        // \u5B50 view \u5171\u4EAB options \u914D\u7F6E\u6570\u636E
        var sharedOptions = {
            data: this.options.data,
            scales: (0,esm/* clone */.d9)(this.options.scales),
            axes: (0,esm/* clone */.d9)(this.options.axes),
            coordinate: (0,esm/* clone */.d9)(this.coordinateController.getOption()),
            tooltip: (0,esm/* clone */.d9)(this.options.tooltip),
            legends: (0,esm/* clone */.d9)(this.options.legends),
            animate: this.options.animate,
            visible: this.visible,
        };
        var v = new View((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ parent: this, canvas: this.canvas, 
            // \u5B50 view \u5171\u7528\u4E09\u5C42 group
            backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }), middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }), foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }), theme: this.themeObject, padding: this.padding }, cfg), { options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, sharedOptions), (0,esm/* get */.U2)(cfg, 'options', {})) }));
        this.views.push(v);
        return v;
    };
    /**
     * @deprecated
     * This method will be removed at G2 V4.1. Replaced by {@link #createView()}
     */
    View.prototype.view = function (cfg) {
        console.warn('This method will be removed at G2 V4.1. Please use chart.createView() instead.');
        return this.createView(cfg);
    };
    /**
     * \u5220\u9664\u4E00\u4E2A\u5B50 view
     * @param view
     * @return removedView
     */
    View.prototype.removeView = function (view) {
        var removedView = (0,esm/* remove */.Od)(this.views, function (v) { return v === view; })[0];
        if (removedView) {
            removedView.destroy();
        }
        return removedView;
    };
    /* end View \u7BA1\u7406\u76F8\u5173\u7684 API */
    // \u4E00\u4E9B get \u65B9\u6CD5
    /**
     * \u83B7\u53D6\u5F53\u524D\u5750\u6807\u7CFB\u5B9E\u4F8B\u3002
     * @returns [[Coordinate]]
     */
    View.prototype.getCoordinate = function () {
        return this.coordinateInstance;
    };
    /**
     * \u83B7\u53D6\u5F53\u524D view \u7684\u4E3B\u9898\u914D\u7F6E\u3002
     * @returns themeObject
     */
    View.prototype.getTheme = function () {
        return this.themeObject;
    };
    /**
     * \u83B7\u5F97 x \u8F74\u5B57\u6BB5\u7684 scale \u5B9E\u4F8B\u3002
     * @returns view \u4E2D Geometry \u5BF9\u4E8E\u7684 x scale
     */
    View.prototype.getXScale = function () {
        // \u62FF\u7B2C\u4E00\u4E2A Geometry \u7684 X scale
        // \u9690\u85CF\u903B\u8F91\uFF1A\u4E00\u4E2A view \u4E2D\u7684 Geometry \u5FC5\u987B x \u5B57\u6BB5\u4E00\u81F4
        var g = this.geometries[0];
        return g ? g.getXScale() : null;
    };
    /**
     * \u83B7\u53D6 y \u8F74\u5B57\u6BB5\u7684 scales \u5B9E\u4F8B\u3002
     * @returns view \u4E2D Geometry \u5BF9\u4E8E\u7684 y scale \u6570\u7EC4
     */
    View.prototype.getYScales = function () {
        // \u62FF\u5230\u6240\u6709\u7684 Geometry \u7684 Y scale\uFF0C\u7136\u540E\u53BB\u91CD
        var tmpMap = {};
        var yScales = [];
        this.geometries.forEach(function (g) {
            var yScale = g.getYScale();
            var field = yScale.field;
            if (!tmpMap[field]) {
                tmpMap[field] = true;
                yScales.push(yScale);
            }
        });
        return yScales;
    };
    /**
     * \u83B7\u53D6 x \u8F74\u6216\u8005 y \u8F74\u5BF9\u5E94\u7684\u6240\u6709 scale \u5B9E\u4F8B\u3002
     * @param dimType x | y
     * @returns x \u8F74\u6216\u8005 y \u8F74\u5BF9\u5E94\u7684\u6240\u6709 scale \u5B9E\u4F8B\u3002
     */
    View.prototype.getScalesByDim = function (dimType) {
        var geometries = this.geometries;
        var scales = {};
        for (var i = 0, len = geometries.length; i < len; i++) {
            var geometry = geometries[i];
            var scale = dimType === 'x' ? geometry.getXScale() : geometry.getYScale();
            if (scale && !scales[scale.field]) {
                scales[scale.field] = scale;
            }
        }
        return scales;
    };
    /**
     * \u6839\u636E\u5B57\u6BB5\u540D\u53BB\u83B7\u53D6 scale \u5B9E\u4F8B\u3002
     * @param field \u6570\u636E\u5B57\u6BB5\u540D\u79F0
     * @param key id
     */
    View.prototype.getScale = function (field, key) {
        var defaultKey = key ? key : this.getScaleKey(field);
        // \u8C03\u7528\u6839\u8282\u70B9 view \u7684\u65B9\u6CD5\u83B7\u53D6
        return this.getRootView().scalePool.getScale(defaultKey);
    };
    /**
     * @deprecated
     * This method will be removed at G2 V4.1. Please use \`getScale\`.
     */
    View.prototype.getScaleByField = function (field, key) {
        return this.getScale(field, key);
    };
    /**
     * \u8FD4\u56DE\u6240\u6709\u914D\u7F6E\u4FE1\u606F\u3002
     * @returns \u6240\u6709\u7684 view API \u914D\u7F6E\u3002
     */
    View.prototype.getOptions = function () {
        return this.options;
    };
    /**
     * \u83B7\u53D6 view \u7684\u6570\u636E\uFF08\u8FC7\u6EE4\u540E\u7684\u6570\u636E\uFF09\u3002
     * @returns \u5904\u7406\u8FC7\u6EE4\u5668\u4E4B\u540E\u7684\u6570\u636E\u3002
     */
    View.prototype.getData = function () {
        return this.filteredData;
    };
    /**
     * \u83B7\u53D6\u539F\u59CB\u6570\u636E
     * @returns \u4F20\u5165 G2 \u7684\u539F\u59CB\u6570\u636E
     */
    View.prototype.getOriginalData = function () {
        return this.options.data;
    };
    /**
     * \u83B7\u53D6\u5E03\u5C40\u540E\u7684\u8FB9\u8DDD padding
     * @returns
     */
    View.prototype.getPadding = function () {
        return this.autoPadding.getPadding();
    };
    /**
     * \u83B7\u53D6\u5F53\u524D view \u6709\u7684 geometries
     * @returns
     */
    View.prototype.getGeometries = function () {
        return this.geometries;
    };
    /**
     * \u83B7\u53D6 view \u4E2D\u7684\u6240\u6709 geome
     */
    View.prototype.getElements = function () {
        return (0,esm/* reduce */.u4)(this.geometries, function (elements, geometry) {
            return elements.concat(geometry.getElements());
        }, []);
    };
    /**
     * \u6839\u636E\u4E00\u5B9A\u7684\u89C4\u5219\u67E5\u627E Geometry \u7684 Elements\u3002
     *
     * \`\`\`typescript
     * getElementsBy((element) => {
     *   const data = element.getData();
     *
     *   return data.a === 'a';
     * });
     * \`\`\`
     *
     * @param condition \u5B9A\u4E49\u67E5\u627E\u89C4\u5219\u7684\u56DE\u8C03\u51FD\u6570\u3002
     * @returns
     */
    View.prototype.getElementsBy = function (condition) {
        return this.getElements().filter(function (el) { return condition(el); });
    };
    /**
     * \u83B7\u5F97\u7ED8\u5236\u7684\u5C42\u7EA7 group\u3002
     * @param layer \u5C42\u7EA7\u540D\u79F0\u3002
     * @returns \u5BF9\u5E94\u5C42\u7EA7\u7684 Group\u3002
     */
    View.prototype.getLayer = function (layer) {
        return layer === LAYER.BG
            ? this.backgroundGroup
            : layer === LAYER.MID
                ? this.middleGroup
                : layer === LAYER.FORE
                    ? this.foregroundGroup
                    : this.foregroundGroup;
    };
    /**
     * \u5BF9\u5916\u66B4\u9732\u65B9\u6CD5\uFF0C\u5224\u65AD\u4E00\u4E2A\u70B9\u662F\u5426\u5728\u7ED8\u56FE\u533A\u57DF\uFF08\u5373\u5750\u6807\u7CFB\u8303\u56F4\uFF09\u5185\u90E8\u3002
     * @param point \u5750\u6807\u70B9
     */
    View.prototype.isPointInPlot = function (point) {
        return isPointInCoordinate(this.getCoordinate(), point);
    };
    /**
     * \u83B7\u5F97\u6240\u6709\u7684 legend \u5BF9\u5E94\u7684 attribute \u5B9E\u4F8B\u3002
     * @returns \u7EF4\u5EA6\u5B57\u6BB5\u7684 Attribute \u6570\u7EC4
     */
    View.prototype.getLegendAttributes = function () {
        return (0,esm/* flatten */.xH)(this.geometries.map(function (g) { return g.getGroupAttributes(); }));
    };
    /**
     * \u83B7\u53D6\u6240\u6709\u7684\u5206\u7EC4\u5B57\u6BB5\u7684 scale \u5B9E\u4F8B\u3002
     * @returns \u83B7\u5F97\u5206\u7EC4\u5B57\u6BB5\u7684 scale \u5B9E\u4F8B\u6570\u7EC4\u3002
     */
    View.prototype.getGroupScales = function () {
        // \u62FF\u5230\u6240\u6709\u7684 Geometry \u7684 \u5206\u7EC4\u5B57\u6BB5 scale\uFF0C\u7136\u540E\u6253\u5E73\u53BB\u91CD
        var scales = this.geometries.map(function (g) { return g.getGroupScales(); });
        return uniq((0,esm/* flatten */.xH)(scales));
    };
    /**
     * \u83B7\u53D6 G.Canvas \u5B9E\u4F8B\u3002
     * @returns G.Canvas \u753B\u5E03\u5B9E\u4F8B\u3002
     */
    View.prototype.getCanvas = function () {
        return this.getRootView().canvas;
    };
    /**
     * \u83B7\u5F97\u6839\u8282\u70B9 view\u3002
     */
    View.prototype.getRootView = function () {
        var v = this;
        while (true) {
            if (v.parent) {
                v = v.parent;
                continue;
            }
            break;
        }
        return v;
    };
    /**
     * \u83B7\u53D6\u8BE5\u6570\u636E\u5728\u53EF\u89C6\u5316\u540E\uFF0C\u5BF9\u5E94\u7684\u753B\u5E03\u5750\u6807\u70B9\u3002
     * @param data \u539F\u59CB\u6570\u636E\u8BB0\u5F55
     * @returns \u5BF9\u5E94\u7684\u753B\u5E03\u5750\u6807\u70B9
     */
    View.prototype.getXY = function (data) {
        var coordinate = this.getCoordinate();
        var xScales = this.getScalesByDim('x');
        var yScales = this.getScalesByDim('y');
        var x;
        var y;
        (0,esm/* each */.S6)(data, function (value, key) {
            if (xScales[key]) {
                x = xScales[key].scale(value);
            }
            if (yScales[key]) {
                y = yScales[key].scale(value);
            }
        });
        if (!(0,esm/* isNil */.UM)(x) && !(0,esm/* isNil */.UM)(y)) {
            return coordinate.convert({ x: x, y: y });
        }
    };
    /**
     * \u83B7\u53D6 name \u5BF9\u5E94\u7684 controller \u5B9E\u4F8B
     * @param name
     */
    View.prototype.getController = function (name) {
        return (0,esm/* find */.sE)(this.controllers, function (c) { return c.name === name; });
    };
    /**
     * \u663E\u793A point \u5750\u6807\u70B9\u5BF9\u5E94\u7684 tooltip\u3002
     * @param point \u753B\u5E03\u5750\u6807\u70B9
     * @returns View
     */
    View.prototype.showTooltip = function (point) {
        var tooltip = this.getController('tooltip');
        if (tooltip) {
            tooltip.showTooltip(point);
        }
        return this;
    };
    /**
     * \u9690\u85CF tooltip\u3002
     * @returns View
     */
    View.prototype.hideTooltip = function () {
        var tooltip = this.getController('tooltip');
        if (tooltip) {
            tooltip.hideTooltip();
        }
        return this;
    };
    /**
     * \u5C06 tooltip \u9501\u5B9A\u5230\u5F53\u524D\u4F4D\u7F6E\u4E0D\u80FD\u79FB\u52A8\u3002
     * @returns View
     */
    View.prototype.lockTooltip = function () {
        var tooltip = this.getController('tooltip');
        if (tooltip) {
            tooltip.lockTooltip();
        }
        return this;
    };
    /**
     * \u5C06 tooltip \u9501\u5B9A\u89E3\u9664\u3002
     * @returns View
     */
    View.prototype.unlockTooltip = function () {
        var tooltip = this.getController('tooltip');
        if (tooltip) {
            tooltip.unlockTooltip();
        }
        return this;
    };
    /**
     * \u662F\u5426\u9501\u5B9A tooltip\u3002
     * @returns \u662F\u5426\u9501\u5B9A
     */
    View.prototype.isTooltipLocked = function () {
        var tooltip = this.getController('tooltip');
        return tooltip && tooltip.isTooltipLocked();
    };
    /**
     * \u83B7\u53D6\u5F53\u524D point \u5BF9\u5E94\u7684 tooltip \u6570\u636E\u9879\u3002
     * @param point \u5750\u6807\u70B9
     * @returns tooltip \u6570\u636E\u9879
     */
    View.prototype.getTooltipItems = function (point) {
        var tooltip = this.getController('tooltip');
        return tooltip ? tooltip.getTooltipItems(point) : [];
    };
    /**
     * \u83B7\u53D6\u903C\u8FD1\u7684\u70B9\u7684\u6570\u636E\u96C6\u5408
     * @param point \u5F53\u524D\u5750\u6807\u70B9
     * @returns  \u6570\u636E
     */
    View.prototype.getSnapRecords = function (point) {
        var geometries = this.geometries;
        var rst = [];
        for (var i = 0, len = geometries.length; i < len; i++) {
            var geom = geometries[i];
            var dataArray = geom.dataArray;
            geom.sort(dataArray); // \u5148\u8FDB\u884C\u6392\u5E8F\uFF0C\u4FBF\u4E8E tooltip \u67E5\u627E
            var record = void 0;
            for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
                var data = dataArray[j];
                record = findDataByPoint(point, data, geom);
                if (record) {
                    rst.push(record);
                }
            }
        }
        // \u540C\u6837\u9012\u5F52\u5904\u7406\u5B50 views
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            var snapRecords = view.getSnapRecords(point);
            rst = rst.concat(snapRecords);
        }
        return rst;
    };
    /**
     * \u83B7\u53D6\u6240\u6709\u7684 pure component \u7EC4\u4EF6\uFF0C\u7528\u4E8E\u5E03\u5C40\u3002
     */
    View.prototype.getComponents = function () {
        var components = [];
        var controllers = this.controllers;
        for (var i = 0, len = controllers.length; i < len; i++) {
            var controller = controllers[i];
            components = components.concat(controller.getComponents());
        }
        return components;
    };
    /**
     * \u5C06 data \u6570\u636E\u8FDB\u884C\u8FC7\u6EE4\u3002
     * @param data
     * @returns \u8FC7\u6EE4\u4E4B\u540E\u7684\u6570\u636E
     */
    View.prototype.filterData = function (data) {
        var filters = this.options.filters;
        // \u4E0D\u5B58\u5728 filters\uFF0C\u5219\u4E0D\u9700\u8981\u8FDB\u884C\u6570\u636E\u8FC7\u6EE4
        if ((0,esm/* size */.dp)(filters) === 0) {
            return data;
        }
        // \u5B58\u5728\u8FC7\u6EE4\u5668\uFF0C\u5219\u9010\u4E2A\u6267\u884C\u8FC7\u6EE4\uFF0C\u8FC7\u6EE4\u5668\u4E4B\u95F4\u662F \u4E0E \u7684\u5173\u7CFB
        return (0,esm/* filter */.hX)(data, function (datum, idx) {
            // \u6240\u6709\u7684 filter \u5B57\u6BB5
            var fields = Object.keys(filters);
            // \u6240\u6709\u7684\u6761\u4EF6\u90FD\u901A\u8FC7\uFF0C\u624D\u7B97\u901A\u8FC7
            return fields.every(function (field) {
                var condition = filters[field];
                // condition \u8FD4\u56DE true\uFF0C\u5219\u4FDD\u7559
                return condition(datum[field], datum, idx);
            });
        });
    };
    /**
     * \u5BF9\u67D0\u4E00\u4E2A\u5B57\u6BB5\u8FDB\u884C\u8FC7\u6EE4
     * @param field
     * @param data
     */
    View.prototype.filterFieldData = function (field, data) {
        var filters = this.options.filters;
        var condition = (0,esm/* get */.U2)(filters, field);
        if ((0,esm/* isUndefined */.o8)(condition)) {
            return data;
        }
        return data.filter(function (datum, idx) { return condition(datum[field], datum, idx); });
    };
    /**
     * \u8C03\u6574 coordinate \u7684\u5750\u6807\u8303\u56F4\u3002
     */
    View.prototype.adjustCoordinate = function () {
        var _a = this.getCoordinate(), curStart = _a.start, curEnd = _a.end;
        var start = this.coordinateBBox.bl;
        var end = this.coordinateBBox.tr;
        // \u5728 defaultLayoutFn \u4E2D\u53EA\u4F1A\u5728 coordinateBBox \u53D1\u751F\u53D8\u5316\u7684\u65F6\u5019\u4F1A\u8C03\u7528 adjustCoordinate()\uFF0C\u6240\u4EE5\u4E0D\u7528\u62C5\u5FC3\u88AB\u7F6E\u4F4D
        if ((0,esm/* isEqual */.Xy)(curStart, start) && (0,esm/* isEqual */.Xy)(curEnd, end)) {
            this.isCoordinateChanged = false;
            // \u5982\u679C\u5927\u5C0F\u6CA1\u6709\u53D8\u5316\u5219\u4E0D\u66F4\u65B0
            return;
        }
        this.isCoordinateChanged = true;
        this.coordinateInstance = this.coordinateController.adjust(start, end);
    };
    View.prototype.paint = function (isUpdate) {
        this.renderDataRecursive(isUpdate);
        // \u5904\u7406 sync scale \u7684\u903B\u8F91
        this.syncScale();
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
        // \u521D\u59CB\u5316\u56FE\u5F62\u3001\u7EC4\u4EF6\u4F4D\u7F6E\uFF0C\u8BA1\u7B97 padding
        this.renderPaddingRecursive(isUpdate);
        // \u5E03\u5C40\u56FE\u5F62\u3001\u7EC4\u4EF6
        this.renderLayoutRecursive(isUpdate);
        // \u80CC\u666F\u8272 shape
        this.renderBackgroundStyleShape();
        // \u6700\u7EC8\u7684\u7ED8\u5236 render
        this.renderPaintRecursive(isUpdate);
        this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
        this.isDataChanged = false; // \u6E32\u67D3\u5B8C\u6BD5\u590D\u4F4D
    };
    /**
     * \u6E32\u67D3\u80CC\u666F\u6837\u5F0F\u7684 shape\u3002
     * \u653E\u5230 view \u4E2D\u521B\u5EFA\u7684\u539F\u56E0\u662F\u8BA9\u4F7F\u7528 view \u7ED8\u5236\u56FE\u5F62\u7684\u65F6\u5019\uFF0C\u4E5F\u80FD\u591F\u5904\u7406\u80CC\u666F\u8272
     */
    View.prototype.renderBackgroundStyleShape = function () {
        // \u53EA\u6709\u6839\u8282\u70B9\u624D\u5904\u7406
        if (this.parent) {
            return;
        }
        var background = (0,esm/* get */.U2)(this.themeObject, 'background');
        // \u914D\u7F6E\u4E86\u80CC\u666F\u8272
        if (background) {
            // 1. \u4E0D\u5B58\u5728\u5219\u521B\u5EFA
            if (!this.backgroundStyleRectShape) {
                this.backgroundStyleRectShape = this.backgroundGroup.addShape('rect', {
                    attrs: {},
                    zIndex: -1,
                    // \u80CC\u666F\u8272 shape \u4E0D\u8BBE\u7F6E\u4E8B\u4EF6\u6355\u83B7
                    capture: false,
                });
                this.backgroundStyleRectShape.toBack();
            }
            // 2. \u6709\u4E86 shape \u4E4B\u540E\u8BBE\u7F6E\u80CC\u666F\uFF0C\u4F4D\u7F6E\uFF08\u66F4\u65B0\u7684\u65F6\u5019\uFF09
            var _a = this.viewBBox, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
            this.backgroundStyleRectShape.attr({
                fill: background,
                x: x,
                y: y,
                width: width,
                height: height,
            });
        }
        else {
            // \u6CA1\u6709\u914D\u7F6E\u80CC\u666F\u8272
            if (this.backgroundStyleRectShape) {
                this.backgroundStyleRectShape.remove(true);
                this.backgroundStyleRectShape = undefined;
            }
        }
    };
    /**
     * \u9012\u5F52\u8BA1\u7B97\u6BCF\u4E2A view \u7684 padding \u503C\uFF0CcoordinateBBox \u548C coordinateInstance
     * @param isUpdate
     */
    View.prototype.renderPaddingRecursive = function (isUpdate) {
        // 1. \u5B50 view \u5927\u5C0F\u76F8\u5BF9 coordinateBBox\uFF0CchangeSize \u7684\u65F6\u5019\u9700\u8981\u91CD\u65B0\u8BA1\u7B97
        this.calculateViewBBox();
        // 2. \u66F4\u65B0 coordinate
        this.adjustCoordinate();
        // 3. \u521D\u59CB\u5316\u7EC4\u4EF6 component
        this.initComponents(isUpdate);
        // 4. \u5E03\u5C40\u8BA1\u7B97\u6BCF\u9694 view \u7684 padding \u503C
        // 4.1. \u81EA\u52A8\u52A0 auto padding -> absolute padding\uFF0C\u5E76\u4E14\u589E\u52A0 appendPadding
        this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
        // 4.2. \u8BA1\u7B97\u51FA\u65B0\u7684 coordinateBBox\uFF0C\u66F4\u65B0 Coordinate
        // \u8FD9\u91CC\u5FC5\u987B\u4FDD\u7559\uFF0C\u539F\u56E0\u662F\u540E\u9762\u5B50 view \u7684 viewBBox \u6216\u6839\u636E parent \u7684 coordinateBBox
        this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
        this.adjustCoordinate();
        // \u5237\u65B0 tooltip (tooltip crosshairs \u4F9D\u8D56 coordinate \u4F4D\u7F6E)
        var tooltipController = this.controllers.find(function (c) { return c.name === 'tooltip'; });
        tooltipController.update();
        // \u540C\u6837\u9012\u5F52\u5904\u7406\u5B50 views
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            view.renderPaddingRecursive(isUpdate);
        }
    };
    /**
     * \u9012\u5F52\u5904\u7406 view \u7684\u5E03\u5C40\uFF0C\u6700\u7EC8\u662F\u8BA1\u7B97\u5404\u4E2A view \u7684 coordinateBBox \u548C coordinateInstance
     * @param isUpdate
     */
    View.prototype.renderLayoutRecursive = function (isUpdate) {
        // 1. \u540C\u6B65\u5B50 view padding
        // \u6839\u636E\u914D\u7F6E\u83B7\u53D6 padding
        var syncViewPaddingFn = this.syncViewPadding === true
            ? defaultSyncViewPadding
            : (0,esm/* isFunction */.mf)(this.syncViewPadding)
                ? this.syncViewPadding
                : undefined;
        if (syncViewPaddingFn) {
            syncViewPaddingFn(this, this.views, PaddingCal);
            // \u540C\u6B65 padding \u4E4B\u540E\uFF0C\u66F4\u65B0 coordinate
            this.views.forEach(function (v) {
                v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
                v.adjustCoordinate();
            });
        }
        // 3. \u5C06 view \u4E2D\u7684\u7EC4\u4EF6\u6309\u7167 view padding \u79FB\u52A8\u5230\u5BF9\u5E94\u7684\u4F4D\u7F6E
        this.doLayout();
        // \u540C\u6837\u9012\u5F52\u5904\u7406\u5B50 views
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            view.renderLayoutRecursive(isUpdate);
        }
    };
    /**
     * \u6700\u7EC8\u9012\u5F52\u7ED8\u5236\u7EC4\u4EF6\u548C\u56FE\u5F62
     * @param isUpdate
     */
    View.prototype.renderPaintRecursive = function (isUpdate) {
        var middleGroup = this.middleGroup;
        if (this.limitInPlot) {
            var _a = getCoordinateClipCfg(this.coordinateInstance), type = _a.type, attrs = _a.attrs;
            middleGroup.setClip({
                type: type,
                attrs: attrs,
            });
        }
        else {
            // \u6E05\u9664\u5DF2\u6709\u7684 clip
            middleGroup.setClip(undefined);
        }
        // 1. \u6E32\u67D3\u51E0\u4F55\u6807\u8BB0
        this.paintGeometries(isUpdate);
        // 2. \u7ED8\u5236\u7EC4\u4EF6
        this.renderComponents(isUpdate);
        // \u540C\u6837\u9012\u5F52\u5904\u7406\u5B50 views
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            view.renderPaintRecursive(isUpdate);
        }
    };
    // end Get \u65B9\u6CD5
    /**
     * \u521B\u5EFA scale\uFF0C\u9012\u5F52\u5230\u9876\u5C42 view \u53BB\u521B\u5EFA\u548C\u7F13\u5B58 scale
     * @param field
     * @param data
     * @param scaleDef
     * @param key
     */
    View.prototype.createScale = function (field, data, scaleDef, key) {
        // 1. \u5408\u5E76 field \u5BF9\u5E94\u7684 scaleDef\uFF0C\u5408\u5E76\u539F\u5219\u662F\u5E95\u5C42\u8986\u76D6\u9876\u5C42\uFF08\u5C31\u8FD1\u539F\u5219\uFF09
        var currentScaleDef = (0,esm/* get */.U2)(this.options.scales, [field]);
        var mergedScaleDef = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, currentScaleDef), scaleDef);
        // 2. \u662F\u5426\u5B58\u5728\u7236 view\uFF0C\u5728\u5219\u9012\u5F52\uFF0C\u5426\u5219\u521B\u5EFA
        if (this.parent) {
            return this.parent.createScale(field, data, mergedScaleDef, key);
        }
        // 3. \u5728\u6839\u8282\u70B9 view \u901A\u8FC7 scalePool \u521B\u5EFA
        return this.scalePool.createScale(field, data, mergedScaleDef, key);
    };
    /**
     * \u9012\u5F52\u6E32\u67D3\u4E2D\u7684\u6570\u636E\u5904\u7406
     * @param isUpdate
     */
    View.prototype.renderDataRecursive = function (isUpdate) {
        // 1. \u5904\u7406\u6570\u636E
        this.doFilterData();
        // 2. \u521B\u5EFA\u5B9E\u4F8B
        this.createCoordinate();
        // 3. \u521D\u59CB\u5316 Geometry
        this.initGeometries(isUpdate);
        // 4. \u5904\u7406\u5206\u9762\u903B\u8F91\uFF0C\u6700\u7EC8\u90FD\u662F\u751F\u6210\u5B50 view \u548C geometry
        this.renderFacet(isUpdate);
        // \u540C\u6837\u9012\u5F52\u5904\u7406\u5B50 views
        var views = this.views;
        for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i];
            view.renderDataRecursive(isUpdate);
        }
    };
    /**
     * \u8BA1\u7B97 region\uFF0C\u8BA1\u7B97\u5B9E\u9645\u7684\u50CF\u7D20\u8303\u56F4\u5750\u6807
     * @private
     */
    View.prototype.calculateViewBBox = function () {
        var x;
        var y;
        var width;
        var height;
        if (this.parent) {
            var bbox = this.parent.coordinateBBox;
            // \u5B58\u5728 parent\uFF0C \u90A3\u4E48\u5C31\u662F\u901A\u8FC7\u7236\u5BB9\u5668\u5927\u5C0F\u8BA1\u7B97
            x = bbox.x;
            y = bbox.y;
            width = bbox.width;
            height = bbox.height;
        }
        else {
            // \u9876\u5C42\u5BB9\u5668\uFF0C\u4ECE canvas \u4E2D\u53D6\u503C \u5BBD\u9AD8
            x = 0;
            y = 0;
            width = this.canvas.get('width');
            height = this.canvas.get('height');
        }
        var _a = this.region, start = _a.start, end = _a.end;
        // \u6839\u636E region \u8BA1\u7B97\u5F53\u524D view \u7684 bbox \u5927\u5C0F\u3002
        var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
        if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
            // viewBBox \u53D1\u751F\u53D8\u5316\u7684\u65F6\u5019\u8FDB\u884C\u66F4\u65B0
            this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
        }
        // \u521D\u59CB\u7684 coordinate bbox \u5927\u5C0F
        this.coordinateBBox = this.viewBBox;
    };
    /**
     * \u521D\u59CB\u5316\u4E8B\u4EF6\u673A\u5236\uFF1AG 4.0 \u5E95\u5C42\u5185\u7F6E\u652F\u6301 name:event \u7684\u673A\u5236\uFF0C\u90A3\u4E48\u53EA\u8981\u6240\u6709\u7EC4\u4EF6\u90FD\u6709\u81EA\u5DF1\u7684 name \u5373\u53EF\u3002
     *
     * G2 \u7684\u4E8B\u4EF6\u53EA\u662F\u83B7\u53D6\u4E8B\u4EF6\u59D4\u6258\uFF0C\u7136\u540E\u5728 view \u5D4C\u5957\u7ED3\u6784\u4E2D\uFF0C\u5F62\u6210\u4E8B\u4EF6\u5192\u6CE1\u673A\u5236\u3002
     * \u5F53\u524D view \u53EA\u59D4\u6258\u81EA\u5DF1 view \u4E2D\u7684 Component \u548C Geometry \u4E8B\u4EF6\uFF0C\u5E76\u5411\u4E0A\u5192\u6CE1
     * @private
     */
    View.prototype.initEvents = function () {
        // \u4E09\u5C42 group \u4E2D\u7684 shape \u4E8B\u4EF6\u90FD\u4F1A\u901A\u8FC7 G \u5192\u6CE1\u4E0A\u6765\u7684
        this.foregroundGroup.on('*', this.onDelegateEvents);
        this.middleGroup.on('*', this.onDelegateEvents);
        this.backgroundGroup.on('*', this.onDelegateEvents);
        this.canvas.on('*', this.onCanvasEvent);
    };
    /**
     * \u521D\u59CB\u5316\u63D2\u4EF6
     */
    View.prototype.initComponentController = function () {
        var usedControllers = this.usedControllers;
        for (var i = 0, len = usedControllers.length; i < len; i++) {
            var controllerName = usedControllers[i];
            var Ctor = getComponentController(controllerName);
            if (Ctor) {
                this.controllers.push(new Ctor(this));
            }
        }
    };
    View.prototype.createViewEvent = function (evt) {
        var shape = evt.shape, name = evt.name;
        var data = shape ? shape.get('origin') : null;
        // \u4E8B\u4EF6\u5728 view \u5D4C\u5957\u4E2D\u5192\u6CE1\uFF08\u6682\u4E0D\u63D0\u4F9B\u963B\u6B62\u5192\u6CE1\u7684\u673A\u5236\uFF09
        var e = new chart_event(this, evt, data);
        e.type = name;
        return e;
    };
    /**
     * \u5904\u7406 PLOT_EVENTS
     * plot event \u9700\u8981\u5904\u7406\u6240\u6709\u7684\u57FA\u7840\u4E8B\u4EF6\uFF0C\u5E76\u5224\u65AD\u662F\u5426\u5728\u753B\u5E03\u4E2D\uFF0C\u7136\u540E\u518D\u51B3\u5B9A\u662F\u5426\u8981 emit\u3002
     * \u5BF9\u4E8E mouseenter\u3001mouseleave \u6BD4\u8F83\u7279\u6B8A\uFF0C\u9700\u8981\u505A\u4E00\u4E0B\u6570\u5B66\u6BD4\u8F83\u3002
     * @param e
     */
    View.prototype.doPlotEvent = function (e) {
        var type = e.type, x = e.x, y = e.y;
        var point = { x: x, y: y };
        var ALL_EVENTS = [
            'mousedown',
            'mouseup',
            'mousemove',
            'mouseleave',
            'mousewheel',
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel',
            'click',
            'dblclick',
            'contextmenu',
        ];
        if (ALL_EVENTS.includes(type)) {
            var currentInPlot = this.isPointInPlot(point);
            var newEvent = e.clone();
            if (currentInPlot) {
                var TYPE = "plot:".concat(type); // \u7EC4\u5408 plot \u4E8B\u4EF6
                newEvent.type = TYPE;
                this.emit(TYPE, newEvent);
                if (type === 'mouseleave' || type === 'touchend') {
                    // \u5728plot \u5185\u90E8\u5374\u79BB\u5F00\u753B\u5E03
                    this.isPreMouseInPlot = false;
                }
            }
            // \u5BF9\u4E8E mouseenter, mouseleave \u7684\u8BA1\u7B97\u5904\u7406
            if (type === 'mousemove' || type === 'touchmove') {
                if (this.isPreMouseInPlot && !currentInPlot) {
                    if (type === 'mousemove') {
                        newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
                        this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
                    }
                    newEvent.type = PLOT_EVENTS.LEAVE;
                    this.emit(PLOT_EVENTS.LEAVE, newEvent);
                }
                else if (!this.isPreMouseInPlot && currentInPlot) {
                    if (type === 'mousemove') {
                        newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
                        this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
                    }
                    newEvent.type = PLOT_EVENTS.ENTER;
                    this.emit(PLOT_EVENTS.ENTER, newEvent);
                }
                // \u8D4B\u65B0\u7684\u72B6\u6001\u503C
                this.isPreMouseInPlot = currentInPlot;
            }
            else if (type === 'mouseleave' || type === 'touchend') {
                // \u53EF\u80FD\u4E0D\u5728 currentInPlot \u4E2D
                if (this.isPreMouseInPlot) {
                    if (type === 'mouseleave') {
                        newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
                        this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
                    }
                    newEvent.type = PLOT_EVENTS.LEAVE;
                    this.emit(PLOT_EVENTS.LEAVE, newEvent);
                    this.isPreMouseInPlot = false;
                }
            }
        }
    };
    // view \u751F\u547D\u5468\u671F \u2014\u2014 \u6E32\u67D3\u6D41\u7A0B
    /**
     * \u5904\u7406\u7B5B\u9009\u5668\uFF0C\u7B5B\u9009\u6570\u636E
     * @private
     */
    View.prototype.doFilterData = function () {
        var data = this.options.data;
        this.filteredData = this.filterData(data);
    };
    /**
     * \u521D\u59CB\u5316 Geometries
     * @private
     */
    View.prototype.initGeometries = function (isUpdate) {
        // \u521D\u59CB\u5316\u56FE\u5F62\u7684\u4E4B\u524D\uFF0C\u5148\u521B\u5EFA / \u66F4\u65B0 scales
        this.createOrUpdateScales();
        // \u5B9E\u4F8B\u5316 Geometry\uFF0C\u7136\u540E view \u5C06\u6240\u6709\u7684 scale \u7BA1\u7406\u8D77\u6765
        var coordinate = this.getCoordinate();
        var scaleDefs = (0,esm/* get */.U2)(this.options, 'scales', {});
        var geometries = this.geometries;
        for (var i = 0, len = geometries.length; i < len; i++) {
            var geometry = geometries[i];
            // \u4FDD\u6301 scales \u5F15\u7528\u4E0D\u8981\u53D8\u5316
            geometry.scales = this.getGeometryScales();
            var cfg = {
                coordinate: coordinate,
                scaleDefs: scaleDefs,
                data: this.filteredData,
                theme: this.themeObject,
                isDataChanged: this.isDataChanged,
                isCoordinateChanged: this.isCoordinateChanged,
            };
            if (isUpdate) {
                // \u6570\u636E\u53D1\u751F\u66F4\u65B0
                geometry.update(cfg);
            }
            else {
                geometry.init(cfg);
            }
        }
        // Geometry \u521D\u59CB\u5316\u4E4B\u540E\uFF0C\u751F\u6210\u4E86 scale\uFF0C\u7136\u540E\u8FDB\u884C\u8C03\u6574 scale \u914D\u7F6E
        this.adjustScales();
    };
    /**
     * \u6839\u636E Geometry \u7684\u6240\u6709\u5B57\u6BB5\u521B\u5EFA scales
     * \u5982\u679C\u5B58\u5728\uFF0C\u5219\u66F4\u65B0\uFF0C\u4E0D\u5B58\u5728\u5219\u521B\u5EFA
     */
    View.prototype.createOrUpdateScales = function () {
        var fields = this.getScaleFields();
        var groupedFields = this.getGroupedFields();
        var _a = this.getOptions(), data = _a.data, _b = _a.scales, scales = _b === void 0 ? {} : _b;
        var filteredData = this.filteredData;
        for (var i = 0, len = fields.length; i < len; i++) {
            var field = fields[i];
            var scaleDef = scales[field];
            // \u8C03\u7528\u65B9\u6CD5\uFF0C\u9012\u5F52\u53BB\u521B\u5EFA
            var key = this.getScaleKey(field);
            this.createScale(field, 
            // \u5206\u7EC4\u5B57\u6BB5\u7684 scale \u4F7F\u7528\u672A\u8FC7\u6EE4\u7684\u6570\u636E\u521B\u5EFA
            groupedFields.includes(field) ? data : filteredData, scaleDef, key);
            // \u7F13\u5B58\u4ECE\u5F53\u524D view \u521B\u5EFA\u7684 scale key
            this.createdScaleKeys.set(key, true);
        }
    };
    /**
     * \u5904\u7406 scale \u540C\u6B65\u903B\u8F91
     */
    View.prototype.syncScale = function () {
        // \u6700\u7EC8\u8C03\u7528 root view \u7684
        this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
    };
    /**
     * \u83B7\u5F97 Geometry \u4E2D\u7684 scale \u5BF9\u8C61
     */
    View.prototype.getGeometryScales = function () {
        var fields = this.getScaleFields();
        var scales = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            scales[field] = this.getScaleByField(field);
        }
        return scales;
    };
    View.prototype.getScaleFields = function () {
        var fields = [];
        var tmpMap = new Map();
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
            var geometry = geometries[i];
            var geometryScales = geometry.getScaleFields();
            uniq(geometryScales, fields, tmpMap);
        }
        return fields;
    };
    View.prototype.getGroupedFields = function () {
        var fields = [];
        var tmpMap = new Map();
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
            var geometry = geometries[i];
            var groupFields = geometry.getGroupFields();
            uniq(groupFields, fields, tmpMap);
        }
        return fields;
    };
    /**
     * \u8C03\u6574 scale \u914D\u7F6E
     * @private
     */
    View.prototype.adjustScales = function () {
        // \u8C03\u6574\u76EE\u524D\u5305\u62EC\uFF1A
        // \u5206\u7C7B scale\uFF0C\u8C03\u6574 range \u8303\u56F4
        this.adjustCategoryScaleRange();
    };
    /**
     * \u8C03\u6574\u5206\u7C7B scale \u7684 range\uFF0C\u9632\u6B62\u8D85\u51FA\u5750\u6807\u7CFB\u5916\u9762
     * @private
     */
    View.prototype.adjustCategoryScaleRange = function () {
        var _this = this;
        var xyScales = (0,tslib_es6/* __spreadArray */.ev)([this.getXScale()], (0,tslib_es6/* __read */.CR)(this.getYScales()), false).filter(function (e) { return !!e; });
        var coordinate = this.getCoordinate();
        var scaleOptions = this.options.scales;
        (0,esm/* each */.S6)(xyScales, function (scale) {
            var field = scale.field, values = scale.values, isCategory = scale.isCategory, isIdentity = scale.isIdentity;
            // \u5206\u7C7B\u6216\u8005 identity \u7684 scale \u624D\u8FDB\u884C\u5904\u7406
            if (isCategory || isIdentity) {
                // \u5B58\u5728 value \u503C\uFF0C\u4E14\u7528\u6237\u6CA1\u6709\u914D\u7F6E range \u914D\u7F6E
                if (values && !(0,esm/* get */.U2)(scaleOptions, [field, 'range'])) {
                    // \u66F4\u65B0 range
                    scale.range = getDefaultCategoryScaleRange(scale, coordinate, _this.theme);
                }
            }
        });
    };
    /**
     * \u6839\u636E options \u914D\u7F6E\u3001Geometry \u5B57\u6BB5\u914D\u7F6E\uFF0C\u81EA\u52A8\u751F\u6210 components
     * @param isUpdate \u662F\u5426\u662F\u66F4\u65B0
     * @private
     */
    View.prototype.initComponents = function (isUpdate) {
        // \u5148\u5168\u90E8\u6E05\u7A7A\uFF0C\u7136\u540E render
        var controllers = this.controllers;
        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];
            // \u66F4\u65B0\u5219\u8D70\u66F4\u65B0\u903B\u8F91\uFF1B\u5426\u5219\u6E05\u7A7A\u8F7D\u91CD\u7ED8
            if (isUpdate) {
                controller.update();
            }
            else {
                controller.clear();
                controller.render();
            }
        }
    };
    View.prototype.doLayout = function () {
        this.layoutFunc(this);
    };
    /**
     * \u521B\u5EFA\u5750\u6807\u7CFB
     * @private
     */
    View.prototype.createCoordinate = function () {
        var start = this.coordinateBBox.bl;
        var end = this.coordinateBBox.tr;
        this.coordinateInstance = this.coordinateController.create(start, end);
    };
    /**
     * \u6839\u636E options \u914D\u7F6E\u81EA\u52A8\u6E32\u67D3 geometry
     * @private
     */
    View.prototype.paintGeometries = function (isUpdate) {
        var doAnimation = this.options.animate;
        // geometry \u7684 paint \u9636\u6BB5
        var coordinate = this.getCoordinate();
        var canvasRegion = {
            x: this.viewBBox.x,
            y: this.viewBBox.y,
            minX: this.viewBBox.minX,
            minY: this.viewBBox.minY,
            maxX: this.viewBBox.maxX,
            maxY: this.viewBBox.maxY,
            width: this.viewBBox.width,
            height: this.viewBBox.height,
        };
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
            var geometry = geometries[i];
            geometry.coordinate = coordinate;
            geometry.canvasRegion = canvasRegion;
            if (!doAnimation) {
                // \u5982\u679C view \u4E0D\u6267\u884C\u52A8\u753B\uFF0C\u90A3\u4E48 view \u4E0B\u6240\u6709\u7684 geometry \u90FD\u4E0D\u6267\u884C\u52A8\u753B
                geometry.animate(false);
            }
            geometry.paint(isUpdate);
        }
    };
    /**
     * \u6700\u540E\u7684\u7ED8\u5236\u7EC4\u4EF6
     * @param isUpdate
     */
    View.prototype.renderComponents = function (isUpdate) {
        var components = this.getComponents();
        // \u5148\u5168\u90E8\u6E05\u7A7A\uFF0C\u7136\u540E render
        for (var i = 0; i < components.length; i++) {
            var co = components[i];
            co.component.render();
        }
    };
    /**
     * \u6E32\u67D3\u5206\u9762\uFF0C\u4F1A\u5728\u5176\u4E2D\u8FDB\u884C\u6570\u636E\u5206\u9762\uFF0C\u7136\u540E\u8FDB\u884C\u5B50 view \u521B\u5EFA
     * @param isUpdate
     */
    View.prototype.renderFacet = function (isUpdate) {
        if (this.facetInstance) {
            if (isUpdate) {
                this.facetInstance.update();
            }
            else {
                this.facetInstance.clear();
                // \u8BA1\u7B97\u5206\u9762\u6570\u636E
                this.facetInstance.init();
                // \u6E32\u67D3\u7EC4\u4EF6\u548C views
                this.facetInstance.render();
            }
        }
    };
    View.prototype.initOptions = function () {
        var _this = this;
        var _a = this.options, _b = _a.geometries, geometries = _b === void 0 ? [] : _b, _c = _a.interactions, interactions = _c === void 0 ? [] : _c, _d = _a.views, views = _d === void 0 ? [] : _d, _e = _a.annotations, annotations = _e === void 0 ? [] : _e, coordinate = _a.coordinate, events = _a.events, facets = _a.facets;
        // \u8BBE\u7F6E\u5750\u6807\u7CFB
        if (this.coordinateController) {
            // \u66F4\u65B0 coordinate controller
            coordinate && this.coordinateController.update(coordinate);
        }
        else {
            // \u521B\u5EFA coordinate controller
            this.coordinateController = new controller_coordinate(coordinate);
        }
        // \u521B\u5EFA geometry \u5B9E\u4F8B
        for (var i = 0; i < geometries.length; i++) {
            var geometryOption = geometries[i];
            this.createGeometry(geometryOption);
        }
        // \u521B\u5EFA interactions \u5B9E\u4F8B
        for (var j = 0; j < interactions.length; j++) {
            var interactionOption = interactions[j];
            var type = interactionOption.type, cfg = interactionOption.cfg;
            this.interaction(type, cfg);
        }
        // \u521B\u5EFA view \u5B9E\u4F8B
        for (var k = 0; k < views.length; k++) {
            var viewOption = views[k];
            this.createView(viewOption);
        }
        // \u8BBE\u7F6E annotation
        var annotationComponent = this.getController('annotation');
        for (var l = 0; l < annotations.length; l++) {
            var annotationOption = annotations[l];
            annotationComponent.annotation(annotationOption);
        }
        // \u8BBE\u7F6E events
        if (events) {
            (0,esm/* each */.S6)(events, function (eventCallback, eventName) {
                _this.on(eventName, eventCallback);
            });
        }
        if (facets) {
            (0,esm/* each */.S6)(facets, function (facet) {
                var type = facet.type, rest = (0,tslib_es6/* __rest */._T)(facet, ["type"]);
                _this.facet(type, rest);
            });
        }
    };
    View.prototype.createGeometry = function (geometryOption) {
        var type = geometryOption.type, _a = geometryOption.cfg, cfg = _a === void 0 ? {} : _a;
        if (this[type]) {
            var geometry_1 = this[type](cfg);
            (0,esm/* each */.S6)(geometryOption, function (v, k) {
                if ((0,esm/* isFunction */.mf)(geometry_1[k])) {
                    geometry_1[k](v);
                }
            });
        }
    };
    /**
     * scale key \u7684\u521B\u5EFA\u65B9\u5F0F
     * @param field
     */
    View.prototype.getScaleKey = function (field) {
        return "".concat(this.id, "-").concat(field);
    };
    return View;
}(base));

/**
 * \u6CE8\u518C geometry \u7EC4\u4EF6
 * @param name
 * @param Ctor
 * @returns Geometry
 */
function registerGeometry(name, Ctor) {
    // \u8BED\u6CD5\u7CD6\uFF0C\u5728 view API \u4E0A\u589E\u52A0\u539F\u578B\u65B9\u6CD5
    View.prototype[name.toLowerCase()] = function (cfg) {
        if (cfg === void 0) { cfg = {}; }
        var props = (0,tslib_es6/* __assign */.pi)({ 
            /** \u56FE\u5F62\u5BB9\u5668 */
            container: this.middleGroup.addGroup(), labelsContainer: this.foregroundGroup.addGroup() }, cfg);
        var geometry = new Ctor(props);
        this.geometries.push(geometry);
        return geometry;
    };
}
/* harmony default export */ var view = (View);
//# sourceMappingURL=view.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/chart.js






/**
 * Chart \u7C7B\uFF0C\u662F\u4F7F\u7528 G2 \u8FDB\u884C\u7ED8\u56FE\u7684\u5165\u53E3\u3002
 */
var Chart = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Chart, _super);
    // @ts-ignore
    function Chart(props) {
        var _this = this;
        var container = props.container, width = props.width, height = props.height, _a = props.autoFit, autoFit = _a === void 0 ? false : _a, padding = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? 'canvas' : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ['tooltip', 'legend-filter', 'legend-active', 'continuous-filter', 'ellipsis-text', 'axis-description'] : _f, options = props.options, limitInPlot = props.limitInPlot, theme = props.theme, syncViewPadding = props.syncViewPadding;
        var ele = (0,esm/* isString */.HD)(container) ? document.getElementById(container) : container;
        // \u751F\u6210\u5185\u90E8\u6B63\u5F0F\u7ED8\u5236\u7684 div \u5143\u7D20
        var wrapperElement = createDom('<div style="position:relative;"></div>');
        ele.appendChild(wrapperElement);
        // if autoFit, use the container size, to avoid the graph render twice.
        var size = getChartSize(ele, autoFit, width, height);
        var G = getEngine(renderer);
        var canvas = new G.Canvas((0,tslib_es6/* __assign */.pi)({ container: wrapperElement, pixelRatio: pixelRatio, localRefresh: localRefresh, supportCSSTransform: supportCSSTransform }, size));
        // \u8C03\u7528 view \u7684\u521B\u5EFA
        _this = _super.call(this, {
            parent: null,
            canvas: canvas,
            // create 3 group layers for views.
            backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
            middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
            foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
            padding: padding,
            appendPadding: appendPadding,
            visible: visible,
            options: options,
            limitInPlot: limitInPlot,
            theme: theme,
            syncViewPadding: syncViewPadding,
        }) || this;
        /**
         * when container size changed, change chart size props, and re-render.
         */
        _this.onResize = (0,esm/* debounce */.Ds)(function () {
            _this.forceFit();
        }, 300);
        _this.ele = ele;
        _this.canvas = canvas;
        _this.width = size.width;
        _this.height = size.height;
        _this.autoFit = autoFit;
        _this.localRefresh = localRefresh;
        _this.renderer = renderer;
        _this.wrapperElement = wrapperElement;
        // \u81EA\u9002\u5E94\u5927\u5C0F
        _this.updateCanvasStyle();
        _this.bindAutoFit();
        _this.initDefaultInteractions(defaultInteractions);
        return _this;
    }
    Chart.prototype.initDefaultInteractions = function (interactions) {
        var _this = this;
        (0,esm/* each */.S6)(interactions, function (interaction) {
            _this.interaction(interaction);
        });
    };
    /**
     * \u8BBE\u7F6E WAI-ARIA \u65E0\u969C\u788D\u6807\u7B7E\u3002\u5982\u4F55\u6839\u636E\u56FE\u5F62\u8BED\u6CD5\u81EA\u52A8\u751F\u6210 arial \u5185\u5BB9\uFF1F
     * @param ariaOption
     */
    Chart.prototype.aria = function (ariaOption) {
        var ATTR = 'aria-label';
        if (ariaOption === false) {
            this.ele.removeAttribute(ATTR);
        }
        else {
            this.ele.setAttribute(ATTR, ariaOption.label);
        }
    };
    /**
     * \u6539\u53D8\u56FE\u8868\u5927\u5C0F\uFF0C\u540C\u65F6\u91CD\u65B0\u6E32\u67D3\u3002
     * @param width \u56FE\u8868\u5BBD\u5EA6
     * @param height \u56FE\u8868\u9AD8\u5EA6
     * @returns
     */
    Chart.prototype.changeSize = function (width, height) {
        // \u5982\u679C\u5BBD\u9AD8\u4E00\u81F4\uFF0C\u90A3\u4E48 changeSize \u4E0D\u6267\u884C\u4EFB\u4F55\u64CD\u4F5C
        if (this.width === width && this.height === height) {
            return this;
        }
        this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
        this.width = width;
        this.height = height;
        this.canvas.changeSize(width, height);
        // \u91CD\u65B0\u6E32\u67D3
        this.render(true);
        this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
        return this;
    };
    /**
     * \u6E05\u7A7A\u56FE\u8868\uFF0C\u540C\u65F6\u6E05\u9664\u6389 aria \u914D\u7F6E
     */
    Chart.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.aria(false);
    };
    /**
     * \u9500\u6BC1\u56FE\u8868\uFF0C\u540C\u65F6\u89E3\u7ED1\u4E8B\u4EF6\uFF0C\u9500\u6BC1\u521B\u5EFA\u7684 G.Canvas \u5B9E\u4F8B\u3002
     * @returns void
     */
    Chart.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.unbindAutoFit();
        this.canvas.destroy();
        removeDom(this.wrapperElement);
        this.wrapperElement = null;
    };
    /**
     * \u663E\u793A\u6216\u9690\u85CF\u56FE\u8868
     * @param visible \u662F\u5426\u53EF\u89C1\uFF0Ctrue \u8868\u793A\u663E\u793A\uFF0Cfalse \u8868\u793A\u9690\u85CF
     * @returns
     */
    Chart.prototype.changeVisible = function (visible) {
        _super.prototype.changeVisible.call(this, visible); // \u9700\u8981\u66F4\u65B0 visible \u53D8\u91CF
        this.wrapperElement.style.display = visible ? '' : 'none';
        return this;
    };
    /**
     * \u81EA\u52A8\u6839\u636E\u5BB9\u5668\u5927\u5C0F resize \u753B\u5E03
     */
    Chart.prototype.forceFit = function () {
        // skip if already destroyed
        if (!this.destroyed) {
            // \u6CE8\u610F\u7B2C\u4E8C\u53C2\u6570\u7528 true\uFF0C\u610F\u601D\u662F\u5373\u65F6 autoFit = false\uFF0CforceFit() \u8C03\u7528\u4E4B\u540E\u4E00\u6837\u662F\u9002\u914D\u5BB9\u5668
            var _a = getChartSize(this.ele, true, this.width, this.height), width = _a.width, height = _a.height;
            this.changeSize(width, height);
        }
    };
    Chart.prototype.updateCanvasStyle = function () {
        modifyCSS(this.canvas.get('el'), {
            display: 'inline-block',
            verticalAlign: 'middle',
        });
    };
    Chart.prototype.bindAutoFit = function () {
        if (this.autoFit) {
            window.addEventListener('resize', this.onResize);
        }
    };
    Chart.prototype.unbindAutoFit = function () {
        if (this.autoFit) {
            window.removeEventListener('resize', this.onResize);
        }
    };
    return Chart;
}(view));
/* harmony default export */ var chart = (Chart);
//# sourceMappingURL=chart.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/base.js

/**
 * Component Controller \u89C4\u8303\u9700\u8981\u5B9A\u4E49\u7684\u57FA\u7C7B
 * 1. \u89C4\u8303\u7684 option \u8F93\u5165
 * 2. \u7EDF\u4E00\u7684\u4FE1\u606F\u83B7\u53D6 API
 * 3. \u660E\u786E\u5B9A\u4E49\u7684\u7EC4\u4EF6\u4E8B\u4EF6\uFF08\u540D\u79F0\u3001\u6570\u636E\uFF09
 */
var Controller = /** @class */ (function () {
    function Controller(view) {
        /** \u662F\u5426\u53EF\u89C1 */
        this.visible = true;
        /** \u6240\u6709\u7684 component */
        this.components = [];
        this.view = view;
    }
    /**
     * clear
     * @param includeOption \u662F\u5426\u6E05\u7A7A option \u914D\u7F6E\u9879\uFF08used in annotation\uFF09
     */
    Controller.prototype.clear = function (includeOption) {
        // destroy all components
        (0,esm/* each */.S6)(this.components, function (co) {
            co.component.destroy();
        });
        // clear all component instance
        this.components = [];
    };
    /**
     * destroy the component
     */
    Controller.prototype.destroy = function () {
        this.clear();
    };
    /**
     * get all components
     * @returns components array
     */
    Controller.prototype.getComponents = function () {
        return this.components;
    };
    /**
     * change visibility of component
     * @param visible
     */
    Controller.prototype.changeVisible = function (visible) {
        if (this.visible === visible) {
            return;
        }
        this.components.forEach(function (co) {
            if (visible) {
                co.component.show();
            }
            else {
                co.component.hide();
            }
        });
        this.visible = visible;
    };
    return Controller;
}());

//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/tooltip.js









// Filter duplicates, use \`name\`, \`color\`, \`value\` and \`title\` property values as condition
function tooltip_uniq(items) {
    var uniqItems = [];
    var _loop_1 = function (index) {
        var item = items[index];
        var result = (0,esm/* find */.sE)(uniqItems, function (subItem) {
            return (subItem.color === item.color &&
                subItem.name === item.name &&
                subItem.value === item.value &&
                subItem.title === item.title);
        });
        if (!result) {
            uniqItems.push(item);
        }
    };
    for (var index = 0; index < items.length; index++) {
        _loop_1(index);
    }
    return uniqItems;
}
/** @ignore */
var tooltip_Tooltip = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Tooltip, _super);
    function Tooltip() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLocked = false;
        return _this;
    }
    Object.defineProperty(Tooltip.prototype, "name", {
        get: function () {
            return 'tooltip';
        },
        enumerable: false,
        configurable: true
    });
    Tooltip.prototype.init = function () { };
    Tooltip.prototype.isVisible = function () {
        var option = this.view.getOptions().tooltip;
        return option !== false;
    };
    Tooltip.prototype.render = function () { };
    /**
     * Shows tooltip
     * @param point
     */
    Tooltip.prototype.showTooltip = function (point) {
        this.point = point;
        if (!this.isVisible()) {
            // \u5982\u679C\u8BBE\u7F6E tooltip(false) \u5219\u59CB\u7EC8\u4E0D\u663E\u793A
            return;
        }
        var view = this.view;
        var items = this.getTooltipItems(point);
        if (!items.length) {
            // \u65E0\u5185\u5BB9\u5219\u4E0D\u5C55\u793A\uFF0C\u540C\u65F6 tooltip \u9700\u8981\u9690\u85CF
            this.hideTooltip();
            return;
        }
        var title = this.getTitle(items);
        var dataPoint = {
            x: items[0].x,
            y: items[0].y,
        }; // \u6570\u636E\u70B9\u4F4D\u7F6E
        view.emit('tooltip:show', chart_event.fromData(view, 'tooltip:show', (0,tslib_es6/* __assign */.pi)({ items: items, title: title }, point)));
        var cfg = this.getTooltipCfg();
        var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
        var lastItems = this.items;
        var lastTitle = this.title;
        if (!(0,esm/* isEqual */.Xy)(lastTitle, title) || !(0,esm/* isEqual */.Xy)(lastItems, items)) {
            // \u5185\u5BB9\u53D1\u751F\u53D8\u5316\u4E86\u66F4\u65B0 tooltip
            view.emit('tooltip:change', chart_event.fromData(view, 'tooltip:change', (0,tslib_es6/* __assign */.pi)({ items: items, title: title }, point)));
            if ((0,esm/* isFunction */.mf)(showContent) ? showContent(items) : showContent) {
                // \u5C55\u793A tooltip \u5185\u5BB9\u6846\u624D\u6E32\u67D3 tooltip
                if (!this.tooltip) {
                    // \u5EF6\u8FDF\u751F\u6210
                    this.renderTooltip();
                }
                this.tooltip.update((0,esm/* mix */.CD)({}, cfg, {
                    items: this.getItemsAfterProcess(items),
                    title: title,
                }, follow ? point : {}));
                this.tooltip.show();
            }
            if (showMarkers) {
                // \u5C55\u793A tooltipMarkers\uFF0CtooltipMarkers \u8DDF\u968F\u6570\u636E
                this.renderTooltipMarkers(items, marker);
            }
        }
        else {
            // \u5185\u5BB9\u672A\u53D1\u751F\u53D8\u5316\uFF0C\u5219\u66F4\u65B0\u4F4D\u7F6E
            if (this.tooltip && follow) {
                this.tooltip.update(point);
                this.tooltip.show(); // tooltip \u6709\u53EF\u80FD\u88AB\u9690\u85CF\uFF0C\u9700\u8981\u4FDD\u8BC1\u663E\u793A\u72B6\u6001
            }
            if (this.tooltipMarkersGroup) {
                this.tooltipMarkersGroup.show();
            }
        }
        this.items = items;
        this.title = title;
        if (showCrosshairs) {
            // \u5C55\u793A tooltip \u8F85\u52A9\u7EBF
            var isCrosshairsFollowCursor = (0,esm/* get */.U2)(cfg, ['crosshairs', 'follow'], false); // \u8F85\u52A9\u7EBF\u662F\u5426\u8981\u8DDF\u968F\u9F20\u6807
            this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
        }
    };
    Tooltip.prototype.hideTooltip = function () {
        var follow = this.getTooltipCfg().follow;
        if (!follow) {
            this.point = null;
            return;
        }
        // hide the tooltipMarkers
        var tooltipMarkersGroup = this.tooltipMarkersGroup;
        if (tooltipMarkersGroup) {
            tooltipMarkersGroup.hide();
        }
        // hide crosshairs
        var xCrosshair = this.xCrosshair;
        var yCrosshair = this.yCrosshair;
        if (xCrosshair) {
            xCrosshair.hide();
        }
        if (yCrosshair) {
            yCrosshair.hide();
        }
        var tooltip = this.tooltip;
        if (tooltip) {
            tooltip.hide();
        }
        this.view.emit('tooltip:hide', chart_event.fromData(this.view, 'tooltip:hide', {}));
        this.point = null;
    };
    /**
     * lockTooltip
     */
    Tooltip.prototype.lockTooltip = function () {
        this.isLocked = true;
        if (this.tooltip) {
            // tooltip contianer \u53EF\u6355\u83B7\u4E8B\u4EF6
            this.tooltip.setCapture(true);
        }
    };
    /**
     * unlockTooltip
     */
    Tooltip.prototype.unlockTooltip = function () {
        this.isLocked = false;
        var cfg = this.getTooltipCfg();
        if (this.tooltip) {
            // \u91CD\u7F6E capture \u5C5E\u6027
            this.tooltip.setCapture(cfg.capture);
        }
    };
    /**
     * isTooltipLocked
     */
    Tooltip.prototype.isTooltipLocked = function () {
        return this.isLocked;
    };
    Tooltip.prototype.clear = function () {
        var _a = this, tooltip = _a.tooltip, xCrosshair = _a.xCrosshair, yCrosshair = _a.yCrosshair, tooltipMarkersGroup = _a.tooltipMarkersGroup;
        if (tooltip) {
            tooltip.hide();
            tooltip.clear();
        }
        if (xCrosshair) {
            xCrosshair.clear();
        }
        if (yCrosshair) {
            yCrosshair.clear();
        }
        if (tooltipMarkersGroup) {
            tooltipMarkersGroup.clear();
        }
        // \u5982\u679C customContent \u4E0D\u4E3A\u7A7A\uFF0C\u5C31\u91CD\u65B0\u751F\u6210 tooltip
        if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get('customContent')) {
            this.tooltip.destroy();
            this.tooltip = null;
        }
        // title \u548C items \u9700\u8981\u6E05\u7A7A, \u5426\u5219 tooltip \u5185\u5BB9\u4F1A\u51FA\u73B0\u7F6E\u7A7A\u7684\u60C5\u51B5
        // \u5373\uFF1A\u9700\u8981\u8D70\u8FDB !isEqual(lastTitle, title) || !isEqual(lastItems, items) \u7684\u903B\u8F91\uFF0C\u66F4\u65B0 tooltip \u7684\u5185\u5BB9
        this.title = null;
        this.items = null;
    };
    Tooltip.prototype.destroy = function () {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
        if (this.xCrosshair) {
            this.xCrosshair.destroy();
        }
        if (this.yCrosshair) {
            this.yCrosshair.destroy();
        }
        if (this.guideGroup) {
            this.guideGroup.remove(true);
        }
        this.reset();
    };
    Tooltip.prototype.reset = function () {
        this.items = null;
        this.title = null;
        this.tooltipMarkersGroup = null;
        this.tooltipCrosshairsGroup = null;
        this.xCrosshair = null;
        this.yCrosshair = null;
        this.tooltip = null;
        this.guideGroup = null;
        this.isLocked = false;
        this.point = null;
    };
    Tooltip.prototype.changeVisible = function (visible) {
        if (this.visible === visible) {
            return;
        }
        var _a = this, tooltip = _a.tooltip, tooltipMarkersGroup = _a.tooltipMarkersGroup, xCrosshair = _a.xCrosshair, yCrosshair = _a.yCrosshair;
        if (visible) {
            if (tooltip) {
                tooltip.show();
            }
            if (tooltipMarkersGroup) {
                tooltipMarkersGroup.show();
            }
            if (xCrosshair) {
                xCrosshair.show();
            }
            if (yCrosshair) {
                yCrosshair.show();
            }
        }
        else {
            if (tooltip) {
                tooltip.hide();
            }
            if (tooltipMarkersGroup) {
                tooltipMarkersGroup.hide();
            }
            if (xCrosshair) {
                xCrosshair.hide();
            }
            if (yCrosshair) {
                yCrosshair.hide();
            }
        }
        this.visible = visible;
    };
    Tooltip.prototype.getTooltipItems = function (point) {
        var e_1, _a, e_2, _b, e_3, _c;
        var items = this.findItemsFromView(this.view, point);
        if (items.length) {
            // \u4E09\u5C42
            items = (0,esm/* flatten */.xH)(items);
            try {
                for (var items_1 = (0,tslib_es6/* __values */.XA)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var itemArr = items_1_1.value;
                    try {
                        for (var itemArr_1 = (e_2 = void 0, (0,tslib_es6/* __values */.XA)(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
                            var item = itemArr_1_1.value;
                            var _d = item.mappingData, x = _d.x, y = _d.y;
                            item.x = (0,esm/* isArray */.kJ)(x) ? x[x.length - 1] : x;
                            item.y = (0,esm/* isArray */.kJ)(y) ? y[y.length - 1] : y;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return)) _b.call(itemArr_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var shared = this.getTooltipCfg().shared;
            // shared: false \u4EE3\u8868\u53EA\u663E\u793A\u5F53\u524D\u62FE\u53D6\u5230\u7684 shape \u7684\u6570\u636E\uFF0C\u4F46\u662F\u4E00\u4E2A view \u4F1A\u6709\u591A\u4E2A Geometry\uFF0C\u6240\u4EE5\u6709\u53EF\u80FD\u4F1A\u62FE\u53D6\u5230\u591A\u4E2A shape
            if (shared === false && items.length > 1) {
                var snapItem = items[0];
                var min = Math.abs(point.y - snapItem[0].y);
                try {
                    for (var items_2 = (0,tslib_es6/* __values */.XA)(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                        var aItem = items_2_1.value;
                        var yDistance = Math.abs(point.y - aItem[0].y);
                        if (yDistance <= min) {
                            snapItem = aItem;
                            min = yDistance;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                items = [snapItem];
            }
            return tooltip_uniq((0,esm/* flatten */.xH)(items));
        }
        return [];
    };
    Tooltip.prototype.layout = function () { };
    Tooltip.prototype.update = function () {
        if (this.point) {
            this.showTooltip(this.point);
        }
        if (this.tooltip) {
            // #2279 \u4FEE\u590Dresize\u4E4B\u540Etooltip\u8D8A\u754C\u7684\u95EE\u9898
            // \u786E\u4FDDtooltip\u5DF2\u7ECF\u521B\u5EFA\u7684\u60C5\u51B5\u4E0B
            var canvas = this.view.getCanvas();
            // TODO \u900D\u4E3A tooltip \u7684\u533A\u57DF\u4E0D\u5E94\u8BE5\u662F canvas\uFF0C\u800C\u5E94\u8BE5\u662F\u6574\u4E2A \u7279\u522B\u662F\u5728\u56FE\u6BD4\u8F83\u5C0F\u7684\u65F6\u5019
            // \u66F4\u65B0 region
            this.tooltip.set('region', {
                start: { x: 0, y: 0 },
                end: { x: canvas.get('width'), y: canvas.get('height') },
            });
        }
    };
    /**
     * \u5F53\u524D\u9F20\u6807\u70B9\u662F\u5728 enter tooltip \u4E2D
     * @param point
     */
    Tooltip.prototype.isCursorEntered = function (point) {
        // \u662F\u53EF\u6355\u83B7\u7684\uFF0C\u5E76\u4E14\u70B9\u5728 tooltip dom \u4E0A
        if (this.tooltip) {
            var el = this.tooltip.getContainer();
            var capture = this.tooltip.get('capture');
            if (el && capture) {
                var _a = el.getBoundingClientRect(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
                return new BBox(x, y, width, height).isPointIn(point);
            }
        }
        return false;
    };
    // \u83B7\u53D6 tooltip \u914D\u7F6E\uFF0C\u56E0\u4E3A\u7528\u6237\u53EF\u80FD\u4F1A\u901A\u8FC7 view.tooltip() \u91CD\u65B0\u914D\u7F6E tooltip\uFF0C\u6240\u4EE5\u5C31\u4E0D\u505A\u7F13\u5B58\uFF0C\u6BCF\u6B21\u76F4\u63A5\u8BFB\u53D6
    Tooltip.prototype.getTooltipCfg = function () {
        var view = this.view;
        var option = view.getOptions().tooltip;
        var processOption = this.processCustomContent(option);
        var theme = view.getTheme();
        var defaultCfg = (0,esm/* get */.U2)(theme, ['components', 'tooltip'], {});
        var enterable = (0,esm/* get */.U2)(processOption, 'enterable', defaultCfg.enterable);
        return (0,esm/* deepMix */.b$)({}, defaultCfg, processOption, {
            capture: enterable || this.isLocked ? true : false,
        });
    };
    // process customContent
    Tooltip.prototype.processCustomContent = function (option) {
        if ((0,esm/* isBoolean */.jn)(option) || !(0,esm/* get */.U2)(option, 'customContent')) {
            return option;
        }
        var currentCustomContent = option.customContent;
        var customContent = function (title, items) {
            var content = currentCustomContent(title, items) || '';
            return (0,esm/* isString */.HD)(content) ? '<div class="g2-tooltip">' + content + '</div>' : content;
        };
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { customContent: customContent });
    };
    Tooltip.prototype.getTitle = function (items) {
        var title = items[0].title || items[0].name;
        this.title = title;
        return title;
    };
    Tooltip.prototype.renderTooltip = function () {
        var canvas = this.view.getCanvas();
        var region = {
            start: { x: 0, y: 0 },
            end: { x: canvas.get('width'), y: canvas.get('height') },
        };
        var cfg = this.getTooltipCfg();
        var tooltip = new HtmlTooltip((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ parent: canvas.get('el').parentNode, region: region }, cfg), { visible: false, crosshairs: null }));
        tooltip.init();
        this.tooltip = tooltip;
    };
    Tooltip.prototype.renderTooltipMarkers = function (items, marker) {
        var e_4, _a;
        var tooltipMarkersGroup = this.getTooltipMarkersGroup();
        var rootView = this.view.getRootView();
        var limitInPlot = rootView.limitInPlot;
        try {
            for (var items_3 = (0,tslib_es6/* __values */.XA)(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                var item = items_3_1.value;
                var x = item.x, y = item.y;
                // \u6709\u88C1\u526A\u5C31\u526A\u5207
                if (limitInPlot || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
                    var _b = getCoordinateClipCfg(rootView.getCoordinate()), type = _b.type, attrs_1 = _b.attrs;
                    tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({
                        type: type,
                        attrs: attrs_1,
                    });
                }
                else {
                    // \u6E05\u9664\u5DF2\u6709\u7684 clip
                    tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(undefined);
                }
                var theme = this.view.getTheme();
                var markerDefaultCfg = (0,esm/* get */.U2)(theme, ['components', 'tooltip', 'marker'], {});
                var attrs = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ fill: item.color, symbol: 'circle', shadowColor: item.color }, ((0,esm/* isFunction */.mf)(marker) ? (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, markerDefaultCfg), marker(item)) : marker)), { x: x, y: y });
                tooltipMarkersGroup.addShape('marker', {
                    attrs: attrs,
                });
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    Tooltip.prototype.renderCrosshairs = function (point, cfg) {
        var crosshairsType = (0,esm/* get */.U2)(cfg, ['crosshairs', 'type'], 'x'); // \u9ED8\u8BA4\u5C55\u793A x \u8F74\u4E0A\u7684\u8F85\u52A9\u7EBF
        if (crosshairsType === 'x') {
            if (this.yCrosshair) {
                this.yCrosshair.hide();
            }
            this.renderXCrosshairs(point, cfg);
        }
        else if (crosshairsType === 'y') {
            if (this.xCrosshair) {
                this.xCrosshair.hide();
            }
            this.renderYCrosshairs(point, cfg);
        }
        else if (crosshairsType === 'xy') {
            this.renderXCrosshairs(point, cfg);
            this.renderYCrosshairs(point, cfg);
        }
    };
    // \u6E32\u67D3 x \u8F74\u4E0A\u7684 tooltip \u8F85\u52A9\u7EBF
    Tooltip.prototype.renderXCrosshairs = function (point, tooltipCfg) {
        var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
        var start;
        var end;
        if (coordinate.isRect) {
            if (coordinate.isTransposed) {
                start = {
                    x: coordinate.start.x,
                    y: point.y,
                };
                end = {
                    x: coordinate.end.x,
                    y: point.y,
                };
            }
            else {
                start = {
                    x: point.x,
                    y: coordinate.end.y,
                };
                end = {
                    x: point.x,
                    y: coordinate.start.y,
                };
            }
        }
        else {
            // \u6781\u5750\u6807\u4E0B x \u8F74\u4E0A\u7684 crosshairs \u8868\u73B0\u4E3A\u534A\u5F84
            var angle = getAngleByPoint(coordinate, point);
            var center = coordinate.getCenter();
            var radius = coordinate.getRadius();
            end = polarToCartesian(center.x, center.y, radius, angle);
            start = center;
        }
        var cfg = (0,esm/* deepMix */.b$)({
            start: start,
            end: end,
            container: this.getTooltipCrosshairsGroup(),
        }, (0,esm/* get */.U2)(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('x', point, tooltipCfg));
        delete cfg.type; // \u4E0E Crosshairs \u7EC4\u4EF6\u7684 type \u51B2\u7A81\u6545\u5220\u9664
        var xCrosshair = this.xCrosshair;
        if (xCrosshair) {
            xCrosshair.update(cfg);
        }
        else {
            xCrosshair = new crosshair_line(cfg);
            xCrosshair.init();
        }
        xCrosshair.render();
        xCrosshair.show();
        this.xCrosshair = xCrosshair;
    };
    // \u6E32\u67D3 y \u8F74\u4E0A\u7684\u8F85\u52A9\u7EBF
    Tooltip.prototype.renderYCrosshairs = function (point, tooltipCfg) {
        var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
        var cfg;
        var type;
        if (coordinate.isRect) {
            var start = void 0;
            var end = void 0;
            if (coordinate.isTransposed) {
                start = {
                    x: point.x,
                    y: coordinate.end.y,
                };
                end = {
                    x: point.x,
                    y: coordinate.start.y,
                };
            }
            else {
                start = {
                    x: coordinate.start.x,
                    y: point.y,
                };
                end = {
                    x: coordinate.end.x,
                    y: point.y,
                };
            }
            cfg = {
                start: start,
                end: end,
            };
            type = 'Line';
        }
        else {
            // \u6781\u5750\u6807\u4E0B y \u8F74\u4E0A\u7684 crosshairs \u8868\u73B0\u4E3A\u5706\u5F27
            cfg = {
                center: coordinate.getCenter(),
                // @ts-ignore
                radius: getDistanceToCenter(coordinate, point),
                startAngle: coordinate.startAngle,
                endAngle: coordinate.endAngle,
            };
            type = 'Circle';
        }
        cfg = (0,esm/* deepMix */.b$)({
            container: this.getTooltipCrosshairsGroup(),
        }, cfg, (0,esm/* get */.U2)(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('y', point, tooltipCfg));
        delete cfg.type; // \u4E0E Crosshairs \u7EC4\u4EF6\u7684 type \u51B2\u7A81\u6545\u5220\u9664
        var yCrosshair = this.yCrosshair;
        if (yCrosshair) {
            // \u5982\u679C\u5750\u6807\u7CFB\u53D1\u751F\u76F4\u89D2\u5750\u6807\u7CFB\u4E0E\u6781\u5750\u6807\u7684\u5207\u6362\u64CD\u4F5C
            if ((coordinate.isRect && yCrosshair.get('type') === 'circle') ||
                (!coordinate.isRect && yCrosshair.get('type') === 'line')) {
                yCrosshair = new crosshair_namespaceObject[type](cfg);
                yCrosshair.init();
            }
            else {
                yCrosshair.update(cfg);
            }
        }
        else {
            yCrosshair = new crosshair_namespaceObject[type](cfg);
            yCrosshair.init();
        }
        yCrosshair.render();
        yCrosshair.show();
        this.yCrosshair = yCrosshair;
    };
    Tooltip.prototype.getCrosshairsText = function (type, point, tooltipCfg) {
        var textCfg = (0,esm/* get */.U2)(tooltipCfg, ['crosshairs', 'text']);
        var follow = (0,esm/* get */.U2)(tooltipCfg, ['crosshairs', 'follow']);
        var items = this.items;
        if (textCfg) {
            var view = this.getViewWithGeometry(this.view);
            // \u9700\u8981\u5C55\u793A\u6587\u672C
            var firstItem = items[0];
            var xScale = view.getXScale();
            var yScale = view.getYScales()[0];
            var xValue = void 0;
            var yValue = void 0;
            if (follow) {
                // \u5982\u679C\u9700\u8981\u8DDF\u968F\u9F20\u6807\u79FB\u52A8\uFF0C\u5C31\u9700\u8981\u5C06\u5F53\u524D\u9F20\u6807\u5750\u6807\u70B9\u8F6C\u6362\u4E3A\u5BF9\u5E94\u7684\u6570\u503C
                var invertPoint = this.view.getCoordinate().invert(point);
                xValue = xScale.invert(invertPoint.x); // \u8F6C\u6362\u4E3A\u539F\u59CB\u503C
                yValue = yScale.invert(invertPoint.y); // \u8F6C\u6362\u4E3A\u539F\u59CB\u503C
            }
            else {
                xValue = firstItem.data[xScale.field];
                yValue = firstItem.data[yScale.field];
            }
            var content = type === 'x' ? xValue : yValue;
            if ((0,esm/* isFunction */.mf)(textCfg)) {
                textCfg = textCfg(type, content, items, point);
            }
            else {
                textCfg.content = content;
            }
            return {
                text: textCfg,
            };
        }
    };
    // \u83B7\u53D6\u5B58\u50A8 tooltipMarkers \u548C crosshairs \u7684\u5BB9\u5668
    Tooltip.prototype.getGuideGroup = function () {
        if (!this.guideGroup) {
            var foregroundGroup = this.view.foregroundGroup;
            this.guideGroup = foregroundGroup.addGroup({
                name: 'tooltipGuide',
                capture: false,
            });
        }
        return this.guideGroup;
    };
    // \u83B7\u53D6 tooltipMarkers \u5B58\u50A8\u7684\u5BB9\u5668
    Tooltip.prototype.getTooltipMarkersGroup = function () {
        var tooltipMarkersGroup = this.tooltipMarkersGroup;
        if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
            tooltipMarkersGroup.clear();
            tooltipMarkersGroup.show();
        }
        else {
            tooltipMarkersGroup = this.getGuideGroup().addGroup({
                name: 'tooltipMarkersGroup',
            });
            tooltipMarkersGroup.toFront();
            this.tooltipMarkersGroup = tooltipMarkersGroup;
        }
        return tooltipMarkersGroup;
    };
    // \u83B7\u53D6 tooltip crosshairs \u5B58\u50A8\u7684\u5BB9\u5668
    Tooltip.prototype.getTooltipCrosshairsGroup = function () {
        var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
        if (!tooltipCrosshairsGroup) {
            tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
                name: 'tooltipCrosshairsGroup',
                capture: false,
            });
            tooltipCrosshairsGroup.toBack();
            this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
        }
        return tooltipCrosshairsGroup;
    };
    Tooltip.prototype.findItemsFromView = function (view, point) {
        var e_5, _a;
        if (view.getOptions().tooltip === false) {
            // \u5982\u679C view \u5173\u95ED\u4E86 tooltip
            return [];
        }
        var tooltipCfg = this.getTooltipCfg();
        var result = findItemsFromView(view, point, tooltipCfg);
        try {
            // \u9012\u5F52\u67E5\u627E\uFF0C\u5E76\u5408\u5E76\u7ED3\u679C
            for (var _b = (0,tslib_es6/* __values */.XA)(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childView = _c.value;
                result = result.concat(this.findItemsFromView(childView, point));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return result;
    };
    // FIXME: hack \u65B9\u6CD5
    // \u56E0\u4E3A tooltip \u7684\u4EA4\u4E92\u662F\u6302\u8F7D\u5728 Chart \u4E0A\uFF0C\u6240\u4EE5\u5F53chart \u4E0A\u6CA1\u6709\u7ED8\u5236 Geometry \u7684\u65F6\u5019\uFF0C\u5C31\u67E5\u627E\u4E0D\u5230\u6570\u636E\uFF0C\u5E76\u4E14\u7ED8\u56FE\u533A\u57DF\u540C\u5B50 View \u7684\u533A\u57DF\u4E0D\u540C
    Tooltip.prototype.getViewWithGeometry = function (view) {
        var _this = this;
        if (view.geometries.length) {
            return view;
        }
        return (0,esm/* find */.sE)(view.views, function (childView) { return _this.getViewWithGeometry(childView); });
    };
    /**
     * \u6839\u636E\u7528\u6237\u914D\u7F6E\u7684 items \u914D\u7F6E\uFF0C\u6765\u8FDB\u884C\u7528\u6237\u81EA\u5B9A\u4E49\u7684\u5904\u7406\uFF0C\u5E76\u8FD4\u56DE\u6700\u7EC8\u7684 items
     * \u9ED8\u8BA4\u4E0D\u505A\u4EFB\u4F55\u5904\u7406
     */
    Tooltip.prototype.getItemsAfterProcess = function (originalItems) {
        var customItems = this.getTooltipCfg().customItems;
        var fn = customItems ? customItems : function (v) { return v; };
        return fn(originalItems);
    };
    return Tooltip;
}(Controller));
/* harmony default export */ var tooltip = (tooltip_Tooltip);
//# sourceMappingURL=tooltip.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/index.js
var ANIMATIONS_MAP = {};
/**
 * \u6839\u636E\u540D\u79F0\u83B7\u53D6\u5BF9\u5E94\u7684\u52A8\u753B\u6267\u884C\u51FD\u6570
 * @param type \u52A8\u753B\u51FD\u6570\u540D\u79F0
 */
function getAnimation(type) {
    return ANIMATIONS_MAP[type.toLowerCase()];
}
/**
 * \u6CE8\u518C\u52A8\u753B\u6267\u884C\u51FD\u6570
 * @param type \u52A8\u753B\u6267\u884C\u51FD\u6570\u540D\u79F0
 * @param animation \u52A8\u753B\u6267\u884C\u51FD\u6570
 */
function registerAnimation(type, animation) {
    ANIMATIONS_MAP[type.toLowerCase()] = animation;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/index.js




// \u9ED8\u8BA4\u7684\u52A8\u753B\u53C2\u6570\u914D\u7F6E
var DEFAULT_ANIMATE_CFG = {
    appear: {
        duration: 450,
        easing: 'easeQuadOut',
    },
    update: {
        duration: 400,
        easing: 'easeQuadInOut',
    },
    enter: {
        duration: 400,
        easing: 'easeQuadInOut',
    },
    leave: {
        duration: 350,
        easing: 'easeQuadIn',
    }, // \u66F4\u65B0\u65F6\u9500\u6BC1\u52A8\u753B\u914D\u7F6E
};
// \u5404\u4E2A Geometry \u9ED8\u8BA4\u7684\u52A8\u753B\u6267\u884C\u51FD\u6570
var GEOMETRY_ANIMATE_CFG = {
    interval: function (coordinate) {
        return {
            enter: {
                animation: coordinate.isRect ? (coordinate.isTransposed ? 'scale-in-x' : 'scale-in-y') : 'fade-in',
            },
            update: {
                animation: coordinate.isPolar && coordinate.isTransposed ? 'sector-path-update' : null,
            },
            leave: {
                animation: 'fade-out',
            },
        };
    },
    line: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    path: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    point: {
        appear: {
            animation: 'zoom-in',
        },
        enter: {
            animation: 'zoom-in',
        },
        leave: {
            animation: 'zoom-out',
        },
    },
    area: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    polygon: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    schema: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    edge: {
        enter: {
            animation: 'fade-in',
        },
        leave: {
            animation: 'fade-out',
        },
    },
    label: {
        appear: {
            animation: 'fade-in',
            delay: 450,
        },
        enter: {
            animation: 'fade-in',
        },
        update: {
            animation: 'position-update',
        },
        leave: {
            animation: 'fade-out',
        },
    },
};
// \u5404\u4E2A Geometry \u9ED8\u8BA4\u7684\u7FA4\u7EC4\u51FA\u573A\u52A8\u753B
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
    line: function () {
        return {
            animation: 'wave-in',
        };
    },
    area: function () {
        return {
            animation: 'wave-in',
        };
    },
    path: function () {
        return {
            animation: 'fade-in',
        };
    },
    interval: function (coordinate) {
        var animation;
        if (coordinate.isRect) {
            animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
        }
        else {
            animation = 'grow-in-xy';
            if (coordinate.isPolar && coordinate.isTransposed) {
                // pie chart
                animation = 'wave-in';
            }
        }
        return {
            animation: animation,
        };
    },
    schema: function (coordinate) {
        var animation;
        if (coordinate.isRect) {
            animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
        }
        else {
            animation = 'grow-in-xy';
        }
        return {
            animation: animation,
        };
    },
    polygon: function () {
        return {
            animation: 'fade-in',
            duration: 500,
        };
    },
    edge: function () {
        return {
            animation: 'fade-in',
        };
    },
};
// \u89E3\u6790\u7528\u6237\u7684\u52A8\u753B\u914D\u7F6E
function parseAnimateConfig(animateCfg, data) {
    return {
        delay: (0,esm/* isFunction */.mf)(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
        easing: (0,esm/* isFunction */.mf)(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
        duration: (0,esm/* isFunction */.mf)(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
        callback: animateCfg.callback,
        repeat: animateCfg.repeat,
    };
}
/**
 * @ignore
 * \u83B7\u53D6 elementName \u5BF9\u5E94\u7684\u52A8\u753B\u914D\u7F6E\uFF0C\u5F53\u58F0\u660E\u4E86 \`animateType\`\uFF0C\u5219\u8FD4\u56DE \`animateType\` \u5BF9\u5E94\u7684\u52A8\u753B\u914D\u7F6E
 * @param elementName \u5143\u7D20\u540D\u79F0
 * @param coordinate \u505A\u8868\u5F1F\u7C7B\u578B
 * @param animateType \u53EF\u9009\uFF0C\u52A8\u753B\u7C7B\u578B
 */
function getDefaultAnimateCfg(elementName, coordinate, animateType) {
    var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
    if (animateCfg) {
        if ((0,esm/* isFunction */.mf)(animateCfg)) {
            animateCfg = animateCfg(coordinate);
        }
        animateCfg = (0,esm/* deepMix */.b$)({}, DEFAULT_ANIMATE_CFG, animateCfg);
        if (animateType) {
            return animateCfg[animateType];
        }
    }
    return animateCfg;
}
/**
 * @ignore
 * \u5DE5\u5177\u51FD\u6570
 * \u6839\u636E\u7528\u6237\u4F20\u5165\u7684\u914D\u7F6E\u4E3A shape \u6267\u884C\u52A8\u753B
 * @param shape \u6267\u884C\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u7684\u4FE1\u606F
 */
function doAnimate(shape, animateCfg, cfg) {
    var data = (0,esm/* get */.U2)(shape.get('origin'), 'data', FIELD_ORIGIN);
    var animation = animateCfg.animation; // \u83B7\u53D6\u52A8\u753B\u6267\u884C\u51FD\u6570
    var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);
    if (animation) {
        // \u7528\u6237\u58F0\u660E\u4E86\u52A8\u753B\u6267\u884C\u51FD\u6570
        var animateFunction = getAnimation(animation);
        if (animateFunction) {
            animateFunction(shape, parsedAnimateCfg, cfg);
        }
    }
    else {
        // \u6CA1\u6709\u58F0\u660E\uFF0C\u5219\u6839\u636E toAttrs \u505A\u5DEE\u503C\u52A8\u753B
        shape.animate(cfg.toAttrs, parsedAnimateCfg);
    }
}
/**
 * @ignore
 * \u6267\u884C Geometry \u7FA4\u7EC4\u5165\u573A\u52A8\u753B
 * @param container \u6267\u884C\u7FA4\u7EC4\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param geometryType geometry \u7C7B\u578B
 * @param coordinate \u5750\u6807\u7CFB\u5BF9\u8C61
 * @param minYPoint y \u8F74\u6700\u5C0F\u503C\u5BF9\u5E94\u7684\u753B\u5E03\u5750\u6807\u70B9
 */
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
    if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
        var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
        var animation = getAnimation((0,esm/* get */.U2)(defaultCfg, 'animation', ''));
        if (animation) {
            var cfg = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
            container.stopAnimate(); // \u5148\u7ED3\u675F\u5F53\u524D container \u52A8\u753B
            animation(container, cfg, {
                coordinate: coordinate,
                minYPoint: minYPoint,
                toAttrs: null,
            });
        }
    }
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/constant.js
/**
 * Name of Background Shape
 */
var BACKGROUND_SHAPE = 'element-background';
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/element/index.js


// \u6682\u672A\u53D1\u5305
// @ts-ignore






/**
 * Element \u56FE\u5F62\u5143\u7D20\u3002
 * \u5B9A\u4E49\uFF1A\u5728 G2 \u4E2D\uFF0C\u6211\u4EEC\u4F1A\u5C06\u6570\u636E\u901A\u8FC7\u56FE\u5F62\u8BED\u6CD5\u6620\u5C04\u6210\u4E0D\u540C\u7684\u56FE\u5F62\uFF0C\u6BD4\u5982\u70B9\u56FE\uFF0C\u6570\u636E\u96C6\u4E2D\u7684\u6BCF\u6761\u6570\u636E\u4F1A\u5BF9\u5E94\u4E00\u4E2A\u70B9\uFF0C\u67F1\u72B6\u56FE\u6BCF\u6761\u6570\u636E\u5BF9\u5E94\u4E00\u4E2A\u67F1\u5B50\uFF0C\u7EBF\u56FE\u5219\u662F\u4E00\u7EC4\u6570\u636E\u5BF9\u5E94\u4E00\u6761\u6298\u7EBF\uFF0CElement \u5373\u4E00\u6761/\u4E00\u7EC4\u6570\u636E\u5BF9\u5E94\u7684\u56FE\u5F62\u5143\u7D20\uFF0C\u5B83\u4EE3\u8868\u4E00\u6761\u6570\u636E\u6216\u8005\u4E00\u4E2A\u6570\u636E\u96C6\uFF0C\u5728\u56FE\u5F62\u5C42\u9762\uFF0C\u5B83\u53EF\u4EE5\u662F\u5355\u4E2A Shape \u4E5F\u53EF\u4EE5\u662F\u591A\u4E2A Shape\uFF0C\u6211\u4EEC\u79F0\u4E4B\u4E3A\u56FE\u5F62\u5143\u7D20\u3002
 */
var element_Element = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Element, _super);
    function Element(cfg) {
        var _this = _super.call(this, cfg) || this;
        /** \u4FDD\u5B58 shape \u5BF9\u5E94\u7684 label */
        _this.labelShape = [];
        // \u5B58\u50A8\u5F53\u524D\u5F00\u542F\u7684\u72B6\u6001
        _this.states = [];
        var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a = cfg.visible, visible = _a === void 0 ? true : _a;
        _this.shapeFactory = shapeFactory;
        _this.container = container;
        _this.offscreenGroup = offscreenGroup;
        _this.visible = visible;
        _this.elementIndex = elementIndex;
        return _this;
    }
    /**
     * \u7ED8\u5236\u56FE\u5F62\u3002
     * @param model \u7ED8\u5236\u6570\u636E\u3002
     * @param isUpdate \u53EF\u9009\uFF0C\u662F\u5426\u662F\u66F4\u65B0\u53D1\u751F\u540E\u7684\u7ED8\u5236\u3002
     */
    Element.prototype.draw = function (model, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        this.model = model;
        this.data = model.data; // \u5B58\u50A8\u539F\u59CB\u6570\u636E
        this.shapeType = this.getShapeType(model);
        // \u7ED8\u5236\u56FE\u5F62
        this.drawShape(model, isUpdate);
        if (this.visible === false) {
            // \u7528\u6237\u5728\u521D\u59CB\u5316\u7684\u65F6\u5019\u58F0\u660E visible: false
            this.changeVisible(false);
        }
    };
    /**
     * \u66F4\u65B0\u56FE\u5F62\u3002
     * @param model \u66F4\u65B0\u7684\u7ED8\u5236\u6570\u636E\u3002
     */
    Element.prototype.update = function (model) {
        var _a = this, shapeFactory = _a.shapeFactory, shape = _a.shape;
        if (!shape) {
            return;
        }
        // \u66F4\u65B0\u6570\u636E
        this.model = model;
        this.data = model.data;
        this.shapeType = this.getShapeType(model);
        // step 1: \u66F4\u65B0 shape \u643A\u5E26\u7684\u4FE1\u606F
        this.setShapeInfo(shape, model);
        // step 2: \u4F7F\u7528\u865A\u62DF Group \u91CD\u65B0\u7ED8\u5236 shape\uFF0C\u7136\u540E\u66F4\u65B0\u5F53\u524D shape
        var offscreenGroup = this.getOffscreenGroup();
        var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
        // @ts-ignore
        newShape.cfg.data = this.data;
        // @ts-ignore
        newShape.cfg.origin = model;
        // label \u9700\u8981\u4F7F\u7528
        newShape.cfg.element = this;
        // step 3: \u540C\u6B65 shape \u6837\u5F0F
        this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));
    };
    /**
     * \u9500\u6BC1 element \u5B9E\u4F8B\u3002
     */
    Element.prototype.destroy = function () {
        var _a = this, shapeFactory = _a.shapeFactory, shape = _a.shape;
        if (shape) {
            var animateCfg = this.getAnimateCfg('leave');
            if (animateCfg) {
                // \u6307\u5B9A\u4E86\u52A8\u753B\u914D\u7F6E\u5219\u6267\u884C\u9500\u6BC1\u52A8\u753B
                doAnimate(shape, animateCfg, {
                    coordinate: shapeFactory.coordinate,
                    toAttrs: (0,tslib_es6/* __assign */.pi)({}, shape.attr()),
                });
            }
            else {
                // \u5426\u5219\u76F4\u63A5\u9500\u6BC1
                shape.remove(true);
            }
        }
        // reset
        this.states = [];
        this.shapeFactory = undefined;
        this.container = undefined;
        this.shape = undefined;
        this.animate = undefined;
        this.geometry = undefined;
        this.labelShape = [];
        this.model = undefined;
        this.data = undefined;
        this.offscreenGroup = undefined;
        this.statesStyle = undefined;
        _super.prototype.destroy.call(this);
    };
    /**
     * \u663E\u793A\u6216\u8005\u9690\u85CF element\u3002
     * @param visible \u662F\u5426\u53EF\u89C1\u3002
     */
    Element.prototype.changeVisible = function (visible) {
        _super.prototype.changeVisible.call(this, visible);
        if (visible) {
            if (this.shape) {
                this.shape.show();
            }
            if (this.labelShape) {
                this.labelShape.forEach(function (label) {
                    label.show();
                });
            }
        }
        else {
            if (this.shape) {
                this.shape.hide();
            }
            if (this.labelShape) {
                this.labelShape.forEach(function (label) {
                    label.hide();
                });
            }
        }
    };
    /**
     * \u8BBE\u7F6E Element \u7684\u72B6\u6001\u3002
     *
     * \u76EE\u524D Element \u5F00\u653E\u4E09\u79CD\u72B6\u6001\uFF1A
     * 1. active
     * 2. selected
     * 3. inactive
     *
     * \u8FD9\u4E09\u79CD\u72B6\u6001\u76F8\u4E92\u72EC\u7ACB\uFF0C\u53EF\u4EE5\u8FDB\u884C\u53E0\u52A0\u3002
     *
     * \u8FD9\u4E09\u79CD\u72B6\u6001\u7684\u6837\u5F0F\u53EF\u5728 [[Theme]] \u4E3B\u9898\u4E2D\u6216\u8005\u901A\u8FC7 \`geometry.state()\` \u63A5\u53E3\u8FDB\u884C\u914D\u7F6E\u3002
     *
     * \`\`\`ts
     * // \u6FC0\u6D3B active \u72B6\u6001
     * setState('active', true);
     * \`\`\`
     *
     * @param stateName \u72B6\u6001\u540D
     * @param stateStatus \u662F\u5426\u5F00\u542F\u72B6\u6001
     */
    Element.prototype.setState = function (stateName, stateStatus) {
        var _a = this, states = _a.states, shapeFactory = _a.shapeFactory, model = _a.model, shape = _a.shape, shapeType = _a.shapeType;
        var index = states.indexOf(stateName);
        if (stateStatus) {
            // \u5F00\u542F\u72B6\u6001
            if (index > -1) {
                // \u8BE5\u72B6\u6001\u5DF2\u7ECF\u5F00\u542F\uFF0C\u5219\u8FD4\u56DE
                return;
            }
            states.push(stateName);
            if (stateName === 'active' || stateName === 'selected') {
                shape === null || shape === void 0 ? void 0 : shape.toFront();
            }
        }
        else {
            if (index === -1) {
                // \u5173\u95ED\u72B6\u6001\uFF0C\u4F46\u662F\u72B6\u6001\u672A\u8BBE\u7F6E\u8FC7
                return;
            }
            states.splice(index, 1);
            if (stateName === 'active' || stateName === 'selected') {
                var _b = this.geometry, sortZIndex = _b.sortZIndex, zIndexReversed = _b.zIndexReversed;
                var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
                sortZIndex ? shape.setZIndex(idx) : shape.set('zIndex', idx);
            }
        }
        // \u4F7F\u7528\u865A\u62DF group \u91CD\u65B0\u7ED8\u5236 shape\uFF0C\u7136\u540E\u5BF9\u8FD9\u4E2A shape \u5E94\u7528\u72B6\u6001\u6837\u5F0F\u540E\uFF0C\u66F4\u65B0\u5F53\u524D shape\u3002
        var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
        if (states.length) {
            // \u5E94\u7528\u5F53\u524D\u72B6\u6001
            this.syncShapeStyle(shape, offscreenShape, states, null);
        }
        else {
            // \u5982\u679C\u6CA1\u6709\u72B6\u6001\uFF0C\u5219\u9700\u8981\u6062\u590D\u81F3\u539F\u59CB\u72B6\u6001
            this.syncShapeStyle(shape, offscreenShape, ['reset'], null);
        }
        offscreenShape.remove(true); // \u9500\u6BC1\uFF0C\u51CF\u5C11\u5185\u5B58\u5360\u7528
        var eventObject = {
            state: stateName,
            stateStatus: stateStatus,
            element: this,
            target: this.container,
        };
        this.container.emit('statechange', eventObject);
        // @ts-ignore
        propagationDelegate(this.shape, 'statechange', eventObject);
    };
    /**
     * \u6E05\u7A7A\u72B6\u91CF\u6001\uFF0C\u6062\u590D\u81F3\u521D\u59CB\u72B6\u6001\u3002
     */
    Element.prototype.clearStates = function () {
        var _this = this;
        var states = this.states;
        (0,esm/* each */.S6)(states, function (state) {
            _this.setState(state, false);
        });
        this.states = [];
    };
    /**
     * \u67E5\u8BE2\u5F53\u524D Element \u4E0A\u662F\u5426\u5DF2\u8BBE\u7F6E \`stateName\` \u5BF9\u5E94\u7684\u72B6\u6001\u3002
     * @param stateName \u72B6\u6001\u540D\u79F0\u3002
     * @returns true \u8868\u793A\u5B58\u5728\uFF0Cfalse \u8868\u793A\u4E0D\u5B58\u5728\u3002
     */
    Element.prototype.hasState = function (stateName) {
        return this.states.includes(stateName);
    };
    /**
     * \u83B7\u53D6\u5F53\u524D Element \u4E0A\u6240\u6709\u7684\u72B6\u6001\u3002
     * @returns \u5F53\u524D Element \u4E0A\u6240\u6709\u7684\u72B6\u6001\u6570\u7EC4\u3002
     */
    Element.prototype.getStates = function () {
        return this.states;
    };
    /**
     * \u83B7\u53D6 Element \u5BF9\u5E94\u7684\u539F\u59CB\u6570\u636E\u3002
     * @returns \u539F\u59CB\u6570\u636E\u3002
     */
    Element.prototype.getData = function () {
        return this.data;
    };
    /**
     * \u83B7\u53D6 Element \u5BF9\u5E94\u7684\u56FE\u5F62\u7ED8\u5236\u6570\u636E\u3002
     * @returns \u56FE\u5F62\u7ED8\u5236\u6570\u636E\u3002
     */
    Element.prototype.getModel = function () {
        return this.model;
    };
    /**
     * \u8FD4\u56DE Element \u5143\u7D20\u6574\u4F53\u7684 bbox\uFF0C\u5305\u542B\u6587\u672C\u53CA\u6587\u672C\u8FDE\u7EBF\uFF08\u6709\u7684\u8BDD\uFF09\u3002
     * @returns \u6574\u4F53\u5305\u56F4\u76D2\u3002
     */
    Element.prototype.getBBox = function () {
        var _a = this, shape = _a.shape, labelShape = _a.labelShape;
        var bbox = {
            x: 0,
            y: 0,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            width: 0,
            height: 0,
        };
        if (shape) {
            bbox = shape.getCanvasBBox();
        }
        if (labelShape) {
            labelShape.forEach(function (label) {
                var labelBBox = label.getCanvasBBox();
                bbox.x = Math.min(labelBBox.x, bbox.x);
                bbox.y = Math.min(labelBBox.y, bbox.y);
                bbox.minX = Math.min(labelBBox.minX, bbox.minX);
                bbox.minY = Math.min(labelBBox.minY, bbox.minY);
                bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
                bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
            });
        }
        bbox.width = bbox.maxX - bbox.minX;
        bbox.height = bbox.maxY - bbox.minY;
        return bbox;
    };
    Element.prototype.getStatesStyle = function () {
        if (!this.statesStyle) {
            var _a = this, shapeType = _a.shapeType, geometry = _a.geometry, shapeFactory = _a.shapeFactory;
            var stateOption = geometry.stateOption;
            var defaultShapeType = shapeFactory.defaultShapeType;
            var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
            this.statesStyle = (0,esm/* deepMix */.b$)({}, stateTheme, stateOption);
        }
        return this.statesStyle;
    };
    // \u4ECE\u4E3B\u9898\u4E2D\u83B7\u53D6\u5BF9\u5E94\u72B6\u6001\u91CF\u7684\u6837\u5F0F
    Element.prototype.getStateStyle = function (stateName, shapeKey) {
        var statesStyle = this.getStatesStyle();
        var stateCfg = (0,esm/* get */.U2)(statesStyle, [stateName, 'style'], {});
        var shapeStyle = stateCfg[shapeKey] || stateCfg;
        if ((0,esm/* isFunction */.mf)(shapeStyle)) {
            return shapeStyle(this);
        }
        return shapeStyle;
    };
    // \u83B7\u53D6\u52A8\u753B\u914D\u7F6E
    Element.prototype.getAnimateCfg = function (animateType) {
        var _this = this;
        var animate = this.animate;
        if (animate) {
            var cfg_1 = animate[animateType];
            if (cfg_1) {
                // \u589E\u52A0\u52A8\u753B\u7684\u56DE\u8C03\u51FD\u6570\uFF0C\u5982\u679C\u5916\u90E8\u4F20\u5165\u4E86\uFF0C\u5219\u5148\u6267\u884C\u5916\u90E8\uFF0C\u7136\u540E\u53D1\u5C04 geometry \u7684 animate \u4E8B\u4EF6
                return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg_1), { callback: function () {
                        var _a;
                        (0,esm/* isFunction */.mf)(cfg_1.callback) && cfg_1.callback();
                        (_a = _this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
                    } });
            }
            return cfg_1;
        }
        return null;
    };
    // \u7ED8\u5236\u56FE\u5F62
    Element.prototype.drawShape = function (model, isUpdate) {
        var _a;
        if (isUpdate === void 0) { isUpdate = false; }
        var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
        // \u81EA\u5B9A\u4E49 shape \u6709\u53EF\u80FD\u8FD4\u56DE\u7A7A shape
        this.shape = shapeFactory.drawShape(shapeType, model, container);
        if (this.shape) {
            this.setShapeInfo(this.shape, model); // \u5B58\u50A8\u7ED8\u56FE\u6570\u636E
            // @ts-ignore
            var name_1 = this.shape.cfg.name;
            // \u9644\u52A0 element \u7684 name, name \u73B0\u5728\u652F\u6301\u6570\u7EC4\u4E86\uFF0C\u5F88\u597D\u7528\u4E86
            if (!name_1) {
                // \u8FD9\u4E2A\u5730\u65B9\u5982\u679C\u7528\u6237\u6DFB\u52A0\u4E86 name, \u5219\u9644\u52A0 name \uFF0C\u5426\u5219\u5C31\u6DFB\u52A0\u81EA\u5DF1\u7684 name
                // @ts-ignore
                this.shape.cfg.name = ['element', this.shapeFactory.geometryType];
            }
            else if ((0,esm/* isString */.HD)(name_1)) {
                // @ts-ignore
                this.shape.cfg.name = ['element', name_1];
            }
            // \u6267\u884C\u5165\u573A\u52A8\u753B
            var animateType = isUpdate ? 'enter' : 'appear';
            var animateCfg = this.getAnimateCfg(animateType);
            if (animateCfg) {
                // \u5F00\u59CB\u6267\u884C\u52A8\u753B\u7684\u751F\u547D\u5468\u671F
                (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
                doAnimate(this.shape, animateCfg, {
                    coordinate: shapeFactory.coordinate,
                    toAttrs: (0,tslib_es6/* __assign */.pi)({}, this.shape.attr()),
                });
            }
        }
    };
    // \u83B7\u53D6\u865A\u62DF Group
    Element.prototype.getOffscreenGroup = function () {
        if (!this.offscreenGroup) {
            var GroupCtor = this.container.getGroupBase(); // \u83B7\u53D6\u5206\u7EC4\u7684\u6784\u9020\u51FD\u6570
            this.offscreenGroup = new GroupCtor({});
        }
        return this.offscreenGroup;
    };
    // \u8BBE\u7F6E shape \u4E0A\u9700\u8981\u643A\u5E26\u7684\u4FE1\u606F
    Element.prototype.setShapeInfo = function (shape, data) {
        var _this = this;
        // @ts-ignore
        shape.cfg.origin = data;
        // @ts-ignore
        shape.cfg.element = this;
        if (shape.isGroup()) {
            var children = shape.get('children');
            children.forEach(function (child) {
                _this.setShapeInfo(child, data);
            });
        }
    };
    // \u66F4\u65B0\u5F53\u524D shape \u7684\u6837\u5F0F
    Element.prototype.syncShapeStyle = function (sourceShape, targetShape, states, animateCfg, index) {
        var _this = this;
        var _a;
        if (states === void 0) { states = []; }
        if (index === void 0) { index = 0; }
        if (!sourceShape || !targetShape) {
            return;
        }
        // \u6240\u6709\u7684 shape \u90FD\u9700\u8981\u540C\u6B65 clip
        var clip = sourceShape.get('clipShape');
        var newClip = targetShape.get('clipShape');
        this.syncShapeStyle(clip, newClip, states, animateCfg);
        if (sourceShape.isGroup()) {
            var children = sourceShape.get('children');
            var newChildren = targetShape.get('children');
            for (var i = 0; i < children.length; i++) {
                this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
            }
        }
        else {
            if (!(0,esm/* isEmpty */.xb)(states) && !(0,esm/* isEqual */.Xy)(states, ['reset'])) {
                var name_2 = sourceShape.get('name');
                if ((0,esm/* isArray */.kJ)(name_2)) {
                    // \u4F1A\u9644\u52A0 element \u7684 name
                    name_2 = name_2[1];
                }
                (0,esm/* each */.S6)(states, function (state) {
                    // background shape \u4E0D\u8FDB\u884C\u72B6\u6001\u6837\u5F0F\u8BBE\u7F6E
                    if (targetShape.get('name') !== BACKGROUND_SHAPE) {
                        var style = _this.getStateStyle(state, name_2 || index); // \u5982\u679C\u7528\u6237\u6CA1\u6709\u8BBE\u7F6E name\uFF0C\u5219\u9ED8\u8BA4\u6839\u636E\u7D22\u5F15\u503C
                        targetShape.attr(style);
                    }
                });
            }
            var newAttrs = getReplaceAttrs(sourceShape, targetShape);
            if (this.animate) {
                if (animateCfg) {
                    (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
                    // \u9700\u8981\u8FDB\u884C\u52A8\u753B
                    doAnimate(sourceShape, animateCfg, {
                        coordinate: this.shapeFactory.coordinate,
                        toAttrs: newAttrs,
                        shapeModel: this.model,
                    });
                }
                else if (!(0,esm/* isEmpty */.xb)(states)) {
                    sourceShape.stopAnimate();
                    sourceShape.animate(newAttrs, {
                        duration: 300,
                    });
                }
                else {
                    sourceShape.attr(newAttrs);
                }
            }
            else {
                sourceShape.attr(newAttrs);
            }
        }
    };
    Element.prototype.getShapeType = function (model) {
        var shape = (0,esm/* get */.U2)(model, 'shape');
        return (0,esm/* isArray */.kJ)(shape) ? shape[0] : shape;
    };
    return Element;
}(base));
/* harmony default export */ var geometry_element = (element_Element);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/index.js
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
/**
 * \u83B7\u53D6 \`type\` \u5BF9\u5E94\u7684 [[GeometryLabel]] \u7C7B
 * @param type
 * @returns
 */
function getGeometryLabel(type) {
    return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
/**
 * \u6CE8\u518C\u5B9A\u4E49\u7684 GeometryLabel \u7C7B
 * @param type GeometryLabel \u7C7B\u578B\u540D\u79F0
 * @param ctor GeometryLabel \u7C7B
 */
function registerGeometryLabel(type, ctor) {
    GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
/**
 * \u83B7\u53D6 \`type\` \u5BF9\u5E94\u7684 [[GeometryLabelsLayoutFn]] label \u5E03\u5C40\u51FD\u6570
 * @param type \u5E03\u5C40\u51FD\u6570\u540D\u79F0
 * @returns
 */
function getGeometryLabelLayout(type) {
    return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
/**
 * \u6CE8\u518C\u5B9A\u4E49\u7684 label \u5E03\u5C40\u51FD\u6570
 * @param type label \u5E03\u5C40\u51FD\u6570\u540D\u79F0
 * @param layoutFn label \u5E03\u5C40\u51FD\u6570
 */
function registerGeometryLabelLayout(type, layoutFn) {
    GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/base.js




/** ShapeFactory \u57FA\u7C7B */
var ShapeFactoryBase = {
    /** \u5750\u6807\u7CFB\u5BF9\u8C61 */
    coordinate: null,
    /** \u9ED8\u8BA4\u7ED8\u5236\u7684 Shape \u7C7B\u578B */
    defaultShapeType: null,
    /** \u4E3B\u9898\u6837\u5F0F */
    theme: null,
    /**
     * \u83B7\u53D6 shape \u7ED8\u5236\u9700\u8981\u7684\u5173\u952E\u70B9
     * @param shapeType shape \u7C7B\u578B
     * @param shapePoint \u6BCF\u6761\u6570\u636E\u6620\u5C04\u540E\u7684\u5750\u6807\u70B9\u4EE5\u53CA size \u6570\u503C
     * @returns \u56FE\u5F62\u5173\u952E\u70B9\u4FE1\u606F
     */
    getShapePoints: function (shapeType, shapePoint) {
        var shape = this.getShape(shapeType);
        if (shape.getPoints) {
            return shape.getPoints(shapePoint);
        }
        return this.getDefaultPoints(shapePoint);
    },
    /**
     * \u6839\u636E shape \u7C7B\u578B\u83B7\u53D6\u5177\u4F53\u7684 shape \u5B9E\u4F8B
     * @param shapeType string shape \u7684\u7C7B\u578B
     * @returns
     */
    getShape: function (shapeType) {
        var shape = this[shapeType] || this[this.defaultShapeType];
        shape.coordinate = this.coordinate;
        return shape;
    },
    /**
     * \u83B7\u53D6 shape \u7684\u9ED8\u8BA4\u5173\u952E\u70B9
     * @override
     */
    getDefaultPoints: function () {
        return [];
    },
    /**
     * \u83B7\u53D6 shape \u7684\u9ED8\u8BA4\u7ED8\u5236\u6837\u5F0F (\u5185\u7F6E\u7684 shapeFactory \u5747\u6709\u6CE8\u518C\u9ED8\u8BA4\u6837\u5F0F)
     */
    getDefaultStyle: function (geometryTheme) {
        return (0,esm/* get */.U2)(geometryTheme, [this.defaultShapeType, 'default', 'style'], {});
    },
    /**
     * \u83B7\u53D6 shape \u5BF9\u5E94\u7684\u7F29\u7565\u56FE\u914D\u7F6E\u4FE1\u606F\u3002
     * @param shapeType shape \u7C7B\u578B
     * @param color \u989C\u8272
     * @param isInPolar \u662F\u5426\u5728\u6781\u5750\u6807\u7CFB\u4E0B
     * @returns \u8FD4\u56DE\u7F29\u7565\u56FE marker \u914D\u7F6E\u3002
     */
    getMarker: function (shapeType, markerCfg) {
        var shape = this.getShape(shapeType);
        if (!shape.getMarker) {
            var defaultShapeType = this.defaultShapeType;
            shape = this.getShape(defaultShapeType);
        }
        var theme = this.theme;
        var shapeStyle = (0,esm/* get */.U2)(theme, [shapeType, 'default'], {});
        var markerStyle = shape.getMarker(markerCfg);
        return (0,esm/* deepMix */.b$)({}, shapeStyle, markerStyle);
    },
    /**
     * \u7ED8\u5236 shape
     * @override
     * @param shapeType \u7ED8\u5236\u7684 shape \u7C7B\u578B
     * @param cfg \u7ED8\u5236 shape \u9700\u8981\u7684\u4FE1\u606F
     * @param element Element \u5B9E\u4F8B
     * @returns
     */
    drawShape: function (shapeType, cfg, container) {
        var shape = this.getShape(shapeType);
        return shape.draw(cfg, container);
    },
};
/** Shape \u57FA\u7C7B */
var ShapeBase = {
    /** \u5750\u6807\u7CFB\u5BF9\u8C61 */
    coordinate: null,
    /**
     * \u5C06\u5F52\u4E00\u5316\u7684 path \u8F6C\u6362\u6210\u5750\u6807\u7CFB\u4E0B\u7684 path
     * @param path \u5F52\u4E00\u5316\u7684\u8DEF\u5F84
     * @returns
     */
    parsePath: function (path) {
        var coordinate = this.coordinate;
        var parsedPath = (0,path_util_esm/* parsePathString */.tr)(path);
        if (coordinate.isPolar) {
            parsedPath = convertPolarPath(coordinate, parsedPath);
        }
        else {
            parsedPath = convertNormalPath(coordinate, parsedPath);
        }
        return parsedPath;
    },
    /**
     * \u5C06\u5F52\u4E00\u5316\u7684\u5750\u6807\u8F6C\u6362\u6210\u753B\u5E03\u5750\u6807
     * @param point \u5F52\u4E00\u5316\u7684\u5750\u6807\u70B9\u6570\u636E
     * @returns
     */
    parsePoint: function (point) {
        var coordinate = this.coordinate;
        return coordinate.convert(point);
    },
    /**
     * 0\uFF5E1 points \u8F6C \u753B\u5E03 points
     * @param points \u8282\u70B9\u96C6\u5408
     * @returns
     */
    parsePoints: function (points) {
        var coordinate = this.coordinate;
        return points.map(function (point) {
            return coordinate.convert(point);
        });
    },
    /**
     * \u7ED8\u5236 shape
     * @override
     */
    draw: function (cfg, container) { },
};
var ShapeFactoryMap = {};
/**
 * \u6CE8\u518C ShapeFactory\u3002
 * @param factoryName  ShapeFactory \u540D\u79F0\uFF0C\u5BF9\u5E94 Geometry \u51E0\u4F55\u6807\u8BB0\u540D\u79F0\u3002
 * @param cfg \u6CE8\u518C ShapeFactory \u9700\u8981\u8986\u5199\u5B9A\u4E49\u7684\u5C5E\u6027\u3002
 * @returns \u8FD4\u56DE ShapeFactory \u5BF9\u8C61\u3002
 */
function registerShapeFactory(factoryName, cfg) {
    var className = (0,esm/* upperFirst */.jC)(factoryName);
    var geomObj = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
    ShapeFactoryMap[className] = geomObj;
    return geomObj;
}
/**
 * \u6CE8\u518C Shape\u3002
 * @param factoryName \u5BF9\u5E94\u7684 ShapeFactory \u540D\u79F0\u3002
 * @param shapeType \u6CE8\u518C\u7684 shape \u540D\u79F0\u3002
 * @param cfg \u6CE8\u518C Shape \u9700\u8981\u8986\u5199\u5B9A\u4E49\u7684\u5C5E\u6027\u3002
 * @returns shape \u8FD4\u56DE\u6CE8\u518C\u7684 shape \u5BF9\u8C61\u3002
 */
function registerShape(factoryName, shapeType, cfg) {
    var className = (0,esm/* upperFirst */.jC)(factoryName);
    var factory = ShapeFactoryMap[className];
    var shapeObj = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, ShapeBase), cfg);
    factory[shapeType] = shapeObj;
    return shapeObj;
}
/**
 * \u83B7\u53D6 factoryName \u5BF9\u5E94\u7684 shapeFactory
 * @param factoryName
 * @returns shape factory
 */
function getShapeFactory(factoryName) {
    var className = (0,esm/* upperFirst */.jC)(factoryName);
    return ShapeFactoryMap[className];
}
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/util/group-data.js


/** @ignore */
function group(data, fields, appendConditions) {
    var e_1, _a;
    if (appendConditions === void 0) { appendConditions = {}; }
    if (!fields) {
        return [data];
    }
    var groups = (0,esm/* groupToMap */.Ms)(data, fields);
    var array = [];
    if (fields.length === 1 && appendConditions[fields[0]]) {
        var values = appendConditions[fields[0]];
        try {
            for (var values_1 = (0,tslib_es6/* __values */.XA)(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var value = values_1_1.value;
                var arr = groups["_".concat(value)];
                if (arr) {
                    // \u53EF\u80FD\u5B58\u5728\u7528\u6237\u8BBE\u7F6E values \uFF0C\u4F46\u662F\u6570\u636E\u4E2D\u6CA1\u6709\u5BF9\u5E94\u7684\u5B57\u6BB5\uFF0C\u5219\u8FD9\u65F6\u5019 arr \u5C31\u4E3A null
                    array.push(arr);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        for (var k in groups) {
            if (groups.hasOwnProperty(k)) {
                var eachGroup = groups[k];
                array.push(eachGroup);
            }
        }
    }
    return array;
}
//# sourceMappingURL=group-data.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/util/is-model-change.js

/**
 * @ignore
 * Determines whether model is change
 * @param currentModel
 * @param preModel
 * @returns
 */
function isModelChange(currentModel, preModel) {
    return (0,esm/* some */.G)(['color', 'shape', 'size', 'x', 'y', 'isInCircle', 'data', 'style', 'defaultStyle', 'points', 'mappingData'], function (key) {
        return !(0,esm/* isEqual */.Xy)(currentModel[key], preModel[key]);
    });
}
//# sourceMappingURL=is-model-change.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/util/parse-fields.js

/** @ignore */
function parseFields(field) {
    if ((0,esm/* isArray */.kJ)(field)) {
        return field;
    }
    return field.split('*');
}
//# sourceMappingURL=parse-fields.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/util/diff.js
/**
 * \u5BF9\u6BD4\u5F53\u524D\u5143\u7D20\u548C\u4E4B\u524D\u7684\u5143\u7D20\uFF0C\u8FD4\u56DE added, updated, removed
 * @param keyItem \u4E4B\u524D\u7684\u5143\u7D20\u7684\uFF0C\u6309\u7167 key-item \u7684 object \u7684\u5F62\u5F0F\u5B58\u50A8
 * @param keys \u73B0\u5728\u7684\u5143\u7D20\uFF0C\u6309\u7167 array \u7684\u5F62\u5F0F\u5B58\u50A8
 * @returns \u7531 added, updated, removed array \u6784\u6210\u7684 object
 */
function diff(keyItem, keys) {
    var added = [];
    var updated = [];
    var removed = [];
    var keyIncluded = new Map();
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (keyItem[key])
            updated.push(key);
        else
            added.push(key);
        keyIncluded.set(key, true);
    }
    Object.keys(keyItem).forEach(function (key) {
        if (!keyIncluded.has(key))
            removed.push(key);
    });
    return {
        added: added,
        updated: updated,
        removed: removed,
    };
}
//# sourceMappingURL=diff.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/base.js

















/**
 * Geometry \u51E0\u4F55\u6807\u8BB0\u57FA\u7C7B\uFF0C\u4E3B\u8981\u8D1F\u8D23\u6570\u636E\u5230\u56FE\u5F62\u5C5E\u6027\u7684\u6620\u5C04\u4EE5\u53CA\u7ED8\u5236\u903B\u8F91\u3002
 */
var Geometry = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Geometry, _super);
    /**
     * \u521B\u5EFA Geometry \u5B9E\u4F8B\u3002
     * @param cfg
     */
    function Geometry(cfg) {
        var _this = _super.call(this, cfg) || this;
        /** Geometry \u51E0\u4F55\u6807\u8BB0\u7C7B\u578B\u3002 */
        _this.type = 'base';
        // \u5185\u90E8\u4EA7\u751F\u7684\u5C5E\u6027
        /** Attribute map  */
        _this.attributes = {};
        /** Element map */
        _this.elements = [];
        /** \u4F7F\u7528 key-value \u7ED3\u6784\u5B58\u50A8 Element\uFF0Ckey \u4E3A\u6BCF\u4E2A Element \u5B9E\u4F8B\u5BF9\u5E94\u7684\u552F\u4E00 ID */
        _this.elementsMap = {};
        /** animate \u914D\u7F6E\u9879 */
        _this.animateOption = true;
        /** \u56FE\u5F62\u5C5E\u6027\u6620\u5C04\u914D\u7F6E */
        _this.attributeOption = {};
        /** \u5B58\u50A8\u4E0A\u4E00\u6B21\u6E32\u67D3\u65F6\u7684 element \u6620\u5C04\u8868\uFF0C\u7528\u4E8E\u66F4\u65B0\u903B\u8F91 */
        _this.lastElementsMap = {};
        /** \u662F\u5426\u751F\u6210\u591A\u4E2A\u70B9\u6765\u7ED8\u5236\u56FE\u5F62\u3002 */
        _this.generatePoints = false;
        /** \u5B58\u50A8\u53D1\u751F\u56FE\u5F62\u5C5E\u6027\u6620\u5C04\u524D\u7684\u6570\u636E */
        _this.beforeMappingData = null;
        _this.adjusts = {};
        _this.idFields = [];
        _this.hasSorted = false;
        _this.isCoordinateChanged = false;
        var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate = cfg.coordinate, data = cfg.data, _a = cfg.sortable, sortable = _a === void 0 ? false : _a, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, 
        // \u67F1\u72B6\u56FE\u95F4\u9694\u4E0E\u5BBD\u5EA6\u76F8\u5173\u914D\u7F6E
        intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
        _this.container = container;
        _this.labelsContainer = labelsContainer;
        _this.coordinate = coordinate;
        _this.data = data;
        _this.sortable = sortable;
        _this.visible = visible;
        _this.userTheme = theme;
        _this.scales = scales;
        _this.scaleDefs = scaleDefs;
        // \u67F1\u72B6\u56FE\u95F4\u9694\u4E0E\u5BBD\u5EA6\u76F8\u5173\u914D\u7F6E
        _this.intervalPadding = intervalPadding;
        _this.dodgePadding = dodgePadding;
        _this.maxColumnWidth = maxColumnWidth;
        _this.minColumnWidth = minColumnWidth;
        _this.columnWidthRatio = columnWidthRatio;
        _this.roseWidthRatio = roseWidthRatio;
        _this.multiplePieWidthRatio = multiplePieWidthRatio;
        _this.zIndexReversed = zIndexReversed;
        _this.sortZIndex = sortZIndex;
        _this.useDeferredLabel = useDeferredLabel ? (typeof useDeferredLabel === 'number' ? useDeferredLabel : Infinity) : null;
        return _this;
    }
    /**
     * \u914D\u7F6E position \u901A\u9053\u6620\u5C04\u89C4\u5219\u3002
     *
     * @example
     * \`\`\`typescript
     * // \u6570\u636E\u7ED3\u6784: [{ x: 'A', y: 10, color: 'red' }]
     * geometry.position('x*y');
     * geometry.position([ 'x', 'y' ]);
     * geometry.position({
     *   fields: [ 'x', 'y' ],
     * });
     * \`\`\`
     *
     * @param cfg \u6620\u5C04\u89C4\u5219
     * @returns
     */
    Geometry.prototype.position = function (cfg) {
        var positionCfg = cfg;
        if (!(0,esm/* isPlainObject */.PO)(cfg)) {
            // \u5B57\u7B26\u4E32\u5B57\u6BB5\u6216\u8005\u6570\u7EC4\u5B57\u6BB5
            positionCfg = {
                fields: parseFields(cfg),
            };
        }
        var fields = (0,esm/* get */.U2)(positionCfg, 'fields');
        if (fields.length === 1) {
            // \u9ED8\u8BA4\u586B\u5145\u4E00\u7EF4 1*xx
            fields.unshift('1');
            (0,esm/* set */.t8)(positionCfg, 'fields', fields);
        }
        (0,esm/* set */.t8)(this.attributeOption, 'position', positionCfg);
        return this;
    };
    Geometry.prototype.color = function (field, cfg) {
        this.createAttrOption('color', field, cfg);
        return this;
    };
    Geometry.prototype.shape = function (field, cfg) {
        this.createAttrOption('shape', field, cfg);
        return this;
    };
    Geometry.prototype.size = function (field, cfg) {
        this.createAttrOption('size', field, cfg);
        return this;
    };
    /**
     * \u8BBE\u7F6E\u6570\u636E\u8C03\u6574\u65B9\u5F0F\u3002G2 \u76EE\u524D\u5185\u7F6E\u4E86\u56DB\u79CD\u7C7B\u578B\uFF1A
     * 1. dodge
     * 2. stack
     * 3. symmetric
     * 4. jitter
     *
     *
     * **Tip**
     * + \u5BF9\u4E8E 'dodge' \u7C7B\u578B\uFF0C\u53EF\u4EE5\u989D\u5916\u8FDB\u884C\u5982\u4E0B\u5C5E\u6027\u7684\u914D\u7F6E:
     * \`\`\`typescript
     * geometry.adjust('dodge', {
     *   marginRatio: 0, // \u53D6 0 \u5230 1 \u8303\u56F4\u7684\u503C\uFF08\u76F8\u5BF9\u4E8E\u6BCF\u4E2A\u67F1\u5B50\u5BBD\u5EA6\uFF09\uFF0C\u7528\u4E8E\u63A7\u5236\u4E00\u4E2A\u5206\u7EC4\u4E2D\u67F1\u5B50\u4E4B\u95F4\u7684\u95F4\u8DDD
     *   dodgeBy: 'x', // \u8BE5\u5C5E\u6027\u53EA\u5BF9 'dodge' \u7C7B\u578B\u751F\u6548\uFF0C\u58F0\u660E\u4EE5\u54EA\u4E2A\u6570\u636E\u5B57\u6BB5\u4E3A\u5206\u7EC4\u4F9D\u636E
     * });
     * \`\`\`
     *
     * + \u5BF9\u4E8E 'stack' \u7C7B\u578B\uFF0C\u53EF\u4EE5\u989D\u5916\u8FDB\u884C\u5982\u4E0B\u5C5E\u6027\u7684\u914D\u7F6E:
     * \`\`\`typescript
     * geometry.adjust('stack', {
     *   reverseOrder: false, // \u7528\u4E8E\u63A7\u5236\u662F\u5426\u5BF9\u6570\u636E\u8FDB\u884C\u53CD\u5E8F\u64CD\u4F5C
     * });
     * \`\`\`
     *
     * @example
     * \`\`\`typescript
     * geometry.adjust('stack');
     *
     * geometry.adjust({
     *   type: 'stack',
     *   reverseOrder: false,
     * });
     *
     * // \u7EC4\u5408\u4F7F\u7528 adjust
     * geometry.adjust([ 'stack', 'dodge' ]);
     *
     * geometry.adjust([
     *   { type: 'stack' },
     *   { type: 'dodge', dodgeBy: 'x' },
     * ]);
     * \`\`\`
     *
     * @param adjustCfg \u6570\u636E\u8C03\u6574\u914D\u7F6E
     * @returns
     */
    Geometry.prototype.adjust = function (adjustCfg) {
        var adjusts = adjustCfg;
        if ((0,esm/* isString */.HD)(adjustCfg) || (0,esm/* isPlainObject */.PO)(adjustCfg)) {
            adjusts = [adjustCfg];
        }
        (0,esm/* each */.S6)(adjusts, function (adjust, index) {
            if (!(0,esm/* isObject */.Kn)(adjust)) {
                adjusts[index] = { type: adjust };
            }
        });
        this.adjustOption = adjusts;
        return this;
    };
    Geometry.prototype.style = function (field, styleFunc) {
        if ((0,esm/* isString */.HD)(field)) {
            var fields = parseFields(field);
            this.styleOption = {
                fields: fields,
                callback: styleFunc,
            };
        }
        else {
            var _a = field, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;
            if (fields || callback || cfg) {
                this.styleOption = field;
            }
            else {
                this.styleOption = {
                    cfg: field,
                };
            }
        }
        return this;
    };
    Geometry.prototype.tooltip = function (field, cfg) {
        if ((0,esm/* isString */.HD)(field)) {
            var fields = parseFields(field);
            this.tooltipOption = {
                fields: fields,
                callback: cfg,
            };
        }
        else {
            this.tooltipOption = field;
        }
        return this;
    };
    /**
     * Geometry \u52A8\u753B\u914D\u7F6E\u3002
     *
     * + \`animate(false)\` \u5173\u95ED\u52A8\u753B
     * + \`animate(true)\` \u5F00\u542F\u52A8\u753B\uFF0C\u9ED8\u8BA4\u5F00\u542F\u3002
     *
     * \u6211\u4EEC\u5C06\u52A8\u753B\u5206\u4E3A\u56DB\u4E2A\u573A\u666F\uFF1A
     * 1. appear: \u56FE\u8868\u7B2C\u4E00\u6B21\u52A0\u8F7D\u65F6\u7684\u5165\u573A\u52A8\u753B\uFF1B
     * 2. enter: \u56FE\u8868\u7ED8\u5236\u5B8C\u6210\uFF0C\u53D1\u751F\u66F4\u65B0\u540E\uFF0C\u4EA7\u751F\u7684\u65B0\u56FE\u5F62\u7684\u8FDB\u573A\u52A8\u753B\uFF1B
     * 3. update: \u56FE\u8868\u7ED8\u5236\u5B8C\u6210\uFF0C\u6570\u636E\u53D1\u751F\u53D8\u66F4\u540E\uFF0C\u6709\u72B6\u6001\u53D8\u66F4\u7684\u56FE\u5F62\u7684\u66F4\u65B0\u52A8\u753B\uFF1B
     * 4. leave: \u56FE\u8868\u7ED8\u5236\u5B8C\u6210\uFF0C\u6570\u636E\u53D1\u751F\u53D8\u66F4\u540E\uFF0C\u88AB\u9500\u6BC1\u56FE\u5F62\u7684\u9500\u6BC1\u52A8\u753B\u3002
     *
     * @example
     * \`\`\`typescript
     * animate({
     *   enter: {
     *     duration: 1000, // enter \u52A8\u753B\u6267\u884C\u65F6\u95F4
     *   },
     *   leave: false, // \u5173\u95ED leave \u9500\u6BC1\u52A8\u753B
     * });
     * \`\`\`
     *
     * @param cfg \u52A8\u753B\u914D\u7F6E
     * @returns
     */
    Geometry.prototype.animate = function (cfg) {
        this.animateOption = cfg;
        return this;
    };
    Geometry.prototype.label = function (field, secondParam, thirdParam) {
        if ((0,esm/* isString */.HD)(field)) {
            var labelOption = {};
            var fields = parseFields(field);
            labelOption.fields = fields;
            if ((0,esm/* isFunction */.mf)(secondParam)) {
                labelOption.callback = secondParam;
            }
            else if ((0,esm/* isPlainObject */.PO)(secondParam)) {
                labelOption.cfg = secondParam;
            }
            if (thirdParam) {
                labelOption.cfg = thirdParam;
            }
            this.labelOption = labelOption;
        }
        else {
            this.labelOption = field;
        }
        return this;
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001\u5BF9\u5E94\u7684\u6837\u5F0F\u3002
     *
     * @example
     * \`\`\`ts
     * chart.interval().state({
     *   selected: {
     *     animate: { duration: 100, easing: 'easeLinear' },
     *     style: {
     *       lineWidth: 2,
     *       stroke: '#000',
     *     },
     *   },
     * });
     * \`\`\`
     *
     * \u5982\u679C\u56FE\u5F62 shape \u662F\u7531\u591A\u4E2A shape \u7EC4\u6210\uFF0C\u5373\u4E3A\u4E00\u4E2A G.Group \u5BF9\u8C61\uFF0C\u90A3\u4E48\u9488\u5BF9 group \u4E2D\u7684\u6BCF\u4E2A shape\uFF0C\u6211\u4EEC\u9700\u8981\u4F7F\u7528\u4E0B\u5217\u65B9\u5F0F\u8FDB\u884C\u72B6\u6001\u6837\u5F0F\u8BBE\u7F6E\uFF1A
     * \u5982\u679C\u6211\u4EEC\u4E3A group \u4E2D\u7684\u6BCF\u4E2A shape \u8BBE\u7F6E\u4E86 'name' \u5C5E\u6027(shape.set('name', 'xx'))\uFF0C\u5219\u4EE5 'name' \u4F5C\u4E3A key\uFF0C\u5426\u5219\u9ED8\u8BA4\u4EE5\u7D22\u5F15\u503C\uFF08\u5373 shape \u7684 \u6DFB\u52A0\u987A\u5E8F\uFF09\u4E3A key\u3002
     *
     * \`\`\`ts
     * chart.interval().shape('groupShape').state({
     *   selected: {
     *     style: {
     *       0: { lineWidth: 2 },
     *       1: { fillOpacity: 1 },
     *     }
     *   }
     * });
     * \`\`\`
     *
     * @param cfg \u72B6\u6001\u6837\u5F0F
     */
    Geometry.prototype.state = function (cfg) {
        this.stateOption = cfg;
        return this;
    };
    /**
     * \u7528\u4E8E\u5411 shape \u4E2D\u4F20\u5165\u81EA\u5B9A\u4E49\u7684\u6570\u636E\u3002\u76EE\u524D\u53EF\u80FD\u4EC5\u4EC5\u53EF\u80FD\u7528\u4E8E\u5728\u81EA\u5B9A\u4E49 shape \u7684\u65F6\u5019\uFF0C\u50CF\u81EA\u5B9A\u4E49 shape \u4E2D\u4F20\u5165\u81EA\u5B9A\u4E49\u7684\u6570\u636E\uFF0C\u65B9\u4FBF\u5B9E\u73B0\u81EA\u5B9A\u4E49 shape \u7684\u914D\u7F6E\u80FD\u529B\u3002
     *
     * @example
     * \`\`\`ts
     * chart.interval().customInfo({ yourData: 'hello, g2!' });
     * \`\`\`
     *
     * \u7136\u540E\u5728\u81EA\u5B9A\u4E49 shape \u7684\u65F6\u5019\uFF0C\u53EF\u4EE5\u62FF\u5230\u8FD9\u4E2A\u4FE1\u606F\u3002
     *
     * \`\`\`ts
     * registerShape('interval', 'your-shape', {
     *   draw(shapeInfo, container) {
     *     const { customInfo } = shapeInfo;
     *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.
     *   }
     * });
     * \`\`\`
     *
     * @param cfg
     */
    Geometry.prototype.customInfo = function (cfg) {
        this.customOption = cfg;
        return this;
    };
    /**
     * \u521D\u59CB\u5316 Geomtry \u5B9E\u4F8B\uFF1A
     * \u521B\u5EFA [[Attribute]] and [[Scale]] \u5B9E\u4F8B\uFF0C\u8FDB\u884C\u6570\u636E\u5904\u7406\uFF0C\u5305\u62EC\u5206\u7EC4\u3001\u6570\u503C\u5316\u4EE5\u53CA\u6570\u636E\u8C03\u6574\u3002
     */
    Geometry.prototype.init = function (cfg) {
        if (cfg === void 0) { cfg = {}; }
        this.setCfg(cfg);
        this.initAttributes(); // \u521B\u5EFA\u56FE\u5F62\u5C5E\u6027
        // \u6570\u636E\u52A0\u5DE5\uFF1A\u5206\u7EC4 -> \u6570\u5B57\u5316 -> adjust
        this.processData(this.data);
        // \u8C03\u6574 scale
        this.adjustScale();
    };
    /**
     * Geometry \u66F4\u65B0\u3002
     * @param [cfg] \u66F4\u65B0\u7684\u914D\u7F6E
     */
    Geometry.prototype.update = function (cfg) {
        if (cfg === void 0) { cfg = {}; }
        var data = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
        var _a = this, attributeOption = _a.attributeOption, lastAttributeOption = _a.lastAttributeOption;
        if (!(0,esm/* isEqual */.Xy)(attributeOption, lastAttributeOption)) {
            // \u6620\u5C04\u53D1\u751F\u6539\u53D8\uFF0C\u5219\u91CD\u65B0\u521B\u5EFA\u56FE\u5F62\u5C5E\u6027
            this.init(cfg);
        }
        else if (data && (isDataChanged || !(0,esm/* isEqual */.Xy)(data, this.data))) {
            // \u6570\u636E\u53D1\u751F\u53D8\u5316
            this.setCfg(cfg);
            this.initAttributes(); // \u521B\u5EFA\u56FE\u5F62\u5C5E\u6027
            this.processData(data); // \u6570\u636E\u52A0\u5DE5\uFF1A\u5206\u7EC4 -> \u6570\u5B57\u5316 -> adjust
        }
        else {
            // \u6709\u53EF\u80FD coordinate \u53D8\u5316
            this.setCfg(cfg);
        }
        // \u8C03\u6574 scale
        this.adjustScale();
        this.isCoordinateChanged = isCoordinateChanged;
    };
    /**
     * \u5C06\u539F\u59CB\u6570\u636E\u6620\u5C04\u81F3\u56FE\u5F62\u7A7A\u95F4\uFF0C\u540C\u65F6\u521B\u5EFA\u56FE\u5F62\u5BF9\u8C61\u3002
     */
    Geometry.prototype.paint = function (isUpdate) {
        var _this = this;
        if (isUpdate === void 0) { isUpdate = false; }
        if (this.animateOption) {
            this.animateOption = (0,esm/* deepMix */.b$)({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
        }
        this.defaultSize = undefined;
        this.elementsMap = {};
        this.elements = [];
        var offscreenGroup = this.getOffscreenGroup();
        offscreenGroup.clear();
        var beforeMappingData = this.beforeMappingData;
        var dataArray = this.beforeMapping(beforeMappingData);
        this.dataArray = new Array(dataArray.length);
        for (var i = 0; i < dataArray.length; i++) {
            var data = dataArray[i];
            this.dataArray[i] = this.mapping(data);
        }
        this.updateElements(this.dataArray, isUpdate);
        this.lastElementsMap = this.elementsMap;
        if (this.canDoGroupAnimation(isUpdate)) {
            // \u5982\u679C\u7528\u6237\u6CA1\u6709\u914D\u7F6E appear.animation\uFF0C\u5C31\u9ED8\u8BA4\u8D70\u6574\u4F53\u52A8\u753B
            var container = this.container;
            var type = this.type;
            var coordinate = this.coordinate;
            var animateCfg = (0,esm/* get */.U2)(this.animateOption, 'appear');
            var yScale = this.getYScale();
            var yMinPoint = coordinate.convert({
                x: 0,
                y: yScale.scale(this.getYMinValue()),
            });
            doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);
        }
        // \u6DFB\u52A0 label
        if (this.labelOption) {
            var deferred = this.useDeferredLabel;
            var callback = (function () { return _this.renderLabels((0,esm/* flatten */.xH)(_this.dataArray), isUpdate); }).bind(this);
            if (typeof deferred === 'number') {
                // Use \`requestIdleCallback\` to render labels in idle time (like react fiber)
                var timeout = (typeof deferred === 'number' && deferred !== Infinity) ? deferred : 0;
                if (!window.requestIdleCallback) {
                    setTimeout(callback, timeout);
                }
                else {
                    var options = timeout && timeout !== Infinity ? { timeout: timeout } : undefined;
                    window.requestIdleCallback(callback, options);
                }
            }
            else {
                callback();
            }
        }
        // \u7F13\u5B58\uFF0C\u7528\u4E8E\u66F4\u65B0
        this.lastAttributeOption = (0,tslib_es6/* __assign */.pi)({}, this.attributeOption);
        if (this.visible === false) {
            // \u7528\u6237\u5728\u521D\u59CB\u5316\u7684\u65F6\u5019\u58F0\u660E visible: false
            this.changeVisible(false);
        }
    };
    /**
     * \u6E05\u7A7A\u5F53\u524D Geometry\uFF0C\u914D\u7F6E\u9879\u4ECD\u4FDD\u7559\uFF0C\u4F46\u662F\u5185\u90E8\u521B\u5EFA\u7684\u5BF9\u8C61\u5168\u90E8\u6E05\u7A7A\u3002
     * @override
     */
    Geometry.prototype.clear = function () {
        var _a = this, container = _a.container, geometryLabel = _a.geometryLabel, offscreenGroup = _a.offscreenGroup;
        if (container) {
            container.clear();
        }
        if (geometryLabel) {
            geometryLabel.clear();
        }
        if (offscreenGroup) {
            offscreenGroup.clear();
        }
        // \u5C5E\u6027\u6062\u590D\u81F3\u51FA\u5382\u72B6\u6001
        this.scaleDefs = undefined;
        this.attributes = {};
        this.scales = {};
        this.elementsMap = {};
        this.lastElementsMap = {};
        this.elements = [];
        this.adjusts = {};
        this.dataArray = null;
        this.beforeMappingData = null;
        this.lastAttributeOption = undefined;
        this.defaultSize = undefined;
        this.idFields = [];
        this.groupScales = undefined;
        this.hasSorted = false;
        this.isCoordinateChanged = false;
    };
    /**
     * \u9500\u6BC1 Geometry \u5B9E\u4F8B\u3002
     */
    Geometry.prototype.destroy = function () {
        this.clear();
        var container = this.container;
        container.remove(true);
        if (this.offscreenGroup) {
            this.offscreenGroup.remove(true);
            this.offscreenGroup = null;
        }
        if (this.geometryLabel) {
            this.geometryLabel.destroy();
            this.geometryLabel = null;
        }
        this.theme = undefined;
        this.shapeFactory = undefined;
        _super.prototype.destroy.call(this);
    };
    /**
     * \u83B7\u53D6\u51B3\u5B9A\u5206\u7EC4\u7684\u56FE\u5F62\u5C5E\u6027\u5BF9\u5E94\u7684 scale \u5B9E\u4F8B\u3002
     * @returns
     */
    Geometry.prototype.getGroupScales = function () {
        return this.groupScales;
    };
    /**
     * \u6839\u636E\u540D\u5B57\u83B7\u53D6\u56FE\u5F62\u5C5E\u6027\u5B9E\u4F8B\u3002
     */
    Geometry.prototype.getAttribute = function (name) {
        return this.attributes[name];
    };
    /** \u83B7\u53D6 x \u8F74\u5BF9\u5E94\u7684 scale \u5B9E\u4F8B\u3002 */
    Geometry.prototype.getXScale = function () {
        return this.getAttribute('position').scales[0];
    };
    /** \u83B7\u53D6 y \u8F74\u5BF9\u5E94\u7684 scale \u5B9E\u4F8B\u3002 */
    Geometry.prototype.getYScale = function () {
        return this.getAttribute('position').scales[1];
    };
    /**
     * \u83B7\u53D6\u51B3\u5B9A\u5206\u7EC4\u7684\u56FE\u5F62\u5C5E\u6027\u5B9E\u4F8B\u3002
     */
    Geometry.prototype.getGroupAttributes = function () {
        var rst = [];
        (0,esm/* each */.S6)(this.attributes, function (attr) {
            if (GROUP_ATTRS.includes(attr.type)) {
                rst.push(attr);
            }
        });
        return rst;
    };
    /** \u83B7\u53D6\u56FE\u5F62\u5C5E\u6027\u9ED8\u8BA4\u7684\u6620\u5C04\u503C\u3002 */
    Geometry.prototype.getDefaultValue = function (attrName) {
        var value;
        var attr = this.getAttribute(attrName);
        if (attr && (0,esm/* isEmpty */.xb)(attr.scales)) {
            // \u83B7\u53D6\u6620\u5C04\u81F3\u5E38\u91CF\u7684\u503C
            value = attr.values[0];
        }
        return value;
    };
    /**
     * \u83B7\u53D6\u8BE5\u6570\u636E\u53D1\u751F\u56FE\u5F62\u6620\u5C04\u540E\u5BF9\u5E94\u7684 Attribute \u56FE\u5F62\u7A7A\u95F4\u6570\u636E\u3002
     * @param attr Attribute \u56FE\u5F62\u5C5E\u6027\u5B9E\u4F8B\u3002
     * @param obj \u9700\u8981\u8FDB\u884C\u6620\u5C04\u7684\u539F\u59CB\u6570\u636E\u3002
     * @returns
     */
    Geometry.prototype.getAttributeValues = function (attr, obj) {
        var params = [];
        var scales = attr.scales;
        for (var index = 0, length_1 = scales.length; index < length_1; index++) {
            var scale = scales[index];
            var field = scale.field;
            if (scale.isIdentity) {
                params.push(scale.values);
            }
            else {
                params.push(obj[field]);
            }
        }
        return attr.mapping.apply(attr, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(params), false));
    };
    /**
     * \u83B7\u53D6\u5BF9\u5E94\u7684 adjust \u5B9E\u4F8B
     * @param adjustType
     * @returns
     */
    Geometry.prototype.getAdjust = function (adjustType) {
        return this.adjusts[adjustType];
    };
    /**
     * \u83B7\u5F97 coordinate \u5B9E\u4F8B
     * @returns
     */
    Geometry.prototype.getCoordinate = function () {
        return this.coordinate;
    };
    Geometry.prototype.getData = function () {
        return this.data;
    };
    /**
     * \u83B7\u53D6 shape \u5BF9\u5E94\u7684 marker \u6837\u5F0F\u3002
     * @param shapeName shape \u5177\u4F53\u540D\u5B57
     * @param cfg marker \u4FE1\u606F
     * @returns
     */
    Geometry.prototype.getShapeMarker = function (shapeName, cfg) {
        var shapeFactory = this.getShapeFactory();
        return shapeFactory.getMarker(shapeName, cfg);
    };
    /**
     * \u6839\u636E\u4E00\u5B9A\u7684\u89C4\u5219\u67E5\u627E Geometry \u7684 Elements\u3002
     *
     * \`\`\`typescript
     * getElementsBy((element) => {
     *   const data = element.getData();
     *
     *   return data.a === 'a';
     * });
     * \`\`\`
     *
     * @param condition \u5B9A\u4E49\u67E5\u627E\u89C4\u5219\u7684\u56DE\u8C03\u51FD\u6570\u3002
     * @returns
     */
    Geometry.prototype.getElementsBy = function (condition) {
        return this.elements.filter(function (element) { return condition(element); });
    };
    /**
     * \u83B7\u53D6 Geometry \u7684\u6240\u6709 Elements\u3002
     *
     * \`\`\`typescript
     * getElements();
     * \`\`\`
     */
    Geometry.prototype.getElements = function () {
        return this.elements;
    };
    /**
     * \u83B7\u53D6\u6570\u636E\u5BF9\u5E94\u7684\u552F\u4E00 id\u3002
     * @param data Element \u5BF9\u5E94\u7684\u7ED8\u5236\u6570\u636E
     * @returns
     */
    Geometry.prototype.getElementId = function (data) {
        data = (0,esm/* isArray */.kJ)(data) ? data[0] : data;
        var originData = data[FIELD_ORIGIN];
        // \u5982\u679C\u7528\u6237\u58F0\u660E\u4E86\u4F7F\u7528\u54EA\u4E9B\u5B57\u6BB5\u4F5C\u4E3A id \u503C
        if (this.idFields.length) {
            var elementId = originData[this.idFields[0]];
            for (var index = 1; index < this.idFields.length; index++) {
                elementId += '-' + originData[this.idFields[index]];
            }
            return elementId;
        }
        var type = this.type;
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale.field || 'x';
        var yField = yScale.field || 'y';
        var yVal = originData[yField];
        var xVal;
        if (xScale.type === 'identity') {
            xVal = xScale.values[0];
        }
        else {
            xVal = originData[xField];
        }
        var id;
        if (type === 'interval' || type === 'schema') {
            id = "".concat(xVal);
        }
        else if (type === 'line' || type === 'area' || type === 'path') {
            id = type;
        }
        else {
            id = "".concat(xVal, "-").concat(yVal);
        }
        var groupScales = this.groupScales;
        for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
            var groupScale = groupScales[index];
            var field = groupScale.field;
            id = "".concat(id, "-").concat(originData[field]);
        }
        // \u7528\u6237\u5728\u8FDB\u884C dodge \u7C7B\u578B\u7684 adjust \u8C03\u6574\u7684\u65F6\u5019\u8BBE\u7F6E\u4E86 dodgeBy \u5C5E\u6027
        var dodgeAdjust = this.getAdjust('dodge');
        if (dodgeAdjust) {
            var dodgeBy = dodgeAdjust.dodgeBy;
            if (dodgeBy) {
                id = "".concat(id, "-").concat(originData[dodgeBy]);
            }
        }
        if (this.getAdjust('jitter')) {
            id = "".concat(id, "-").concat(data.x, "-").concat(data.y);
        }
        return id;
    };
    /**
     * \u83B7\u53D6\u6240\u6709\u9700\u8981\u521B\u5EFA scale \u7684\u5B57\u6BB5\u540D\u79F0\u3002
     */
    Geometry.prototype.getScaleFields = function () {
        var fields = [];
        var tmpMap = new Map();
        var _a = this, attributeOption = _a.attributeOption, labelOption = _a.labelOption, tooltipOption = _a.tooltipOption;
        // \u83B7\u53D6\u56FE\u5F62\u5C5E\u6027\u4E0A\u7684 fields
        for (var attributeType in attributeOption) {
            if (attributeOption.hasOwnProperty(attributeType)) {
                var eachOpt = attributeOption[attributeType];
                if (eachOpt.fields) {
                    uniq(eachOpt.fields, fields, tmpMap);
                }
                else if (eachOpt.values) {
                    // \u8003\u8651 size(10), shape('circle') \u7B49\u573A\u666F
                    uniq(eachOpt.values, fields, tmpMap);
                }
            }
        }
        // \u83B7\u53D6 label \u4E0A\u7684\u5B57\u6BB5
        if (labelOption && labelOption.fields) {
            uniq(labelOption.fields, fields, tmpMap);
        }
        // \u83B7\u53D6 tooltip \u4E0A\u7684\u5B57\u6BB5
        if ((0,esm/* isObject */.Kn)(tooltipOption) && tooltipOption.fields) {
            uniq(tooltipOption.fields, fields, tmpMap);
        }
        return fields;
    };
    /**
     * \u663E\u793A\u6216\u8005\u9690\u85CF geometry\u3002
     * @param visible
     */
    Geometry.prototype.changeVisible = function (visible) {
        _super.prototype.changeVisible.call(this, visible);
        var elements = this.elements;
        for (var index = 0, length_3 = elements.length; index < length_3; index++) {
            var element = elements[index];
            element.changeVisible(visible);
        }
        if (visible) {
            if (this.container) {
                this.container.show();
            }
            if (this.labelsContainer) {
                this.labelsContainer.show();
            }
        }
        else {
            if (this.container) {
                this.container.hide();
            }
            if (this.labelsContainer) {
                this.labelsContainer.hide();
            }
        }
    };
    /**
     * \u83B7\u5F97\u6240\u6709\u7684\u5B57\u6BB5
     */
    Geometry.prototype.getFields = function () {
        var uniqMap = new Map();
        var fields = [];
        Object.values(this.attributeOption).forEach(function (cfg) {
            var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
            fs.forEach(function (f) {
                if (!uniqMap.has(f)) {
                    fields.push(f);
                }
                uniqMap.set(f, true);
            });
        }, []);
        return fields;
    };
    /**
     * \u83B7\u53D6\u5F53\u524D\u914D\u7F6E\u4E2D\u7684\u6240\u6709\u5206\u7EC4 & \u5206\u7C7B\u7684\u5B57\u6BB5\u3002
     * @return fields string[]
     */
    Geometry.prototype.getGroupFields = function () {
        var groupFields = [];
        var tmpMap = new Map(); // \u7528\u4E8E\u53BB\u91CD\u8FC7\u6EE4
        for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
            var attributeName = GROUP_ATTRS[index];
            var cfg = this.attributeOption[attributeName];
            if (cfg && cfg.fields) {
                uniq(cfg.fields, groupFields, tmpMap);
            }
        }
        return groupFields;
    };
    /**
     * \u83B7\u5F97\u56FE\u5F62\u7684 x y \u5B57\u6BB5\u3002
     */
    Geometry.prototype.getXYFields = function () {
        var _a = (0,tslib_es6/* __read */.CR)(this.attributeOption.position.fields, 2), x = _a[0], y = _a[1];
        return [x, y];
    };
    /**
     * x \u5B57\u6BB5
     * @returns
     */
    Geometry.prototype.getXField = function () {
        return (0,esm/* get */.U2)(this.getXYFields(), [0]);
    };
    /**
     * y \u5B57\u6BB5
     * @returns
     */
    Geometry.prototype.getYField = function () {
        return (0,esm/* get */.U2)(this.getXYFields(), [1]);
    };
    /**
     * \u83B7\u53D6\u8BE5 Geometry \u4E0B\u6240\u6709\u751F\u6210\u7684 shapes\u3002
     * @returns shapes
     */
    Geometry.prototype.getShapes = function () {
        return this.elements.map(function (element) { return element.shape; });
    };
    /**
     * \u83B7\u53D6\u865A\u62DF Group\u3002
     * @returns
     */
    Geometry.prototype.getOffscreenGroup = function () {
        if (!this.offscreenGroup) {
            var GroupCtor = this.container.getGroupBase(); // \u83B7\u53D6\u5206\u7EC4\u7684\u6784\u9020\u51FD\u6570
            this.offscreenGroup = new GroupCtor({});
        }
        return this.offscreenGroup;
    };
    // \u5BF9\u6570\u636E\u8FDB\u884C\u6392\u5E8F
    Geometry.prototype.sort = function (mappingArray) {
        if (!this.hasSorted) {
            // \u672A\u53D1\u751F\u8FC7\u6392\u5E8F
            var xScale_1 = this.getXScale();
            var xField_1 = xScale_1.field;
            for (var index = 0; index < mappingArray.length; index++) {
                var itemArr = mappingArray[index];
                itemArr.sort(function (obj1, obj2) {
                    return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
                });
            }
        }
        this.hasSorted = true;
    };
    /**
     * \u8C03\u6574\u5EA6\u91CF\u8303\u56F4\u3002\u4E3B\u8981\u9488\u5BF9\u53D1\u751F\u5C42\u53E0\u4EE5\u53CA\u4E00\u4E9B\u7279\u6B8A\u9700\u6C42\u7684 Geometry\uFF0C\u6BD4\u5982 Interval \u4E0B\u7684\u67F1\u72B6\u56FE Y \u8F74\u9ED8\u8BA4\u4ECE 0 \u5F00\u59CB\u3002
     */
    Geometry.prototype.adjustScale = function () {
        var yScale = this.getYScale();
        // \u5982\u679C\u6570\u636E\u53D1\u751F\u8FC7 stack adjust\uFF0C\u9700\u8981\u8C03\u6574\u4E0B yScale \u7684\u6570\u636E\u8303\u56F4
        if (yScale && this.getAdjust('stack')) {
            this.updateStackRange(yScale, this.beforeMappingData);
        }
    };
    /**
     * \u83B7\u53D6\u5F53\u524D Geometry \u5BF9\u5E94\u7684 Shape \u5DE5\u5382\u5B9E\u4F8B\u3002
     */
    Geometry.prototype.getShapeFactory = function () {
        var shapeType = this.shapeType;
        if (!getShapeFactory(shapeType)) {
            return;
        }
        if (!this.shapeFactory) {
            this.shapeFactory = (0,esm/* clone */.d9)(getShapeFactory(shapeType)); // \u9632\u6B62\u591A\u4E2A view \u5171\u4EAB\u4E00\u4E2A shapeFactory \u5B9E\u4F8B\uFF0C\u5BFC\u81F4 coordinate \u88AB\u7BE1\u6539
        }
        // \u56E0\u4E3A\u8FD9\u91CC\u7F13\u5B58\u4E86 shapeFactory\uFF0C\u4F46\u662F\u5916\u90E8\u53EF\u80FD\u4F1A\u53D8\u66F4 coordinate\uFF0C\u5BFC\u81F4\u65E0\u6CD5\u91CD\u65B0\u8BBE\u7F6E\u5230 shapeFactory \u4E2D
        this.shapeFactory.coordinate = this.coordinate;
        // theme \u539F\u56E0\u540C\u4E0A
        this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
        return this.shapeFactory;
    };
    /**
     * \u83B7\u53D6\u6BCF\u4E2A Shape \u5BF9\u5E94\u7684\u5173\u952E\u70B9\u6570\u636E\u3002
     * @param obj \u7ECF\u8FC7\u5206\u7EC4 -> \u6570\u5B57\u5316 -> adjust \u8C03\u6574\u540E\u7684\u6570\u636E\u8BB0\u5F55
     * @returns
     */
    Geometry.prototype.createShapePointsCfg = function (obj) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var x = this.normalizeValues(obj[xScale.field], xScale);
        var y; // \u5B58\u5728\u6CA1\u6709 y \u7684\u60C5\u51B5
        if (yScale) {
            y = this.normalizeValues(obj[yScale.field], yScale);
        }
        else {
            y = obj.y ? obj.y : 0.1;
        }
        return {
            x: x,
            y: y,
            y0: yScale ? yScale.scale(this.getYMinValue()) : undefined,
        };
    };
    /**
     * \u521B\u5EFA Element \u5B9E\u4F8B\u3002
     * @param mappingDatum Element \u5BF9\u5E94\u7684\u7ED8\u5236\u6570\u636E
     * @param [isUpdate] \u662F\u5426\u5904\u4E8E\u66F4\u65B0\u9636\u6BB5
     * @returns element \u8FD4\u56DE\u521B\u5EFA\u7684 Element \u5B9E\u4F8B
     */
    Geometry.prototype.createElement = function (mappingDatum, index, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        var container = this.container;
        var shapeCfg = this.getDrawCfg(mappingDatum); // \u83B7\u53D6\u7ED8\u5236\u56FE\u5F62\u7684\u914D\u7F6E\u4FE1\u606F
        var shapeFactory = this.getShapeFactory();
        var element = new geometry_element({
            shapeFactory: shapeFactory,
            container: container,
            offscreenGroup: this.getOffscreenGroup(),
            elementIndex: index,
        });
        element.animate = this.animateOption;
        element.geometry = this;
        element.draw(shapeCfg, isUpdate); // \u7ED8\u5236
        return element;
    };
    /**
     * \u83B7\u53D6\u6BCF\u6761\u6570\u636E\u5BF9\u5E94\u7684\u56FE\u5F62\u7ED8\u5236\u6570\u636E\u3002
     * @param mappingDatum \u6620\u5C04\u540E\u7684\u6570\u636E
     * @returns draw cfg
     */
    Geometry.prototype.getDrawCfg = function (mappingDatum) {
        var originData = mappingDatum[FIELD_ORIGIN]; // \u539F\u59CB\u6570\u636E
        var cfg = {
            mappingData: mappingDatum,
            data: originData,
            x: mappingDatum.x,
            y: mappingDatum.y,
            color: mappingDatum.color,
            size: mappingDatum.size,
            isInCircle: this.coordinate.isPolar,
            customInfo: this.customOption,
        };
        var shapeName = mappingDatum.shape;
        if (!shapeName && this.getShapeFactory()) {
            shapeName = this.getShapeFactory().defaultShapeType;
        }
        cfg.shape = shapeName;
        // \u83B7\u53D6\u9ED8\u8BA4\u6837\u5F0F
        var theme = this.theme.geometries[this.shapeType];
        cfg.defaultStyle = (0,esm/* get */.U2)(theme, [shapeName, 'default'], {}).style;
        if (!cfg.defaultStyle && this.getShapeFactory()) {
            cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
        }
        var styleOption = this.styleOption;
        if (styleOption) {
            cfg.style = this.getStyleCfg(styleOption, originData);
        }
        if (this.generatePoints) {
            cfg.points = mappingDatum.points;
            cfg.nextPoints = mappingDatum.nextPoints;
        }
        return cfg;
    };
    Geometry.prototype.updateElements = function (mappingDataArray, isUpdate) {
        var e_1, _a, e_2, _b, e_3, _c;
        if (isUpdate === void 0) { isUpdate = false; }
        var keyDatum = new Map();
        var keys = [];
        // \u7528\u6765\u4FDD\u6301 diff \u5143\u7D20\u4E4B\u540E added, updated \u7684\u76F8\u5BF9\u987A\u5E8F
        var keyIndex = new Map();
        var index = 0;
        // \u83B7\u5F97\u66F4\u65B0\u6570\u636E\u6240\u6709\u7684 keys
        // \u5C06\u66F4\u65B0\u7684\u6570\u636E\u7528 key \u7D22\u5F15
        for (var i = 0; i < mappingDataArray.length; i++) {
            var mappingData = mappingDataArray[i];
            for (var j = 0; j < mappingData.length; j++) {
                var mappingDatum = mappingData[j];
                var key = this.getElementId(mappingDatum);
                var finalKey = keyDatum.has(key) ? "".concat(key, "-").concat(i, "-").concat(j) : key;
                keys.push(finalKey);
                keyDatum.set(finalKey, mappingDatum);
                keyIndex.set(finalKey, index);
                index++;
            }
        }
        this.elements = new Array(index);
        var _d = diff(this.lastElementsMap, keys), added = _d.added, updated = _d.updated, removed = _d.removed;
        try {
            // \u65B0\u5EFA element
            for (var added_1 = (0,tslib_es6/* __values */.XA)(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
                var key = added_1_1.value;
                var mappingDatum = keyDatum.get(key);
                var i = keyIndex.get(key);
                var element = this.createElement(mappingDatum, i, isUpdate);
                this.elements[i] = element;
                this.elementsMap[key] = element;
                if (element.shape) {
                    element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (added_1_1 && !added_1_1.done && (_a = added_1.return)) _a.call(added_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // \u66F4\u65B0 element
            for (var updated_1 = (0,tslib_es6/* __values */.XA)(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
                var key = updated_1_1.value;
                var element = this.lastElementsMap[key];
                var mappingDatum = keyDatum.get(key);
                var currentShapeCfg = this.getDrawCfg(mappingDatum);
                var preShapeCfg = element.getModel();
                var i = keyIndex.get(key);
                if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
                    element.animate = this.animateOption;
                    // \u901A\u8FC7\u7ED8\u5236\u6570\u636E\u7684\u53D8\u66F4\u6765\u5224\u65AD\u662F\u5426\u9700\u8981\u66F4\u65B0\uFF0C\u56E0\u4E3A\u7528\u6237\u6709\u53EF\u80FD\u4F1A\u4FEE\u6539\u56FE\u5F62\u5C5E\u6027\u6620\u5C04
                    element.update(currentShapeCfg); // \u66F4\u65B0\u5BF9\u5E94\u7684 element
                }
                this.elements[i] = element;
                this.elementsMap[key] = element;
                if (element.shape) {
                    element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // \u5168\u90E8 setZIndex \u4E4B\u540E\uFF0C\u518D\u6267\u884C sort
        if (this.container) {
            this.container.sort();
        }
        try {
            // \u9500\u6BC1\u88AB\u5220\u9664\u7684 elements
            for (var removed_1 = (0,tslib_es6/* __values */.XA)(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
                var key = removed_1_1.value;
                var element = this.lastElementsMap[key];
                // \u66F4\u65B0\u52A8\u753B\u914D\u7F6E\uFF0C\u7528\u6237\u6709\u53EF\u80FD\u5728\u66F4\u65B0\u4E4B\u524D\u6709\u5BF9\u52A8\u753B\u8FDB\u884C\u914D\u7F6E\u64CD\u4F5C
                element.animate = this.animateOption;
                element.destroy();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * \u83B7\u53D6\u6E32\u67D3\u7684 label \u7C7B\u578B\u3002
     */
    Geometry.prototype.getLabelType = function () {
        var _a = this, labelOption = _a.labelOption, coordinate = _a.coordinate, type = _a.type;
        var coordinateType = coordinate.type, isTransposed = coordinate.isTransposed;
        var labelType = (0,esm/* get */.U2)(labelOption, ['cfg', 'type']);
        if (!labelType) {
            // \u7528\u6237\u672A\u5B9A\u4E49\uFF0C\u5219\u8FDB\u884C\u9ED8\u8BA4\u7684\u903B\u8F91
            if (coordinateType === 'polar') {
                // \u6781\u5750\u6807\u4E0B\u4F7F\u7528\u901A\u7528\u7684\u6781\u5750\u6807\u6587\u672C\uFF0C\u8F6C\u7F6E\u5219\u4F7F\u7528\u997C\u56FE
                labelType = isTransposed ? 'pie' : 'polar';
            }
            else if (coordinateType === 'theta') {
                // theta \u5750\u6807\u7CFB\u4E0B\u4F7F\u7528\u997C\u56FE\u6587\u672C
                labelType = 'pie';
            }
            else if (type === 'interval' || type === 'polygon') {
                labelType = 'interval';
            }
            else {
                labelType = 'base';
            }
        }
        return labelType;
    };
    /**
     * \u83B7\u53D6 Y \u8F74\u4E0A\u7684\u6700\u5C0F\u503C\u3002
     */
    Geometry.prototype.getYMinValue = function () {
        var yScale = this.getYScale();
        var min = yScale.min, max = yScale.max;
        var value;
        if (min >= 0) {
            value = min;
        }
        else if (max <= 0) {
            // \u5F53\u503C\u5168\u4F4D\u4E8E\u8D1F\u533A\u95F4\u65F6\uFF0C\u9700\u8981\u4FDD\u8BC1 ymin \u5728\u533A\u57DF\u5185\uFF0C\u4E0D\u53EF\u4E3A 0
            value = max;
        }
        else {
            value = 0;
        }
        return value;
    };
    // \u521B\u5EFA\u56FE\u5F62\u5C5E\u6027\u76F8\u5173\u7684\u914D\u7F6E\u9879
    Geometry.prototype.createAttrOption = function (attrName, field, cfg) {
        if ((0,esm/* isNil */.UM)(field) || (0,esm/* isObject */.Kn)(field)) {
            if ((0,esm/* isObject */.Kn)(field) && (0,esm/* isEqual */.Xy)(Object.keys(field), ['values'])) {
                // shape({ values: [ 'funnel' ] })
                (0,esm/* set */.t8)(this.attributeOption, attrName, {
                    fields: field.values,
                });
            }
            else {
                (0,esm/* set */.t8)(this.attributeOption, attrName, field);
            }
        }
        else {
            var attrCfg = {};
            if ((0,esm/* isNumber */.hj)(field)) {
                // size(3)
                attrCfg.values = [field];
            }
            else {
                attrCfg.fields = parseFields(field);
            }
            if (cfg) {
                if ((0,esm/* isFunction */.mf)(cfg)) {
                    attrCfg.callback = cfg;
                }
                else {
                    attrCfg.values = cfg;
                }
            }
            (0,esm/* set */.t8)(this.attributeOption, attrName, attrCfg);
        }
    };
    Geometry.prototype.initAttributes = function () {
        var _this = this;
        var _a = this, attributes = _a.attributes, attributeOption = _a.attributeOption, theme = _a.theme, shapeType = _a.shapeType;
        this.groupScales = [];
        var tmpMap = {};
        var _loop_1 = function (attrType) {
            if (attributeOption.hasOwnProperty(attrType)) {
                var option = attributeOption[attrType];
                if (!option) {
                    return { value: void 0 };
                }
                var attrCfg = (0,tslib_es6/* __assign */.pi)({}, option);
                var callback = attrCfg.callback, values = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
                // \u83B7\u53D6\u6BCF\u4E00\u4E2A\u5B57\u6BB5\u5BF9\u5E94\u7684 scale
                var scales = fields.map(function (field) {
                    var scale = _this.scales[field];
                    if (!tmpMap[field] && GROUP_ATTRS.includes(attrType)) {
                        var inferedScaleType = inferScaleType(scale, (0,esm/* get */.U2)(_this.scaleDefs, field), attrType, _this.type);
                        if (inferedScaleType === 'cat') {
                            _this.groupScales.push(scale);
                            tmpMap[field] = true;
                        }
                    }
                    return scale;
                });
                attrCfg.scales = scales;
                if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {
                    // \u7528\u6237\u5728\u56FE\u5F62\u901A\u9053\u4E0A\u58F0\u660E\u4E86\u5E38\u91CF\u5B57\u6BB5 color('red'), size(5)
                    attrCfg.values = scales[0].values;
                }
                else if (!callback && !values) {
                    // \u7528\u6237\u6CA1\u6709\u6307\u5B9A\u4EFB\u4F55\u89C4\u5219\uFF0C\u5219\u4F7F\u7528\u9ED8\u8BA4\u7684\u6620\u5C04\u89C4\u5219
                    if (attrType === 'size') {
                        attrCfg.values = theme.sizes;
                    }
                    else if (attrType === 'shape') {
                        attrCfg.values = theme.shapes[shapeType] || [];
                    }
                    else if (attrType === 'color') {
                        if (scales.length) {
                            // \u6839\u636E\u6570\u503C\u4E2A\u6570\u4F7F\u7528\u5BF9\u5E94\u7684\u8272\u677F
                            attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
                        }
                        else {
                            attrCfg.values = theme.colors10;
                        }
                    }
                }
                var AttributeCtor = getAttribute(attrType);
                attributes[attrType] = new AttributeCtor(attrCfg);
            }
        };
        // \u904D\u5386\u6BCF\u4E00\u4E2A attrOption\uFF0C\u5404\u81EA\u521B\u5EFA Attribute \u5B9E\u4F8B
        for (var attrType in attributeOption) {
            var state_1 = _loop_1(attrType);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    // \u5904\u7406\u6570\u636E\uFF1A\u5206\u7EC4 -> \u6570\u5B57\u5316 -> adjust \u8C03\u6574
    Geometry.prototype.processData = function (data) {
        var e_4, _a;
        this.hasSorted = false;
        var scales = this.getAttribute('position').scales;
        var categoryScales = scales.filter(function (scale) { return scale.isCategory; });
        var groupedArray = this.groupData(data); // \u6570\u636E\u5206\u7EC4
        var beforeAdjust = [];
        for (var i = 0, len = groupedArray.length; i < len; i++) {
            var subData = groupedArray[i];
            var arr = [];
            for (var j = 0, subLen = subData.length; j < subLen; j++) {
                var originData = subData[j];
                var item = {};
                // tslint:disable-next-line: forin
                for (var k in originData) {
                    item[k] = originData[k];
                }
                item[FIELD_ORIGIN] = originData;
                try {
                    // \u5C06\u5206\u7C7B\u6570\u636E\u7FFB\u8BD1\u6210\u6570\u636E, \u4EC5\u5BF9\u4F4D\u7F6E\u76F8\u5173\u7684\u5EA6\u91CF\u8FDB\u884C\u6570\u5B57\u5316\u5904\u7406
                    for (var categoryScales_1 = (e_4 = void 0, (0,tslib_es6/* __values */.XA)(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
                        var scale = categoryScales_1_1.value;
                        var field = scale.field;
                        item[field] = scale.translate(item[field]);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (categoryScales_1_1 && !categoryScales_1_1.done && (_a = categoryScales_1.return)) _a.call(categoryScales_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                arr.push(item);
            }
            beforeAdjust.push(arr);
        }
        var dataArray = this.adjustData(beforeAdjust); // \u8FDB\u884C adjust \u6570\u636E\u8C03\u6574
        this.beforeMappingData = dataArray;
        return dataArray;
    };
    // \u8C03\u6574\u6570\u636E
    Geometry.prototype.adjustData = function (dataArray) {
        var adjustOption = this.adjustOption;
        var _a = this, intervalPadding = _a.intervalPadding, dodgePadding = _a.dodgePadding, theme = _a.theme;
        // \u517C\u5BB9theme\u914D\u7F6E
        var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
        var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
        var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
        var result = dataArray;
        if (adjustOption) {
            var xScale_2 = this.getXScale();
            var yScale = this.getYScale();
            var xField = xScale_2.field;
            var yField = yScale ? yScale.field : null;
            var xDimensionLength = getXDimensionLength(this.coordinate);
            var groupNum = xScale_2.values.length;
            // \u4F20\u5165size\u8BA1\u7B97\u76F8\u5173\u53C2\u6570\uFF0C\u9ED8\u8BA4\u5BBD\u5EA6\u3001\u6700\u5927\u6700\u5C0F\u5BBD\u5EA6\u7EA6\u675F
            var sizeAttr = this.getAttribute('size');
            var defaultSize = void 0;
            if (sizeAttr) {
                defaultSize = sizeAttr.values[0];
            }
            for (var i = 0, len = adjustOption.length; i < len; i++) {
                var adjust = adjustOption[i];
                var adjustCfg = (0,tslib_es6/* __assign */.pi)({ xField: xField, yField: yField, intervalPadding: intervalPadding, dodgePadding: dodgePadding, xDimensionLength: xDimensionLength, groupNum: groupNum, defaultSize: defaultSize, maxColumnWidth: maxColumnWidth, minColumnWidth: minColumnWidth, columnWidthRatio: columnWidthRatio }, adjust);
                var type = adjust.type;
                if (type === 'dodge') {
                    var adjustNames = [];
                    if (xScale_2.isCategory || xScale_2.type === 'identity') {
                        adjustNames.push('x');
                    }
                    else if (!yScale) {
                        adjustNames.push('y');
                    }
                    else {
                        throw new Error('dodge is not support linear attribute, please use category attribute!');
                    }
                    adjustCfg.adjustNames = adjustNames;
                    // \u6BCF\u4E2A\u5206\u7EC4\u5185\u6BCF\u6761\u67F1\u5B50\u7684\u5BBD\u5EA6\u5360\u6BD4\uFF0C\u7528\u6237\u4E0D\u53EF\u6307\u5B9A\uFF0C\u7528\u6237\u9700\u8981\u901A\u8FC7 columnWidthRatio \u6307\u5B9A
                    // \u517C\u5BB9theme\u914D\u7F6E
                    adjustCfg.dodgeRatio = columnWidthRatio;
                }
                else if (type === 'stack') {
                    var coordinate = this.coordinate;
                    if (!yScale) {
                        // \u4E00\u7EF4\u7684\u60C5\u51B5\u4E0B\u83B7\u53D6\u9AD8\u5EA6\u548C\u9ED8\u8BA4size
                        adjustCfg.height = coordinate.getHeight();
                        var size = this.getDefaultValue('size') || 3;
                        adjustCfg.size = size;
                    }
                    // \u4E0D\u8FDB\u884C transpose \u65F6\uFF0C\u7528\u6237\u53C8\u6CA1\u6709\u8BBE\u7F6E\u8FD9\u4E2A\u53C2\u6570\u65F6\uFF0C\u9ED8\u8BA4\u4ECE\u4E0A\u5411\u4E0B
                    if (!coordinate.isTransposed && (0,esm/* isNil */.UM)(adjustCfg.reverseOrder)) {
                        adjustCfg.reverseOrder = true;
                    }
                }
                var adjustCtor = getAdjust(type);
                adjustCfg.dimValuesMap = {};
                //\u751F\u6210dimValuesMap
                if (xScale_2 && xScale_2.values) {
                    adjustCfg.dimValuesMap[xScale_2.field] = xScale_2.values.map(function (v) { return xScale_2.translate(v); });
                }
                var adjustInstance = new adjustCtor(adjustCfg);
                result = adjustInstance.process(result);
                this.adjusts[type] = adjustInstance;
            }
        }
        return result;
    };
    // \u5BF9\u6570\u636E\u8FDB\u884C\u5206\u7EC4
    Geometry.prototype.groupData = function (data) {
        var groupScales = this.getGroupScales();
        var scaleDefs = this.scaleDefs;
        var appendConditions = {};
        var groupFields = [];
        for (var index = 0; index < groupScales.length; index++) {
            var scale = groupScales[index];
            var field = scale.field;
            groupFields.push(field);
            if ((0,esm/* get */.U2)(scaleDefs, [field, 'values'])) {
                // \u7528\u6237\u901A\u8FC7 view.scale() \u63A5\u53E3\u6307\u5B9A\u4E86 values \u5C5E\u6027
                appendConditions[field] = scaleDefs[field].values;
            }
        }
        return group(data, groupFields, appendConditions);
    };
    // \u66F4\u65B0\u53D1\u751F\u5C42\u53E0\u540E\u7684\u6570\u636E\u5BF9\u5E94\u7684\u5EA6\u91CF\u8303\u56F4
    Geometry.prototype.updateStackRange = function (scale, dataArray) {
        var mergeArray = (0,esm/* flatten */.xH)(dataArray);
        var field = scale.field;
        var min = scale.min;
        var max = scale.max;
        for (var index = 0; index < mergeArray.length; index++) {
            var obj = mergeArray[index];
            var tmpMin = Math.min.apply(null, obj[field]);
            var tmpMax = Math.max.apply(null, obj[field]);
            if (tmpMin < min) {
                min = tmpMin;
            }
            if (tmpMax > max) {
                max = tmpMax;
            }
        }
        var scaleDefs = this.scaleDefs;
        var cfg = {};
        if (min < scale.min && !(0,esm/* get */.U2)(scaleDefs, [field, 'min'])) {
            // \u7528\u6237\u5982\u679C\u5728\u5217\u5B9A\u4E49\u4E2D\u5B9A\u4E49\u4E86 min\uFF0C\u5219\u4EE5\u7528\u6237\u5B9A\u4E49\u7684\u4E3A\u51C6
            cfg.min = min;
        }
        if (max > scale.max && !(0,esm/* get */.U2)(scaleDefs, [field, 'max'])) {
            // \u7528\u6237\u5982\u679C\u5728\u5217\u5B9A\u4E49\u4E2D\u5B9A\u4E49\u4E86 max
            cfg.max = max;
        }
        scale.change(cfg);
    };
    // \u5C06\u6570\u636E\u6620\u5C04\u81F3\u56FE\u5F62\u7A7A\u95F4\u524D\u7684\u64CD\u4F5C\uFF1A\u6392\u5E8F\u4EE5\u53CA\u5173\u952E\u70B9\u7684\u751F\u6210
    Geometry.prototype.beforeMapping = function (beforeMappingData) {
        // \u5F53\u521D\u52A0 clone \u662F\u56E0\u4E3A points \u7684\u5F15\u7528\u5173\u7CFB\uFF0C\u5BFC\u81F4\u66F4\u65B0\u5931\u8D25\uFF0C\u53EF\u662F\u73B0\u5728\u8C8C\u4F3C\u590D\u73B0\u4E0D\u51FA\u6765\u4E86\uFF0C\u6240\u4EE5\u6682\u65F6\u4E0D\u8FDB\u884C clone
        // const source = clone(beforeMappingData);
        var source = beforeMappingData;
        if (this.sortable) {
            this.sort(source);
        }
        if (this.generatePoints) {
            // \u9700\u8981\u751F\u6210\u5173\u952E\u70B9
            for (var index = 0, length_5 = source.length; index < length_5; index++) {
                var currentData = source[index];
                this.generateShapePoints(currentData);
                var nextData = source[index + 1];
                if (nextData) {
                    this.generateShapePoints(nextData);
                    currentData[0].nextPoints = nextData[0].points;
                }
            }
        }
        return source;
    };
    // \u751F\u6210 shape \u7684\u5173\u952E\u70B9
    Geometry.prototype.generateShapePoints = function (data) {
        var shapeFactory = this.getShapeFactory();
        var shapeAttr = this.getAttribute('shape');
        for (var index = 0; index < data.length; index++) {
            var obj = data[index];
            var cfg = this.createShapePointsCfg(obj);
            var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
            var points = shapeFactory.getShapePoints(shape, cfg);
            obj.points = points;
        }
    };
    // \u5C06\u6570\u636E\u5F52\u4E00\u5316
    Geometry.prototype.normalizeValues = function (values, scale) {
        var rst = [];
        if ((0,esm/* isArray */.kJ)(values)) {
            for (var index = 0; index < values.length; index++) {
                var value = values[index];
                rst.push(scale.scale(value));
            }
        }
        else {
            rst = scale.scale(values);
        }
        return rst;
    };
    // \u5C06\u6570\u636E\u6620\u5C04\u81F3\u56FE\u5F62\u7A7A\u95F4
    Geometry.prototype.mapping = function (data) {
        var attributes = this.attributes;
        var mappingData = [];
        for (var index = 0; index < data.length; index++) {
            var record = data[index];
            var newRecord = {
                _origin: record[FIELD_ORIGIN],
                points: record.points,
                nextPoints: record.nextPoints,
            };
            for (var k in attributes) {
                if (attributes.hasOwnProperty(k)) {
                    var attr = attributes[k];
                    var names = attr.names;
                    var values = this.getAttributeValues(attr, record);
                    if (names.length > 1) {
                        // position \u4E4B\u7C7B\u7684\u751F\u6210\u591A\u4E2A\u5B57\u6BB5\u7684\u5C5E\u6027
                        for (var j = 0; j < values.length; j += 1) {
                            var val = values[j];
                            var name_1 = names[j];
                            newRecord[name_1] = (0,esm/* isArray */.kJ)(val) && val.length === 1 ? val[0] : val; // \u53EA\u6709\u4E00\u4E2A\u503C\u65F6\u8FD4\u56DE\u7B2C\u4E00\u4E2A\u5C5E\u6027\u503C
                        }
                    }
                    else {
                        // values.length === 1 \u7684\u5224\u65AD\u662F\u4EE5\u4E0B\u60C5\u51B5\uFF0C\u83B7\u53D6\u7528\u6237\u8BBE\u7F6E\u7684\u56FE\u5F62\u5C5E\u6027\u503C
                        // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])
                        newRecord[names[0]] = values.length === 1 ? values[0] : values;
                    }
                }
            }
            this.convertPoint(newRecord); // \u5C06 x\u3001y \u8F6C\u6362\u6210\u753B\u5E03\u5750\u6807
            mappingData.push(newRecord);
        }
        return mappingData;
    };
    // \u5C06\u5F52\u4E00\u5316\u7684\u5750\u6807\u503C\u8F6C\u6362\u6210\u753B\u5E03\u5750\u6807
    Geometry.prototype.convertPoint = function (mappingRecord) {
        var x = mappingRecord.x, y = mappingRecord.y;
        var rstX;
        var rstY;
        var obj;
        var coordinate = this.coordinate;
        if ((0,esm/* isArray */.kJ)(x) && (0,esm/* isArray */.kJ)(y)) {
            rstX = [];
            rstY = [];
            for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
                obj = coordinate.convert({
                    x: x[i],
                    y: y[j],
                });
                rstX.push(obj.x);
                rstY.push(obj.y);
            }
        }
        else if ((0,esm/* isArray */.kJ)(y)) {
            rstY = [];
            for (var index = 0; index < y.length; index++) {
                var yVal = y[index];
                obj = coordinate.convert({
                    x: x,
                    y: yVal,
                });
                if (rstX && rstX !== obj.x) {
                    if (!(0,esm/* isArray */.kJ)(rstX)) {
                        rstX = [rstX];
                    }
                    rstX.push(obj.x);
                }
                else {
                    rstX = obj.x;
                }
                rstY.push(obj.y);
            }
        }
        else if ((0,esm/* isArray */.kJ)(x)) {
            rstX = [];
            for (var index = 0; index < x.length; index++) {
                var xVal = x[index];
                obj = coordinate.convert({
                    x: xVal,
                    y: y,
                });
                if (rstY && rstY !== obj.y) {
                    if (!(0,esm/* isArray */.kJ)(rstY)) {
                        rstY = [rstY];
                    }
                    rstY.push(obj.y);
                }
                else {
                    rstY = obj.y;
                }
                rstX.push(obj.x);
            }
        }
        else {
            var point = coordinate.convert({
                x: x,
                y: y,
            });
            rstX = point.x;
            rstY = point.y;
        }
        mappingRecord.x = rstX;
        mappingRecord.y = rstY;
    };
    // \u83B7\u53D6 style \u914D\u7F6E
    Geometry.prototype.getStyleCfg = function (styleOption, originData) {
        var _a = styleOption.fields, fields = _a === void 0 ? [] : _a, callback = styleOption.callback, cfg = styleOption.cfg;
        if (cfg) {
            // \u7528\u6237\u76F4\u63A5\u914D\u7F6E\u6837\u5F0F\u5C5E\u6027
            return cfg;
        }
        var params = fields.map(function (field) {
            return originData[field];
        });
        return callback.apply(void 0, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(params), false));
    };
    Geometry.prototype.setCfg = function (cfg) {
        var _this = this;
        var coordinate = cfg.coordinate, data = cfg.data, theme = cfg.theme, scaleDefs = cfg.scaleDefs;
        if (coordinate) {
            this.coordinate = coordinate;
        }
        if (data) {
            this.data = data;
        }
        if (scaleDefs) {
            this.scaleDefs = scaleDefs;
            this.idFields = [];
            (0,esm/* each */.S6)(scaleDefs, function (scaleDef, field) {
                if (scaleDef && scaleDef.key) {
                    _this.idFields.push(field);
                }
            });
        }
        if (theme) {
            this.theme = this.userTheme ? (0,esm/* deepMix */.b$)({}, theme, this.userTheme) : theme; // \u652F\u6301 geometry \u5C42\u7EA7\u7684\u4E3B\u9898\u8BBE\u7F6E
        }
    };
    Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function () {
            var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a, _b, _c, element, labels;
            var e_5, _d;
            var _this = this;
            return (0,tslib_es6/* __generator */.Jh)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        geometryLabel = this.geometryLabel;
                        this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
                        if (!geometryLabel) {
                            labelType = this.getLabelType();
                            GeometryLabelsCtor = getGeometryLabel(labelType);
                            geometryLabel = new GeometryLabelsCtor(this);
                            this.geometryLabel = geometryLabel;
                        }
                        return [4 /*yield*/, geometryLabel.render(mappingArray, isUpdate)];
                    case 1:
                        _e.sent();
                        labelsMap = geometryLabel.labelsRenderer.shapesMap;
                        elementLabels = new Map();
                        (0,esm/* each */.S6)(labelsMap, function (labelGroup, labelGroupId) {
                            var labelChildren = labelGroup.getChildren() || [];
                            for (var j = 0; j < labelChildren.length; j++) {
                                var labelShape = labelChildren[j];
                                var element = _this.elementsMap[labelShape.get('elementId') || labelGroupId.split(' ')[0]];
                                if (element) {
                                    labelShape.cfg.name = ['element', 'label'];
                                    labelShape.cfg.element = element;
                                    var labels = elementLabels.get(element) || new Set();
                                    labels.add(labelGroup);
                                    elementLabels.set(element, labels);
                                }
                            }
                        });
                        try {
                            for (_a = (0,tslib_es6/* __values */.XA)(elementLabels.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {
                                _c = (0,tslib_es6/* __read */.CR)(_b.value, 2), element = _c[0], labels = _c[1];
                                element.labelShape = (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(labels), false);
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * \u662F\u5426\u9700\u8981\u8FDB\u884C\u7FA4\u7EC4\u5165\u573A\u52A8\u753B
     * \u89C4\u5219\uFF1A
     * 1. \u5982\u679C\u53D1\u751F\u66F4\u65B0\uFF0C\u5219\u4E0D\u8FDB\u884C
     * 2. \u5982\u679C\u7528\u6237\u5173\u95ED geometry \u52A8\u753B\uFF0C\u5219\u4E0D\u8FDB\u884C
     * 3. \u5982\u679C\u7528\u6237\u5173\u95ED\u4E86 appear \u52A8\u753B\uFF0C\u5219\u4E0D\u8FDB\u884C
     * 4. \u5982\u679C\u7528\u6237\u914D\u7F6E\u4E86 appear.animation\uFF0C\u5219\u4E0D\u8FDB\u884C
     */
    Geometry.prototype.canDoGroupAnimation = function (isUpdate) {
        return (!isUpdate &&
            this.animateOption &&
            ((0,esm/* get */.U2)(this.animateOption, 'appear') === undefined ||
                ((0,esm/* get */.U2)(this.animateOption, 'appear') && (0,esm/* get */.U2)(this.animateOption, ['appear', 'animation']) === undefined)));
    };
    return Geometry;
}(base));
/* harmony default export */ var geometry_base = (Geometry);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/transform.js

var transform = ext/* transform */.vs;

/**
 * \u5BF9\u5143\u7D20\u8FDB\u884C\u5E73\u79FB\u64CD\u4F5C\u3002
 * @param element \u8FDB\u884C\u53D8\u6362\u7684\u5143\u7D20
 * @param x x \u65B9\u5411\u4F4D\u79FB
 * @param y y \u65B9\u5411\u4F4D\u79FB
 */
function translate(element, x, y) {
    var matrix = transform(element.getMatrix(), [['t', x, y]]);
    element.setMatrix(matrix);
}
/**
 * \u83B7\u53D6\u5143\u7D20\u65CB\u8F6C\u77E9\u9635 (\u4EE5\u5143\u7D20\u7684\u5DE6\u4E0A\u89D2\u4E3A\u65CB\u8F6C\u70B9)
 * @param element \u8FDB\u884C\u53D8\u6362\u7684\u5143\u7D20
 * @param rotateRadian \u65CB\u8F6C\u5F27\u5EA6
 */
function getRotateMatrix(element, rotateRadian) {
    var _a = element.attr(), x = _a.x, y = _a.y;
    var matrix = transform(element.getMatrix(), [
        ['t', -x, -y],
        ['r', rotateRadian],
        ['t', x, y],
    ]);
    return matrix;
}
/**
 * \u5BF9\u5143\u7D20\u8FDB\u884C\u65CB\u8F6C\u64CD\u4F5C\u3002
 * @param element \u8FDB\u884C\u53D8\u6362\u7684\u5143\u7D20
 * @param rotateRadian \u65CB\u8F6C\u5F27\u5EA6
 */
function rotate(element, rotateRadian) {
    var matrix = getRotateMatrix(element, rotateRadian);
    element.setMatrix(matrix);
}
/**
 * \u83B7\u53D6\u5143\u77E9\u9635\u3002
 * @returns identity matrix
 */
function getIdentityMatrix() {
    return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}
/**
 * \u56F4\u7ED5\u56FE\u5F62\u4E2D\u5FC3\u70B9\u8FDB\u884C\u7F29\u653E
 * @param element \u8FDB\u884C\u7F29\u653E\u7684\u56FE\u5F62\u5143\u7D20
 * @param ratio \u7F29\u653E\u6BD4\u4F8B
 */
function zoom(element, ratio) {
    var bbox = element.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    element.applyToMatrix([x, y, 1]);
    var matrix = transform(element.getMatrix(), [
        ['t', -x, -y],
        ['s', ratio, ratio],
        ['t', x, y],
    ]);
    element.setMatrix(matrix);
}
//# sourceMappingURL=transform.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/util/index.js
/**
 * @file utils of label
 */


/**
 * \u67E5\u627E Label Group \u4E2D\u7684\u6587\u672C shape \u5BF9\u8C61
 * @param label
 */
function findLabelTextShape(label) {
    return label.find(function (el) { return el.get('type') === 'text'; });
}
/**
 * \u83B7\u53D6\u6807\u7B7E\u80CC\u666F\u4FE1\u606F: box (\u65E0\u65CB\u8F6C) + rotation (\u65CB\u8F6C\u89D2\u5EA6)
 */
function getLabelBackgroundInfo(labelGroup, labelItem, padding) {
    if (padding === void 0) { padding = [0, 0, 0, 0]; }
    var content = labelGroup && labelGroup.getChildren()[0];
    if (content) {
        var labelShape = content.clone();
        // revert rotate
        if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
            rotate(labelShape, -labelItem.rotate);
        }
        // use \`getCanvasBBox\`, because if Shape is been translated, \`getBBox\` is not the actual box position
        var _a = labelShape.getCanvasBBox(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        labelShape.destroy();
        var boxPadding = padding;
        if ((0,esm/* isNil */.UM)(boxPadding)) {
            boxPadding = [2, 2, 2, 2];
        }
        else if ((0,esm/* isNumber */.hj)(boxPadding)) {
            boxPadding = new Array(4).fill(boxPadding);
        }
        return {
            x: x - boxPadding[3],
            y: y - boxPadding[0],
            width: width + boxPadding[1] + boxPadding[3],
            height: height + boxPadding[0] + boxPadding[2],
            rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0,
        };
    }
    return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
}
/**
 * \u8BA1\u7B97\u4E24\u4E2A\u77E9\u5F62\u4E4B\u95F4\u7684\u5806\u53E0\u533A\u57DF\u9762\u79EF
 */
function getOverlapArea(a, b, margin) {
    if (margin === void 0) { margin = 0; }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
}
/** \u68C0\u6D4B\u662F\u5426\u548C\u5DF2\u5E03\u5C40\u7684\u5806\u53E0 */
function checkShapeOverlap(cur, dones) {
    var box = cur.getBBox();
    return (0,esm/* some */.G)(dones, function (done) {
        var target = done.getBBox();
        return getOverlapArea(box, target, 2) > 0;
    });
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/component/update-label.js



/**
 * @desc \u66F4\u65B0 label (\u76EE\u524D\u6CA1\u6709\u6839\u636E id \u7D22\u5F15\uFF0C\u8FD8\u662F\u4F1A\u5B58\u5728\u4E00\u70B9\u5C0F\u95EE\u9898\u7684\uFF0C\u53EA\u80FD\u6839\u636E idx \u7D22\u5F15)
 * @done shape \u5C5E\u6027\u66F4\u65B0
 * @done shape delete
 * @done shape append
 *
 * @param fromShape old labelShape
 * @param toShape new labelShape
 * @param cfg
 */
function updateLabel(fromShape, toShape, cfg) {
    var data = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate = cfg.coordinate;
    var updateAnimateCfg = (0,esm/* get */.U2)(animateCfg, 'update');
    fromShape.set('data', data);
    fromShape.set('origin', origin);
    fromShape.set('animateCfg', animateCfg);
    fromShape.set('coordinate', coordinate);
    fromShape.set('visible', toShape.get('visible'));
    (fromShape.getChildren() || []).forEach(function (fromChild, idx) {
        var toChild = toShape.getChildByIndex(idx);
        if (!toChild) {
            fromShape.removeChild(fromChild);
            fromChild.remove(true);
        }
        else {
            fromChild.set('data', data);
            fromChild.set('origin', origin);
            fromChild.set('animateCfg', animateCfg);
            fromChild.set('coordinate', coordinate);
            var newAttrs = getReplaceAttrs(fromChild, toChild);
            if (updateAnimateCfg) {
                doAnimate(fromChild, updateAnimateCfg, {
                    toAttrs: newAttrs,
                    coordinate: coordinate,
                });
            }
            else {
                fromChild.attr(newAttrs);
            }
            if (toChild.isGroup()) {
                updateLabel(fromChild, toChild, cfg);
            }
        }
    });
    // append
    (0,esm/* each */.S6)(toShape.getChildren(), function (child, idx) {
        if (idx >= fromShape.getCount()) {
            if (!child.destroyed) {
                fromShape.add(child);
            }
        }
    });
}
//# sourceMappingURL=update-label.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/component/labels.js









/**
 * Geometry labels \u6E32\u67D3\u7EC4\u4EF6
 */
var Labels = /** @class */ (function () {
    function Labels(cfg) {
        /** \u5B58\u50A8\u5F53\u524D shape \u7684\u6620\u5C04\u8868\uFF0C\u952E\u503C\u4E3A shape id */
        this.shapesMap = {};
        var layout = cfg.layout, container = cfg.container;
        this.layout = layout;
        this.container = container;
    }
    /**
     * \u6E32\u67D3\u6587\u672C
     */
    Labels.prototype.render = function (items, shapes, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function () {
            var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
            var e_1, _a;
            var _this = this;
            return (0,tslib_es6/* __generator */.Jh)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        shapesMap = {};
                        offscreenGroup = this.createOffscreenGroup();
                        if (!items.length) return [3 /*break*/, 2];
                        try {
                            // \u5982\u679C items \u7A7A\u7684\u8BDD\u5C31\u4E0D\u8FDB\u884C\u7ED8\u5236\u8C03\u6574\u64CD\u4F5C
                            // step 1: \u5728\u865A\u62DF group \u4E2D\u521B\u5EFA shapes
                            for (items_1 = (0,tslib_es6/* __values */.XA)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                                item = items_1_1.value;
                                if (item) {
                                    shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        // [todo] Move layout into Worker.
                        // step 2: \u6839\u636E\u5E03\u5C40\uFF0C\u8C03\u6574 labels
                        return [4 /*yield*/, this.doLayout(items, shapes, shapesMap)];
                    case 1:
                        // [todo] Move layout into Worker.
                        // step 2: \u6839\u636E\u5E03\u5C40\uFF0C\u8C03\u6574 labels
                        _b.sent();
                        // step 3.1: \u7ED8\u5236 labelLine
                        this.renderLabelLine(items, shapesMap);
                        // step 3.2: \u7ED8\u5236 labelBackground
                        this.renderLabelBackground(items, shapesMap);
                        // step 4: \u6839\u636E\u7528\u6237\u8BBE\u7F6E\u7684\u504F\u79FB\u91CF\u8C03\u6574 label
                        this.adjustLabel(items, shapesMap);
                        _b.label = 2;
                    case 2:
                        lastShapesMap = this.shapesMap;
                        (0,esm/* each */.S6)(shapesMap, function (shape, id) {
                            if (shape.destroyed) {
                                // label \u5728\u5E03\u5C40\u8C03\u6574\u73AF\u8282\u88AB\u5220\u9664\u4E86\uFF08doLayout\uFF09
                                delete shapesMap[id];
                            }
                            else {
                                if (lastShapesMap[id]) {
                                    // \u56FE\u5F62\u53D1\u751F\u66F4\u65B0
                                    var data = shape.get('data');
                                    var origin_1 = shape.get('origin');
                                    var coordinate = shape.get('coordinate');
                                    var currentAnimateCfg = shape.get('animateCfg');
                                    var currentShape = lastShapesMap[id]; // \u5DF2\u7ECF\u5728\u6E32\u67D3\u6811\u4E0A\u7684 shape
                                    updateLabel(currentShape, shapesMap[id], {
                                        data: data,
                                        origin: origin_1,
                                        animateCfg: currentAnimateCfg,
                                        coordinate: coordinate,
                                    });
                                    shapesMap[id] = currentShape; // \u4FDD\u5B58\u5F15\u7528
                                }
                                else {
                                    // \u65B0\u751F\u6210\u7684 shape
                                    // If container has been destroyed, no need to render labels.
                                    if (_this.container.destroyed)
                                        return;
                                    _this.container.add(shape);
                                    var animateCfg = (0,esm/* get */.U2)(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');
                                    if (animateCfg) {
                                        doAnimate(shape, animateCfg, {
                                            toAttrs: (0,tslib_es6/* __assign */.pi)({}, shape.attr()),
                                            coordinate: shape.get('coordinate'),
                                        });
                                    }
                                }
                                delete lastShapesMap[id];
                            }
                        });
                        // \u79FB\u9664
                        (0,esm/* each */.S6)(lastShapesMap, function (deleteShape) {
                            var animateCfg = (0,esm/* get */.U2)(deleteShape.get('animateCfg'), 'leave');
                            if (animateCfg) {
                                doAnimate(deleteShape, animateCfg, {
                                    toAttrs: null,
                                    coordinate: deleteShape.get('coordinate'),
                                });
                            }
                            else {
                                deleteShape.remove(true); // \u79FB\u9664
                            }
                        });
                        this.shapesMap = shapesMap;
                        offscreenGroup.destroy();
                        return [2 /*return*/];
                }
            });
        });
    };
    /** \u6E05\u9664\u5F53\u524D labels */
    Labels.prototype.clear = function () {
        this.container.clear();
        this.shapesMap = {};
    };
    /** \u9500\u6BC1 */
    Labels.prototype.destroy = function () {
        this.container.destroy();
        this.shapesMap = null;
    };
    Labels.prototype.renderLabel = function (cfg, container) {
        var id = cfg.id, elementId = cfg.elementId, data = cfg.data, mappingData = cfg.mappingData, coordinate = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
        var shapeAppendCfg = {
            id: id,
            elementId: elementId,
            capture: capture,
            data: data,
            origin: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
            coordinate: coordinate,
        };
        var labelGroup = container.addGroup((0,tslib_es6/* __assign */.pi)({ name: 'label', 
            // \u5982\u679C this.animate === false \u6216\u8005 cfg.animate === false/null \u5219\u4E0D\u8FDB\u884C\u52A8\u753B\uFF0C\u5426\u5219\u8FDB\u884C\u52A8\u753B\u914D\u7F6E\u7684\u5408\u5E76
            animateCfg: this.animate === false || animate === null || animate === false ? false : (0,esm/* deepMix */.b$)({}, this.animate, animate) }, shapeAppendCfg));
        var labelShape;
        if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {
            // \u5982\u679C content \u662F Group \u6216\u8005 Shape\uFF0C\u6839\u636E textAlign \u8C03\u6574\u4F4D\u7F6E\u540E\uFF0C\u76F4\u63A5\u5C06\u5176\u52A0\u5165 labelGroup
            var _a = content.getCanvasBBox(), width = _a.width, height = _a.height;
            var textAlign = (0,esm/* get */.U2)(cfg, 'textAlign', 'left');
            var x = cfg.x;
            var y = cfg.y - height / 2;
            if (textAlign === 'center') {
                x = x - width / 2;
            }
            else if (textAlign === 'right' || textAlign === 'end') {
                x = x - width;
            }
            translate(content, x, y); // \u5C06 label \u5E73\u79FB\u81F3 x, y \u6307\u5B9A\u7684\u4F4D\u7F6E
            labelShape = content;
            labelGroup.add(content);
        }
        else {
            var fill = (0,esm/* get */.U2)(cfg, ['style', 'fill']);
            labelShape = labelGroup.addShape('text', (0,tslib_es6/* __assign */.pi)({ attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: (0,esm/* get */.U2)(cfg, 'textBaseline', 'middle'), text: cfg.content }, cfg.style), { fill: (0,esm/* isNull */.Ft)(fill) ? cfg.color : fill }) }, shapeAppendCfg));
        }
        if (cfg.rotate) {
            rotate(labelShape, cfg.rotate);
        }
        return labelGroup;
    };
    // \u6839\u636Etype\u5BF9label\u5E03\u5C40
    Labels.prototype.doLayout = function (items, shapes, shapesMap) {
        return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function () {
            var layouts;
            var _this = this;
            return (0,tslib_es6/* __generator */.Jh)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.layout) return [3 /*break*/, 2];
                        layouts = (0,esm/* isArray */.kJ)(this.layout) ? this.layout : [this.layout];
                        return [4 /*yield*/, Promise.all(layouts.map(function (layout) {
                                var layoutFn = getGeometryLabelLayout((0,esm/* get */.U2)(layout, 'type', ''));
                                if (!layoutFn)
                                    return;
                                var labelShapes = [];
                                var geometryShapes = [];
                                (0,esm/* each */.S6)(shapesMap, function (labelShape, id) {
                                    labelShapes.push(labelShape);
                                    geometryShapes.push(shapes[labelShape.get('elementId')]);
                                });
                                // [todo] Refactor more layout into Worker.
                                return layoutFn(items, labelShapes, geometryShapes, _this.region, layout.cfg);
                            }))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Labels.prototype.renderLabelLine = function (labelItems, shapesMap) {
        (0,esm/* each */.S6)(labelItems, function (labelItem) {
            var coordinate = (0,esm/* get */.U2)(labelItem, 'coordinate');
            if (!labelItem || !coordinate) {
                return;
            }
            var center = coordinate.getCenter();
            var radius = coordinate.getRadius();
            if (!labelItem.labelLine) {
                // labelLine: null | false\uFF0C\u5173\u95ED label \u5BF9\u5E94\u7684 labelLine
                return;
            }
            var labelLineCfg = (0,esm/* get */.U2)(labelItem, 'labelLine', {});
            var id = labelItem.id;
            var path = labelLineCfg.path;
            if (!path) {
                var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);
                path = [
                    ['M', start.x, start.y],
                    ['L', labelItem.x, labelItem.y],
                ];
            }
            var labelGroup = shapesMap[id];
            if (!labelGroup.destroyed) {
                labelGroup.addShape('path', {
                    capture: false,
                    attrs: (0,tslib_es6/* __assign */.pi)({ path: path, stroke: labelItem.color ? labelItem.color : (0,esm/* get */.U2)(labelItem, ['style', 'fill'], '#000'), fill: null }, labelLineCfg.style),
                    id: id,
                    origin: labelItem.mappingData,
                    data: labelItem.data,
                    coordinate: labelItem.coordinate,
                });
            }
        });
    };
    /**
     * \u7ED8\u5236\u6807\u7B7E\u80CC\u666F
     * @param labelItems
     */
    Labels.prototype.renderLabelBackground = function (labelItems, shapesMap) {
        (0,esm/* each */.S6)(labelItems, function (labelItem) {
            var coordinate = (0,esm/* get */.U2)(labelItem, 'coordinate');
            var background = (0,esm/* get */.U2)(labelItem, 'background');
            if (!background || !coordinate) {
                return;
            }
            var id = labelItem.id;
            var labelGroup = shapesMap[id];
            if (!labelGroup.destroyed) {
                var labelContentShape = labelGroup.getChildren()[0];
                if (labelContentShape) {
                    var _a = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a.rotation, box = (0,tslib_es6/* __rest */._T)(_a, ["rotation"]);
                    var backgroundShape = labelGroup.addShape('rect', {
                        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, box), (background.style || {})),
                        id: id,
                        origin: labelItem.mappingData,
                        data: labelItem.data,
                        coordinate: labelItem.coordinate,
                    });
                    backgroundShape.setZIndex(-1);
                    if (rotation) {
                        var matrix = labelContentShape.getMatrix();
                        backgroundShape.setMatrix(matrix);
                    }
                }
            }
        });
    };
    Labels.prototype.createOffscreenGroup = function () {
        var container = this.container;
        var GroupClass = container.getGroupBase(); // \u83B7\u53D6\u5206\u7EC4\u7684\u6784\u9020\u51FD\u6570
        var newGroup = new GroupClass({});
        return newGroup;
    };
    Labels.prototype.adjustLabel = function (items, shapesMap) {
        (0,esm/* each */.S6)(items, function (item) {
            if (item) {
                var id = item.id;
                var labelGroup = shapesMap[id];
                if (!labelGroup.destroyed) {
                    // fix: \u5982\u679C\u8BF4\u5F00\u53D1\u8005\u7684 label content \u662F\u4E00\u4E2A group\uFF0C\u6B64\u5904\u7684\u504F\u79FB\u65E0\u6CD5\u5BF9 \u6574\u4E2A content group \u751F\u6548\uFF1B\u573A\u666F\u7C7B\u4F3C \u997C\u56FE spider label \u662F\u4E00\u4E2A\u542B 2 \u4E2A textShape \u7684 gorup
                    var labelShapes = labelGroup.findAll(function (ele) { return ele.get('type') !== 'path'; });
                    (0,esm/* each */.S6)(labelShapes, function (labelShape) {
                        if (labelShape) {
                            if (item.offsetX) {
                                labelShape.attr('x', labelShape.attr('x') + item.offsetX);
                            }
                            if (item.offsetY) {
                                labelShape.attr('y', labelShape.attr('y') + item.offsetY);
                            }
                        }
                    });
                }
            }
        });
    };
    return Labels;
}());
/* harmony default export */ var labels = (Labels);
//# sourceMappingURL=labels.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/base.js






function avg(arr) {
    var sum = 0;
    (0,esm/* each */.S6)(arr, function (value) {
        sum += value;
    });
    return sum / arr.length;
}
/**
 * Geometry Label \u57FA\u7C7B\uFF0C\u7528\u4E8E\u751F\u6210 Geometry \u4E0B\u6240\u6709 label \u7684\u914D\u7F6E\u9879\u4FE1\u606F
 */
var GeometryLabel = /** @class */ (function () {
    function GeometryLabel(geometry) {
        this.geometry = geometry;
    }
    GeometryLabel.prototype.getLabelItems = function (mapppingArray) {
        var _this = this;
        var items = [];
        var labelCfgs = this.getLabelCfgs(mapppingArray);
        // \u83B7\u53D6 label \u76F8\u5173\u7684 x\uFF0Cy \u7684\u503C\uFF0C\u83B7\u53D6\u5177\u4F53\u7684 x, y\uFF0C\u9632\u6B62\u5B58\u5728\u6570\u7EC4
        (0,esm/* each */.S6)(mapppingArray, function (mappingData, index) {
            var labelCfg = labelCfgs[index];
            if (!labelCfg || (0,esm/* isNil */.UM)(mappingData.x) || (0,esm/* isNil */.UM)(mappingData.y)) {
                items.push(null);
                return;
            }
            var labelContent = !(0,esm/* isArray */.kJ)(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
            labelCfg.content = labelContent;
            var total = labelContent.length;
            (0,esm/* each */.S6)(labelContent, function (content, subIndex) {
                if ((0,esm/* isNil */.UM)(content) || content === '') {
                    items.push(null);
                    return;
                }
                var item = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
                if (!item.textAlign) {
                    item.textAlign = _this.getLabelAlign(item, subIndex, total);
                }
                if (item.offset <= 0) {
                    item.labelLine = null;
                }
                items.push(item);
            });
        });
        return items;
    };
    GeometryLabel.prototype.render = function (mappingArray, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function () {
            var labelItems, labelsRenderer, shapes;
            return (0,tslib_es6/* __generator */.Jh)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        labelItems = this.getLabelItems(mappingArray);
                        labelsRenderer = this.getLabelsRenderer();
                        shapes = this.getGeometryShapes();
                        // \u6E32\u67D3\u6587\u672C
                        return [4 /*yield*/, labelsRenderer.render(labelItems, shapes, isUpdate)];
                    case 1:
                        // \u6E32\u67D3\u6587\u672C
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    GeometryLabel.prototype.clear = function () {
        var labelsRenderer = this.labelsRenderer;
        if (labelsRenderer) {
            labelsRenderer.clear();
        }
    };
    GeometryLabel.prototype.destroy = function () {
        var labelsRenderer = this.labelsRenderer;
        if (labelsRenderer) {
            labelsRenderer.destroy();
        }
        this.labelsRenderer = null;
    };
    // geometry \u66F4\u65B0\u4E4B\u540E\uFF0C\u5BF9\u5E94\u7684 Coordinate \u4E5F\u4F1A\u66F4\u65B0\uFF0C\u4E3A\u4E86\u83B7\u53D6\u5230\u6700\u65B0\u9C9C\u7684 Coordinate\uFF0C\u6545\u4F7F\u7528\u65B9\u6CD5\u83B7\u53D6
    GeometryLabel.prototype.getCoordinate = function () {
        return this.geometry.coordinate;
    };
    /**
     * \u83B7\u53D6 label \u7684\u9ED8\u8BA4\u914D\u7F6E
     */
    GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {
        var geometry = this.geometry;
        var type = geometry.type, theme = geometry.theme;
        if (type === 'polygon' ||
            (type === 'interval' && position === 'middle') ||
            (offset < 0 && !['line', 'point', 'path'].includes(type))) {
            // polygon \u6216\u8005 (interval \u4E14 middle) \u6216\u8005 offset \u5C0F\u4E8E 0 \u65F6\uFF0C\u6587\u672C\u5C55\u793A\u5728\u56FE\u5F62\u5185\u90E8\uFF0C\u5C06\u5176\u989C\u8272\u8BBE\u7F6E\u4E3A \u767D\u8272
            return (0,esm/* get */.U2)(theme, 'innerLabels', {});
        }
        return (0,esm/* get */.U2)(theme, 'labels', {});
    };
    /**
     * \u83B7\u53D6\u5F53\u524D label \u7684\u6700\u7EC8\u914D\u7F6E
     * @param labelCfg
     */
    GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {
        var geometry = this.geometry;
        var defaultLabelCfg = this.getDefaultLabelCfg();
        var type = geometry.type, theme = geometry.theme;
        var themedLabelCfg;
        if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {
            // polygon \u6216\u8005 offset \u5C0F\u4E8E 0 \u65F6\uFF0C\u6587\u672C\u5C55\u793A\u5728\u56FE\u5F62\u5185\u90E8\uFF0C\u5C06\u5176\u989C\u8272\u8BBE\u7F6E\u4E3A \u767D\u8272
            themedLabelCfg = (0,esm/* deepMix */.b$)({}, defaultLabelCfg, theme.innerLabels, labelCfg);
        }
        else {
            themedLabelCfg = (0,esm/* deepMix */.b$)({}, defaultLabelCfg, theme.labels, labelCfg);
        }
        return themedLabelCfg;
    };
    /**
     * \u8BBE\u7F6E label \u4F4D\u7F6E
     * @param labelPointCfg
     * @param mappingData
     * @param index
     * @param position
     */
    GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) { };
    /**
     * @desc \u83B7\u53D6 label offset
     */
    GeometryLabel.prototype.getLabelOffset = function (offset) {
        var coordinate = this.getCoordinate();
        var vector = this.getOffsetVector(offset);
        return coordinate.isTransposed ? vector[0] : vector[1];
    };
    /**
     * \u83B7\u53D6\u6BCF\u4E2A label \u7684\u504F\u79FB\u91CF (\u77E2\u91CF)
     * @param labelCfg
     * @param index
     * @param total
     * @return {Point} offsetPoint
     */
    GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {
        var offset = labelCfg.offset;
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var dim = transposed ? 'x' : 'y';
        var factor = transposed ? 1 : -1; // y \u65B9\u5411\u4E0A\u8D8A\u5927\uFF0C\u50CF\u7D20\u7684\u5750\u6807\u8D8A\u5C0F\uFF0C\u6240\u4EE5transposed\u65F6\u5C06\u7CFB\u6570\u53D8\u6210
        var offsetPoint = {
            x: 0,
            y: 0,
        };
        if (index > 0 || total === 1) {
            // \u5224\u65AD\u662F\u5426\u5C0F\u4E8E0
            offsetPoint[dim] = offset * factor;
        }
        else {
            offsetPoint[dim] = offset * factor * -1;
        }
        return offsetPoint;
    };
    /**
     * \u83B7\u53D6\u6BCF\u4E2A label \u7684\u4F4D\u7F6E
     * @param labelCfg
     * @param mappingData
     * @param index
     * @returns label point
     */
    GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
        var coordinate = this.getCoordinate();
        var total = labelCfg.content.length;
        function getDimValue(value, idx, isAvg) {
            if (isAvg === void 0) { isAvg = false; }
            var v = value;
            if ((0,esm/* isArray */.kJ)(v)) {
                if (labelCfg.content.length === 1) {
                    if (isAvg) {
                        v = avg(v);
                    }
                    else {
                        // \u5982\u679C\u4EC5\u4E00\u4E2A label\uFF0C\u591A\u4E2A y, \u53D6\u6700\u540E\u4E00\u4E2A y
                        if (v.length <= 2) {
                            v = v[value.length - 1];
                        }
                        else {
                            v = avg(v);
                        }
                    }
                }
                else {
                    v = v[idx];
                }
            }
            return v;
        }
        var label = {
            content: labelCfg.content[index],
            x: 0,
            y: 0,
            start: { x: 0, y: 0 },
            color: '#fff',
        };
        var shape = (0,esm/* isArray */.kJ)(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
        var isFunnel = shape === 'funnel' || shape === 'pyramid';
        // \u591A\u8FB9\u5F62\u573A\u666F\uFF0C\u591A\u7528\u4E8E\u5730\u56FE
        if (this.geometry.type === 'polygon') {
            var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
            label.x = centroid[0];
            label.y = centroid[1];
        }
        else if (this.geometry.type === 'interval' && !isFunnel) {
            // \u5BF9\u76F4\u65B9\u56FE\u7684label X \u65B9\u5411\u7684\u4F4D\u7F6E\u5C45\u4E2D
            label.x = getDimValue(mappingData.x, index, true);
            label.y = getDimValue(mappingData.y, index);
        }
        else {
            label.x = getDimValue(mappingData.x, index);
            label.y = getDimValue(mappingData.y, index);
        }
        // \u5904\u7406\u6F0F\u6597\u56FE\u6587\u672C\u4F4D\u7F6E
        if (isFunnel) {
            var nextPoints = (0,esm/* get */.U2)(mappingData, 'nextPoints');
            var points = (0,esm/* get */.U2)(mappingData, 'points');
            if (nextPoints) {
                // \u975E\u6F0F\u6597\u56FE\u5E95\u90E8
                var point1 = coordinate.convert(points[1]);
                var point2 = coordinate.convert(nextPoints[1]);
                label.x = (point1.x + point2.x) / 2;
                label.y = (point1.y + point2.y) / 2;
            }
            else if (shape === 'pyramid') {
                var point1 = coordinate.convert(points[1]);
                var point2 = coordinate.convert(points[2]);
                label.x = (point1.x + point2.x) / 2;
                label.y = (point1.y + point2.y) / 2;
            }
        }
        if (labelCfg.position) {
            // \u5982\u679C label \u652F\u6301 position \u5C5E\u6027
            this.setLabelPosition(label, mappingData, index, labelCfg.position);
        }
        var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
        label.start = { x: label.x, y: label.y };
        label.x += offsetPoint.x;
        label.y += offsetPoint.y;
        label.color = mappingData.color;
        return label;
    };
    /**
     * \u83B7\u53D6\u6587\u672C\u7684\u5BF9\u9F50\u65B9\u5F0F
     * @param item
     * @param index
     * @param total
     * @returns
     */
    GeometryLabel.prototype.getLabelAlign = function (item, index, total) {
        var align = 'center';
        var coordinate = this.getCoordinate();
        if (coordinate.isTransposed) {
            var offset = item.offset;
            if (offset < 0) {
                align = 'right';
            }
            else if (offset === 0) {
                align = 'center';
            }
            else {
                align = 'left';
            }
            if (total > 1 && index === 0) {
                if (align === 'right') {
                    align = 'left';
                }
                else if (align === 'left') {
                    align = 'right';
                }
            }
        }
        return align;
    };
    /**
     * \u83B7\u53D6\u6BCF\u4E00\u4E2A label \u7684\u552F\u4E00 id
     * @param mappingData label \u5BF9\u5E94\u7684\u56FE\u5F62\u7684\u7ED8\u5236\u6570\u636E
     */
    GeometryLabel.prototype.getLabelId = function (mappingData) {
        var geometry = this.geometry;
        var type = geometry.type;
        var xScale = geometry.getXScale();
        var yScale = geometry.getYScale();
        var origin = mappingData[FIELD_ORIGIN]; // \u539F\u59CB\u6570\u636E
        var labelId = geometry.getElementId(mappingData);
        if (type === 'line' || type === 'area') {
            // \u6298\u7EBF\u56FE\u4EE5\u53CA\u533A\u57DF\u56FE\uFF0C\u4E00\u6761\u7EBF\u4F1A\u5BF9\u5E94\u4E00\u7EC4\u6570\u636E\uFF0C\u5373\u591A\u4E2A labels\uFF0C\u4E3A\u4E86\u533A\u5206\u8FD9\u4E9B labels\uFF0C\u9700\u8981\u5728 line id \u7684\u524D\u63D0\u4E0B\u52A0\u4E0A x \u5B57\u6BB5\u503C
            labelId += " ".concat(origin[xScale.field]);
        }
        else if (type === 'path') {
            // path \u8DEF\u5F84\u56FE\uFF0C\u65E0\u5E8F\uFF0C\u6709\u53EF\u80FD\u5B58\u5728\u76F8\u540C x \u4E0D\u540C y \u7684\u60C5\u51B5\uFF0C\u9700\u8981\u901A\u8FC7 x y \u6765\u786E\u5B9A\u552F\u4E00 id
            labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
        }
        return labelId;
    };
    // \u83B7\u53D6 labels \u7EC4\u4EF6
    GeometryLabel.prototype.getLabelsRenderer = function () {
        var _a = this.geometry, labelsContainer = _a.labelsContainer, labelOption = _a.labelOption, canvasRegion = _a.canvasRegion, animateOption = _a.animateOption;
        var coordinate = this.geometry.coordinate;
        var labelsRenderer = this.labelsRenderer;
        if (!labelsRenderer) {
            labelsRenderer = new labels({
                container: labelsContainer,
                layout: (0,esm/* get */.U2)(labelOption, ['cfg', 'layout'], {
                    type: this.defaultLayout,
                }),
            });
            this.labelsRenderer = labelsRenderer;
        }
        labelsRenderer.region = canvasRegion;
        // \u8BBE\u7F6E\u52A8\u753B\u914D\u7F6E\uFF0C\u5982\u679C geometry \u7684\u52A8\u753B\u5173\u95ED\u4E86\uFF0C\u90A3\u4E48 label \u7684\u52A8\u753B\u4E5F\u4F1A\u5173\u95ED
        labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;
        return labelsRenderer;
    };
    GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {
        var _this = this;
        var geometry = this.geometry;
        var labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;
        var _a = labelOption, fields = _a.fields, callback = _a.callback, cfg = _a.cfg;
        var labelScales = fields.map(function (field) {
            return scales[field];
        });
        var labelCfgs = [];
        (0,esm/* each */.S6)(mapppingArray, function (mappingData, index) {
            var origin = mappingData[FIELD_ORIGIN]; // \u539F\u59CB\u6570\u636E
            var originText = _this.getLabelText(origin, labelScales);
            var callbackCfg;
            if (callback) {
                // \u5F53\u540C\u65F6\u914D\u7F6E\u4E86 callback \u548C cfg \u65F6\uFF0C\u4EE5 callback \u4E3A\u51C6
                var originValues = fields.map(function (field) { return origin[field]; });
                callbackCfg = callback.apply(void 0, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(originValues), false));
                if ((0,esm/* isNil */.UM)(callbackCfg)) {
                    labelCfgs.push(null);
                    return;
                }
            }
            var labelCfg = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ id: _this.getLabelId(mappingData), elementId: _this.geometry.getElementId(mappingData), data: origin, // \u5B58\u50A8\u539F\u59CB\u6570\u636E
                mappingData: mappingData, // \u5B58\u50A8\u6620\u5C04\u540E\u7684\u6570\u636E,
                coordinate: coordinate }, cfg), callbackCfg);
            if ((0,esm/* isFunction */.mf)(labelCfg.position)) {
                labelCfg.position = labelCfg.position(origin, mappingData, index);
            }
            var offset = _this.getLabelOffset(labelCfg.offset || 0);
            // defaultCfg \u9700\u8981\u5224\u65AD innerLabels & labels
            var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
            // labelCfg priority: defaultCfg < cfg < callbackCfg
            labelCfg = (0,esm/* deepMix */.b$)({}, defaultLabelCfg, labelCfg);
            // \u83B7\u53D6\u6700\u7EC8\u7684 offset
            labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
            var content = labelCfg.content;
            if ((0,esm/* isFunction */.mf)(content)) {
                labelCfg.content = content(origin, mappingData, index);
            }
            else if ((0,esm/* isUndefined */.o8)(content)) {
                // \u7528\u6237\u672A\u914D\u7F6E content\uFF0C\u5219\u9ED8\u8BA4\u4E3A\u6620\u5C04\u7684\u7B2C\u4E00\u4E2A\u5B57\u6BB5\u7684\u503C
                labelCfg.content = originText[0];
            }
            labelCfgs.push(labelCfg);
        });
        return labelCfgs;
    };
    GeometryLabel.prototype.getLabelText = function (origin, scales) {
        var labelTexts = [];
        (0,esm/* each */.S6)(scales, function (scale) {
            var value = origin[scale.field];
            if ((0,esm/* isArray */.kJ)(value)) {
                value = value.map(function (subVal) {
                    return scale.getText(subVal);
                });
            }
            else {
                value = scale.getText(value);
            }
            if ((0,esm/* isNil */.UM)(value) || value === '') {
                labelTexts.push(null);
            }
            else {
                labelTexts.push(value);
            }
        });
        return labelTexts;
    };
    GeometryLabel.prototype.getOffsetVector = function (offset) {
        if (offset === void 0) { offset = 0; }
        var coordinate = this.getCoordinate();
        var actualOffset = 0;
        if ((0,esm/* isNumber */.hj)(offset)) {
            actualOffset = offset;
        }
        // \u5982\u679C x,y \u7FFB\u8F6C\uFF0C\u5219\u504F\u79FB x\uFF0C\u5426\u5219\u504F\u79FB y
        return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
    };
    GeometryLabel.prototype.getGeometryShapes = function () {
        var geometry = this.geometry;
        var shapes = {};
        (0,esm/* each */.S6)(geometry.elementsMap, function (element, id) {
            shapes[id] = element.shape;
        });
        // \u56E0\u4E3A\u6709\u53EF\u80FD shape \u8FD8\u5728\u8FDB\u884C\u52A8\u753B\uFF0C\u5BFC\u81F4 shape.getBBox() \u83B7\u53D6\u5230\u7684\u503C\u4E0D\u662F\u6700\u7EC8\u6001\uFF0C\u6240\u4EE5\u9700\u8981\u4ECE offscreenGroup \u83B7\u53D6
        (0,esm/* each */.S6)(geometry.getOffscreenGroup().getChildren(), function (child) {
            var id = geometry.getElementId(child.get('origin').mappingData);
            shapes[id] = child;
        });
        return shapes;
    };
    return GeometryLabel;
}());
/* harmony default export */ var label_base = (GeometryLabel);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/attr.js

/**
 * @ignore
 * get the mapping value by attribute, if mapping value is nil, return def
 * @param attr
 * @param value
 * @param def
 * @returns get mapping value
 */
function getMappingValue(attr, value, def) {
    if (!attr) {
        return def;
    }
    var r;
    // \u591A\u53C2\u6570\u6620\u5C04\uFF0C\u963B\u6B62\u7A0B\u5E8F\u62A5\u9519
    if (attr.callback && attr.callback.length > 1) {
        var restArgs = Array(attr.callback.length - 1).fill('');
        r = attr.mapping.apply(attr, (0,tslib_es6/* __spreadArray */.ev)([value], (0,tslib_es6/* __read */.CR)(restArgs), false)).join('');
    }
    else {
        r = attr.mapping(value).join('');
    }
    return r || def;
}
//# sourceMappingURL=attr.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/marker.js
/** @ignore */
var MarkerSymbols = {
    hexagon: function (x, y, r) {
        var diffX = (r / 2) * Math.sqrt(3);
        return [
            ['M', x, y - r],
            ['L', x + diffX, y - r / 2],
            ['L', x + diffX, y + r / 2],
            ['L', x, y + r],
            ['L', x - diffX, y + r / 2],
            ['L', x - diffX, y - r / 2],
            ['Z'],
        ];
    },
    bowtie: function (x, y, r) {
        var diffY = r - 1.5;
        return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];
    },
    cross: function (x, y, r) {
        return [
            ['M', x - r, y - r],
            ['L', x + r, y + r],
            ['M', x + r, y - r],
            ['L', x - r, y + r],
        ];
    },
    tick: function (x, y, r) {
        return [
            ['M', x - r / 2, y - r],
            ['L', x + r / 2, y - r],
            ['M', x, y - r],
            ['L', x, y + r],
            ['M', x - r / 2, y + r],
            ['L', x + r / 2, y + r],
        ];
    },
    plus: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['L', x + r, y],
            ['M', x, y - r],
            ['L', x, y + r],
        ];
    },
    hyphen: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['L', x + r, y],
        ];
    },
    line: function (x, y, r) {
        return [
            ['M', x, y - r],
            ['L', x, y + r],
        ];
    },
};
//# sourceMappingURL=marker.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/legend.js






/** \u7EBF\u6761\u5F62 marker symbol */
var STROKES_SYMBOLS = ['line', 'cross', 'tick', 'plus', 'hyphen'];
/**
 * \u5904\u7406\u7528\u6237\u914D\u7F6E\u7684 marker style
 * @param markerStyle
 * @param userMarker.style
 * @returns {ShapeAttrs} newStyle
 */
function handleUserMarkerStyle(markerStyle, style) {
    if ((0,esm/* isFunction */.mf)(style)) {
        return style(markerStyle);
    }
    return (0,esm/* deepMix */.b$)({}, markerStyle, style);
}
/**
 * \u6839\u636E marker \u662F\u5426\u4E3A\u7EBF\u6761\u5F62 symbol, \u6765\u8C03\u6574\u4E0B\u6837\u5F0F
 * @param symbol
 * @param style
 * @param color
 */
function adpatorMarkerStyle(marker, color) {
    var symbol = marker.symbol;
    if ((0,esm/* isString */.HD)(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
        var markerStyle = (0,esm/* get */.U2)(marker, 'style', {});
        var lineWidth = (0,esm/* get */.U2)(markerStyle, 'lineWidth', 1);
        var stroke = markerStyle.stroke || markerStyle.fill || color;
        marker.style = (0,esm/* deepMix */.b$)({}, marker.style, { lineWidth: lineWidth, stroke: stroke, fill: null });
    }
}
/**
 * \u8BBE\u7F6E marker \u7684 symbol\uFF0C\u5C06 \u5B57\u7B26\u4E32\u7684 symbol \u8F6C\u6362\u4E3A\u771F\u6B63\u7684\u7ED8\u5236\u547D\u4EE4
 * @param marker
 */
function setMarkerSymbol(marker) {
    var symbol = marker.symbol;
    if ((0,esm/* isString */.HD)(symbol) && MarkerSymbols[symbol]) {
        marker.symbol = MarkerSymbols[symbol];
    }
}
/**
 * @ignore
 * get the legend layout from direction
 * @param direction
 * @returns layout 'horizontal' | 'vertical'
 */
function getLegendLayout(direction) {
    return direction.startsWith(constant_DIRECTION.LEFT) || direction.startsWith(constant_DIRECTION.RIGHT) ? 'vertical' : 'horizontal';
}
/**
 * @ignore
 * get the legend items
 * @param view
 * @param geometry
 * @param attr
 * @param themeMarker
 * @param markerCfg
 * @returns legend items
 */
function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
    var scale = attr.getScale(attr.type);
    if (scale.isCategory) {
        var field_1 = scale.field;
        var colorAttr_1 = geometry.getAttribute('color');
        var shapeAttr_1 = geometry.getAttribute('shape');
        var defaultColor_1 = view.getTheme().defaultColor;
        var isInPolar_1 = geometry.coordinate.isPolar;
        return scale.getTicks().map(function (tick, index) {
            var _a;
            var text = tick.text, scaleValue = tick.value;
            var name = text;
            var value = scale.invert(scaleValue);
            // \u901A\u8FC7\u8FC7\u6EE4\u56FE\u4F8B\u9879\u7684\u6570\u636E\uFF0C\u6765\u770B\u662F\u5426 unchecked
            var unchecked = view.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length === 0;
            (0,esm/* each */.S6)(view.views, function (subView) {
                var _a;
                if (!subView.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length) {
                    unchecked = true;
                }
            });
            // @ts-ignore
            var color = getMappingValue(colorAttr_1, value, defaultColor_1);
            var shape = getMappingValue(shapeAttr_1, value, 'point');
            var marker = geometry.getShapeMarker(shape, {
                color: color,
                isInPolar: isInPolar_1,
            });
            var markerCfg = userMarker;
            if ((0,esm/* isFunction */.mf)(markerCfg)) {
                markerCfg = markerCfg(name, index, (0,tslib_es6/* __assign */.pi)({ name: name, value: value }, (0,esm/* deepMix */.b$)({}, themeMarker, marker)));
            }
            // the marker configure order should be ensure
            marker = (0,esm/* deepMix */.b$)({}, themeMarker, marker, omit((0,tslib_es6/* __assign */.pi)({}, markerCfg), ['style']));
            adpatorMarkerStyle(marker, color);
            if (markerCfg && markerCfg.style) {
                // handle user's style settings
                marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
            }
            setMarkerSymbol(marker);
            return { id: value, name: name, value: value, marker: marker, unchecked: unchecked };
        });
    }
    return [];
}
/**
 *
 * @ignore
 * custom legend \u7684 items \u83B7\u53D6
 * @param themeMarker
 * @param userMarker
 * @param customItems
 */
function getCustomLegendItems(themeMarker, userMarker, customItems) {
    // \u5982\u679C\u6709\u81EA\u5B9A\u4E49\u7684 item\uFF0C\u90A3\u4E48\u5C31\u76F4\u63A5\u4F7F\u7528\uFF0C\u5E76\u5408\u5E76\u4E3B\u9898\u7684 marker \u914D\u7F6E
    return customItems.map(function (item, index) {
        var markerCfg = userMarker;
        if ((0,esm/* isFunction */.mf)(markerCfg)) {
            markerCfg = markerCfg(item.name, index, (0,esm/* deepMix */.b$)({}, themeMarker, item));
        }
        var itemMarker = (0,esm/* isFunction */.mf)(item.marker)
            ? item.marker(item.name, index, (0,esm/* deepMix */.b$)({}, themeMarker, item))
            : item.marker;
        var marker = (0,esm/* deepMix */.b$)({}, themeMarker, markerCfg, itemMarker);
        setMarkerSymbol(marker);
        item.marker = marker;
        return item;
    });
}
/**
 * get the legend cfg from theme, will mix the common cfg of legend theme
 *
 * @param theme view theme object
 * @param direction legend direction
 * @returns legend theme cfg
 */
function getLegendThemeCfg(theme, direction) {
    var legendTheme = (0,esm/* get */.U2)(theme, ['components', 'legend'], {});
    return (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(legendTheme, ['common'], {}), (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(legendTheme, [direction], {})));
}
//# sourceMappingURL=legend.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js


function isValueEmpty(value) {
    if (value) {
        return false;
    }
    return value === null || value === undefined || isNaN(value);
}
function isYNil(point) {
    if ((0,esm/* isArray */.kJ)(point)) {
        // \u7279\u6B8A\u5904\u7406 area \u7684\u5173\u952E\u70B9\u6570\u636E\uFF0C\u5176\u5173\u952E\u70B9\u7ED3\u6784\u4E3A [{x: 0, y: 1}, {x: 0, y: 2}]
        return isValueEmpty(point[1].y);
    }
    var value = point.y;
    return (0,esm/* isArray */.kJ)(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
}
/**
 * @ignore
 * \u5206\u5272\u6570\u636E\uFF0C\u7528\u4E8E\u5904\u7406\u5728\u4E00\u7EC4\u70B9\u6570\u636E\u4E2D\uFF0Cy \u5BF9\u5E94\u7684\u6570\u503C\u5B58\u5728 null/undefined/NaN \u7684\u60C5\u51B5
 * \u5E94\u7528\u4E8E\u6298\u7EBF\u56FE\u3001\u533A\u57DF\u56FE\u4EE5\u53CA\u8DEF\u5F84\u56FE
 *
 * \`\`\`typescript
 * // return [[{x: 1, y: 2}, {x: 3, y: 3}]]
 * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);
 * // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]
 * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);
 * // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]
 * getPathPoints([
 *   [{ x: 1, y: 10 }, { x: 2, y: 2 }],
 *   [{ x: 4, y: 2 }, { x: 8, y: NaN }],
 *   [{ x: 9, y: 34 }, { x: 1, y: 1 }],
 * ], true);
 * \`\`\`
 *
 * @param points \u8981\u8FDB\u884C\u5904\u7406\u70B9\u96C6\u5408
 * @param connectNulls \u662F\u5426\u8FDE\u63A5\u7A7A\u503C\u6570\u636E
 * @param showSinglePoint \u662F\u5426\u5C55\u793A\u5B64\u7ACB\u70B9
 * @returns \u8FD4\u56DE\u5904\u7406\u540E\u7684\u70B9\u96C6\u5408
 */
function getPathPoints(points, connectNulls, showSinglePoint) {
    if (connectNulls === void 0) { connectNulls = false; }
    if (showSinglePoint === void 0) { showSinglePoint = true; }
    if (!points.length || (points.length === 1 && !showSinglePoint)) {
        // \u7A7A\u6216\u8005\u53EA\u6709\u4E00\u4E2A\u70B9\u5E76\u914D\u7F6E\u4E0D\u5C55\u793A\u65F6
        return [];
    }
    if (connectNulls) {
        // \u5373 y \u503C\u4E3A\u7A7A\u7684\u573A\u666F
        var filtered = [];
        for (var i = 0, len = points.length; i < len; i++) {
            var point = points[i];
            if (!isYNil(point)) {
                filtered.push(point);
            }
        }
        return [filtered];
    }
    var result = [];
    var tmp = [];
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isYNil(point)) {
            if (tmp.length) {
                if (!(tmp.length === 1 && !showSinglePoint)) {
                    // \u5982\u679C\u524D\u6BB5\u6570\u636E\u53EA\u6709\u4E00\u4E2A\u5B57\u6BB5\u5E76\u4E14\u4E0D\u9700\u8981\u5C55\u793A\u65F6\u5219\u4E0D\u52A0\u5165
                    result.push(tmp);
                }
                tmp = [];
            }
        }
        else {
            tmp.push(point);
        }
    }
    if (tmp.length) {
        result.push(tmp);
    }
    return result;
}
/**
 * \u83B7\u53D6\u5C0F\u63D0\u7434\u56FE\u7684\u8FB9\u754C path
 * @param points
 * @returns
 */
function getViolinPath(points) {
    var path = [];
    for (var i = 0; i < points.length; i++) {
        var point = points[i];
        if (point) {
            var action = i === 0 ? 'M' : 'L';
            path.push([action, point.x, point.y]);
        }
    }
    var first = points[0];
    if (first) {
        path.push(['L', first.x, first.y]);
        path.push(['z']);
    }
    return path;
}
/**
 * \u83B7\u53D6\u5C0F\u63D0\u7434\u56FE \u5E73\u6ED1\u7684\u8FB9\u754C path
 * @param points
 * @returns
 */
function getSmoothViolinPath(points) {
    var half = points.length / 2;
    var leftPoints = [];
    var rightPoints = [];
    for (var i = 0; i < points.length; i++) {
        if (i < half) {
            leftPoints.push(points[i]);
        }
        else {
            rightPoints.push(points[i]);
        }
    }
    var leftPath = getSplinePath(leftPoints, false);
    var rightPath = getSplinePath(rightPoints, false);
    if (rightPoints.length) {
        leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);
    }
    rightPath.shift();
    var path = leftPath.concat(rightPath);
    if (leftPoints.length) {
        path.push(['L', leftPoints[0].x, leftPoints[0].y]);
    }
    path.push(['z']);
    return path;
}
//# sourceMappingURL=get-path-points.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/util/get-style.js


/**
 * @ignore
 * \u83B7\u53D6 Shape \u7684\u56FE\u5F62\u5C5E\u6027
 * @param cfg
 * @param isStroke \u662F\u5426\u9700\u8981\u63CF\u8FB9
 * @param isFill \u662F\u5426\u9700\u8981\u586B\u5145
 * @param [sizeName] \u53EF\u9009\uFF0C\u8868\u793A\u56FE\u5F62\u5927\u5C0F\u7684\u5C5E\u6027\uFF0ClineWidth \u6216\u8005 r
 * @returns
 */
function get_style_getStyle(cfg, isStroke, isFill, sizeName) {
    if (sizeName === void 0) { sizeName = ''; }
    var _a = cfg.style, style = _a === void 0 ? {} : _a, defaultStyle = cfg.defaultStyle, color = cfg.color, size = cfg.size;
    var attrs = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, defaultStyle), style);
    if (color) {
        if (isStroke) {
            if (!style.stroke) {
                // \u5982\u679C\u7528\u6237\u5728 style() \u4E2D\u914D\u7F6E\u4E86 stroke\uFF0C\u5219\u4EE5\u7528\u6237\u914D\u7F6E\u7684\u4E3A\u51C6
                attrs.stroke = color;
            }
        }
        if (isFill) {
            if (!style.fill) {
                // \u5982\u679C\u7528\u6237\u5728 style() \u4E2D\u914D\u7F6E\u4E86 fill
                attrs.fill = color;
            }
        }
    }
    if (sizeName && (0,esm/* isNil */.UM)(style[sizeName]) && !(0,esm/* isNil */.UM)(size)) {
        // \u5982\u679C\u7528\u6237\u5728 style() \u4E2D\u914D\u7F6E\u4E86 lineWidth \u6216\u8005 r \u5C5E\u6027
        attrs[sizeName] = size;
    }
    return attrs;
}
/**
 * \u83B7\u53D6 \u77E9\u5F62\u80CC\u666F \u7684\u6837\u5F0F
 * @param cfg
 */
function getBackgroundRectStyle(cfg) {
    return (0,esm/* deepMix */.b$)({}, {
        // \u9ED8\u8BA4\u80CC\u666F\u8272\uFF0Ccopy from active-region
        fill: '#CCD6EC',
        fillOpacity: 0.3,
    }, (0,esm/* get */.U2)(cfg, ['background', 'style']));
}
//# sourceMappingURL=get-style.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/util/split-points.js

/**
 * @ignore
 * \u62C6\u5206\u70B9\u6570\u636E
 * @example
 * // result: [{x: 20, y: 20}, {x: 20, y: 30}]
 * splitPoints({x: 20,y: [20, 30]});
 * @example
 * // result: [{x: 20, y: 20}, {x: 30, y: 30}]
 * splitPoints({x: [20, 30],y: [20, 30]});
 * @param obj
 */
function splitPoints(obj) {
    // y \u6709\u53EF\u80FD\u662F\u6570\u7EC4\uFF0C\u5BF9\u5E94\u539F\u59CB\u6570\u636E\u4E2D y \u4E3A\u4E00\u4E2A\u533A\u95F4\u6570\u636E\uFF0C\u5982 [19, 30]\uFF0C\u4E3A\u4E86\u7EDF\u4E00\u4E5F\u5C06 x \u8F6C\u6362\u4E3A\u6570\u7EC4
    var x = obj.x;
    var y = (0,esm/* isArray */.kJ)(obj.y) ? obj.y : [obj.y];
    return y.map(function (eachY, index) {
        return {
            x: (0,esm/* isArray */.kJ)(x) ? x[index] : x,
            y: eachY,
        };
    });
}
//# sourceMappingURL=split-points.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/line/util.js
var LineSymbols = {
    line: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['L', x + r, y],
        ];
    },
    dot: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['L', x + r, y],
        ];
    },
    dash: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['L', x + r, y],
        ];
    },
    smooth: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['A', r / 2, r / 2, 0, 1, 1, x, y],
            ['A', r / 2, r / 2, 0, 1, 0, x + r, y],
        ];
    },
    hv: function (x, y, r) {
        return [
            ['M', x - r - 1, y - 2.5],
            ['L', x, y - 2.5],
            ['L', x, y + 2.5],
            ['L', x + r + 1, y + 2.5],
        ];
    },
    vh: function (x, y, r) {
        return [
            ['M', x - r - 1, y + 2.5],
            ['L', x, y + 2.5],
            ['L', x, y - 2.5],
            ['L', x + r + 1, y - 2.5],
        ];
    },
    hvh: function (x, y, r) {
        return [
            ['M', x - (r + 1), y + 2.5],
            ['L', x - r / 2, y + 2.5],
            ['L', x - r / 2, y - 2.5],
            ['L', x + r / 2, y - 2.5],
            ['L', x + r / 2, y + 2.5],
            ['L', x + r + 1, y + 2.5],
        ];
    },
    vhv: function (x, y) {
        // \u5BBD 13px\uFF0C\u9AD8 8px
        return [
            ['M', x - 5, y + 2.5],
            ['L', x - 5, y],
            ['L', x, y],
            ['L', x, y - 3],
            ['L', x, y + 3],
            ['L', x + 6.5, y + 3],
        ];
    },
};
/**
 * Gets line marker
 * @ignore
 * @param markerCfg
 * @param shapeType
 * @returns \u8FD4\u56DE Line \u7684 marker \u914D\u7F6E
 */
function getLineMarker(markerCfg, shapeType) {
    var color = markerCfg.color;
    return {
        symbol: LineSymbols[shapeType],
        style: {
            lineWidth: 2,
            r: 6,
            stroke: color,
        },
    };
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/line/index.js







function getShapeAttrs(cfg, smooth, constraint) {
    var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
    var shapeAttrs = get_style_getStyle(cfg, true, false, 'lineWidth');
    var points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // \u6839\u636E connectNulls \u503C\u5904\u7406 points
    var path = [];
    for (var i = 0, len = points.length; i < len; i++) {
        var eachLinePoints = points[i];
        path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
    }
    shapeAttrs.path = path;
    return shapeAttrs;
}
// \u5355\u6761 path
function getSinglePath(points, isInCircle, smooth, constraint, style) {
    if (points.length === 1) {
        // \u53EA\u6709\u4E00\u4E2A\u70B9\u65F6
        return [
            ['M', points[0].x, points[0].y - style.lineWidth / 2],
            ['L', points[0].x, points[0].y],
            ['L', points[0].x, points[0].y + style.lineWidth / 2],
        ];
    }
    var path;
    if (!smooth) {
        path = path_getLinePath(points, false);
        if (isInCircle) {
            path.push(['Z']);
        }
    }
    else {
        // \u76F4\u89D2\u5750\u6807\u7CFB\u4E0B\u7ED8\u5236\u66F2\u7EBF\u65F6\u9650\u5236\u6700\u5927\u503C\u3001\u6700\u5C0F\u503C
        if (isInCircle && points.length) {
            points.push({ x: points[0].x, y: points[0].y });
        }
        path = getSplinePath(points, false, constraint);
    }
    return path;
}
function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
    var topPoints = [];
    var bottomPoints = [];
    (0,esm/* each */.S6)(points, function (point) {
        var result = splitPoints(point);
        topPoints.push(result[1]); // \u4E0A\u8FB9
        bottomPoints.push(result[0]); // \u5E95\u8FB9
    });
    var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
    var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
    if (isStack) {
        return topPath;
    }
    return topPath.concat(bottomPath);
}
/**
 * \u83B7\u53D6\u6298\u7EBF\u56FE path
 */
function getPath(points, isInCircle, isStack, smooth, constraint, style) {
    if (points.length) {
        var first = points[0];
        return (0,esm/* isArray */.kJ)(first.y)
            ? getRangePath(points, isInCircle, isStack, smooth, constraint, style)
            : getSinglePath(points, isInCircle, smooth, constraint, style);
    }
    return [];
}
var LineShapeFactory = registerShapeFactory('line', {
    defaultShapeType: 'line',
});
// \u8FD9\u91CC\u56E0\u4E3A\u4EE3\u7801\u516C\u7528\uFF0C\u6240\u4EE5\u76F4\u63A5\u5168\u90E8\u6CE8\u518C
// 'line' \u9ED8\u8BA4\u6298\u7EBF\uFF1B'dot' \u70B9\u7EBF \xB7\xB7\xB7\uFF1B'dash' \u65AD\u7EBF - - -
(0,esm/* each */.S6)(['line', 'dot', 'dash', 'smooth'], function (shapeType) {
    registerShape('line', shapeType, {
        draw: function (cfg, container) {
            var smooth = shapeType === 'smooth';
            var constraint;
            if (smooth) {
                var _a = this.coordinate, start = _a.start, end = _a.end;
                constraint = [
                    [start.x, end.y],
                    [end.x, start.y],
                ];
            }
            var attrs = getShapeAttrs(cfg, smooth, constraint);
            var shape = container.addShape({
                type: 'path',
                attrs: attrs,
                name: 'line',
                capture: !smooth,
            });
            return shape;
        },
        getMarker: function (markerCfg) {
            return getLineMarker(markerCfg, shapeType);
        },
    });
});
/* harmony default export */ var shape_line = ((/* unused pure expression or super */ null && (LineShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/core.js
/* G2 \u7684\u4E00\u4E2A\u58F3\u5B50\uFF0C\u4E0D\u5305\u542B Geometry\uFF0C\u7531\u5F00\u53D1\u8005\u81EA\u5DF1\u5B9A\u4E49\u548C\u5F15\u5165 */
var VERSION = '4.2.10';
// \u6838\u5FC3\u57FA\u7C7B\u5BFC\u51FA
 // Chart, View \u7C7B
 // G2 \u7EC4\u4EF6\u57FA\u7C7B
 // G2 tooltip \u7EC4\u4EF6\u57FA\u7C7B
 // Geometry \u57FA\u7C7B
 // Element \u7C7B
 // Geometry Label \u57FA\u7C7B
 // Interaction, Action \u57FA\u7C7B
 // Facet \u57FA\u7C7B
 // Interaction Action \u57FA\u7C7B
// \u6CE8\u518C ComponentController

// \u6CE8\u518C Geometry

// \u6CE8\u518C Geometry Shape

// \u6CE8\u518C Geometry label \u4EE5\u53CA Geometry Label \u5E03\u5C40\u51FD\u6570

// \u6CE8\u518C interaction

// \u6CE8\u518C facet

// \u6CE8\u518C\u4E3B\u9898

// G engine \u7BA1\u7406\u76F8\u5173

// \u6CE8\u518C\u52A8\u753B\u51FD\u6570


// \u56E0\u4E3A typescript \u90E8\u5206\u7248\u672C\u4E0D\u652F\u6301 export * as \u8BED\u6CD5\u3002


// \u4E00\u4E9B\u5DE5\u5177\u65B9\u6CD5\u5BFC\u51FA








var Util = {
    getLegendItems: getLegendItems,
    translate: translate,
    rotate: rotate,
    zoom: zoom,
    transform: transform,
    getAngle: getAngle,
    getSectorPath: getSectorPath,
    polarToCartesian: polarToCartesian,
    getDelegationObject: getDelegationObject,
    getTooltipItems: getTooltipItems,
    getMappingValue: getMappingValue,
    // shape \u7684\u4E00\u4E9B\u64CD\u4F5C\u65B9\u6CD5
    getPath: getPath,
    getPathPoints: getPathPoints,
};
//# sourceMappingURL=core.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/theme/style-sheet/dark.js

var dark_WHITE_COLORS = {
    100: '#000',
    95: '#0D0D0D',
    85: '#262626',
    65: '#595959',
    45: '#8C8C8C',
    25: '#BFBFBF',
    15: '#D9D9D9',
    6: '#F0F0F0',
};
var dark_BLACK_COLORS = {
    100: '#FFFFFF',
    95: '#F2F2F2',
    85: '#D9D9D9',
    65: '#A6A6A6',
    45: '#737373',
    25: '#404040',
    15: '#262626',
    6: '#0F0F0F',
};
var dark_QUALITATIVE_10 = [
    '#5B8FF9',
    '#5AD8A6',
    '#5D7092',
    '#F6BD16',
    '#E86452',
    '#6DC8EC',
    '#945FB9',
    '#FF9845',
    '#1E9493',
    '#FF99C3',
];
var dark_QUALITATIVE_20 = [
    '#5B8FF9',
    '#CDDDFD',
    '#5AD8A6',
    '#CDF3E4',
    '#5D7092',
    '#CED4DE',
    '#F6BD16',
    '#FCEBB9',
    '#E86452',
    '#F8D0CB',
    '#6DC8EC',
    '#D3EEF9',
    '#945FB9',
    '#DECFEA',
    '#FF9845',
    '#FFE0C7',
    '#1E9493',
    '#BBDEDE',
    '#FF99C3',
    '#FFE0ED',
];
/** \u5355\u8272\u987A\u5E8F\u8272\u677F */
var dark_SINGLE_SEQUENCE = [
    '#B8E1FF',
    '#9AC5FF',
    '#7DAAFF',
    '#5B8FF9',
    '#3D76DD',
    '#085EC0',
    '#0047A5',
    '#00318A',
    '#001D70',
];
var createDarkStyleSheet = function (cfg) {
    if (cfg === void 0) { cfg = {}; }
    var _a = cfg.paletteQualitative10, paletteQualitative10 = _a === void 0 ? dark_QUALITATIVE_10 : _a, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? dark_QUALITATIVE_20 : _b;
    var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
    var token = {
        /** \u56FE\u8868\u80CC\u666F\u8272 */
        backgroundColor: '#141414',
        /** \u4E3B\u9898\u8272 */
        brandColor: brandColor,
        /** \u56FE\u8868\u8F85\u52A9\u8272 */
        subColor: 'rgba(255,255,255,0.05)',
        /** \u5206\u7C7B\u8272\u677F 1\uFF0C\u5728\u6570\u636E\u91CF\u5C0F\u4E8E\u7B49\u4E8E 10 \u65F6\u4F7F\u7528 */
        paletteQualitative10: paletteQualitative10,
        /** \u5206\u7C7B\u8272\u677F 2\uFF0C\u5728\u6570\u636E\u91CF\u5927\u4E8E 10 \u65F6\u4F7F\u7528 */
        paletteQualitative20: paletteQualitative20,
        /** \u8BED\u4E49\u8272 */
        paletteSemanticRed: '#F4664A',
        /** \u8BED\u4E49\u8272 */
        paletteSemanticGreen: '#30BF78',
        /** \u8BED\u4E49\u8272 */
        paletteSemanticYellow: '#FAAD14',
        /** (\u5355\u8272)\u987A\u5E8F\u8272\u677F */
        paletteSequence: dark_SINGLE_SEQUENCE,
        /** \u5B57\u4F53 */
        fontFamily: "\\"Segoe UI\\", Roboto, \\"Helvetica Neue\\", Arial,\\n    \\"Noto Sans\\", sans-serif, \\"Apple Color Emoji\\", \\"Segoe UI Emoji\\", \\"Segoe UI Symbol\\",\\n    \\"Noto Color Emoji\\"",
        // -------------------- \u5750\u6807\u8F74 --------------------
        /** \u5750\u6807\u8F74\u7EBF\u989C\u8272 */
        axisLineBorderColor: dark_BLACK_COLORS[25],
        /** \u5750\u6807\u8F74\u7EBF\u7C97\u7EC6 */
        axisLineBorder: 1,
        /** \u5750\u6807\u8F74\u7EBF lineDash \u8BBE\u7F6E */
        axisLineDash: null,
        /** \u5750\u6807\u8F74\u6807\u9898\u989C\u8272 */
        axisTitleTextFillColor: dark_BLACK_COLORS[65],
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        axisTitleTextFontSize: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u884C\u9AD8 */
        axisTitleTextLineHeight: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        axisTitleTextFontWeight: 'normal',
        /** \u5750\u6807\u8F74\u6807\u9898\u8DDD\u79BB\u5750\u6807\u8F74\u6587\u672C\u7684\u95F4\u8DDD */
        axisTitleSpacing: 12,
        /** \u5750\u6807\u8F74\u6807\u9898\u8BE6\u7EC6\u8BF4\u660Eicon\u989C\u8272 */
        axisDescriptionIconFillColor: dark_WHITE_COLORS[85],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u989C\u8272 */
        axisTickLineBorderColor: dark_BLACK_COLORS[25],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u957F\u5EA6 */
        axisTickLineLength: 4,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u7EBF\u7C97\u7EC6 */
        axisTickLineBorder: 1,
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u989C\u8272 */
        axisSubTickLineBorderColor: dark_BLACK_COLORS[15],
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u957F\u5EA6 */
        axisSubTickLineLength: 2,
        /** \u5750\u6807\u8F74\u6B21\u523B\u5EA6\u7EBF\u7C97\u7EC6 */
        axisSubTickLineBorder: 1,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u989C\u8272 */
        axisLabelFillColor: dark_BLACK_COLORS[45],
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        axisLabelFontSize: 12,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u884C\u9AD8 */
        axisLabelLineHeight: 12,
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        axisLabelFontWeight: 'normal',
        /** \u5750\u6807\u8F74\u523B\u5EA6\u6587\u672C\u8DDD\u79BB\u5750\u6807\u8F74\u7EBF\u7684\u95F4\u8DDD */
        axisLabelOffset: 8,
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u989C\u8272 */
        axisGridBorderColor: dark_BLACK_COLORS[15],
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u7C97\u7EC6 */
        axisGridBorder: 1,
        /** \u5750\u6807\u8F74\u7F51\u683C\u7EBF\u865A\u7EBF\u8BBE\u7F6E */
        axisGridLineDash: null,
        // -------------------- \u56FE\u4F8B --------------------
        /** \u56FE\u4F8B\u6807\u9898\u989C\u8272 */
        legendTitleTextFillColor: dark_BLACK_COLORS[45],
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendTitleTextFontSize: 12,
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u884C\u9AD8 */
        legendTitleTextLineHeight: 21,
        /** \u56FE\u4F8B\u6807\u9898\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        legendTitleTextFontWeight: 'normal',
        /** \u56FE\u4F8B marker \u989C\u8272 */
        legendMarkerColor: dark_QUALITATIVE_10[0],
        /** \u56FE\u4F8B marker \u8DDD\u79BB\u56FE\u4F8B\u6587\u672C\u7684\u95F4\u8DDD */
        legendMarkerSpacing: 8,
        /** \u56FE\u4F8B marker \u9ED8\u8BA4\u534A\u5F84\u5927\u5C0F */
        legendMarkerSize: 4,
        /** \u56FE\u4F8B 'circle' marker \u534A\u5F84 */
        legendCircleMarkerSize: 4,
        /** \u56FE\u4F8B 'square' marker \u534A\u5F84 */
        legendSquareMarkerSize: 4,
        /** \u56FE\u4F8B 'line' marker \u534A\u5F84 */
        legendLineMarkerSize: 5,
        /** \u56FE\u4F8B\u9879\u6587\u672C\u989C\u8272 */
        legendItemNameFillColor: dark_BLACK_COLORS[65],
        /** \u56FE\u4F8B\u9879\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendItemNameFontSize: 12,
        /** \u56FE\u4F8B\u9879\u6587\u672C\u884C\u9AD8 */
        legendItemNameLineHeight: 12,
        /** \u56FE\u4F8B\u9879\u7C97\u7EC6 */
        legendItemNameFontWeight: 'normal',
        /** \u56FE\u4F8B\u9879\u4E4B\u95F4\u7684\u6C34\u5E73\u95F4\u8DDD */
        legendItemSpacing: 24,
        /** \u56FE\u4F8B\u9879\u5782\u76F4\u65B9\u5411\u7684\u95F4\u9694 */
        legendItemMarginBottom: 12,
        /** \u56FE\u4F8B\u4E0E\u56FE\u8868\u7ED8\u56FE\u533A\u57DF\u7684\u504F\u79FB\u8DDD\u79BB  */
        legendSpacing: 16,
        /** \u56FE\u4F8B\u4E0E\u56FE\u8868\u7ED8\u56FE\u533A\u57DF\u7684\u504F\u79FB\u8DDD\u79BB  */
        legendPadding: [8, 8, 8, 8],
        /** \u6C34\u5E73\u5E03\u5C40\u7684\u56FE\u4F8B\u4E0E\u7ED8\u56FE\u533A\u57DF\u504F\u79FB\u8DDD\u79BB */
        legendHorizontalPadding: [8, 0, 8, 0],
        /** \u5782\u76F4\u5E03\u5C40\u7684\u56FE\u4F8B\u4E0E\u7ED8\u56FE\u533A\u57DF\u504F\u79FB\u8DDD\u79BB */
        legendVerticalPadding: [0, 8, 0, 8],
        // \u56FE\u4F8B\u5206\u9875\u5668
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u5927\u5C0F */
        legendPageNavigatorMarkerSize: 12,
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u586B\u5145\u8272 */
        legendPageNavigatorMarkerInactiveFillColor: dark_BLACK_COLORS[45],
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u586B\u5145\u8272\u900F\u660E\u5EA6 */
        legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u6FC0\u6D3B\u72B6\u6001\u586B\u5145\u8272 */
        legendPageNavigatorMarkerFillColor: dark_BLACK_COLORS[45],
        /** \u56FE\u4F8B\u5206\u9875\u5668 marker \u6FC0\u6D3B\u72B6\u6001\u586B\u5145\u8272\u900F\u660E\u5EA6 */
        legendPageNavigatorMarkerFillOpacity: 1,
        /** \u56FE\u4F8B\u5206\u9875\u5668\u6587\u672C\u989C\u8272 */
        legendPageNavigatorTextFillColor: dark_BLACK_COLORS[65],
        /** \u56FE\u4F8B\u5206\u9875\u5668\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        legendPageNavigatorTextFontSize: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u586B\u5145\u8272 */
        sliderRailFillColor: dark_BLACK_COLORS[15],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u7C97\u7EC6 */
        sliderRailBorder: 0,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u989C\u8272 */
        sliderRailBorderColor: null,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u5BBD\u5EA6 */
        sliderRailWidth: 100,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u9AD8\u5EA6 */
        sliderRailHeight: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u989C\u8272 */
        sliderLabelTextFillColor: dark_BLACK_COLORS[45],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        sliderLabelTextFontSize: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u884C\u9AD8 */
        sliderLabelTextLineHeight: 12,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        sliderLabelTextFontWeight: 'normal',
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u989C\u8272 */
        sliderHandlerFillColor: dark_WHITE_COLORS[6],
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u5BBD\u5EA6 */
        sliderHandlerWidth: 10,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u9AD8\u5EA6 */
        sliderHandlerHeight: 14,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u7C97\u7EC6 */
        sliderHandlerBorder: 1,
        /** \u8FDE\u7EED\u56FE\u4F8B\u6ED1\u5757\u8FB9\u6846\u989C\u8272 */
        sliderHandlerBorderColor: dark_WHITE_COLORS[25],
        // -------------------- Annotation\uFF0C\u56FE\u5F62\u6807\u6CE8 --------------------
        /** arc \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u989C\u8272 */
        annotationArcBorderColor: dark_BLACK_COLORS[15],
        /** arc \u56FE\u5F62\u6807\u6CE8\u7C97\u7EC6 */
        annotationArcBorder: 1,
        /** line \u56FE\u5F62\u6807\u6CE8\u989C\u8272 */
        annotationLineBorderColor: dark_BLACK_COLORS[25],
        /** line \u56FE\u5F62\u6807\u6CE8\u7C97\u7EC6 */
        annotationLineBorder: 1,
        /** lube \u56FE\u5F62\u6807\u6CE8\u7684\u865A\u7EBF\u95F4\u9694 */
        annotationLineDash: null,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u989C\u8272 */
        annotationTextFillColor: dark_BLACK_COLORS[65],
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        annotationTextFontSize: 12,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u884C\u9AD8 */
        annotationTextLineHeight: 12,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        annotationTextFontWeight: 'normal',
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u8FB9\u6846\u989C\u8272 */
        annotationTextBorderColor: null,
        /** text \u56FE\u5F62\u6807\u6CE8\u6587\u672C\u8FB9\u6846\u7C97\u7EC6 */
        annotationTextBorder: 0,
        /** region \u56FE\u5F62\u6807\u6CE8\u586B\u5145\u989C\u8272 */
        annotationRegionFillColor: dark_BLACK_COLORS[100],
        /** region \u56FE\u5F62\u6807\u6CE8\u586B\u5145\u989C\u8272\u900F\u660E\u8272 */
        annotationRegionFillOpacity: 0.06,
        /** region \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u7C97\u7EC6 */
        annotationRegionBorder: 0,
        /** region \u56FE\u5F62\u6807\u6CE8\u63CF\u8FB9\u989C\u8272 */
        annotationRegionBorderColor: null,
        /** dataMarker \u56FE\u5F62\u6807\u6CE8\u7EBF\u7684\u957F\u5EA6 */
        annotationDataMarkerLineLength: 16,
        // -------------------- Tooltip --------------------
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u989C\u8272 */
        tooltipCrosshairsBorderColor: dark_BLACK_COLORS[25],
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u7C97\u7EC6 */
        tooltipCrosshairsBorder: 1,
        /** tooltip crosshairs \u8F85\u52A9\u7EBF\u865A\u7EBF\u95F4\u9694 */
        tooltipCrosshairsLineDash: null,
        /** tooltip \u5185\u5BB9\u6846\u80CC\u666F\u8272 */
        tooltipContainerFillColor: '#1f1f1f',
        tooltipContainerFillOpacity: 0.95,
        /** tooltip \u5185\u5BB9\u6846\u9634\u5F71 */
        tooltipContainerShadow: '0px 2px 4px rgba(0,0,0,.5)',
        /** tooltip \u5185\u5BB9\u6846\u5706\u89D2 */
        tooltipContainerBorderRadius: 3,
        /** tooltip \u6587\u672C\u989C\u8272 */
        tooltipTextFillColor: dark_BLACK_COLORS[65],
        /** tooltip \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        tooltipTextFontSize: 12,
        /** tooltip \u6587\u672C\u884C\u9AD8 */
        tooltipTextLineHeight: 12,
        /** tooltip \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        tooltipTextFontWeight: 'bold',
        // -------------------- Geometry labels --------------------
        /** Geometry label \u6587\u672C\u989C\u8272 */
        labelFillColor: dark_BLACK_COLORS[65],
        labelFillColorDark: '#2c3542',
        labelFillColorLight: '#ffffff',
        /** Geometry label \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        labelFontSize: 12,
        /** Geometry label \u6587\u672C\u884C\u9AD8 */
        labelLineHeight: 12,
        /** Geometry label \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        labelFontWeight: 'normal',
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        labelBorderColor: null,
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        labelBorder: 0,
        /** Geometry innerLabel \u6587\u672C\u989C\u8272 */
        innerLabelFillColor: dark_WHITE_COLORS[100],
        /** Geometry innerLabel \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        innerLabelFontSize: 12,
        /** Geometry innerLabel \u6587\u672C\u884C\u9AD8 */
        innerLabelLineHeight: 12,
        /** Geometry innerLabel \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        innerLabelFontWeight: 'normal',
        /** Geometry innerLabel \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        innerLabelBorderColor: null,
        /** Geometry innerLabel \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        innerLabelBorder: 0,
        /** Geometry label \u6587\u672C\u989C\u8272 */
        overflowLabelFillColor: dark_BLACK_COLORS[65],
        overflowLabelFillColorDark: '#2c3542',
        overflowLabelFillColorLight: '#ffffff',
        /** Geometry label \u6587\u672C\u5B57\u4F53\u5927\u5C0F */
        overflowLabelFontSize: 12,
        /** Geometry label \u6587\u672C\u884C\u9AD8 */
        overflowLabelLineHeight: 12,
        /** Geometry label \u6587\u672C\u5B57\u4F53\u7C97\u7EC6 */
        overflowLabelFontWeight: 'normal',
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u989C\u8272 */
        overflowLabelBorderColor: dark_WHITE_COLORS[100],
        /** Geometry label \u6587\u672C\u63CF\u8FB9\u7C97\u7EC6 */
        overflowLabelBorder: 1,
        /** Geometry label \u6587\u672C\u8FDE\u63A5\u7EBF\u7C97\u7EC6 */
        labelLineBorder: 1,
        /** Geometry label \u6587\u672C\u8FDE\u63A5\u7EBF\u989C\u8272 */
        labelLineBorderColor: dark_BLACK_COLORS[25],
        // -------------------- Slider \u7EC4\u4EF6\u6837\u5F0F--------------------
        /** slider \u6ED1\u9053\u9AD8\u5EA6 */
        cSliderRailHieght: 16,
        /** slider \u6ED1\u9053\u80CC\u666F\u8272 */
        cSliderBackgroundFillColor: '#416180',
        /** slider \u6ED1\u9053\u80CC\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderBackgroundFillOpacity: 0.05,
        /** slider \u6ED1\u9053\u524D\u666F\u8272 */
        cSliderForegroundFillColor: '#5B8FF9',
        /** slider \u6ED1\u9053\u524D\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderForegroundFillOpacity: 0.15,
        // slider handlerStyle \u624B\u67C4\u6837\u5F0F
        /** slider \u624B\u67C4\u9AD8\u5EA6 */
        cSliderHandlerHeight: 24,
        /** Slider \u624B\u67C4\u5BBD\u5EA6 */
        cSliderHandlerWidth: 10,
        /** Slider \u624B\u67C4\u80CC\u666F\u8272 */
        cSliderHandlerFillColor: '#F7F7F7',
        /** Slider \u624B\u67C4\u80CC\u666F\u8272\u900F\u660E\u5EA6 */
        cSliderHandlerFillOpacity: 1,
        /** Slider \u624B\u67C4\u9AD8\u4EAE\u80CC\u666F\u8272 */
        cSliderHandlerHighlightFillColor: '#FFF',
        /** Slider \u624B\u67C4\u8FB9\u6846\u8272 */
        cSliderHandlerBorderColor: '#BFBFBF',
        /** Slider \u624B\u67C4\u8FB9\u6846\u7C97\u7EC6 */
        cSliderHandlerBorder: 1,
        /** Slider \u624B\u67C4\u8FB9\u6846\u5706\u89D2 */
        cSliderHandlerBorderRadius: 2,
        // slider textStyle \u5B57\u4F53\u6807\u7B7E\u6837\u5F0F
        /** Slider \u5B57\u4F53\u6807\u7B7E\u989C\u8272 */
        cSliderTextFillColor: '#fff',
        /** Slider \u5B57\u4F53\u6807\u7B7E\u900F\u660E\u5EA6 */
        cSliderTextFillOpacity: 0.45,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u5927\u5C0F */
        cSliderTextFontSize: 12,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u884C\u9AD8 */
        cSliderTextLineHeight: 12,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u5B57\u91CD */
        cSliderTextFontWeight: 'normal',
        /** Slider \u5B57\u4F53\u6807\u7B7E\u63CF\u8FB9\u8272 */
        cSliderTextBorderColor: null,
        /** Slider \u5B57\u4F53\u6807\u7B7E\u63CF\u8FB9\u7C97\u7EC6 */
        cSliderTextBorder: 0,
        // -------------------- Scrollbar \u7EC4\u4EF6\u6837\u5F0F--------------------
        /** \u6EDA\u52A8\u6761 \u6EDA\u9053\u586B\u5145\u8272 */
        scrollbarTrackFillColor: 'rgba(255,255,255,0.65)',
        /** \u6EDA\u52A8\u6761 \u6ED1\u5757\u586B\u5145\u8272 */
        scrollbarThumbFillColor: 'rgba(0,0,0,0.35)',
        /** \u6EDA\u52A8\u6761 \u6ED1\u5757\u9AD8\u4EAE\u586B\u5145\u8272 */
        scrollbarThumbHighlightFillColor: 'rgba(0,0,0,0.45)',
        // -------------------- Geometry \u56FE\u5F62\u6837\u5F0F--------------------
        /** \u70B9\u56FE\u586B\u5145\u989C\u8272 */
        pointFillColor: dark_QUALITATIVE_10[0],
        /** \u70B9\u56FE\u586B\u5145\u989C\u8272\u900F\u660E\u5EA6 */
        pointFillOpacity: 0.95,
        /** \u70B9\u56FE\u5927\u5C0F */
        pointSize: 4,
        /** \u70B9\u56FE\u63CF\u8FB9\u7C97\u7EC6 */
        pointBorder: 1,
        /** \u70B9\u56FE\u63CF\u8FB9\u989C\u8272 */
        pointBorderColor: dark_WHITE_COLORS[100],
        /** \u70B9\u56FE\u63CF\u8FB9\u900F\u660E\u5EA6 */
        pointBorderOpacity: 1,
        /** \u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        pointActiveBorderColor: dark_BLACK_COLORS[100],
        /** \u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        pointSelectedBorder: 2,
        /** \u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        pointSelectedBorderColor: dark_BLACK_COLORS[100],
        /** \u70B9\u56FE inactive \u72B6\u6001\u4E0B\u586B\u5145\u989C\u8272\u900F\u660E\u5EA6 */
        pointInactiveFillOpacity: 0.3,
        /** \u70B9\u56FE inactive \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        pointInactiveBorderOpacity: 0.3,
        /** \u7A7A\u5FC3\u70B9\u56FE\u5927\u5C0F */
        hollowPointSize: 4,
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointBorder: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u989C\u8272 */
        hollowPointBorderColor: dark_QUALITATIVE_10[0],
        /** \u7A7A\u5FC3\u70B9\u56FE\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointBorderOpacity: 0.95,
        hollowPointFillColor: dark_WHITE_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointActiveBorder: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        hollowPointActiveBorderColor: dark_BLACK_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE active \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointActiveBorderOpacity: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u7C97\u7EC6 */
        hollowPointSelectedBorder: 2,
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u989C\u8272 */
        hollowPointSelectedBorderColor: dark_BLACK_COLORS[100],
        /** \u7A7A\u5FC3\u70B9\u56FE selected \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointSelectedBorderOpacity: 1,
        /** \u7A7A\u5FC3\u70B9\u56FE inactive \u72B6\u6001\u4E0B\u63CF\u8FB9\u900F\u660E\u5EA6 */
        hollowPointInactiveBorderOpacity: 0.3,
        /** \u7EBF\u56FE\u7C97\u7EC6 */
        lineBorder: 2,
        /** \u7EBF\u56FE\u989C\u8272 */
        lineBorderColor: dark_QUALITATIVE_10[0],
        /** \u7EBF\u56FE\u900F\u660E\u5EA6 */
        lineBorderOpacity: 1,
        /** \u7EBF\u56FE Active \u72B6\u6001\u4E0B\u7C97\u7EC6 */
        lineActiveBorder: 3,
        /** \u7EBF\u56FE selected \u72B6\u6001\u4E0B\u7C97\u7EC6 */
        lineSelectedBorder: 3,
        /** \u7EBF\u56FE inactive \u72B6\u6001\u4E0B\u900F\u660E\u5EA6 */
        lineInactiveBorderOpacity: 0.3,
        /** area \u586B\u5145\u989C\u8272 */
        areaFillColor: dark_QUALITATIVE_10[0],
        /** area \u586B\u5145\u900F\u660E\u5EA6 */
        areaFillOpacity: 0.25,
        /** area \u5728 active \u72B6\u6001\u4E0B\u7684\u586B\u5145\u900F\u660E\u5EA6 */
        areaActiveFillColor: dark_QUALITATIVE_10[0],
        areaActiveFillOpacity: 0.5,
        /** area \u5728 selected \u72B6\u6001\u4E0B\u7684\u586B\u5145\u900F\u660E\u5EA6 */
        areaSelectedFillColor: dark_QUALITATIVE_10[0],
        areaSelectedFillOpacity: 0.5,
        /** area inactive \u72B6\u6001\u4E0B\u586B\u5145\u900F\u660E\u5EA6 */
        areaInactiveFillOpacity: 0.3,
        /** hollowArea \u989C\u8272 */
        hollowAreaBorderColor: dark_QUALITATIVE_10[0],
        /** hollowArea \u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaBorder: 2,
        /** hollowArea \u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowAreaBorderOpacity: 1,
        /** hollowArea active \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaActiveBorder: 3,
        hollowAreaActiveBorderColor: dark_BLACK_COLORS[100],
        /** hollowArea selected \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u7C97\u7EC6 */
        hollowAreaSelectedBorder: 3,
        hollowAreaSelectedBorderColor: dark_BLACK_COLORS[100],
        /** hollowArea inactive \u72B6\u6001\u4E0B\u7684\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowAreaInactiveBorderOpacity: 0.3,
        /** interval \u586B\u5145\u989C\u8272 */
        intervalFillColor: dark_QUALITATIVE_10[0],
        /** interval \u586B\u5145\u900F\u660E\u5EA6 */
        intervalFillOpacity: 0.95,
        /** interval active \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        intervalActiveBorder: 1,
        /** interval active \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        intervalActiveBorderColor: dark_BLACK_COLORS[100],
        intervalActiveBorderOpacity: 1,
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        intervalSelectedBorder: 2,
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        intervalSelectedBorderColor: dark_BLACK_COLORS[100],
        /** interval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        intervalSelectedBorderOpacity: 1,
        /** interval inactive \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        intervalInactiveBorderOpacity: 0.3,
        /** interval inactive \u72B6\u6001\u4E0B\u586B\u5145\u900F\u660E\u5EA6 */
        intervalInactiveFillOpacity: 0.3,
        /** interval \u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalBorder: 2,
        /** hollowInterval \u8FB9\u6846\u989C\u8272 */
        hollowIntervalBorderColor: dark_QUALITATIVE_10[0],
        /** hollowInterval \u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalBorderOpacity: 1,
        hollowIntervalFillColor: dark_WHITE_COLORS[100],
        /** hollowInterval active \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalActiveBorder: 2,
        /** hollowInterval active \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        hollowIntervalActiveBorderColor: dark_BLACK_COLORS[100],
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u7C97\u7EC6 */
        hollowIntervalSelectedBorder: 3,
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u989C\u8272 */
        hollowIntervalSelectedBorderColor: dark_BLACK_COLORS[100],
        /** hollowInterval selected \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalSelectedBorderOpacity: 1,
        /** hollowInterval inactive \u72B6\u6001\u4E0B\u8FB9\u6846\u900F\u660E\u5EA6 */
        hollowIntervalInactiveBorderOpacity: 0.3,
    };
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, token), cfg);
};
var antvDark = createDarkStyleSheet();
//# sourceMappingURL=dark.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/util.js
function getPixelRatio() {
    return window ? window.devicePixelRatio : 1;
}
/**
 * \u4E24\u70B9\u4E4B\u95F4\u7684\u8DDD\u79BB
 * @param {number} x1 \u8D77\u59CB\u70B9 x
 * @param {number} y1 \u8D77\u59CB\u70B9 y
 * @param {number} x2 \u7ED3\u675F\u70B9 x
 * @param {number} y2 \u7ED3\u675F\u70B9 y
 */
function util_util_distance(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
}
/**
 * \u662F\u5426\u5728\u5305\u56F4\u76D2\u5185
 * @param {number} minX   \u5305\u56F4\u76D2\u5F00\u59CB\u7684\u70B9 x
 * @param {number} minY   \u5305\u56F4\u76D2\u5F00\u59CB\u7684\u70B9 y
 * @param {number} width  \u5BBD\u5EA6
 * @param {number} height \u9AD8\u5EA6
 * @param {[type]} x      \u68C0\u6D4B\u70B9\u7684 x
 * @param {[type]} y      \u76D1\u6D4B\u70B9\u7684 y
 */
function inBox(minX, minY, width, height, x, y) {
    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function util_intersectRect(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
// \u5408\u5E76\u4E24\u4E2A\u533A\u57DF
function mergeRegion(region1, region2) {
    if (!region1 || !region2) {
        return region1 || region2;
    }
    return {
        minX: Math.min(region1.minX, region2.minX),
        minY: Math.min(region1.minY, region2.minY),
        maxX: Math.max(region1.maxX, region2.maxX),
        maxY: Math.max(region1.maxY, region2.maxY),
    };
}
/**
 * \u5224\u65AD\u4E24\u4E2A\u70B9\u662F\u5426\u91CD\u5408\uFF0C\u70B9\u5750\u6807\u7684\u683C\u5F0F\u4E3A [x, y]
 * @param {Array} point1 \u7B2C\u4E00\u4E2A\u70B9
 * @param {Array} point2 \u7B2C\u4E8C\u4E2A\u70B9
 */
function isSamePoint(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
}

//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/parse.js

var parse_regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var parse_regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;
var parse_regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;
function addStop(steps, gradient) {
    var arr = steps.match(parse_regexColorStop);
    (0,esm/* each */.S6)(arr, function (item) {
        var itemArr = item.split(':');
        gradient.addColorStop(itemArr[0], itemArr[1]);
    });
}
/**
 * \u5C06\u8FB9\u548C\u586B\u5145\u8BBE\u7F6E\u7684\u989C\u8272\u8F6C\u6362\u6210\u7EBF\u6027\u6E10\u53D8\u5BF9\u8C61
 * @param {CanvasRenderingContext2D} context canvas \u4E0A\u4E0B\u6587
 * @param {IElement}                 element  \u56FE\u5F62\u5143\u7D20
 * @param {string}                   gradientStr   \u989C\u8272
 * @returns {any} \u6E10\u53D8\u5BF9\u8C61
 */
function parseLineGradient(context, element, gradientStr) {
    var arr = parse_regexLG.exec(gradientStr);
    var angle = (parseFloat(arr[1]) % 360) * (Math.PI / 180);
    var steps = arr[2];
    var box = element.getBBox();
    var start;
    var end;
    if (angle >= 0 && angle < (1 / 2) * Math.PI) {
        start = {
            x: box.minX,
            y: box.minY,
        };
        end = {
            x: box.maxX,
            y: box.maxY,
        };
    }
    else if ((1 / 2) * Math.PI <= angle && angle < Math.PI) {
        start = {
            x: box.maxX,
            y: box.minY,
        };
        end = {
            x: box.minX,
            y: box.maxY,
        };
    }
    else if (Math.PI <= angle && angle < (3 / 2) * Math.PI) {
        start = {
            x: box.maxX,
            y: box.maxY,
        };
        end = {
            x: box.minX,
            y: box.minY,
        };
    }
    else {
        start = {
            x: box.minX,
            y: box.maxY,
        };
        end = {
            x: box.maxX,
            y: box.minY,
        };
    }
    var tanTheta = Math.tan(angle);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;
    var gradient = context.createLinearGradient(start.x, start.y, x, y);
    addStop(steps, gradient);
    return gradient;
}
/**
 * \u5C06\u8FB9\u548C\u586B\u5145\u8BBE\u7F6E\u7684\u989C\u8272\u8F6C\u6362\u6210\u5706\u5F62\u6E10\u53D8\u5BF9\u8C61
 * @param {CanvasRenderingContext2D} context canvas \u4E0A\u4E0B\u6587
 * @param {IElement}                 element  \u56FE\u5F62\u5143\u7D20
 * @param {string}                   gradientStr   \u989C\u8272
 * @returns {any} \u6E10\u53D8\u5BF9\u8C61
 */
function parseRadialGradient(context, element, gradientStr) {
    var arr = parse_regexRG.exec(gradientStr);
    var fx = parseFloat(arr[1]);
    var fy = parseFloat(arr[2]);
    var fr = parseFloat(arr[3]);
    var steps = arr[4];
    // \u73AF\u534A\u5F84\u4E3A0\u65F6\uFF0C\u9ED8\u8BA4\u65E0\u6E10\u53D8\uFF0C\u53D6\u6E10\u53D8\u5E8F\u5217\u7684\u6700\u540E\u4E00\u4E2A\u989C\u8272
    if (fr === 0) {
        var colors = steps.match(parse_regexColorStop);
        return colors[colors.length - 1].split(':')[1];
    }
    var box = element.getBBox();
    var width = box.maxX - box.minX;
    var height = box.maxY - box.minY;
    var r = Math.sqrt(width * width + height * height) / 2;
    var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);
    addStop(steps, gradient);
    return gradient;
}
/**
 * \u8FB9\u548C\u586B\u5145\u8BBE\u7F6E\u7684\u989C\u8272\u8F6C\u6362\u6210 pattern
 * @param {CanvasRenderingContext2D} context canvas \u4E0A\u4E0B\u6587
 * @param {IElement}                 element  \u56FE\u5F62\u5143\u7D20
 * @param {string}                   patternStr   \u751F\u6210 pattern \u7684\u5B57\u7B26\u4E32
 */
function parsePattern(context, element, patternStr) {
    // \u5728\u8F6C\u6362\u8FC7\u7A0B\u4E2D\u8FDB\u884C\u4E86\u7F13\u5B58
    if (element.get('patternSource') && element.get('patternSource') === patternStr) {
        return element.get('pattern');
    }
    var pattern;
    var img;
    var arr = regexPR.exec(patternStr);
    var repeat = arr[1];
    var source = arr[2];
    // Function to be called when pattern loads
    function onload() {
        // Create pattern
        pattern = context.createPattern(img, repeat);
        element.set('pattern', pattern); // be a cache
        element.set('patternSource', patternStr);
    }
    switch (repeat) {
        case 'a':
            repeat = 'repeat';
            break;
        case 'x':
            repeat = 'repeat-x';
            break;
        case 'y':
            repeat = 'repeat-y';
            break;
        case 'n':
            repeat = 'no-repeat';
            break;
        default:
            repeat = 'no-repeat';
    }
    img = new Image();
    // If source URL is not a data URL
    if (!source.match(/^data:/i)) {
        // Set crossOrigin for this image
        img.crossOrigin = 'Anonymous';
    }
    img.src = source;
    if (img.complete) {
        onload();
    }
    else {
        img.onload = onload;
        // Fix onload() bug in IE9
        img.src = img.src;
    }
    return pattern;
}
function parseStyle(context, element, color) {
    var bbox = element.getBBox();
    if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
        return color;
    }
    if ((0,esm/* isString */.HD)(color)) {
        if (color[1] === '(' || color[2] === '(') {
            if (color[0] === 'l') {
                // regexLG.test(color)
                return parseLineGradient(context, element, color);
            }
            if (color[0] === 'r') {
                // regexRG.test(color)
                return parseRadialGradient(context, element, color);
            }
            if (color[0] === 'p') {
                // regexPR.test(color)
                return parsePattern(context, element, color);
            }
        }
        return color;
    }
    if (color instanceof CanvasPattern) {
        return color;
    }
}
function parseRadius(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if ((0,esm/* isArray */.kJ)(radius)) {
        if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
        }
        else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
        }
        else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
        }
        else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = radius;
    }
    return [r1, r2, r3, r4];
}
//# sourceMappingURL=parse.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/arc-params.js

// \u5411\u91CF\u957F\u5EA6
function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
// u.v/|u||v|\uFF0C\u8BA1\u7B97\u5939\u89D2\u7684\u4F59\u5F26\u503C
function vRatio(u, v) {
    // \u5F53\u5B58\u5728\u4E00\u4E2A\u5411\u91CF\u7684\u957F\u5EA6\u4E3A 0 \u65F6\uFF0C\u5939\u89D2\u4E5F\u4E3A 0\uFF0C\u5373\u5939\u89D2\u7684\u4F59\u5F26\u503C\u4E3A 1
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
// \u5411\u91CF\u89D2\u5EA6
function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y
function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = (0,esm/* mod */.wQ)((0,esm/* toRadian */.c$)(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    // \u5F27\u5F62\u8D77\u70B9\u5750\u6807
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    // \u5F27\u5F62\u7EC8\u70B9\u5750\u6807
    var x2 = params[6];
    var y2 = params[7];
    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;
    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;
    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
        f *= -1;
    }
    if (isNaN(f)) {
        f = 0;
    }
    // \u65CB\u8F6C\u524D\u7684\u8D77\u70B9\u5750\u6807\uFF0C\u4E14\u5F53\u957F\u534A\u8F74\u548C\u77ED\u534A\u8F74\u7684\u957F\u5EA6\u4E3A 0 \u65F6\uFF0C\u5750\u6807\u6309 (0, 0) \u5904\u7406
    var cxp = ry ? (f * rx * yp) / ry : 0;
    var cyp = rx ? (f * -ry * xp) / rx : 0;
    // \u692D\u5706\u5706\u5FC3\u5750\u6807
    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    // \u8D77\u59CB\u70B9\u7684\u5355\u4F4D\u5411\u91CF
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    // \u7EC8\u6B62\u70B9\u7684\u5355\u4F4D\u5411\u91CF
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    // \u8BA1\u7B97\u8D77\u59CB\u70B9\u548C\u5706\u5FC3\u7684\u8FDE\u7EBF\uFF0C\u4E0E x \u8F74\u6B63\u65B9\u5411\u7684\u5939\u89D2
    var theta = vAngle([1, 0], u);
    // \u8BA1\u7B97\u5706\u5F27\u8D77\u59CB\u70B9\u548C\u7EC8\u6B62\u70B9\u4E0E\u692D\u5706\u5706\u5FC3\u8FDE\u7EBF\u7684\u5939\u89D2
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
        dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
        dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * Math.PI;
    }
    return {
        cx: cx,
        cy: cy,
        // \u5F27\u5F62\u7684\u8D77\u70B9\u548C\u7EC8\u70B9\u76F8\u540C\u65F6\uFF0C\u957F\u8F74\u548C\u77ED\u8F74\u7684\u957F\u5EA6\u6309 0 \u5904\u7406
        rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
        ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
        startAngle: theta,
        endAngle: theta + dTheta,
        xRotation: xRotation,
        arcFlag: arcFlag,
        sweepFlag: sweepFlag,
    };
}
//# sourceMappingURL=arc-params.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/arrow.js


var sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    var arrowShape = new path({
        type: 'path',
        canvas: shape.get('canvas'),
        isArrowShape: true,
        attrs: {
            // \u9ED8\u8BA4\u7BAD\u5934\u7684\u8FB9\u957F\u4E3A 10\uFF0C\u5939\u89D2\u4E3A 60 \u5EA6
            path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
            // \u4F7F\u7528 shape stroke \u503C
            stroke: stroke,
            lineWidth: lineWidth,
        },
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 * \u7BAD\u5934 path \u7684\u8BBE\u7F6E\u8981\u6C42
 * 1. \u7BAD\u5934\u9876\u70B9\u5750\u6807\u9700\u8981\u4E3A (0, 0)
 * 2. \u7BAD\u5934\u5939\u89D2\u7684\u4E2D\u5FC3\u5206\u5272\u7EBF\u9700\u8981\u4E0E X \u8F74\u6B63\u65B9\u5411\u5BF9\u9F50
 */
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var arrowAttrs = isStart ? startArrow : endArrow;
    var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = (0,tslib_es6/* __rest */._T)(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    if (d) {
        x2 = x2 - cos(rad) * d;
        y2 = y2 - sin(rad) * d;
    }
    var arrowShape = new path({
        type: 'path',
        canvas: shape.get('canvas'),
        isArrowShape: true,
        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, restAttrs), { 
            // \u652F\u6301\u5355\u72EC\u8BBE\u7F6E\u7BAD\u5934\u7684 stroke \u548C lineWidth\uFF0C\u82E5\u4E3A\u7A7A\u5219\u4F7F\u7528 shape \u7684\u503C
            stroke: arrowStroke || stroke, lineWidth: arrowLineWidth || lineWidth, 
            // \u7BAD\u5934\u662F\u5426\u586B\u5145\u9700\u8981\u624B\u52A8\u8BBE\u7F6E\uFF0C\u4E0D\u4F1A\u7EE7\u627F\u81EA shape \u7684\u503C
            fill: arrowFill }),
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 * \u5982\u679C\u81EA\u5B9A\u4E49\u7BAD\u5934\u5E76\u4E14\u6709 d \u9700\u8981\u505A\u504F\u79FB\uFF0C\u5982\u679C\u76F4\u63A5\u753B\uFF0C\u7EBF\u6761\u4F1A\u8D85\u51FA\u7BAD\u5934\u5C16\u7AEF\uFF0C\u56E0\u6B64\u9700\u8981\u6839\u636E\u7BAD\u5934\u504F\u79FB d, \u8FD4\u56DE\u7EBF\u9700\u8981\u7F29\u77ED\u7684\u8DDD\u79BB
 * |----------------
 * |<|--------------
 * |
 * @param {number} x1 \u8D77\u59CB\u70B9 x
 * @param {number} y1 \u8D77\u59CB\u70B9 y
 * @param {number} x2 \u7BAD\u5934\u4F5C\u7528\u70B9 x
 * @param {number} y2 \u7BAD\u5934\u4F5C\u7528\u70B9 y
 * @param {number} d  \u7BAD\u5934\u6CBF\u7EBF\u6761\u65B9\u5411\u7684\u504F\u79FB\u8DDD\u79BB
 * @return {{dx: number, dy: number}} \u8FD4\u56DE\u7EBF\u6761\u504F\u79FB\u8DDD\u79BB
 */
function getShortenOffset(x1, y1, x2, y2, d) {
    var rad = atan2(y2 - y1, x2 - x1);
    return {
        dx: cos(rad) * d,
        dy: sin(rad) * d,
    };
}
/**
 * \u7ED8\u5236\u8D77\u59CB\u7BAD\u5934
 * @param {IShape} shape \u56FE\u5F62
 * @param {ShapeAttrs} attrs shape \u7684\u7ED8\u56FE\u5C5E\u6027
 * @param {number} x1 \u8D77\u59CB\u70B9 x
 * @param {number} y1 \u8D77\u59CB\u70B9 y
 * @param {number} x2 \u7BAD\u5934\u4F5C\u7528\u70B9 x
 * @param {number} y2 \u7BAD\u5934\u4F5C\u7528\u70B9 y
 */
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.startArrow === 'object') {
        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
    }
    else if (attrs.startArrow) {
        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
    }
    else {
        shape.set('startArrowShape', null);
    }
}
/**
 * \u7ED8\u5236\u7ED3\u675F\u7BAD\u5934
 * @param {IShape} shape \u56FE\u5F62
 * @param {ShapeAttrs} attrs shape \u7684\u7ED8\u56FE\u5C5E\u6027
 * @param {number} x1 \u8D77\u59CB\u70B9 x
 * @param {number} y1 \u8D77\u59CB\u70B9 y
 * @param {number} x2 \u7BAD\u5934\u4F5C\u7528\u70B9 x
 * @param {number} y2 \u7BAD\u5934\u4F5C\u7528\u70B9 y
 */
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.endArrow === 'object') {
        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
    }
    else if (attrs.endArrow) {
        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
    }
    else {
        shape.set('startArrowShape', null);
    }
}
//# sourceMappingURL=arrow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/draw.js





var SHAPE_ATTRS_MAP = {
    fill: 'fillStyle',
    stroke: 'strokeStyle',
    opacity: 'globalAlpha',
};
function applyAttrsToContext(context, element) {
    var attrs = element.attr();
    for (var k in attrs) {
        var v = attrs[k];
        // \u8F6C\u6362\u4E00\u4E0B\u4E0D\u4E0E canvas \u517C\u5BB9\u7684\u5C5E\u6027\u540D
        var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
        if (name_1 === 'matrix' && v) {
            // \u8BBE\u7F6E\u77E9\u9635
            context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
        }
        else if (name_1 === 'lineDash' && context.setLineDash) {
            // \u8BBE\u7F6E\u865A\u7EBF\uFF0C\u53EA\u652F\u6301\u6570\u7EC4\u5F62\u5F0F\uFF0C\u975E\u6570\u7EC4\u5F62\u5F0F\u4E0D\u505A\u4EFB\u4F55\u64CD\u4F5C
            (0,esm/* isArray */.kJ)(v) && context.setLineDash(v);
        }
        else {
            if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {
                // \u5982\u679C\u5B58\u5728\u6E10\u53D8\u3001pattern \u8FD9\u4E2A\u5F00\u9500\u6709\u4E9B\u5927
                // \u53EF\u4EE5\u8003\u8651\u7F13\u5B58\u673A\u5236\uFF0C\u901A\u8FC7 hasUpdate \u6765\u907F\u514D\u4E00\u4E9B\u8FD0\u7B97
                v = parseStyle(context, element, v);
            }
            else if (name_1 === 'globalAlpha') {
                // opacity \u6548\u679C\u53EF\u4EE5\u53E0\u52A0\uFF0C\u5B50\u5143\u7D20\u7684 opacity \u9700\u8981\u4E0E\u7236\u5143\u7D20 opacity \u76F8\u4E58
                v = v * context.globalAlpha;
            }
            context[name_1] = v;
        }
    }
}
function drawChildren(context, children, region) {
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.cfg.visible) {
            child.draw(context, region);
        }
        else {
            child.skipDraw();
        }
    }
}
// \u8FD9\u4E2A\u5730\u65B9\u7684\u903B\u8F91\u6BD4\u8F83\u590D\u6742\uFF0C\u7B80\u5355\u753B\u4E86\u4E00\u5F20\u56FE\uFF1Ahttps://www.yuque.com/antv/ou292n/pcgt5g#OW1QE
function checkRefresh(canvas, children, region) {
    var refreshElements = canvas.get('refreshElements');
    // \u5148\u904D\u5386\u9700\u8981\u5237\u65B0\u7684\u5143\u7D20\uFF0C\u5C06\u8FD9\u4E9B\u5143\u7D20\u7684\u7236\u5143\u7D20\u4E5F\u8BBE\u7F6E refresh
    (0,esm/* each */.S6)(refreshElements, function (el) {
        if (el !== canvas) {
            var parent_1 = el.cfg.parent;
            while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
                parent_1.cfg.refresh = true;
                parent_1 = parent_1.cfg.parent;
            }
        }
    });
    if (refreshElements[0] === canvas) {
        setChildrenRefresh(children, region);
    }
    else {
        // \u68C0\u67E5\u6240\u6709\u5B50\u5143\u7D20\u662F\u5426\u53EF\u4EE5\u5237\u65B0
        checkChildrenRefresh(children, region);
    }
}
// \u68C0\u67E5\u6240\u6709\u7684\u5B50\u5143\u7D20\u662F\u5426\u5E94\u8BE5\u66F4\u65B0
function checkChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.cfg.visible) {
            // \u5148\u5224\u65AD hasChanged\uFF0C\u56E0\u4E3A\u5B83\u7684\u4F18\u5148\u7EA7\u5224\u65AD\u5E94\u8BE5\u9AD8\u4E8E refresh
            if (child.cfg.hasChanged) {
                // \u5982\u679C\u8282\u70B9\u53D1\u751F\u4E86 change\uFF0C\u5219\u9700\u8981\u7EA7\u8054\u8BBE\u7F6E\u5B50\u5143\u7D20\u7684 refresh
                child.cfg.refresh = true;
                if (child.isGroup()) {
                    setChildrenRefresh(child.cfg.children, region);
                }
            }
            else if (child.cfg.refresh) {
                // \u5982\u679C\u5F53\u524D\u56FE\u5F62/\u5206\u7EC4 refresh = true\uFF0C\u8BF4\u660E\u5176\u5B50\u8282\u70B9\u5B58\u5728 changed
                if (child.isGroup()) {
                    checkChildrenRefresh(child.cfg.children, region);
                }
            }
            else {
                // \u8FD9\u4E2A\u5206\u652F\u8BF4\u660E\u6B64\u6B21\u5C40\u90E8\u5237\u65B0\uFF0C\u6240\u6709\u7684\u8282\u70B9\u548C\u7236\u5143\u7D20\u6CA1\u6709\u53D1\u751F\u53D8\u5316\uFF0C\u4EC5\u9700\u8981\u68C0\u67E5\u5305\u56F4\u76D2\uFF08\u7F13\u5B58\uFF09\u662F\u5426\u76F8\u4EA4\u5373\u53EF
                var refresh = checkElementRefresh(child, region);
                child.cfg.refresh = refresh;
                if (refresh && child.isGroup()) {
                    // \u5982\u679C\u9700\u8981\u5237\u65B0\uFF0C\u8BF4\u660E\u5B50\u5143\u7D20\u4E5F\u9700\u8981\u5237\u65B0\uFF0C\u7EE7\u7EED\u8FDB\u884C\u5224\u5B9A
                    checkChildrenRefresh(child.cfg.children, region);
                }
            }
        }
    }
}
// \u7531\u4E8E\u5BF9\u6539\u53D8\u7684\u56FE\u5F62\u653E\u5165 refreshElements \u65F6\u505A\u4E86\u4F18\u5316\uFF0C\u5224\u5B9A\u7236\u5143\u7D20 changed \u65F6\u4E0D\u52A0\u5165
// \u90A3\u4E48\u6709\u53EF\u80FD\u4F1A\u51FA\u73B0 elements \u90FD\u4E3A\u7A7A\uFF0C\u6240\u4EE5\u6700\u7EC8 group
function clearChanged(elements) {
    for (var i = 0; i < elements.length; i++) {
        var el = elements[i];
        el.cfg.hasChanged = false;
        // \u7EA7\u8054\u6E05\u7406
        if (el.isGroup() && !el.destroyed) {
            clearChanged(el.cfg.children);
        }
    }
}
// \u5F53\u67D0\u4E2A\u7236\u5143\u7D20\u53D1\u751F\u6539\u53D8\u65F6\uFF0C\u8C03\u7528\u8FD9\u4E2A\u65B9\u6CD5\u7EA7\u8054\u8BBE\u7F6E refresh
function setChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (!child.cfg.visible) {
            continue;
        }
        // let refresh = true;
        // \u83B7\u53D6\u7F13\u5B58\u7684 bbox\uFF0C\u5982\u679C\u8FD9\u4E2A bbox \u8FD8\u5B58\u5728\u5219\u8BF4\u660E\u7236\u5143\u7D20\u4E0D\u662F\u77E9\u9635\u53D1\u751F\u4E86\u6539\u53D8
        // const bbox = child.cfg.canvasBBox;
        // if (bbox) {
        //   // \u5982\u679C\u8FD9\u65F6\u5019
        //   refresh = intersectRect(bbox, region);
        // }
        child.cfg.refresh = true;
        // \u5982\u679C\u9700\u8981\u5237\u65B0\u5F53\u524D\u8282\u70B9\uFF0C\u6240\u6709\u7684\u5B50\u5143\u7D20\u8BBE\u7F6E refresh
        if (child.isGroup()) {
            setChildrenRefresh(child.get('children'), region);
        }
    }
}
function checkElementRefresh(shape, region) {
    var bbox = shape.cfg.cacheCanvasBBox;
    var isAllow = shape.cfg.isInView && bbox && util_intersectRect(bbox, region);
    return isAllow;
}
// \u7ED8\u5236 path
function drawPath(shape, context, attrs, arcParamsCache) {
    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (!path) {
        return;
    }
    var currentPoint = [0, 0]; // \u5F53\u524D\u56FE\u5F62
    var startMovePoint = [0, 0]; // \u5F00\u59CB M \u7684\u70B9\uFF0C\u53EF\u80FD\u4F1A\u6709\u591A\u4E2A
    var distance = {
        dx: 0,
        dy: 0,
    };
    context.beginPath();
    for (var i = 0; i < path.length; i++) {
        var params = path[i];
        var command = params[0];
        if (i === 0 && startArrow && startArrow.d) {
            var tangent = shape.getStartTangent();
            distance = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
        }
        else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {
            // \u4E3A\u4E86\u9632\u6B62\u7ED3\u5C3E\u4E3A Z \u7684 segment \u7F29\u77ED\u4E0D\u8D77\u6548\uFF0C\u9700\u8981\u53D6\u6700\u540E\u4E24\u4E2A segment \u7279\u6B8A\u5904\u7406
            var lastPath = path[i + 1];
            if (lastPath[0] === 'Z') {
                var tangent = shape.getEndTangent();
                distance = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
            }
        }
        else if (i === path.length - 1 && endArrow && endArrow.d) {
            if (path[0] !== 'Z') {
                var tangent = shape.getEndTangent();
                distance = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
            }
        }
        var dx = distance.dx, dy = distance.dy;
        // V,H,S,T \u90FD\u5728\u524D\u9762\u88AB\u8F6C\u6362\u6210\u6807\u51C6\u5F62\u5F0F
        switch (command) {
            case 'M':
                context.moveTo(params[1] - dx, params[2] - dy);
                startMovePoint = [params[1], params[2]];
                break;
            case 'L':
                context.lineTo(params[1] - dx, params[2] - dy);
                break;
            case 'Q':
                context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
                break;
            case 'C':
                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
                break;
            case 'A': {
                var arcParams = void 0;
                // \u4E3A\u4E86\u52A0\u901F\u7ED8\u5236\uFF0C\u53EF\u4EE5\u63D0\u4F9B\u53C2\u6570\u7684\u7F13\u5B58\uFF0C\u5404\u4E2A\u56FE\u5F62\u81EA\u5DF1\u7F13\u5B58
                if (arcParamsCache) {
                    arcParams = arcParamsCache[i];
                    if (!arcParams) {
                        arcParams = getArcParams(currentPoint, params);
                        arcParamsCache[i] = arcParams;
                    }
                }
                else {
                    arcParams = getArcParams(currentPoint, params);
                }
                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
                // \u76F4\u63A5\u4F7F\u7528\u692D\u5706\u7684 api
                if (context.ellipse) {
                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
                }
                else {
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    context.translate(cx, cy);
                    context.rotate(xRotation);
                    context.scale(scaleX, scaleY);
                    context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
                    context.scale(1 / scaleX, 1 / scaleY);
                    context.rotate(-xRotation);
                    context.translate(-cx, -cy);
                }
                break;
            }
            case 'Z':
                context.closePath();
                break;
            default:
                break;
        }
        // \u6709\u4E86 Z \u540E\uFF0C\u5F53\u524D\u8282\u70B9\u4ECE\u5F00\u59CB M \u7684\u70B9\u5F00\u59CB
        if (command === 'Z') {
            currentPoint = startMovePoint;
        }
        else {
            var len = params.length;
            currentPoint = [params[len - 2], params[len - 1]];
        }
    }
}
// \u5237\u65B0\u56FE\u5F62\u5143\u7D20(Shape \u6216\u8005 Group)
function refreshElement(element, changeType) {
    var canvas = element.get('canvas');
    // \u53EA\u6709\u5B58\u5728\u4E8E canvas \u4E0A\u65F6\u751F\u6548
    if (canvas) {
        if (changeType === 'remove') {
            // \u4E00\u65E6 remove\uFF0C\u5219\u65E0\u6CD5\u5728 element \u4E0A\u62FF\u5230\u5305\u56F4\u76D2
            // destroy \u540E\u6240\u6709\u5C5E\u6027\u90FD\u62FF\u4E0D\u5230\uFF0C\u6240\u4EE5\u9700\u8981\u6682\u5B58\u4E00\u4E0B
            // \u8FD9\u662F\u4E00\u6BB5 hack \u7684\u4EE3\u7801
            element._cacheCanvasBBox = element.get('cacheCanvasBBox');
        }
        // \u9632\u6B62\u53CD\u590D\u5237\u65B0
        if (!element.get('hasChanged')) {
            // \u4F46\u662F\u59CB\u7EC8\u8981\u6807\u8BB0\u4E3A hasChanged\uFF0C\u4FBF\u4E8E\u540E\u9762\u8FDB\u884C\u5C40\u90E8\u6E32\u67D3
            element.set('hasChanged', true);
            // \u672C\u6765\u53EA\u6709\u5C40\u90E8\u6E32\u67D3\u6A21\u5F0F\u4E0B\uFF0C\u624D\u9700\u8981\u8BB0\u5F55\u66F4\u65B0\u7684\u5143\u7D20\u961F\u5217
            // if (canvas.get('localRefresh')) {
            //   canvas.refreshElement(element, changeType, canvas);
            // }
            // \u4F46\u5BF9\u4E8E https://github.com/antvis/g/issues/422 \u7684\u573A\u666F\uFF0C\u5168\u5C40\u6E32\u67D3\u7684\u6A21\u5F0F\u4E0B\u4E5F\u9700\u8981\u8BB0\u5F55\u66F4\u65B0\u7684\u5143\u7D20\u961F\u5217
            // \u5982\u679C\u5F53\u524D\u5143\u7D20\u7684\u7236\u5143\u7D20\u53D1\u751F\u4E86\u6539\u53D8\uFF0C\u53EF\u4EE5\u4E0D\u653E\u5165\u961F\u5217\uFF0C\u8FD9\u53E5\u8BDD\u5927\u6982\u80FD\u591F\u63D0\u5347 15% \u7684\u521D\u6B21\u6E32\u67D3\u6027\u80FD
            if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {
                canvas.refreshElement(element, changeType, canvas);
                if (canvas.get('autoDraw')) {
                    canvas.draw();
                }
            }
        }
    }
}
function getRefreshRegion(element) {
    var region;
    if (!element.destroyed) {
        var cacheBox = element.get('cacheCanvasBBox');
        var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
        var bbox = element.getCanvasBBox();
        var validBBox = bbox && !!(bbox.width && bbox.height);
        // \u662F\u5426\u662F\u6709\u6548 bbox \u5224\u5B9A\uFF0C\u4E00\u4E9B NaN \u6216\u8005 \u5BBD\u9AD8\u4E3A 0 \u7684\u60C5\u51B5\u8FC7\u6EE4\u6389
        if (validCache && validBBox) {
            region = mergeRegion(cacheBox, bbox);
        }
        else if (validCache) {
            region = cacheBox;
        }
        else if (validBBox) {
            region = bbox;
        }
    }
    else {
        // \u56E0\u4E3A\u5143\u7D20\u5DF2\u7ECF\u9500\u6BC1\u6240\u4EE5\u65E0\u6CD5\u83B7\u53D6\u5230\u7F13\u5B58\u7684\u5305\u56F4\u76D2
        region = element['_cacheCanvasBBox'];
    }
    return region;
}
function getMergedRegion(elements) {
    if (!elements.length) {
        return null;
    }
    var minXArr = [];
    var minYArr = [];
    var maxXArr = [];
    var maxYArr = [];
    (0,esm/* each */.S6)(elements, function (el) {
        var region = getRefreshRegion(el);
        if (region) {
            minXArr.push(region.minX);
            minYArr.push(region.minY);
            maxXArr.push(region.maxX);
            maxYArr.push(region.maxY);
        }
    });
    return {
        minX: (0,esm/* min */.VV)(minXArr),
        minY: (0,esm/* min */.VV)(minYArr),
        maxX: (0,esm/* max */.Fp)(maxXArr),
        maxY: (0,esm/* max */.Fp)(maxYArr),
    };
}
function mergeView(region, viewRegion) {
    if (!region || !viewRegion) {
        return null;
    }
    // \u4E0D\u76F8\u4EA4\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE null
    if (!util_intersectRect(region, viewRegion)) {
        return null;
    }
    return {
        minX: Math.max(region.minX, viewRegion.minX),
        minY: Math.max(region.minY, viewRegion.minY),
        maxX: Math.min(region.maxX, viewRegion.maxX),
        maxY: Math.min(region.maxY, viewRegion.maxY),
    };
}
//# sourceMappingURL=draw.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/group.js






var Group = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    Group.prototype.onCanvasChange = function (changeType) {
        refreshElement(this, changeType);
    };
    Group.prototype.getShapeBase = function () {
        return esm_shape_namespaceObject;
    };
    Group.prototype.getGroupBase = function () {
        return Group;
    };
    // \u540C shape \u4E2D\u7684\u65B9\u6CD5\u91CD\u590D\u4E86
    Group.prototype._applyClip = function (context, clip) {
        if (clip) {
            context.save();
            // \u5C06 clip \u7684\u5C5E\u6027\u6302\u8F7D\u5230 context \u4E0A
            applyAttrsToContext(context, clip);
            // \u7ED8\u5236 clip \u8DEF\u5F84
            clip.createPath(context);
            context.restore();
            // \u88C1\u526A
            context.clip();
            clip._afterDraw();
        }
    };
    // \u8FD9\u4E2A\u65B9\u6CD5\u4EE5\u524D\u76F4\u63A5\u4F7F\u7528\u7684 getCanvasBBox\uFF0C\u7531\u4E8E group \u4E0A\u6CA1\u6709\u7F13\u5B58\uFF0C\u6240\u4EE5\u6BCF\u6B21\u91CD\u65B0\u8BA1\u7B97\uFF0C\u5BFC\u81F4\u6027\u80FD\u5F00\u9500\u6BD4\u8F83\u5927
    // \u5927\u6982\u80FD\u591F\u8282\u7701\u5168\u5C40\u6E32\u67D3 15-20% \u7684\u6027\u80FD\uFF0C\u5982\u679C\u4E0D\u5728\u8FD9\u91CC\u52A0\u7F13\u5B58\u4F18\u5316\u540E 10W \u4E2A\u8282\u70B9\u65E0\u6CD5\u8FBE\u5230 5-6 ms\uFF0C\u5927\u6982\u80FD\u591F 30-40ms
    Group.prototype.cacheCanvasBBox = function () {
        var children = this.cfg.children;
        var xArr = [];
        var yArr = [];
        (0,esm/* each */.S6)(children, function (child) {
            var bbox = child.cfg.cacheCanvasBBox;
            // isInview \u7684\u5224\u5B9A\u662F\u4E00\u65E6\u56FE\u5F62\u6216\u8005\u5206\u7EC4\u6E32\u67D3\u5C31\u8981\u8BA1\u7B97\u662F\u5426\u5728\u89C6\u56FE\u5185\uFF0C
            // \u8FD9\u4E2A\u5224\u5B9A 10W \u4E2A\u56FE\u5F62\u4E0B\u5DEE\u4E0D\u591A\u80FD\u591F\u8282\u7701 5-6 ms \u7684\u5F00\u9500
            if (bbox && child.cfg.isInView) {
                xArr.push(bbox.minX, bbox.maxX);
                yArr.push(bbox.minY, bbox.maxY);
            }
        });
        var bbox = null;
        if (xArr.length) {
            var minX = (0,esm/* min */.VV)(xArr);
            var maxX = (0,esm/* max */.Fp)(xArr);
            var minY = (0,esm/* min */.VV)(yArr);
            var maxY = (0,esm/* max */.Fp)(yArr);
            bbox = {
                minX: minX,
                minY: minY,
                x: minX,
                y: minY,
                maxX: maxX,
                maxY: maxY,
                width: maxX - minX,
                height: maxY - minY,
            };
            var canvas = this.cfg.canvas;
            if (canvas) {
                var viewRange = canvas.getViewRange();
                // \u5982\u679C\u8FD9\u4E2A\u5730\u65B9\u5224\u5B9A isInView == false \u8BBE\u7F6E bbox \u4E3A false \u7684\u8BDD\uFF0C\u62FE\u53D6\u7684\u6027\u80FD\u4F1A\u66F4\u9AD8
                // \u4F46\u662F\u76EE\u524D 10W \u56FE\u5F62\u7684\u62FE\u53D6\u5728 2-5ms \u5185\uFF0C\u8FD9\u4E2A\u4F18\u5316\u610F\u4E49\u4E0D\u5927\uFF0C\u53EF\u4EE5\u540E\u671F\u89C2\u5BDF\u518D\u770B
                this.set('isInView', util_intersectRect(bbox, viewRange));
            }
        }
        else {
            this.set('isInView', false);
        }
        this.set('cacheCanvasBBox', bbox);
    };
    Group.prototype.draw = function (context, region) {
        var children = this.cfg.children;
        var allowDraw = region ? this.cfg.refresh : true; // \u5C40\u90E8\u5237\u65B0\u9700\u8981\u5224\u5B9A
        // \u8FD9\u4E2A\u5730\u65B9\u9700\u8981\u5224\u5B9A\uFF0C\u5728 G6 \u7684\u573A\u666F\u6BCF\u4E2A group \u90FD\u6709 transform \u7684\u573A\u666F\u4E0B\u6027\u80FD\u4F1A\u5F00\u9500\u975E\u5E38\u5927
        // \u901A\u8FC7 refresh \u7684\u5224\u5B9A\uFF0C\u53EF\u4EE5\u4E0D\u5237\u65B0\u6CA1\u6709\u53D1\u751F\u8FC7\u53D8\u5316\u7684\u5206\u7EC4\uFF0C\u4E0D\u5728\u89C6\u7A97\u5185\u7684\u5206\u7EC4\u7B49\u7B49
        // \u5982\u679C\u60F3\u8FDB\u4E00\u6B65\u63D0\u5347\u5C40\u90E8\u6E32\u67D3\u6027\u80FD\uFF0C\u53EF\u4EE5\u8FDB\u4E00\u6B65\u4F18\u5316 refresh \u7684\u5224\u5B9A\uFF0C\u4F9D\u7136\u6709\u6F5C\u529B
        if (children.length && allowDraw) {
            context.save();
            // group \u4E0A\u7684\u77E9\u9635\u548C\u5C5E\u6027\u4E5F\u4F1A\u5E94\u7528\u5230\u4E0A\u4E0B\u6587\u4E0A
            // \u5148\u5C06 attrs \u5E94\u7528\u5230\u4E0A\u4E0B\u6587\u4E2D\uFF0C\u518D\u8BBE\u7F6E clip\u3002\u56E0\u4E3A clip \u5E94\u8BE5\u88AB\u5F53\u524D\u5143\u7D20\u7684 matrix \u6240\u5F71\u54CD
            applyAttrsToContext(context, this);
            this._applyClip(context, this.getClip());
            drawChildren(context, children, region);
            context.restore();
            this.cacheCanvasBBox();
        }
        // \u8FD9\u91CC\u7684\u6210\u672C\u6BD4\u8F83\u5927\uFF0C\u5982\u679C\u4E0D\u7ED8\u5236\u5219\u4E0D\u518D
        // this.set('cacheCanvasBBox', this.getCanvasBBox());
        this.cfg.refresh = null;
        // \u7ED8\u5236\u540E\uFF0C\u6D88\u9664\u66F4\u65B0\u6807\u8BB0
        this.set('hasChanged', false);
    };
    // \u7ED8\u5236\u65F6\u88AB\u8DF3\u8FC7\uFF0C\u4E00\u822C\u53D1\u751F\u5728\u5206\u7EC4\u9690\u85CF\u65F6
    Group.prototype.skipDraw = function () {
        this.set('cacheCanvasBBox', null);
        this.set('hasChanged', false);
    };
    return Group;
}(g_base_esm.AbstractGroup));
/* harmony default export */ var esm_group = (Group);
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/base.js







var base_ShapeBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ShapeBase, _super);
    function ShapeBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        // \u8BBE\u7F6E\u9ED8\u8BA4\u503C
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase.prototype.getShapeBase = function () {
        return esm_shape_namespaceObject;
    };
    ShapeBase.prototype.getGroupBase = function () {
        return esm_group;
    };
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    ShapeBase.prototype.onCanvasChange = function (changeType) {
        refreshElement(this, changeType);
    };
    ShapeBase.prototype.calculateBBox = function () {
        var type = this.get('type');
        var lineWidth = this.getHitLineWidth();
        // const attrs = this.attr();
        var bboxMethod = (0,g_base_esm.getBBoxMethod)(type);
        var box = bboxMethod(this);
        var halfLineWidth = lineWidth / 2;
        var minX = box.x - halfLineWidth;
        var minY = box.y - halfLineWidth;
        var maxX = box.x + box.width + halfLineWidth;
        var maxY = box.y + box.height + halfLineWidth;
        return {
            x: minX,
            minX: minX,
            y: minY,
            minY: minY,
            width: box.width + lineWidth,
            height: box.height + lineWidth,
            maxX: maxX,
            maxY: maxY,
        };
    };
    ShapeBase.prototype.isFill = function () {
        return !!this.attrs['fill'] || this.isClipShape();
    };
    ShapeBase.prototype.isStroke = function () {
        return !!this.attrs['stroke'];
    };
    // \u540C shape \u4E2D\u7684\u65B9\u6CD5\u91CD\u590D\u4E86
    ShapeBase.prototype._applyClip = function (context, clip) {
        if (clip) {
            context.save();
            // \u5C06 clip \u7684\u5C5E\u6027\u6302\u8F7D\u5230 context \u4E0A
            applyAttrsToContext(context, clip);
            // \u7ED8\u5236 clip \u8DEF\u5F84
            clip.createPath(context);
            context.restore();
            // \u88C1\u526A
            context.clip();
            clip._afterDraw();
        }
    };
    // \u7ED8\u5236\u56FE\u5F62\u65F6\u9700\u8981\u8003\u8651 region \u9650\u5236
    ShapeBase.prototype.draw = function (context, region) {
        var clip = this.cfg.clipShape;
        // \u5982\u679C\u6307\u5B9A\u4E86 region\uFF0C\u540C\u65F6\u4E0D\u5141\u8BB8\u5237\u65B0\u65F6\uFF0C\u76F4\u63A5\u8FD4\u56DE
        if (region) {
            if (this.cfg.refresh === false) {
                // this._afterDraw();
                this.set('hasChanged', false);
                return;
            }
            // \u662F\u5426\u76F8\u4EA4\u9700\u8981\u8003\u8651 clip \u7684\u5305\u56F4\u76D2
            var bbox = this.getCanvasBBox();
            if (!util_intersectRect(region, bbox)) {
                // \u56FE\u5F62\u7684\u5305\u56F4\u76D2\u4E0E\u91CD\u7ED8\u533A\u57DF\u4E0D\u76F8\u4EA4\u65F6\uFF0C\u4E5F\u9700\u8981\u6E05\u9664\u6807\u8BB0
                this.set('hasChanged', false);
                // \u5B58\u5728\u591A\u79CD\u60C5\u5F62\u9700\u8981\u66F4\u65B0 cacheCanvasBBox \u548C isInview \u7684\u5224\u5B9A
                // 1. \u4E4B\u524D\u56FE\u5F62\u5728\u89C6\u7A97\u5185\uFF0C\u4F46\u662F\u73B0\u5728\u4E0D\u518D\u89C6\u7A97\u5185
                // 2. \u5982\u679C\u5F53\u524D\u7684\u56FE\u5F62\u4EE5\u53CA\u7236\u5143\u7D20\u90FD\u6CA1\u6709\u53D1\u751F\u8FC7\u53D8\u5316\uFF0Crefresh = false \u4E0D\u4F1A\u8D70\u5230\u8FD9\u91CC\uFF0C\u6240\u4EE5\u8FD9\u91CC\u7684\u56FE\u5F62\u90FD\u662F\u7236\u5143\u7D20\u53D1\u751F\u53D8\u5316\uFF0C\u4F46\u662F\u6CA1\u6709\u5728\u89C6\u56FE\u5185\u7684\u5143\u7D20
                if (this.cfg.isInView) {
                    this._afterDraw();
                }
                return;
            }
        }
        context.save();
        // \u5148\u5C06 attrs \u5E94\u7528\u5230\u4E0A\u4E0B\u6587\u4E2D\uFF0C\u518D\u8BBE\u7F6E clip\u3002\u56E0\u4E3A clip \u5E94\u8BE5\u88AB\u5F53\u524D\u5143\u7D20\u7684 matrix \u6240\u5F71\u54CD
        applyAttrsToContext(context, this);
        this._applyClip(context, clip);
        this.drawPath(context);
        context.restore();
        this._afterDraw();
    };
    ShapeBase.prototype.getCanvasViewBox = function () {
        var canvas = this.cfg.canvas;
        if (canvas) {
            // @ts-ignore
            return canvas.getViewRange();
        }
        return null;
    };
    ShapeBase.prototype.cacheCanvasBBox = function () {
        var canvasBBox = this.getCanvasViewBox();
        // \u7ED8\u5236\u7684\u65F6\u5019\u7F13\u5B58\u5305\u56F4\u76D2
        if (canvasBBox) {
            var bbox = this.getCanvasBBox();
            var isInView = util_intersectRect(bbox, canvasBBox);
            this.set('isInView', isInView);
            // \u4E0D\u518D\u89C6\u7A97\u5185 cacheCanvasBBox \u8BBE\u7F6E\u6210 null\uFF0C\u4F1A\u63D0\u5347\u5C40\u90E8\u6E32\u67D3\u7684\u6027\u80FD\uFF0C
            // \u56E0\u4E3A\u5728\u5C40\u90E8\u6E32\u67D3\u5F71\u54CD\u7684\u5305\u56F4\u76D2\u8BA1\u7B97\u65F6\u4E0D\u8003\u8651\u8FD9\u4E2A\u56FE\u5F62\u7684\u5305\u56F4\u76D2
            // \u7236\u5143\u7D20 cacheCanvasBBox \u8BA1\u7B97\u7684\u65F6\u5019\u4E5F\u4E0D\u8BA1\u7B97
            if (isInView) {
                this.set('cacheCanvasBBox', bbox);
            }
            else {
                this.set('cacheCanvasBBox', null);
            }
        }
    };
    ShapeBase.prototype._afterDraw = function () {
        this.cacheCanvasBBox();
        // \u7ED8\u5236\u540E\u6D88\u9664\u6807\u8BB0
        this.set('hasChanged', false);
        this.set('refresh', null);
    };
    ShapeBase.prototype.skipDraw = function () {
        this.set('cacheCanvasBBox', null);
        this.set('isInView', null);
        this.set('hasChanged', false);
    };
    /**
     * \u7ED8\u5236\u56FE\u5F62\u7684\u8DEF\u5F84
     * @param {CanvasRenderingContext2D} context \u4E0A\u4E0B\u6587
     */
    ShapeBase.prototype.drawPath = function (context) {
        this.createPath(context);
        this.strokeAndFill(context);
        this.afterDrawPath(context);
    };
    /**
     * @protected
     * \u586B\u5145\u56FE\u5F62
     * @param {CanvasRenderingContext2D} context context \u4E0A\u4E0B\u6587
     */
    ShapeBase.prototype.fill = function (context) {
        context.fill();
    };
    /**
     * @protected
     * \u7ED8\u5236\u56FE\u5F62\u8FB9\u6846
     * @param {CanvasRenderingContext2D} context context \u4E0A\u4E0B\u6587
     */
    ShapeBase.prototype.stroke = function (context) {
        context.stroke();
    };
    // \u7ED8\u5236\u6216\u8005\u586B\u5145
    ShapeBase.prototype.strokeAndFill = function (context) {
        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;
        if (this.isFill()) {
            if (!(0,esm/* isNil */.UM)(fillOpacity) && fillOpacity !== 1) {
                context.globalAlpha = fillOpacity;
                this.fill(context);
                context.globalAlpha = opacity;
            }
            else {
                this.fill(context);
            }
        }
        if (this.isStroke()) {
            if (lineWidth > 0) {
                if (!(0,esm/* isNil */.UM)(strokeOpacity) && strokeOpacity !== 1) {
                    context.globalAlpha = strokeOpacity;
                }
                this.stroke(context);
            }
        }
        this.afterDrawPath(context);
    };
    /**
     * @protected
     * \u7ED8\u5236\u56FE\u5F62\u7684\u8DEF\u5F84
     * @param {CanvasRenderingContext2D} context \u4E0A\u4E0B\u6587
     */
    ShapeBase.prototype.createPath = function (context) { };
    /**
     * \u7ED8\u5236\u5B8C\u6210 path \u540E\u7684\u64CD\u4F5C
     * @param {CanvasRenderingContext2D} context \u4E0A\u4E0B\u6587
     */
    ShapeBase.prototype.afterDrawPath = function (context) { };
    ShapeBase.prototype.isInShape = function (refX, refY) {
        // return HitUtil.isHitShape(this, refX, refY);
        var isStroke = this.isStroke();
        var isFill = this.isFill();
        var lineWidth = this.getHitLineWidth();
        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    // \u4E4B\u6240\u4EE5\u4E0D\u62C6\u6210 isInStroke \u548C isInPath \u5728\u4E8E\u4E24\u8005\u5B58\u5728\u4E00\u4E9B\u5171\u540C\u7684\u8BA1\u7B97
    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        return false;
    };
    /**
     * \u83B7\u53D6\u7EBF\u62FE\u53D6\u7684\u5BBD\u5EA6
     * @returns {number} \u7EBF\u7684\u62FE\u53D6\u5BBD\u5EA6
     */
    ShapeBase.prototype.getHitLineWidth = function () {
        if (!this.isStroke()) {
            return 0;
        }
        var attrs = this.attrs;
        return attrs['lineWidth'] + attrs['lineAppendWidth'];
    };
    return ShapeBase;
}(g_base_esm.AbstractShape));
/* harmony default export */ var shape_base = (base_ShapeBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/circle.js
/**
 * @fileoverview \u5706
 * @author dxq613@gmail.com
 */



var shape_circle_Circle = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        var attrs = this.attr();
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.r;
        var halfLineWidth = lineWidth / 2;
        var absDistance = util_util_distance(cx, cy, x, y);
        // \u76F4\u63A5\u7528\u8DDD\u79BB\uFF0C\u5982\u679C\u540C\u65F6\u5B58\u5728\u8FB9\u548C\u586B\u5145\u65F6\uFF0C\u53EF\u4EE5\u51CF\u5C11\u4E24\u6B21\u8BA1\u7B97
        if (isFill && isStroke) {
            return absDistance <= r + halfLineWidth;
        }
        if (isFill) {
            return absDistance <= r;
        }
        if (isStroke) {
            return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
        }
        return false;
    };
    Circle.prototype.createPath = function (context) {
        var attrs = this.attr();
        var cx = attrs.x;
        var cy = attrs.y;
        var r = attrs.r;
        context.beginPath();
        context.arc(cx, cy, r, 0, Math.PI * 2, false);
        context.closePath();
    };
    return Circle;
}(shape_base));
/* harmony default export */ var shape_circle = (shape_circle_Circle);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/ellipse.js
/**
 * @fileoverview \u692D\u5706
 * @author dxq613@gmail.com
 */


// \u6839\u636E\u692D\u5706\u516C\u5F0F\u8BA1\u7B97 x*x/rx*rx + y*y/ry*ry;
function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Ellipse, _super);
    function Ellipse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        var attrs = this.attr();
        var halfLineWith = lineWidth / 2;
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx, ry = attrs.ry;
        var squareX = (x - cx) * (x - cx);
        var squareY = (y - cy) * (y - cy);
        // \u4F7F\u7528\u692D\u5706\u7684\u516C\u5F0F\uFF1A x*x/rx*rx + y*y/ry*ry = 1;
        if (isFill && isStroke) {
            return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
        }
        if (isFill) {
            return ellipseDistance(squareX, squareY, rx, ry) <= 1;
        }
        if (isStroke) {
            return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&
                ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1);
        }
        return false;
    };
    Ellipse.prototype.createPath = function (context) {
        var attrs = this.attr();
        var cx = attrs.x;
        var cy = attrs.y;
        var rx = attrs.rx;
        var ry = attrs.ry;
        context.beginPath();
        // \u517C\u5BB9\u903B\u8F91
        if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
        }
        else {
            // \u5982\u679C\u4E0D\u652F\u6301\uFF0C\u5219\u4F7F\u7528\u5706\u6765\u7ED8\u5236\uFF0C\u8FDB\u884C\u53D8\u5F62
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.save();
            context.translate(cx, cy);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, 0, Math.PI * 2);
            context.restore();
            context.closePath();
        }
    };
    return Ellipse;
}(shape_base));
/* harmony default export */ var ellipse = (Ellipse);
//# sourceMappingURL=ellipse.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/image.js
/**
 * @fileoverview \u56FE\u7247
 * @author dxq613@gmail.com
 */



function isCanvas(dom) {
    return dom instanceof HTMLElement && (0,esm/* isString */.HD)(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';
}
var ImageShape = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ImageShape, _super);
    function ImageShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape.prototype.initAttrs = function (attrs) {
        this._setImage(attrs.img);
    };
    // image \u4E0D\u8BA1\u7B97 stroke
    ImageShape.prototype.isStroke = function () {
        return false;
    };
    // \u4EC5\u4EC5\u4F7F\u7528\u5305\u56F4\u76D2\u68C0\u6D4B\u6765\u8FDB\u884C\u62FE\u53D6
    // \u6240\u4EE5\u4E0D\u9700\u8981\u590D\u5199 isInStrokeOrPath \u7684\u65B9\u6CD5
    ImageShape.prototype.isOnlyHitBox = function () {
        return true;
    };
    ImageShape.prototype._afterLoading = function () {
        if (this.get('toDraw') === true) {
            var canvas = this.get('canvas');
            if (canvas) {
                // \u8FD9\u6BB5\u5E94\u8BE5\u6539\u6210\u5C40\u90E8\u6E32\u67D3
                canvas.draw();
            }
            else {
                // \u8FD9\u79CD\u65B9\u5F0F\u5982\u679C\u53D1\u751F\u906E\u6321\u4F1A\u51FA\u73B0\u95EE\u9898
                this.createPath(this.get('context'));
            }
        }
    };
    ImageShape.prototype._setImage = function (img) {
        var _this = this;
        var attrs = this.attrs;
        if ((0,esm/* isString */.HD)(img)) {
            var image_1 = new Image();
            image_1.onload = function () {
                // \u56FE\u7247\u672A\u52A0\u8F7D\u5B8C\uFF0C\u5219\u5DF2\u7ECF\u88AB\u9500\u6BC1
                if (_this.destroyed) {
                    return false;
                }
                // \u7F13\u5B58\u539F\u59CB\u5730\u5740\uFF0C\u53EF\u4EE5\u505A\u5BF9\u6BD4\uFF0C\u9632\u6B62\u91CD\u590D\u52A0\u8F7D\u56FE\u7247
                // \u5982\u679C\u8003\u8651\u5230\u5728\u52A0\u8F7D\u8FC7\u7A0B\u4E2D\u53EF\u80FD\u66FF\u6362 img \u5C5E\u6027\uFF0C\u5219\u60C5\u51B5\u66F4\u52A0\u590D\u6742
                // this.set('imgSrc', img);
                // \u8FD9\u91CC\u4F1A\u5FAA\u73AF\u8C03\u7528 _setImage \u65B9\u6CD5\uFF0C\u4F46\u4E0D\u4F1A\u518D\u8D70\u8FD9\u4E2A\u5206\u652F
                _this.attr('img', image_1);
                _this.set('loading', false);
                _this._afterLoading();
                var callback = _this.get('callback');
                if (callback) {
                    callback.call(_this);
                }
            };
            // \u8BBE\u7F6E\u8DE8\u57DF
            image_1.crossOrigin = 'Anonymous';
            image_1.src = img;
            // loading \u8FC7\u7A0B\u4E2D\u4E0D\u7ED8\u5236
            this.set('loading', true);
        }
        else if (img instanceof Image) {
            // \u5982\u679C\u662F\u4E00\u4E2A image \u5BF9\u8C61\uFF0C\u5219\u8BBE\u7F6E\u5BBD\u9AD8
            if (!attrs.width) {
                attrs.width = img.width;
            }
            if (!attrs.height) {
                attrs.height = img.height;
            }
        }
        else if (isCanvas(img)) {
            // \u5982\u679C\u8BBE\u7F6E\u4E86 canvas \u5BF9\u8C61
            if (!attrs.width) {
                attrs.width = Number(img.getAttribute('width'));
            }
            if (!attrs.height) {
                attrs.height, Number(img.getAttribute('height'));
            }
        }
    };
    ImageShape.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        // \u5982\u679C\u52A0\u8F7D\u7684\u5DF2\u7ECF\u662F\u5F53\u524D\u56FE\u7247\uFF0C\u5219\u4E0D\u518D\u5904\u7406
        if (name === 'img') {
            // \u53EF\u4EE5\u52A0\u7F13\u51B2\uFF0C&& this.get('imgSrc') !== value
            this._setImage(value);
        }
    };
    ImageShape.prototype.createPath = function (context) {
        // \u6B63\u5728\u52A0\u8F7D\u5219\u4E0D\u7ED8\u5236
        if (this.get('loading')) {
            this.set('toDraw', true); // \u52A0\u8F7D\u5B8C\u6210\u540E\u7ED8\u5236
            this.set('context', context);
            return;
        }
        var attrs = this.attr();
        var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
        var img = attrs.img;
        if (img instanceof Image || isCanvas(img)) {
            if (!(0,esm/* isNil */.UM)(sx) && !(0,esm/* isNil */.UM)(sy) && !(0,esm/* isNil */.UM)(swidth) && !(0,esm/* isNil */.UM)(sheight)) {
                context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
            }
            else {
                context.drawImage(img, x, y, width, height);
            }
        }
    };
    return ImageShape;
}(shape_base));
/* harmony default export */ var shape_image = (ImageShape);
//# sourceMappingURL=image.js.map
// EXTERNAL MODULE: ./node_modules/@antv/g-math/esm/index.js + 10 modules
var g_math_esm = __webpack_require__(32793);
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-stroke/line.js

function inLine(x1, y1, x2, y2, lineWidth, x, y) {
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var halfWidth = lineWidth / 2;
    // \u56E0\u4E3A\u76EE\u524D\u7684\u65B9\u6848\u662F\u8BA1\u7B97\u70B9\u5230\u76F4\u7EBF\u7684\u8DDD\u79BB\uFF0C\u800C\u6709\u53EF\u80FD\u4F1A\u5728\u5EF6\u957F\u7EBF\u4E0A\uFF0C\u6240\u4EE5\u8981\u5148\u5224\u65AD\u662F\u5426\u5728\u5305\u56F4\u76D2\u5185
    // \u8FD9\u79CD\u65B9\u6848\u4F1A\u5728\u6C34\u5E73\u6216\u8005\u7AD6\u76F4\u7684\u60C5\u51B5\u4E0B\u8F7D\u7EBF\u7684\u5EF6\u957F\u7EBF\u4E0A\u6709\u534A lineWidth \u7684\u8BEF\u5DEE
    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
        return false;
    }
    // \u56E0\u4E3A\u5DF2\u7ECF\u8BA1\u7B97\u4E86\u5305\u56F4\u76D2\uFF0C\u6240\u4EE5\u4EC5\u9700\u8981\u8BA1\u7B97\u5230\u76F4\u7EBF\u7684\u8DDD\u79BB\u5373\u53EF\uFF0C\u53EF\u4EE5\u663E\u8457\u63D0\u5347\u6027\u80FD
    return g_math_esm/* Line.pointToLine */.x1.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/line.js

/**
 * @fileoverview \u7EBF
 * @author dxq613@gmail.com
 */




var shape_line_Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Line.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line.prototype.initAttrs = function (attrs) {
        this.setArrow();
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86\u7BAD\u5934
    Line.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        // \u7531\u4E8E\u7BAD\u5934\u7684\u7ED8\u5236\u4F9D\u8D56\u4E8E line \u7684\u8BF8\u591A attrs\uFF0C\u56E0\u6B64\u8FD9\u91CC\u4E0D\u518D\u5BF9\u6BCF\u4E2A attr \u8FDB\u884C\u5224\u65AD\uFF0Cattr \u6BCF\u6B21\u53D8\u5316\u90FD\u4F1A\u5F71\u54CD\u7BAD\u5934\u7684\u66F4\u65B0
        this.setArrow();
    };
    Line.prototype.setArrow = function () {
        var attrs = this.attr();
        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
        if (startArrow) {
            addStartArrow(this, attrs, x2, y2, x1, y1);
        }
        if (endArrow) {
            addEndArrow(this, attrs, x1, y1, x2, y2);
        }
    };
    Line.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        if (!isStroke || !lineWidth) {
            return false;
        }
        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
        return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line.prototype.createPath = function (context) {
        var attrs = this.attr();
        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
        var startArrowDistance = {
            dx: 0,
            dy: 0,
        };
        var endArrowDistance = {
            dx: 0,
            dy: 0,
        };
        if (startArrow && startArrow.d) {
            startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
        }
        if (endArrow && endArrow.d) {
            endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
        }
        context.beginPath();
        // \u5982\u679C\u81EA\u5B9A\u4E49\u7BAD\u5934\uFF0C\u7EBF\u6761\u76F8\u5E94\u7F29\u8FDB
        context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
        context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line.prototype.afterDrawPath = function (context) {
        var startArrowShape = this.get('startArrowShape');
        var endArrowShape = this.get('endArrowShape');
        if (startArrowShape) {
            startArrowShape.draw(context);
        }
        if (endArrowShape) {
            endArrowShape.draw(context);
        }
    };
    /**
     * Get length of line
     * @return {number} length
     */
    Line.prototype.getTotalLength = function () {
        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
        return g_math_esm/* Line.length */.x1.length(x1, y1, x2, y2);
    };
    /**
     * Get point according to ratio
     * @param {number} ratio
     * @return {Point} point
     */
    Line.prototype.getPoint = function (ratio) {
        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
        return g_math_esm/* Line.pointAt */.x1.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line;
}(shape_base));
/* harmony default export */ var esm_shape_line = (shape_line_Line);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/marker.js
/**
 * @fileoverview Marker
 * @author dxq613@gmail.com
 */






var Symbols = {
    // \u5706
    circle: function (x, y, r) {
        return [
            ['M', x - r, y],
            ['A', r, r, 0, 1, 0, x + r, y],
            ['A', r, r, 0, 1, 0, x - r, y],
        ];
    },
    // \u6B63\u65B9\u5F62
    square: function (x, y, r) {
        return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
    },
    // \u83F1\u5F62
    diamond: function (x, y, r) {
        return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
    },
    // \u4E09\u89D2\u5F62
    triangle: function (x, y, r) {
        var diffY = r * Math.sin((1 / 3) * Math.PI);
        return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];
    },
    // \u5012\u4E09\u89D2\u5F62
    'triangle-down': function (x, y, r) {
        var diffY = r * Math.sin((1 / 3) * Math.PI);
        return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
    },
};
var Marker = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Marker, _super);
    function Marker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker.prototype.initAttrs = function (attrs) {
        this._resetParamsCache();
    };
    // \u91CD\u7F6E\u7ED8\u5236 path \u5B58\u50A8\u7684\u7F13\u5B58
    Marker.prototype._resetParamsCache = function () {
        // \u4E3A\u4E86\u52A0\u901F path \u7684\u7ED8\u5236\u3001\u62FE\u53D6\u548C\u8BA1\u7B97\uFF0C\u8FD9\u4E2A\u5730\u65B9\u53EF\u4EE5\u7F13\u5B58\u5F88\u591A\u4E1C\u897F
        // \u8FD9\u4E9B\u7F13\u5B58\u90FD\u662F\u7B2C\u4E00\u6B21\u9700\u8981\u65F6\u8BA1\u7B97\u548C\u5B58\u50A8\uFF0C\u867D\u7136\u589E\u52A0\u4E86\u590D\u6742\u5EA6\uFF0C\u4F46\u662F\u9891\u7E41\u8C03\u7528\u7684\u65B9\u6CD5\uFF0C\u6027\u80FD\u6709\u5F88\u5927\u63D0\u5347
        this.set('paramsCache', {}); // \u6E05\u7406\u7F13\u5B58
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86 path
    Marker.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {
            // path \u76F8\u5173\u5C5E\u6027\u66F4\u6539\u65F6\uFF0C\u6E05\u7406\u7F13\u5B58
            this._resetParamsCache();
        }
    };
    // \u4EC5\u4EC5\u4F7F\u7528\u5305\u56F4\u76D2\u68C0\u6D4B\u6765\u8FDB\u884C\u62FE\u53D6
    // \u6240\u4EE5\u4E0D\u9700\u8981\u590D\u5199 isInStrokeOrPath \u7684\u65B9\u6CD5
    Marker.prototype.isOnlyHitBox = function () {
        return true;
    };
    Marker.prototype._getR = function (attrs) {
        // \u517C\u5BB9 r \u548C radius \u4E24\u79CD\u5199\u6CD5\uFF0C\u63A8\u8350\u4F7F\u7528 r
        return (0,esm/* isNil */.UM)(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker.prototype._getPath = function () {
        var attrs = this.attr();
        var x = attrs.x, y = attrs.y;
        var symbol = attrs.symbol || 'circle';
        var r = this._getR(attrs);
        var method;
        var path;
        if ((0,esm/* isFunction */.mf)(symbol)) {
            method = symbol;
            path = method(x, y, r);
            // \u5C06 path \u8F6C\u6210\u7EDD\u5BF9\u8DEF\u5F84
            path = (0,path_util_esm/* path2Absolute */.wb)(path);
        }
        else {
            // \u5185\u7F6E symbol \u7684 path \u90FD\u662F\u7EDD\u5BF9\u8DEF\u5F84\uFF0C\u76F4\u63A5\u7ED8\u5236\u5373\u53EF\uFF0C\u4E0D\u9700\u8981\u5BF9 path \u8FDB\u884C\u7279\u6B8A\u5904\u7406
            method = Marker.Symbols[symbol];
            if (!method) {
                console.warn(symbol + " marker is not supported.");
                return null;
            }
            path = method(x, y, r);
        }
        return path;
    };
    Marker.prototype.createPath = function (context) {
        var path = this._getPath();
        var paramsCache = this.get('paramsCache');
        drawPath(this, context, { path: path }, paramsCache);
    };
    Marker.Symbols = Symbols;
    return Marker;
}(shape_base));
/* harmony default export */ var marker = (Marker);
//# sourceMappingURL=marker.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js

function isPointInPath(shape, x, y) {
    var ctx = (0,g_base_esm.getOffScreenContext)();
    shape.createPath(ctx);
    return ctx.isPointInPath(x, y);
}
//# sourceMappingURL=point-in-path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
/**
 * @fileoverview \u5224\u65AD\u70B9\u662F\u5426\u5728\u591A\u8FB9\u5F62\u5185
 * @author dxq613@gmail.com
 */
// \u591A\u8FB9\u5F62\u7684\u5C04\u7EBF\u68C0\u6D4B\uFF0C\u53C2\u8003\uFF1Ahttps://blog.csdn.net/WilliamSun0122/article/details/77994526
var tolerance = 1e-6;
// \u4E09\u6001\u51FD\u6570\uFF0C\u5224\u65AD\u4E24\u4E2Adouble\u5728eps\u7CBE\u5EA6\u4E0B\u7684\u5927\u5C0F\u5173\u7CFB
function dcmp(x) {
    if (Math.abs(x) < tolerance) {
        return 0;
    }
    return x < 0 ? -1 : 1;
}
// \u5224\u65AD\u70B9Q\u662F\u5426\u5728p1\u548Cp2\u7684\u7EBF\u6BB5\u4E0A
function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&
        Math.min(p1[0], p2[0]) <= q[0] &&
        q[0] <= Math.max(p1[0], p2[0]) &&
        Math.min(p1[1], p2[1]) <= q[1] &&
        q[1] <= Math.max(p1[1], p2[1])) {
        return true;
    }
    return false;
}
// \u5224\u65AD\u70B9P\u5728\u591A\u8FB9\u5F62\u5185-\u5C04\u7EBF\u6CD5
function isInPolygon(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
        // svg \u4E2D\u70B9\u5C0F\u4E8E 3 \u4E2A\u65F6\uFF0C\u4E0D\u663E\u793A\uFF0C\u4E5F\u65E0\u6CD5\u88AB\u62FE\u53D6
        return false;
    }
    for (var i = 0; i < n; i++) {
        var p1 = points[i];
        var p2 = points[(i + 1) % n];
        if (onSegment(p1, p2, [x, y])) {
            // \u70B9\u5728\u591A\u8FB9\u5F62\u4E00\u6761\u8FB9\u4E0A
            return true;
        }
        // \u524D\u4E00\u4E2A\u5224\u65ADmin(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
        // \u540E\u4E00\u4E2A\u5224\u65AD\u88AB\u6D4B\u70B9 \u5728 \u5C04\u7EBF\u4E0E\u8FB9\u4EA4\u70B9 \u7684\u5DE6\u8FB9
        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&
            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {
            isHit = !isHit;
        }
    }
    return isHit;
}
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js

function arc_arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // \u8F6C\u6362\u5230 0 - 2 * Math.PI \u4E4B\u95F4
    if (angle < startAngle || angle > endAngle) {
        return false;
    }
    var point = {
        x: cx + r * Math.cos(angle),
        y: cy + r * Math.sin(angle),
    };
    return util_util_distance(point.x, point.y, x, y) <= lineWidth / 2;
}
//# sourceMappingURL=arc.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/path.js

/**
 * @fileoverview path \u7684\u4E00\u4E9B\u5DE5\u5177
 * @author dxq613@gmail.com
 */








var path_transform = ext/* transform */.vs;
function hasArc(path) {
    var hasArc = false;
    var count = path.length;
    for (var i = 0; i < count; i++) {
        var params = path[i];
        var cmd = params[0];
        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
            hasArc = true;
            break;
        }
    }
    return hasArc;
}
function isPointInStroke(segments, lineWidth, x, y, length) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;
        // \u5982\u679C\u5728\u524D\u9762\u5DF2\u7ECF\u751F\u6210\u8FC7\u5305\u56F4\u76D2\uFF0C\u76F4\u63A5\u6309\u7167\u5305\u56F4\u76D2\u8BA1\u7B97
        if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {
            continue;
        }
        switch (segment.command) {
            // L \u548C Z \u90FD\u662F\u76F4\u7EBF\uFF0C M \u4E0D\u8FDB\u884C\u62FE\u53D6
            case 'L':
            case 'Z':
                isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
                break;
            case 'Q':
                var qDistance = g_math_esm/* Quad.pointDistance */.lD.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
                isHit = qDistance <= lineWidth / 2;
                break;
            case 'C':
                var cDistance = g_math_esm/* Cubic.pointDistance */.Ll.pointDistance(prePoint[0], // \u4E0A\u4E00\u6BB5\u7ED3\u675F\u4F4D\u7F6E, \u5373 C \u7684\u8D77\u59CB\u70B9
                prePoint[1], params[1], // 'C' \u7684\u53C2\u6570\uFF0C1\u30012 \u4E3A\u7B2C\u4E00\u4E2A\u63A7\u5236\u70B9\uFF0C3\u30014 \u4E3A\u7B2C\u4E8C\u4E2A\u63A7\u5236\u70B9\uFF0C5\u30016 \u4E3A\u7ED3\u675F\u70B9
                params[2], params[3], params[4], params[5], params[6], x, y, length);
                isHit = cDistance <= lineWidth / 2;
                break;
            case 'A':
                // \u8BA1\u7B97\u70B9\u5230\u692D\u5706\u5706\u5F27\u7684\u8DDD\u79BB\uFF0C\u6682\u65F6\u4F7F\u7528\u8FD1\u4F3C\u7B97\u6CD5\uFF0C\u540E\u9762\u53EF\u4EE5\u6539\u6210\u5207\u5272\u6CD5\u6C42\u6700\u8FD1\u8DDD\u79BB
                var arcParams = segment.arcParams;
                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
                var p = [x, y, 1];
                var r = rx > ry ? rx : ry;
                var scaleX = rx > ry ? 1 : rx / ry;
                var scaleY = rx > ry ? ry / rx : 1;
                var m = path_transform(null, [
                    ['t', -cx, -cy],
                    ['r', -xRotation],
                    ['s', 1 / scaleX, 1 / scaleY],
                ]);
                transformMat3(p, p, m);
                isHit = arc_arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
                break;
            default:
                break;
        }
        if (isHit) {
            break;
        }
    }
    return isHit;
}
/**
 * \u63D0\u53D6\u51FA\u5185\u90E8\u7684\u95ED\u5408\u591A\u8FB9\u5F62\u548C\u975E\u95ED\u5408\u7684\u591A\u8FB9\u5F62\uFF0C\u5047\u8BBE path \u4E0D\u5B58\u5728\u5706\u5F27
 * @param {Array} path \u8DEF\u5F84
 * @returns {Array} \u70B9\u7684\u96C6\u5408
 */
function extractPolygons(path) {
    var count = path.length;
    var polygons = [];
    var polylines = [];
    var points = []; // \u9632\u6B62\u7B2C\u4E00\u4E2A\u547D\u4EE4\u4E0D\u662F 'M'
    for (var i = 0; i < count; i++) {
        var params = path[i];
        var cmd = params[0];
        if (cmd === 'M') {
            // \u9047\u5230 'M' \u5224\u5B9A\u662F\u5426\u662F\u65B0\u6570\u7EC4\uFF0C\u65B0\u6570\u7EC4\u4E2D\u6CA1\u6709\u70B9
            if (points.length) {
                // \u5982\u679C\u5B58\u5728\u70B9\uFF0C\u5219\u8BF4\u660E\u6CA1\u6709\u9047\u5230 'Z'\uFF0C\u5F00\u59CB\u4E86\u4E00\u4E2A\u65B0\u7684\u591A\u8FB9\u5F62
                polylines.push(points);
                points = []; // \u521B\u5EFA\u65B0\u7684\u70B9
            }
            points.push([params[1], params[2]]);
        }
        else if (cmd === 'Z') {
            if (points.length) {
                // \u5B58\u5728\u70B9
                polygons.push(points);
                points = []; // \u5F00\u59CB\u65B0\u7684\u70B9\u96C6\u5408
            }
            // \u5982\u679C\u4E0D\u5B58\u5728\u70B9\uFF0C\u540C\u65F6 'Z'\uFF0C\u5219\u8BF4\u660E\u662F\u9519\u8BEF\uFF0C\u4E0D\u5904\u7406
        }
        else {
            points.push([params[1], params[2]]);
        }
    }
    // \u8BF4\u660E points \u672A\u653E\u5165 polygons \u6216\u8005 polyline
    // \u4EC5\u5F53\u53EA\u6709\u4E00\u4E2A M\uFF0C\u6CA1\u6709 Z \u65F6\u4F1A\u53D1\u751F\u8FD9\u79CD\u60C5\u51B5
    if (points.length > 0) {
        polylines.push(points);
    }
    return {
        polygons: polygons,
        polylines: polylines,
    };
}
/* harmony default export */ var util_path = ((0,tslib_es6/* __assign */.pi)({ hasArc: hasArc,
    extractPolygons: extractPolygons,
    isPointInStroke: isPointInStroke }, g_base_esm.PathUtil));
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/path.js










// \u662F\u5426\u5728\u591A\u4E2A\u591A\u8FB9\u5F62\u5185\u90E8
function isInPolygons(polygons, x, y) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
        var points = polygons[i];
        isHit = isInPolygon(points, x, y);
        if (isHit) {
            break;
        }
    }
    return isHit;
}
var Path = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Path, _super);
    function Path() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Path.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { startArrow: false, endArrow: false });
    };
    Path.prototype.initAttrs = function (attrs) {
        this._setPathArr(attrs.path);
        this.setArrow();
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86 path
    Path.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        if (name === 'path') {
            this._setPathArr(value);
        }
        // \u7531\u4E8E\u7BAD\u5934\u7684\u7ED8\u5236\u4F9D\u8D56\u4E8E line \u7684\u8BF8\u591A attrs\uFF0C\u56E0\u6B64\u8FD9\u91CC\u4E0D\u518D\u5BF9\u6BCF\u4E2A attr \u8FDB\u884C\u5224\u65AD\uFF0Cattr \u6BCF\u6B21\u53D8\u5316\u90FD\u4F1A\u5F71\u54CD\u7BAD\u5934\u7684\u66F4\u65B0
        this.setArrow();
    };
    // \u5C06 path \u8F6C\u6362\u6210\u7EDD\u5BF9\u8DEF\u5F84
    Path.prototype._setPathArr = function (path) {
        // \u8F6C\u6362 path \u7684\u683C\u5F0F
        this.attrs.path = (0,path_util_esm/* path2Absolute */.wb)(path);
        var hasArc = util_path.hasArc(path);
        // \u4E3A\u4E86\u52A0\u901F path \u7684\u7ED8\u5236\u3001\u62FE\u53D6\u548C\u8BA1\u7B97\uFF0C\u8FD9\u4E2A\u5730\u65B9\u53EF\u4EE5\u7F13\u5B58\u5F88\u591A\u4E1C\u897F
        // \u8FD9\u4E9B\u7F13\u5B58\u90FD\u662F\u7B2C\u4E00\u6B21\u9700\u8981\u65F6\u8BA1\u7B97\u548C\u5B58\u50A8\uFF0C\u867D\u7136\u589E\u52A0\u4E86\u590D\u6742\u5EA6\uFF0C\u4F46\u662F\u9891\u7E41\u8C03\u7528\u7684\u65B9\u6CD5\uFF0C\u6027\u80FD\u6709\u5F88\u5927\u63D0\u5347
        this.set('hasArc', hasArc);
        this.set('paramsCache', {}); // \u6E05\u7406\u7F13\u5B58
        this.set('segments', null); // \u5EF6\u8FDF\u751F\u6210 path\uFF0C\u5728\u52A8\u753B\u573A\u666F\u4E0B\u53EF\u80FD\u4E0D\u4F1A\u6709\u62FE\u53D6
        this.set('curve', null);
        this.set('tCache', null);
        this.set('totalLength', null);
    };
    Path.prototype.getSegments = function () {
        var segments = this.get('segements');
        if (!segments) {
            segments = (0,path_util_esm/* path2Segments */.zx)(this.attr('path'));
            this.set('segments', segments);
        }
        return segments;
    };
    Path.prototype.setArrow = function () {
        var attrs = this.attr();
        var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
        if (startArrow) {
            var tangent = this.getStartTangent();
            addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
        }
        if (endArrow) {
            var tangent = this.getEndTangent();
            addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
        }
    };
    Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        var segments = this.getSegments();
        var hasArc = this.get('hasArc');
        var isHit = false;
        if (isStroke) {
            var length_1 = this.getTotalLength();
            isHit = util_path.isPointInStroke(segments, lineWidth, x, y, length_1);
        }
        if (!isHit && isFill) {
            if (hasArc) {
                // \u5B58\u5728\u66F2\u7EBF\u65F6\uFF0C\u6682\u65F6\u4F7F\u7528 canvas \u7684 api \u8BA1\u7B97\uFF0C\u540E\u7EED\u53EF\u4EE5\u8FDB\u884C\u591A\u8FB9\u5F62\u5207\u5272
                isHit = isPointInPath(this, x, y);
            }
            else {
                var path = this.attr('path');
                var extractResutl = util_path.extractPolygons(path);
                // \u63D0\u53D6\u51FA\u6765\u7684\u591A\u8FB9\u5F62\u5305\u542B\u95ED\u5408\u7684\u548C\u975E\u95ED\u5408\u7684\uFF0C\u5728\u8FD9\u91CC\u7EDF\u4E00\u6309\u7167\u591A\u8FB9\u5F62\u5904\u7406
                isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
            }
        }
        return isHit;
    };
    Path.prototype.createPath = function (context) {
        var attrs = this.attr();
        var paramsCache = this.get('paramsCache'); // \u7531\u4E8E\u8BA1\u7B97\u5706\u5F27\u7684\u53C2\u6570\u6210\u672C\u5F88\u5927\uFF0C\u6240\u4EE5\u8981\u7F13\u5B58
        drawPath(this, context, attrs, paramsCache);
    };
    Path.prototype.afterDrawPath = function (context) {
        var startArrowShape = this.get('startArrowShape');
        var endArrowShape = this.get('endArrowShape');
        if (startArrowShape) {
            startArrowShape.draw(context);
        }
        if (endArrowShape) {
            endArrowShape.draw(context);
        }
    };
    /**
     * Get total length of path
     * @return {number} length
     */
    Path.prototype.getTotalLength = function () {
        var totalLength = this.get('totalLength');
        if (!(0,esm/* isNil */.UM)(totalLength)) {
            return totalLength;
        }
        this._calculateCurve();
        this._setTcache();
        return this.get('totalLength');
    };
    /**
     * Get point according to ratio
     * @param {number} ratio
     * @return {Point} point
     */
    Path.prototype.getPoint = function (ratio) {
        var tCache = this.get('tCache');
        if (!tCache) {
            this._calculateCurve();
            this._setTcache();
            tCache = this.get('tCache');
        }
        var subt;
        var index;
        var curve = this.get('curve');
        if (!tCache || tCache.length === 0) {
            if (curve) {
                return {
                    x: curve[0][1],
                    y: curve[0][2],
                };
            }
            return null;
        }
        (0,esm/* each */.S6)(tCache, function (v, i) {
            if (ratio >= v[0] && ratio <= v[1]) {
                subt = (ratio - v[0]) / (v[1] - v[0]);
                index = i;
            }
        });
        var seg = curve[index];
        if ((0,esm/* isNil */.UM)(seg) || (0,esm/* isNil */.UM)(index)) {
            return null;
        }
        var l = seg.length;
        var nextSeg = curve[index + 1];
        return g_math_esm/* Cubic.pointAt */.Ll.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path.prototype._calculateCurve = function () {
        var path = this.attr().path;
        this.set('curve', util_path.pathToCurve(path));
    };
    Path.prototype._setTcache = function () {
        var totalLength = 0;
        var tempLength = 0;
        // \u6BCF\u6BB5 curve \u5BF9\u5E94\u8D77\u6B62\u70B9\u7684\u957F\u5EA6\u6BD4\u4F8B\u5217\u8868\uFF0C\u5F62\u5982: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]
        var tCache = [];
        var segmentT;
        var segmentL;
        var segmentN;
        var l;
        var curve = this.get('curve');
        if (!curve) {
            return;
        }
        (0,esm/* each */.S6)(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;
            if (segmentN) {
                totalLength +=
                    g_math_esm/* Cubic.length */.Ll.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
            }
        });
        this.set('totalLength', totalLength);
        if (totalLength === 0) {
            this.set('tCache', []);
            return;
        }
        (0,esm/* each */.S6)(curve, function (segment, i) {
            segmentN = curve[i + 1];
            l = segment.length;
            if (segmentN) {
                segmentT = [];
                segmentT[0] = tempLength / totalLength;
                segmentL = g_math_esm/* Cubic.length */.Ll.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
                // \u5F53 path \u4E0D\u8FDE\u7EED\u65F6\uFF0CsegmentL \u53EF\u80FD\u4E3A\u7A7A\uFF0C\u4E3A\u7A7A\u65F6\u9700\u8981\u4F5C\u4E3A 0 \u5904\u7406
                tempLength += segmentL || 0;
                segmentT[1] = tempLength / totalLength;
                tCache.push(segmentT);
            }
        });
        this.set('tCache', tCache);
    };
    /**
     * Get start tangent vector
     * @return {Array}
     */
    Path.prototype.getStartTangent = function () {
        var segments = this.getSegments();
        var result;
        if (segments.length > 1) {
            var startPoint = segments[0].currentPoint;
            var endPoint = segments[1].currentPoint;
            var tangent = segments[1].startTangent;
            result = [];
            if (tangent) {
                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
                result.push([startPoint[0], startPoint[1]]);
            }
            else {
                result.push([endPoint[0], endPoint[1]]);
                result.push([startPoint[0], startPoint[1]]);
            }
        }
        return result;
    };
    /**
     * Get end tangent vector
     * @return {Array}
     */
    Path.prototype.getEndTangent = function () {
        var segments = this.getSegments();
        var length = segments.length;
        var result;
        if (length > 1) {
            var startPoint = segments[length - 2].currentPoint;
            var endPoint = segments[length - 1].currentPoint;
            var tangent = segments[length - 1].endTangent;
            result = [];
            if (tangent) {
                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
                result.push([endPoint[0], endPoint[1]]);
            }
            else {
                result.push([startPoint[0], startPoint[1]]);
                result.push([endPoint[0], endPoint[1]]);
            }
        }
        return result;
    };
    return Path;
}(shape_base));
/* harmony default export */ var path = (Path);
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js

function inPolyline(points, lineWidth, x, y, isClose) {
    var count = points.length;
    if (count < 2) {
        return false;
    }
    for (var i = 0; i < count - 1; i++) {
        var x1 = points[i][0];
        var y1 = points[i][1];
        var x2 = points[i + 1][0];
        var y2 = points[i + 1][1];
        if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
            return true;
        }
    }
    // \u5982\u679C\u5C01\u95ED\uFF0C\u5219\u8BA1\u7B97\u8D77\u59CB\u70B9\u548C\u7ED3\u675F\u70B9\u7684\u8FB9
    if (isClose) {
        var first = points[0];
        var last = points[count - 1];
        if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=polyline.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/polygon.js
/**
 * @fileoverview \u591A\u8FB9\u5F62
 * @author dxq613@gmail.com
 */




var Polygon = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Polygon, _super);
    function Polygon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        var points = this.attr().points;
        var isHit = false;
        if (isStroke) {
            isHit = inPolyline(points, lineWidth, x, y, true);
        }
        if (!isHit && isFill) {
            isHit = isInPolygon(points, x, y); // isPointInPath(shape, x, y);
        }
        return isHit;
    };
    Polygon.prototype.createPath = function (context) {
        var attrs = this.attr();
        var points = attrs.points;
        if (points.length < 2) {
            return;
        }
        context.beginPath();
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            if (i === 0) {
                context.moveTo(point[0], point[1]);
            }
            else {
                context.lineTo(point[0], point[1]);
            }
        }
        context.closePath();
    };
    return Polygon;
}(shape_base));
/* harmony default export */ var polygon = (Polygon);
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/polyline.js







var PolyLine = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PolyLine, _super);
    function PolyLine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine.prototype.initAttrs = function (attrs) {
        this.setArrow();
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86 points
    PolyLine.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        this.setArrow();
        if (['points'].indexOf(name) !== -1) {
            this._resetCache();
        }
    };
    PolyLine.prototype._resetCache = function () {
        this.set('totalLength', null);
        this.set('tCache', null);
    };
    PolyLine.prototype.setArrow = function () {
        var attrs = this.attr();
        var _a = this.attrs, points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;
        var length = points.length;
        var x1 = points[0][0];
        var y1 = points[0][1];
        var x2 = points[length - 1][0];
        var y2 = points[length - 1][1];
        if (startArrow) {
            addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
        }
        if (endArrow) {
            addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);
        }
    };
    // \u4E0D\u5141\u8BB8 fill
    PolyLine.prototype.isFill = function () {
        return false;
    };
    PolyLine.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        // \u6CA1\u6709\u8BBE\u7F6E stroke \u4E0D\u80FD\u88AB\u62FE\u53D6, \u6CA1\u6709\u7EBF\u5BBD\u4E0D\u80FD\u88AB\u62FE\u53D6
        if (!isStroke || !lineWidth) {
            return false;
        }
        var points = this.attr().points;
        return inPolyline(points, lineWidth, x, y, false);
    };
    // \u59CB\u7EC8\u586B\u5145
    PolyLine.prototype.isStroke = function () {
        return true;
    };
    PolyLine.prototype.createPath = function (context) {
        var _a = this.attr(), points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;
        var length = points.length;
        if (points.length < 2) {
            return;
        }
        var x1 = points[0][0];
        var y1 = points[0][1];
        var x2 = points[length - 1][0];
        var y2 = points[length - 1][1];
        // \u5982\u679C\u5B9A\u4E49\u4E86\u7BAD\u5934\uFF0C\u5E76\u4E14\u662F\u81EA\u5B9A\u4E49\u7BAD\u5934\uFF0C\u7EBF\u6761\u76F8\u5E94\u7F29\u8FDB
        if (startArrow && startArrow.d) {
            var distance = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
            x1 += distance.dx;
            y1 += distance.dy;
        }
        if (endArrow && endArrow.d) {
            var distance = getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);
            x2 -= distance.dx;
            y2 -= distance.dy;
        }
        context.beginPath();
        context.moveTo(x1, y1);
        for (var i = 0; i < length - 1; i++) {
            var point = points[i];
            context.lineTo(point[0], point[1]);
        }
        context.lineTo(x2, y2);
    };
    PolyLine.prototype.afterDrawPath = function (context) {
        var startArrowShape = this.get('startArrowShape');
        var endArrowShape = this.get('endArrowShape');
        if (startArrowShape) {
            startArrowShape.draw(context);
        }
        if (endArrowShape) {
            endArrowShape.draw(context);
        }
    };
    /**
     * Get length of polyline
     * @return {number} length
     */
    PolyLine.prototype.getTotalLength = function () {
        var points = this.attr().points;
        // get totalLength from cache
        var totalLength = this.get('totalLength');
        if (!(0,esm/* isNil */.UM)(totalLength)) {
            return totalLength;
        }
        this.set('totalLength', g_math_esm/* Polyline.length */.aH.length(points));
        return this.get('totalLength');
    };
    /**
     * Get point according to ratio
     * @param {number} ratio
     * @return {Point} point
     */
    PolyLine.prototype.getPoint = function (ratio) {
        var points = this.attr().points;
        // get tCache from cache
        var tCache = this.get('tCache');
        if (!tCache) {
            this._setTcache();
            tCache = this.get('tCache');
        }
        var subt;
        var index;
        (0,esm/* each */.S6)(tCache, function (v, i) {
            if (ratio >= v[0] && ratio <= v[1]) {
                subt = (ratio - v[0]) / (v[1] - v[0]);
                index = i;
            }
        });
        return g_math_esm/* Line.pointAt */.x1.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    PolyLine.prototype._setTcache = function () {
        var points = this.attr().points;
        if (!points || points.length === 0) {
            return;
        }
        var totalLength = this.getTotalLength();
        if (totalLength <= 0) {
            return;
        }
        var tempLength = 0;
        var tCache = [];
        var segmentT;
        var segmentL;
        (0,esm/* each */.S6)(points, function (p, i) {
            if (points[i + 1]) {
                segmentT = [];
                segmentT[0] = tempLength / totalLength;
                segmentL = g_math_esm/* Line.length */.x1.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
                tempLength += segmentL;
                segmentT[1] = tempLength / totalLength;
                tCache.push(segmentT);
            }
        });
        this.set('tCache', tCache);
    };
    /**
     * Get start tangent vector
     * @return {Array}
     */
    PolyLine.prototype.getStartTangent = function () {
        var points = this.attr().points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
    };
    /**
     * Get end tangent vector
     * @return {Array}
     */
    PolyLine.prototype.getEndTangent = function () {
        var points = this.attr().points;
        var l = points.length - 1;
        var result = [];
        result.push([points[l - 1][0], points[l - 1][1]]);
        result.push([points[l][0], points[l][1]]);
        return result;
    };
    return PolyLine;
}(shape_base));
/* harmony default export */ var polyline = (PolyLine);
//# sourceMappingURL=polyline.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js

function inRect(minX, minY, width, height, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    // \u5C06\u56DB\u4E2A\u8FB9\u770B\u505A\u77E9\u5F62\u6765\u68C0\u6D4B\uFF0C\u6BD4\u8FB9\u7684\u68C0\u6D4B\u7B97\u6CD5\u8981\u5FEB
    return (inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // \u4E0A\u8FB9
        inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // \u53F3\u8FB9
        inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // \u4E0B\u8FB9
        inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)); // \u5DE6\u8FB9
}
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js


function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    return (inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) ||
        inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) ||
        inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) ||
        inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) ||
        arc_arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||
        arc_arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) ||
        arc_arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||
        arc_arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y));
}
//# sourceMappingURL=rect-radius.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/rect.js
/**
 * @fileoverview \u77E9\u5F62
 * @author dxq613@gmail.com
 */







var Rect = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Rect, _super);
    function Rect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
        var attrs = this.attr();
        var minX = attrs.x;
        var minY = attrs.y;
        var width = attrs.width;
        var height = attrs.height;
        var radius = attrs.radius;
        // \u65E0\u5706\u89D2\u65F6\u7684\u7B56\u7565
        if (!radius) {
            var halfWidth = lineWidth / 2;
            // \u540C\u65F6\u586B\u5145\u548C\u5E26\u6709\u8FB9\u6846
            if (isFill && isStroke) {
                return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
            }
            // \u4EC5\u586B\u5145
            if (isFill) {
                return inBox(minX, minY, width, height, x, y);
            }
            if (isStroke) {
                return inRect(minX, minY, width, height, lineWidth, x, y);
            }
        }
        else {
            var isHit = false;
            if (isStroke) {
                isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
            }
            // \u4EC5\u586B\u5145\u65F6\u5E26\u6709\u5706\u89D2\u7684\u77E9\u5F62\u76F4\u63A5\u901A\u8FC7\u56FE\u5F62\u62FE\u53D6
            // \u4EE5\u540E\u53EF\u4EE5\u6539\u6210\u7EAF\u6570\u5B66\u7684\u8FD1\u4F3C\u62FE\u53D6\uFF0C\u5C06\u5706\u5F27\u5207\u5272\u6210\u591A\u8FB9\u5F62
            if (!isHit && isFill) {
                isHit = isPointInPath(this, x, y);
            }
            return isHit;
        }
    };
    Rect.prototype.createPath = function (context) {
        var attrs = this.attr();
        var x = attrs.x;
        var y = attrs.y;
        var width = attrs.width;
        var height = attrs.height;
        var radius = attrs.radius;
        context.beginPath();
        if (radius === 0) {
            // \u6539\u6210\u539F\u751F\u7684rect\u65B9\u6CD5
            context.rect(x, y, width, height);
        }
        else {
            var _a = parseRadius(radius), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];
            context.moveTo(x + r1, y);
            context.lineTo(x + width - r2, y);
            r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
            context.lineTo(x + width, y + height - r3);
            r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
            context.lineTo(x + r4, y + height);
            r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
            context.lineTo(x, y + r1);
            r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
            context.closePath();
        }
    };
    return Rect;
}(shape_base));
/* harmony default export */ var rect = (Rect);
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/text.js
/**
 * @fileoverview \u6587\u672C
 * @author dxq613@gmail.com
 */




var Text = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // \u9ED8\u8BA4\u6587\u672C\u5C5E\u6027
    Text.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });
    };
    // \u4EC5\u4EC5\u4F7F\u7528\u5305\u56F4\u76D2\u68C0\u6D4B\u6765\u8FDB\u884C\u62FE\u53D6
    Text.prototype.isOnlyHitBox = function () {
        return true;
    };
    // \u521D\u59CB\u5316\u65F6\u7EC4\u5408 font\uFF0C\u540C\u65F6\u5224\u65AD text \u662F\u5426\u6362\u884C
    Text.prototype.initAttrs = function (attrs) {
        this._assembleFont();
        if (attrs.text) {
            this._setText(attrs.text);
        }
    };
    // \u7EC4\u88C5\u5B57\u4F53
    Text.prototype._assembleFont = function () {
        var attrs = this.attrs;
        attrs.font = (0,g_base_esm.assembleFont)(attrs);
    };
    // \u5982\u679C\u6587\u672C\u6362\u884C\uFF0C\u5219\u7F13\u5B58\u6570\u7EC4
    Text.prototype._setText = function (text) {
        var textArr = null;
        if ((0,esm/* isString */.HD)(text) && text.indexOf('\\n') !== -1) {
            textArr = text.split('\\n');
        }
        this.set('textArr', textArr);
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86 font\u3001text
    Text.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        if (name.startsWith('font')) {
            this._assembleFont();
        }
        if (name === 'text') {
            this._setText(value);
        }
    };
    // \u8FD9\u4E2A\u65B9\u6CD5\u5728 text \u65F6\u6CA1\u6709\u53EF\u4EE5\u505A\u7684\u4E8B\u60C5\uFF0C\u5982\u679C\u8981\u652F\u6301\u6587\u5B57\u80CC\u666F\u65F6\u53EF\u4EE5\u8003\u8651
    // createPath(context) {
    // }
    // \u5982\u679C\u6587\u672C\u591A\u884C\uFF0C\u9700\u8981\u83B7\u53D6\u6587\u672C\u95F4\u8DDD
    Text.prototype._getSpaceingY = function () {
        var attrs = this.attrs;
        var lineHeight = attrs.lineHeight;
        var fontSize = attrs.fontSize * 1;
        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    // \u7ED8\u5236\u6587\u672C\uFF0C\u8003\u8651\u591A\u884C\u7684\u573A\u666F
    Text.prototype._drawTextArr = function (context, textArr, isFill) {
        var attrs = this.attrs;
        var textBaseline = attrs.textBaseline;
        var x = attrs.x;
        var y = attrs.y;
        var fontSize = attrs.fontSize * 1;
        var spaceingY = this._getSpaceingY();
        var height = (0,g_base_esm.getTextHeight)(attrs.text, attrs.fontSize, attrs.lineHeight);
        var subY;
        (0,esm/* each */.S6)(textArr, function (subText, index) {
            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;
            if (textBaseline === 'middle')
                subY += height - fontSize - (height - fontSize) / 2;
            if (textBaseline === 'top')
                subY += height - fontSize;
            if (!(0,esm/* isNil */.UM)(subText)) {
                if (isFill) {
                    context.fillText(subText, x, subY);
                }
                else {
                    context.strokeText(subText, x, subY);
                }
            }
        });
    };
    // \u7ED8\u5236\u6587\u672C\uFF0C\u540C\u65F6\u8003\u8651\u586B\u5145\u548C\u7ED8\u5236\u8FB9\u6846
    Text.prototype._drawText = function (context, isFill) {
        var attrs = this.attr();
        var x = attrs.x;
        var y = attrs.y;
        var textArr = this.get('textArr');
        if (textArr) {
            this._drawTextArr(context, textArr, isFill);
        }
        else {
            var text = attrs.text;
            if (!(0,esm/* isNil */.UM)(text)) {
                if (isFill) {
                    context.fillText(text, x, y);
                }
                else {
                    context.strokeText(text, x, y);
                }
            }
        }
    };
    // \u590D\u5199\u7ED8\u5236\u548C\u586B\u5145\u7684\u903B\u8F91\uFF1A\u5BF9\u4E8E\u6587\u672C\uFF0C\u5E94\u8BE5\u5148\u7ED8\u5236\u8FB9\u6846\uFF0C\u518D\u8FDB\u884C\u586B\u5145
    Text.prototype.strokeAndFill = function (context) {
        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;
        if (this.isStroke()) {
            if (lineWidth > 0) {
                if (!(0,esm/* isNil */.UM)(strokeOpacity) && strokeOpacity !== 1) {
                    context.globalAlpha = opacity;
                }
                this.stroke(context);
            }
        }
        if (this.isFill()) {
            if (!(0,esm/* isNil */.UM)(fillOpacity) && fillOpacity !== 1) {
                context.globalAlpha = fillOpacity;
                this.fill(context);
                context.globalAlpha = opacity;
            }
            else {
                this.fill(context);
            }
        }
        this.afterDrawPath(context);
    };
    // \u590D\u5199\u586B\u5145\u903B\u8F91
    Text.prototype.fill = function (context) {
        this._drawText(context, true);
    };
    // \u590D\u5199\u7ED8\u5236\u8FB9\u6846\u7684\u903B\u8F91
    Text.prototype.stroke = function (context) {
        this._drawText(context, false);
    };
    return Text;
}(shape_base));
/* harmony default export */ var shape_text = (Text);
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/shape/index.js











//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/util/hit.js

function invertFromMatrix(v, matrix) {
    if (matrix) {
        var invertMatrix = (0,g_base_esm.invert)(matrix);
        return (0,g_base_esm.multiplyVec2)(invertMatrix, v);
    }
    return v;
}
function getRefXY(element, x, y) {
    // @ts-ignore
    var totalMatrix = element.getTotalMatrix();
    if (totalMatrix) {
        var _a = invertFromMatrix([x, y, 1], totalMatrix), refX = _a[0], refY = _a[1];
        return [refX, refY];
    }
    return [x, y];
}
// \u62FE\u53D6\u524D\u7684\u68C0\u6D4B\uFF0C\u53EA\u6709\u901A\u8FC7\u68C0\u6D4B\u624D\u80FD\u7EE7\u7EED\u62FE\u53D6
function preTest(element, x, y) {
    // @ts-ignore
    if (element.isCanvas && element.isCanvas()) {
        return true;
    }
    // \u4E0D\u5141\u8BB8\u88AB\u62FE\u53D6\uFF0C\u5219\u8FD4\u56DE null
    // @ts-ignore
    if (!(0,g_base_esm.isAllowCapture)(element) || element.cfg.isInView === false) {
        return false;
    }
    if (element.cfg.clipShape) {
        // \u5982\u679C\u5B58\u5728 clip
        var _a = getRefXY(element, x, y), refX = _a[0], refY = _a[1];
        if (element.isClipped(refX, refY)) {
            return false;
        }
    }
    // @ts-ignore \uFF0C\u8FD9\u4E2A\u5730\u65B9\u8C03\u7528\u8FC7\u4E8E\u9891\u7E41
    var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
    // \u5982\u679C\u6CA1\u6709\u7F13\u5B58 bbox\uFF0C\u5219\u8BF4\u660E\u4E0D\u53EF\u89C1
    // \u6CE8\u91CA\u6389\u7684\u8FD9\u6BB5\u53EF\u80FD\u4F1A\u52A0\u901F\u62FE\u53D6\uFF0C\u4E0A\u9762\u7684\u8BED\u53E5\u6539\u5199\u6210 const bbox = element.cfg.cacheCanvasBBox;
    // \u8FD9\u65F6\u5019\u7684\u62FE\u53D6\u5047\u8BBE\u56FE\u5F62/\u5206\u7EC4\u5728\u4E0A\u4E00\u6B21\u7ED8\u5236\u90FD\u5728\u89C6\u7A97\u5185\uFF0C\u4F46\u662F\u4E0A\u9762\u5DF2\u7ECF\u5224\u5B9A\u4E86 isInView \u6240\u4EE5\u610F\u4E49\u4E0D\u5927
    // \u73B0\u5728\u8FD8\u8C03\u7528 element.getCanvasBBox(); \u4E00\u4E2A\u5F88\u5927\u7684\u539F\u56E0\u662F\u4FBF\u4E8E\u5355\u5143\u6D4B\u8BD5
    // if (!bbox) {
    //   return false;
    // }
    if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
        return false;
    }
    return true;
}
// \u8FD9\u4E2A\u65B9\u6CD5\u590D\u5199\u4E86 g-base \u7684 getShape
function getShape(container, x, y) {
    // \u6CA1\u6709\u901A\u8FC7\u68C0\u6D4B\uFF0C\u5219\u8FD4\u56DE null
    if (!preTest(container, x, y)) {
        return null;
    }
    var shape = null;
    var children = container.getChildren();
    var count = children.length;
    for (var i = count - 1; i >= 0; i--) {
        var child = children[i];
        if (child.isGroup()) {
            shape = getShape(child, x, y);
        }
        else if (preTest(child, x, y)) {
            var curShape = child;
            var _a = getRefXY(child, x, y), refX = _a[0], refY = _a[1];
            // @ts-ignore
            if (curShape.isInShape(refX, refY)) {
                shape = child;
            }
        }
        if (shape) {
            break;
        }
    }
    return shape;
}
//# sourceMappingURL=hit.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/canvas.js







var Canvas = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Canvas, _super);
    function Canvas() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        // \u8BBE\u7F6E\u6E32\u67D3\u5F15\u64CE\u4E3A canvas\uFF0C\u53EA\u8BFB\u5C5E\u6027
        cfg['renderer'] = 'canvas';
        // \u662F\u5426\u81EA\u52A8\u7ED8\u5236\uFF0C\u4E0D\u9700\u8981\u7528\u6237\u8C03\u7528 draw \u65B9\u6CD5
        cfg['autoDraw'] = true;
        // \u662F\u5426\u5141\u8BB8\u5C40\u90E8\u5237\u65B0\u56FE\u8868
        cfg['localRefresh'] = true;
        cfg['refreshElements'] = [];
        // \u662F\u5426\u5728\u89C6\u56FE\u5185\u81EA\u52A8\u88C1\u526A
        cfg['clipView'] = true;
        // \u662F\u5426\u4F7F\u7528\u5FEB\u901F\u62FE\u53D6\u7684\u65B9\u6848\uFF0C\u9ED8\u8BA4\u4E3A false\uFF0C\u4E0A\u5C42\u53EF\u4EE5\u6253\u5F00
        cfg['quickHit'] = false;
        return cfg;
    };
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    Canvas.prototype.onCanvasChange = function (changeType) {
        /**
         * \u89E6\u53D1\u753B\u5E03\u66F4\u65B0\u7684\u4E09\u79CD changeType
         * 1. attr: \u4FEE\u6539\u753B\u5E03\u7684\u7ED8\u56FE\u5C5E\u6027
         * 2. sort: \u753B\u5E03\u6392\u5E8F\uFF0C\u56FE\u5F62\u7684\u5C42\u6B21\u4F1A\u53D1\u751F\u53D8\u5316
         * 3. changeSize: \u6539\u53D8\u753B\u5E03\u5927\u5C0F
         */
        if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {
            this.set('refreshElements', [this]);
            this.draw();
        }
    };
    Canvas.prototype.getShapeBase = function () {
        return esm_shape_namespaceObject;
    };
    Canvas.prototype.getGroupBase = function () {
        return esm_group;
    };
    /**
     * \u83B7\u53D6\u5C4F\u5E55\u50CF\u7D20\u6BD4
     */
    Canvas.prototype.getPixelRatio = function () {
        var pixelRatio = this.get('pixelRatio') || getPixelRatio();
        // \u4E0D\u8DB3 1 \u7684\u53D6 1\uFF0C\u8D85\u51FA 1 \u7684\u53D6\u6574
        return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas.prototype.getViewRange = function () {
        return {
            minX: 0,
            minY: 0,
            maxX: this.cfg.width,
            maxY: this.cfg.height,
        };
    };
    // \u590D\u5199\u57FA\u7C7B\u7684\u65B9\u6CD5\u751F\u6210\u6807\u7B7E
    Canvas.prototype.createDom = function () {
        var element = document.createElement('canvas');
        var context = element.getContext('2d');
        // \u7F13\u5B58 context \u5BF9\u8C61
        this.set('context', context);
        return element;
    };
    Canvas.prototype.setDOMSize = function (width, height) {
        _super.prototype.setDOMSize.call(this, width, height);
        var context = this.get('context');
        var el = this.get('el');
        var pixelRatio = this.getPixelRatio();
        el.width = pixelRatio * width;
        el.height = pixelRatio * height;
        // \u8BBE\u7F6E canvas \u5143\u7D20\u7684\u5BBD\u5EA6\u548C\u9AD8\u5EA6\uFF0C\u4F1A\u91CD\u7F6E\u7F29\u653E\uFF0C\u56E0\u6B64 context.scale \u9700\u8981\u5728\u6BCF\u6B21\u8BBE\u7F6E\u5BBD\u3001\u9AD8\u540E\u8C03\u7528
        if (pixelRatio > 1) {
            context.scale(pixelRatio, pixelRatio);
        }
    };
    // \u590D\u5199\u57FA\u7C7B\u65B9\u6CD5
    Canvas.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._clearFrame(); // \u9700\u8981\u6E05\u7406\u6389\u5EF6\u8FDF\u7ED8\u5236\u7684\u5E27
        var context = this.get('context');
        var element = this.get('el');
        context.clearRect(0, 0, element.width, element.height);
    };
    Canvas.prototype.getShape = function (x, y) {
        var shape;
        if (this.get('quickHit')) {
            shape = getShape(this, x, y);
        }
        else {
            shape = _super.prototype.getShape.call(this, x, y, null);
        }
        return shape;
    };
    // \u5BF9\u7ED8\u5236\u533A\u57DF\u8FB9\u7F18\u53D6\u6574\uFF0C\u907F\u514D\u6D6E\u70B9\u6570\u95EE\u9898
    Canvas.prototype._getRefreshRegion = function () {
        var elements = this.get('refreshElements');
        var viewRegion = this.getViewRange();
        var region;
        // \u5982\u679C\u662F\u5F53\u524D\u753B\u5E03\u6574\u4F53\u53D1\u751F\u4E86\u53D8\u5316\uFF0C\u5219\u76F4\u63A5\u91CD\u7ED8\u6574\u4E2A\u753B\u5E03
        if (elements.length && elements[0] === this) {
            region = viewRegion;
        }
        else {
            region = getMergedRegion(elements);
            if (region) {
                region.minX = Math.floor(region.minX);
                region.minY = Math.floor(region.minY);
                region.maxX = Math.ceil(region.maxX);
                region.maxY = Math.ceil(region.maxY);
                region.maxY += 1; // \u5728\u5F88\u591A\u73AF\u5883\u4E0B\u5B57\u4F53\u7684\u9AD8\u4F4E\u4F1A\u4E0D\u4E00\u81F4\uFF0C\u9644\u52A0\u4E00\u50CF\u7D20\uFF0C\u907F\u514D\u6B8B\u5F71
                var clipView = this.get('clipView');
                // \u81EA\u52A8\u88C1\u526A\u4E0D\u5728 view \u5185\u7684\u533A\u57DF
                if (clipView) {
                    region = mergeView(region, viewRegion);
                }
            }
        }
        return region;
    };
    /**
     * \u5237\u65B0\u56FE\u5F62\u5143\u7D20\uFF0C\u8FD9\u91CC\u4EC5\u4EC5\u662F\u653E\u5165\u961F\u5217\uFF0C\u4E0B\u6B21\u7ED8\u5236\u65F6\u8FDB\u884C\u7ED8\u5236
     * @param {IElement} element \u56FE\u5F62\u5143\u7D20
     */
    Canvas.prototype.refreshElement = function (element) {
        var refreshElements = this.get('refreshElements');
        refreshElements.push(element);
        // if (this.get('autoDraw')) {
        //   this._startDraw();
        // }
    };
    // \u6E05\u7406\u8FD8\u5728\u8FDB\u884C\u7684\u7ED8\u5236
    Canvas.prototype._clearFrame = function () {
        var drawFrame = this.get('drawFrame');
        if (drawFrame) {
            // \u5982\u679C\u5168\u90E8\u6E32\u67D3\u65F6\uFF0C\u5B58\u5728\u5C40\u90E8\u6E32\u67D3\uFF0C\u5219\u629B\u5F03\u6389\u5C40\u90E8\u6E32\u67D3
            (0,esm/* clearAnimationFrame */.VS)(drawFrame);
            this.set('drawFrame', null);
            this.set('refreshElements', []);
        }
    };
    // \u624B\u5DE5\u8C03\u7528\u7ED8\u5236\u63A5\u53E3
    Canvas.prototype.draw = function () {
        var drawFrame = this.get('drawFrame');
        if (this.get('autoDraw') && drawFrame) {
            return;
        }
        this._startDraw();
    };
    // \u7ED8\u5236\u6240\u6709\u56FE\u5F62
    Canvas.prototype._drawAll = function () {
        var context = this.get('context');
        var element = this.get('el');
        var children = this.getChildren();
        context.clearRect(0, 0, element.width, element.height);
        applyAttrsToContext(context, this);
        drawChildren(context, children);
        // \u5BF9\u4E8E https://github.com/antvis/g/issues/422 \u7684\u573A\u666F\uFF0C\u5168\u5C40\u6E32\u67D3\u7684\u6A21\u5F0F\u4E0B\u4E5F\u4F1A\u8BB0\u5F55\u66F4\u65B0\u7684\u5143\u7D20\u961F\u5217\uFF0C\u56E0\u6B64\u5168\u5C40\u6E32\u67D3\u5B8C\u540E\u4E5F\u9700\u8981\u7F6E\u7A7A
        this.set('refreshElements', []);
    };
    // \u7ED8\u5236\u5C40\u90E8
    Canvas.prototype._drawRegion = function () {
        var context = this.get('context');
        var refreshElements = this.get('refreshElements');
        var children = this.getChildren();
        var region = this._getRefreshRegion();
        // \u9700\u8981\u6CE8\u610F\u53EF\u80FD\u6CA1\u6709 region \u7684\u573A\u666F
        // \u4E00\u822C\u53D1\u751F\u5728\u8BBE\u7F6E\u4E86 localRefresh ,\u5728\u6CA1\u6709\u56FE\u5F62\u53D1\u751F\u53D8\u5316\u7684\u60C5\u51B5\u4E0B\uFF0C\u7528\u6237\u8C03\u7528\u4E86 draw
        if (region) {
            // \u6E05\u7406\u6307\u5B9A\u533A\u57DF
            context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
            // \u4FDD\u5B58\u4E0A\u4E0B\u6587\uFF0C\u8BBE\u7F6E clip
            context.save();
            context.beginPath();
            context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
            context.clip();
            applyAttrsToContext(context, this);
            // \u786E\u8BA4\u66F4\u65B0\u7684\u5143\u7D20\uFF0C\u8FD9\u4E2A\u4F18\u5316\u53EF\u4EE5\u63D0\u5347 10 \u500D\u5DE6\u53F3\u7684\u6027\u80FD\uFF0C10W \u4E2A\u5E26\u6709 group \u7684\u8282\u70B9\uFF0C\u5C40\u90E8\u6E32\u67D3\u4F1A\u4ECE 90ms \u4E0B\u964D\u5230 5-6 ms
            checkRefresh(this, children, region);
            // \u7ED8\u5236\u5B50\u5143\u7D20
            drawChildren(context, children, region);
            context.restore();
        }
        else if (refreshElements.length) {
            // \u9632\u6B62\u53D1\u751F\u6539\u53D8\u7684 elements \u6CA1\u6709 region \u7684\u573A\u666F\uFF0C\u8FD9\u4F1A\u53D1\u751F\u5728\u591A\u4E2A\u60C5\u51B5\u4E0B
            // 1. \u7A7A\u7684 group
            // 2. \u6240\u6709 elements \u6CA1\u6709\u5728\u7ED8\u56FE\u533A\u57DF
            // 3. group \u4E0B\u9762\u7684 elements \u9690\u85CF\u6389
            // \u5982\u679C\u4E0D\u8FDB\u884C\u6E05\u7406 hasChanged \u7684\u72B6\u6001\u4F1A\u4E0D\u6B63\u786E
            clearChanged(refreshElements);
        }
        (0,esm/* each */.S6)(refreshElements, function (element) {
            if (element.get('hasChanged')) {
                // \u5728\u89C6\u7A97\u5916\u7684 Group \u5143\u7D20\u4F1A\u52A0\u5165\u5230\u66F4\u65B0\u961F\u5217\u91CC\uFF0C\u4F46\u5B9E\u9645\u5374\u6CA1\u6709\u6267\u884C draw() \u903B\u8F91\uFF0C\u4E5F\u5C31\u6CA1\u6709\u6E05\u9664 hasChanged \u6807\u8BB0
                // \u5373\u5DF2\u7ECF\u91CD\u7ED8\u5B8C\u3001\u4F46 hasChanged \u6807\u8BB0\u6CA1\u6709\u6E05\u9664\u7684\u5143\u7D20\uFF0C\u9700\u8981\u7EDF\u4E00\u6E05\u9664\u6389\u3002\u4E3B\u8981\u662F Group \u5B58\u5728\u95EE\u9898\uFF0C\u5177\u4F53\u539F\u56E0\u5F85\u6392\u67E5
                element.set('hasChanged', false);
            }
        });
        this.set('refreshElements', []);
    };
    // \u89E6\u53D1\u7ED8\u5236
    Canvas.prototype._startDraw = function () {
        var _this = this;
        var drawFrame = this.get('drawFrame');
        if (!drawFrame) {
            drawFrame = (0,esm/* requestAnimationFrame */.U7)(function () {
                if (_this.get('localRefresh')) {
                    _this._drawRegion();
                }
                else {
                    _this._drawAll();
                }
                _this.set('drawFrame', null);
            });
            this.set('drawFrame', drawFrame);
        }
    };
    Canvas.prototype.skipDraw = function () { };
    Canvas.prototype.removeDom = function () {
        var el = this.get('el');
        // \u9700\u8981\u6E05\u7406 canvas \u753B\u5E03\u5185\u5BB9\uFF0C\u5426\u5219ios\u4E0B \u521B\u5EFA\u7684canvas\u5783\u573E\u672A\u56DE\u6536\uFF0C\u5BFC\u81F4Total canvas memory use exceeds\u95EE\u9898
        // \u76F8\u5173\u95EE\u9898\u5217\u8868
        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12
        // https://github.com/openlayers/openlayers/issues/9291
        el.width = 0;
        el.height = 0;
        el.parentNode.removeChild(el);
    };
    return Canvas;
}(g_base_esm.AbstractCanvas));
/* harmony default export */ var canvas = (Canvas);
//# sourceMappingURL=canvas.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-canvas/esm/index.js






var version = '0.5.12';
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
    rect: 'path',
    circle: 'circle',
    line: 'line',
    path: 'path',
    marker: 'path',
    text: 'text',
    polyline: 'polyline',
    polygon: 'polygon',
    image: 'image',
    ellipse: 'ellipse',
    dom: 'foreignObject',
};
var SVG_ATTR_MAP = {
    opacity: 'opacity',
    fillStyle: 'fill',
    fill: 'fill',
    fillOpacity: 'fill-opacity',
    strokeStyle: 'stroke',
    strokeOpacity: 'stroke-opacity',
    stroke: 'stroke',
    x: 'x',
    y: 'y',
    r: 'r',
    rx: 'rx',
    ry: 'ry',
    width: 'width',
    height: 'height',
    x1: 'x1',
    x2: 'x2',
    y1: 'y1',
    y2: 'y2',
    lineCap: 'stroke-linecap',
    lineJoin: 'stroke-linejoin',
    lineWidth: 'stroke-width',
    lineDash: 'stroke-dasharray',
    lineDashOffset: 'stroke-dashoffset',
    miterLimit: 'stroke-miterlimit',
    font: 'font',
    fontSize: 'font-size',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    fontFamily: 'font-family',
    startArrow: 'marker-start',
    endArrow: 'marker-end',
    path: 'd',
    class: 'class',
    id: 'id',
    style: 'style',
    preserveAspectRatio: 'preserveAspectRatio',
};
var EVENTS = (/* unused pure expression or super */ null && ([
    'click',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'mouseenter',
    'mouseleave',
    'mouseover',
    'mouseout',
    'mousemove',
    'wheel',
]));
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/util/dom.js


/**
 * \u521B\u5EFA\u5E76\u8FD4\u56DE\u56FE\u5F62\u7684 svg \u5143\u7D20
 * @param type svg\u7C7B\u578B
 */
function createSVGElement(type) {
    return document.createElementNS('http://www.w3.org/2000/svg', type);
}
/**
 * \u521B\u5EFA\u5E76\u8FD4\u56DE\u56FE\u5F62\u7684 dom \u5143\u7D20
 * @param  {IShape} shape \u56FE\u5F62
 * @return {SVGElement}
 */
function dom_createDom(shape) {
    var type = SHAPE_TO_TAGS[shape.type];
    var parent = shape.getParent();
    if (!type) {
        throw new Error("the type " + shape.type + " is not supported by svg");
    }
    var element = createSVGElement(type);
    if (shape.get('id')) {
        element.id = shape.get('id');
    }
    shape.set('el', element);
    shape.set('attrs', {});
    // \u5BF9\u4E8E defs \u4E0B\u7684 dom \u8282\u70B9\uFF0Cparent \u4E3A\u7A7A\uFF0C\u901A\u8FC7 context \u7EDF\u4E00\u6302\u8F7D\u5230 defs \u8282\u70B9\u4E0B
    if (parent) {
        var parentNode = parent.get('el');
        if (parentNode) {
            parentNode.appendChild(element);
        }
        else {
            // parentNode maybe null for group
            parentNode = parent.createDom();
            parent.set('el', parentNode);
            parentNode.appendChild(element);
        }
    }
    return element;
}
/**
 * \u5BF9 dom \u5143\u7D20\u8FDB\u884C\u6392\u5E8F
 * @param {IElement} element  \u5143\u7D20
 * @param {sorter}   function \u6392\u5E8F\u51FD\u6570
 */
function sortDom(element, sorter) {
    var el = element.get('el');
    var childList = (0,esm/* toArray */.qo)(el.children).sort(sorter);
    // create empty fragment
    var fragment = document.createDocumentFragment();
    childList.forEach(function (child) {
        fragment.appendChild(child);
    });
    el.appendChild(fragment);
}
/**
 * \u5C06 dom \u5143\u7D20\u79FB\u52A8\u5230\u7236\u5143\u7D20\u4E0B\u7684\u6307\u5B9A\u4F4D\u7F6E
 * @param {SVGElement} element     dom \u5143\u7D20
 * @param {number}     targetIndex \u76EE\u6807\u4F4D\u7F6E(\u4ECE 0 \u5F00\u59CB)
 */
function moveTo(element, targetIndex) {
    var parentNode = element.parentNode;
    var siblings = Array.from(parentNode.childNodes).filter(
    // \u8981\u6C42\u4E3A\u5143\u7D20\u8282\u70B9\uFF0C\u4E14\u4E0D\u80FD\u4E3A defs \u8282\u70B9
    function (node) { return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs'; });
    // \u83B7\u53D6\u76EE\u6807\u8282\u70B9
    var target = siblings[targetIndex];
    var currentIndex = siblings.indexOf(element);
    // \u5982\u679C\u76EE\u6807\u8282\u70B9\u5B58\u5728
    if (target) {
        // \u5F53\u524D\u7D22\u5F15 > \u76EE\u6807\u7D22\u5F15\uFF0C\u76F4\u63A5\u63D2\u5165\u5230\u76EE\u6807\u8282\u70B9\u4E4B\u524D\u5373\u53EF
        if (currentIndex > targetIndex) {
            parentNode.insertBefore(element, target);
        }
        else if (currentIndex < targetIndex) {
            // \u5F53\u524D\u7D22\u5F15 < \u76EE\u6807\u7D22\u5F15
            // \u83B7\u53D6\u76EE\u6807\u8282\u70B9\u7684\u4E0B\u4E00\u4E2A\u8282\u70B9
            var targetNext = siblings[targetIndex + 1];
            // \u5982\u679C\u76EE\u6807\u8282\u70B9\u7684\u4E0B\u4E00\u4E2A\u8282\u70B9\u5B58\u5728\uFF0C\u63D2\u5165\u5230\u8BE5\u8282\u70B9\u4E4B\u524D
            if (targetNext) {
                parentNode.insertBefore(element, targetNext);
            }
            else {
                // \u5982\u679C\u8BE5\u8282\u70B9\u4E0D\u5B58\u5728\uFF0C\u5219\u8FFD\u52A0\u5230\u672B\u5C3E
                parentNode.appendChild(element);
            }
        }
    }
    else {
        parentNode.appendChild(element);
    }
}
//# sourceMappingURL=dom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/util/svg.js

function setShadow(model, context) {
    var el = model.cfg.el;
    var attrs = model.attr();
    var cfg = {
        dx: attrs.shadowOffsetX,
        dy: attrs.shadowOffsetY,
        blur: attrs.shadowBlur,
        color: attrs.shadowColor,
    };
    if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
        el.removeAttribute('filter');
    }
    else {
        var id = context.find('filter', cfg);
        if (!id) {
            id = context.addShadow(cfg);
        }
        el.setAttribute('filter', "url(#" + id + ")");
    }
}
function setTransform(model) {
    var matrix = model.attr().matrix;
    if (matrix) {
        var el = model.cfg.el;
        var transform = [];
        for (var i = 0; i < 9; i += 3) {
            transform.push(matrix[i] + "," + matrix[i + 1]);
        }
        transform = transform.join(',');
        if (transform.indexOf('NaN') === -1) {
            el.setAttribute('transform', "matrix(" + transform + ")");
        }
        else {
            console.warn('invalid matrix:', matrix);
        }
    }
}
function setClip(model, context) {
    var clip = model.getClip();
    var el = model.get('el');
    if (!clip) {
        el.removeAttribute('clip-path');
    }
    else if (clip && !el.hasAttribute('clip-path')) {
        dom_createDom(clip);
        clip.createPath(context);
        var id = context.addClip(clip);
        el.setAttribute('clip-path', "url(#" + id + ")");
    }
}
//# sourceMappingURL=svg.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/util/draw.js


function draw_drawChildren(context, children) {
    children.forEach(function (child) {
        child.draw(context);
    });
}
/**
 * \u66F4\u65B0\u5143\u7D20\uFF0C\u5305\u62EC group \u548C shape
 * @param {IElement} element       SVG \u5143\u7D20
 * @param {ChangeType} changeType  \u66F4\u65B0\u7C7B\u578B
 */
function draw_refreshElement(element, changeType) {
    // \u5BF9\u4E8E\u8FD8\u6CA1\u6709\u6302\u8F7D\u5230\u753B\u5E03\u4E0B\u7684\u5143\u7D20\uFF0Ccanvas \u53EF\u80FD\u4E3A\u7A7A
    var canvas = element.get('canvas');
    // \u53EA\u6709\u6302\u8F7D\u5230\u753B\u5E03\u4E0B\uFF0C\u624D\u5BF9\u5143\u7D20\u8FDB\u884C\u5B9E\u9645\u6E32\u67D3
    if (canvas && canvas.get('autoDraw')) {
        var context = canvas.get('context');
        var parent_1 = element.getParent();
        var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
        var el = element.get('el');
        if (changeType === 'remove') {
            var isClipShape = element.get('isClipShape');
            // \u5BF9\u4E8E clip\uFF0C\u4E0D\u4EC5\u9700\u8981\u5C06 clipShape \u5BF9\u4E8E\u7684 SVG \u5143\u7D20\u5220\u9664\uFF0C\u8FD8\u9700\u8981\u5C06\u4E0A\u5C42\u7684 clipPath \u5143\u7D20\u4E5F\u5220\u9664
            if (isClipShape) {
                var clipPathEl = el && el.parentNode;
                var defsEl = clipPathEl && clipPathEl.parentNode;
                if (clipPathEl && defsEl) {
                    defsEl.removeChild(clipPathEl);
                }
            }
            else if (el && el.parentNode) {
                el.parentNode.removeChild(el);
            }
        }
        else if (changeType === 'show') {
            el.setAttribute('visibility', 'visible');
        }
        else if (changeType === 'hide') {
            el.setAttribute('visibility', 'hidden');
        }
        else if (changeType === 'zIndex') {
            moveTo(el, parentChildren.indexOf(element));
        }
        else if (changeType === 'sort') {
            var children_1 = element.get('children');
            if (children_1 && children_1.length) {
                sortDom(element, function (a, b) {
                    return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
                });
            }
        }
        else if (changeType === 'clear') {
            // el maybe null for group
            if (el) {
                el.innerHTML = '';
            }
        }
        else if (changeType === 'matrix') {
            setTransform(element);
        }
        else if (changeType === 'clip') {
            setClip(element, context);
        }
        else if (changeType === 'attr') {
            // \u5DF2\u5728 afterAttrsChange \u8FDB\u884C\u4E86\u5904\u7406\uFF0C\u6B64\u5904 do nothing
        }
        else if (changeType === 'add') {
            element.draw(context);
        }
    }
}
//# sourceMappingURL=draw.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/group.js








var group_Group = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // SVG \u4E2D\u5206\u7EC4\u5BF9\u5E94\u5B9E\u4F53\u6807\u7B7E <g>
    Group.prototype.isEntityGroup = function () {
        return true;
    };
    Group.prototype.createDom = function () {
        var element = createSVGElement('g');
        this.set('el', element);
        var parent = this.getParent();
        if (parent) {
            var parentNode = parent.get('el');
            if (parentNode) {
                parentNode.appendChild(element);
            }
            else {
                // parentNode maybe null for group
                parentNode = parent.createDom();
                parent.set('el', parentNode);
                parentNode.appendChild(element);
            }
        }
        return element;
    };
    // \u8986\u76D6\u57FA\u7C7B\u7684 afterAttrsChange \u65B9\u6CD5
    Group.prototype.afterAttrsChange = function (targetAttrs) {
        _super.prototype.afterAttrsChange.call(this, targetAttrs);
        var canvas = this.get('canvas');
        // \u53EA\u6709\u6302\u8F7D\u5230\u753B\u5E03\u4E0B\uFF0C\u624D\u5BF9\u5143\u7D20\u8FDB\u884C\u5B9E\u9645\u6E32\u67D3
        if (canvas && canvas.get('autoDraw')) {
            var context = canvas.get('context');
            this.createPath(context, targetAttrs);
        }
    };
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    Group.prototype.onCanvasChange = function (changeType) {
        draw_refreshElement(this, changeType);
    };
    Group.prototype.getShapeBase = function () {
        return g_svg_esm_shape_namespaceObject;
    };
    Group.prototype.getGroupBase = function () {
        return Group;
    };
    Group.prototype.draw = function (context) {
        var children = this.getChildren();
        var el = this.get('el');
        if (this.get('destroyed')) {
            if (el) {
                el.parentNode.removeChild(el);
            }
        }
        else {
            if (!el) {
                this.createDom();
            }
            setClip(this, context);
            this.createPath(context);
            if (children.length) {
                draw_drawChildren(context, children);
            }
        }
    };
    /**
     * \u7ED8\u5236\u5206\u7EC4\u7684\u8DEF\u5F84
     * @param {Defs} context \u4E0A\u4E0B\u6587
     * @param {ShapeAttrs} targetAttrs \u6E32\u67D3\u7684\u76EE\u6807\u5C5E\u6027
     */
    Group.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
        setTransform(this);
    };
    return Group;
}(g_base_esm.AbstractGroup));
/* harmony default export */ var g_svg_esm_group = (group_Group);
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/base.js









var shape_base_ShapeBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ShapeBase, _super);
    function ShapeBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'svg';
        _this.canFill = false;
        _this.canStroke = false;
        return _this;
    }
    ShapeBase.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        // \u8BBE\u7F6E\u9ED8\u8BA4\u503C
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    // \u8986\u76D6\u57FA\u7C7B\u7684 afterAttrsChange \u65B9\u6CD5
    ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {
        _super.prototype.afterAttrsChange.call(this, targetAttrs);
        var canvas = this.get('canvas');
        // \u53EA\u6709\u6302\u8F7D\u5230\u753B\u5E03\u4E0B\uFF0C\u624D\u5BF9\u5143\u7D20\u8FDB\u884C\u5B9E\u9645\u6E32\u67D3
        if (canvas && canvas.get('autoDraw')) {
            var context = canvas.get('context');
            this.draw(context, targetAttrs);
        }
    };
    ShapeBase.prototype.getShapeBase = function () {
        return g_svg_esm_shape_namespaceObject;
    };
    ShapeBase.prototype.getGroupBase = function () {
        return g_svg_esm_group;
    };
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    ShapeBase.prototype.onCanvasChange = function (changeType) {
        draw_refreshElement(this, changeType);
    };
    ShapeBase.prototype.calculateBBox = function () {
        var el = this.get('el');
        var bbox = null;
        // \u5305\u56F4\u76D2\u8BA1\u7B97\u4F9D\u8D56\u4E8E\u7ED8\u5236\uFF0C\u5982\u679C\u8FD8\u6CA1\u6709\u751F\u6210\u5BF9\u5E94\u7684 Dom \u5143\u7D20\uFF0C\u5219\u5305\u56F4\u76D2\u7684\u957F\u5BBD\u5747\u4E3A 0
        if (el) {
            bbox = el.getBBox();
        }
        else {
            var bboxMethod = (0,g_base_esm.getBBoxMethod)(this.get('type'));
            if (bboxMethod) {
                bbox = bboxMethod(this);
            }
        }
        if (bbox) {
            var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
            var lineWidth = this.getHitLineWidth();
            var halfWidth = lineWidth / 2;
            var minX = x - halfWidth;
            var minY = y - halfWidth;
            var maxX = x + width + halfWidth;
            var maxY = y + height + halfWidth;
            return {
                x: minX,
                y: minY,
                minX: minX,
                minY: minY,
                maxX: maxX,
                maxY: maxY,
                width: width + lineWidth,
                height: height + lineWidth,
            };
        }
        return {
            x: 0,
            y: 0,
            minX: 0,
            minY: 0,
            maxX: 0,
            maxY: 0,
            width: 0,
            height: 0,
        };
    };
    ShapeBase.prototype.isFill = function () {
        var _a = this.attr(), fill = _a.fill, fillStyle = _a.fillStyle;
        return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase.prototype.isStroke = function () {
        var _a = this.attr(), stroke = _a.stroke, strokeStyle = _a.strokeStyle;
        return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase.prototype.draw = function (context, targetAttrs) {
        var el = this.get('el');
        if (this.get('destroyed')) {
            if (el) {
                el.parentNode.removeChild(el);
            }
        }
        else {
            if (!el) {
                dom_createDom(this);
            }
            setClip(this, context);
            this.createPath(context, targetAttrs);
            this.shadow(context, targetAttrs);
            this.strokeAndFill(context, targetAttrs);
            this.transform(targetAttrs);
        }
    };
    /**
     * @protected
     * \u7ED8\u5236\u56FE\u5F62\u7684\u8DEF\u5F84
     * @param {Defs} context \u4E0A\u4E0B\u6587
     * @param {ShapeAttrs} targetAttrs \u6E32\u67D3\u7684\u76EE\u6807\u5C5E\u6027
     */
    ShapeBase.prototype.createPath = function (context, targetAttrs) { };
    // stroke and fill
    ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {
        var attrs = targetAttrs || this.attr();
        var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
        var el = this.get('el');
        if (this.canFill) {
            // \u521D\u6B21\u6E32\u67D3\u548C\u66F4\u65B0\u6E32\u67D3\u7684\u903B\u8F91\u6709\u6240\u4E0D\u540C: \u521D\u6B21\u6E32\u67D3\u503C\u4E3A\u7A7A\u65F6\uFF0C\u9700\u8981\u8BBE\u7F6E\u4E3A none\uFF0C\u5426\u5219\u5C31\u4F1A\u662F\u9ED1\u8272\uFF0C\u800C\u66F4\u65B0\u6E32\u67D3\u5219\u4E0D\u9700\u8981
            if (!targetAttrs) {
                this._setColor(context, 'fill', fill || fillStyle);
            }
            else if ('fill' in attrs) {
                this._setColor(context, 'fill', fill);
            }
            else if ('fillStyle' in attrs) {
                // compatible with fillStyle
                this._setColor(context, 'fill', fillStyle);
            }
            if (fillOpacity) {
                el.setAttribute(SVG_ATTR_MAP.fillOpacity, fillOpacity);
            }
        }
        if (this.canStroke && lineWidth > 0) {
            if (!targetAttrs) {
                this._setColor(context, 'stroke', stroke || strokeStyle);
            }
            else if ('stroke' in attrs) {
                this._setColor(context, 'stroke', stroke);
            }
            else if ('strokeStyle' in attrs) {
                // compatible with strokeStyle
                this._setColor(context, 'stroke', strokeStyle);
            }
            if (strokeOpacity) {
                el.setAttribute(SVG_ATTR_MAP.strokeOpacity, strokeOpacity);
            }
            if (lineWidth) {
                el.setAttribute(SVG_ATTR_MAP.lineWidth, lineWidth);
            }
        }
    };
    ShapeBase.prototype._setColor = function (context, attr, value) {
        var el = this.get('el');
        if (!value) {
            // need to set \`none\` to avoid default value
            el.setAttribute(SVG_ATTR_MAP[attr], 'none');
            return;
        }
        value = value.trim();
        if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {
            var id = context.find('gradient', value);
            if (!id) {
                id = context.addGradient(value);
            }
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        }
        else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {
            var id = context.find('pattern', value);
            if (!id) {
                id = context.addPattern(value);
            }
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
        }
        else {
            el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
    };
    ShapeBase.prototype.shadow = function (context, targetAttrs) {
        var attrs = this.attr();
        var _a = targetAttrs || attrs, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY, shadowBlur = _a.shadowBlur, shadowColor = _a.shadowColor;
        if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
            setShadow(this, context);
        }
    };
    ShapeBase.prototype.transform = function (targetAttrs) {
        var attrs = this.attr();
        var matrix = (targetAttrs || attrs).matrix;
        if (matrix) {
            setTransform(this);
        }
    };
    ShapeBase.prototype.isInShape = function (refX, refY) {
        return this.isPointInPath(refX, refY);
    };
    ShapeBase.prototype.isPointInPath = function (refX, refY) {
        var el = this.get('el');
        var canvas = this.get('canvas');
        var bbox = canvas.get('el').getBoundingClientRect();
        var clientX = refX + bbox.left;
        var clientY = refY + bbox.top;
        var element = document.elementFromPoint(clientX, clientY);
        if (element && element.isEqualNode(el)) {
            return true;
        }
        return false;
    };
    /**
     * \u83B7\u53D6\u7EBF\u62FE\u53D6\u7684\u5BBD\u5EA6
     * @returns {number} \u7EBF\u7684\u62FE\u53D6\u5BBD\u5EA6
     */
    ShapeBase.prototype.getHitLineWidth = function () {
        var _a = this.attrs, lineWidth = _a.lineWidth, lineAppendWidth = _a.lineAppendWidth;
        if (this.isStroke()) {
            return lineWidth + lineAppendWidth;
        }
        return 0;
    };
    return ShapeBase;
}(g_base_esm.AbstractShape));
/* harmony default export */ var esm_shape_base = (shape_base_ShapeBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/circle.js
/**
 * @fileoverview circle
 * @author dengfuping_develop@163.com
 */




var esm_shape_circle_Circle = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Circle, _super);
    function Circle() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'circle';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Circle.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            // \u5706\u548C\u692D\u5706\u7684\u70B9\u5750\u6807\u5C5E\u6027\u4E0D\u662F x, y\uFF0C\u800C\u662F cx, cy
            if (attr === 'x' || attr === 'y') {
                el.setAttribute("c" + attr, value);
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    return Circle;
}(esm_shape_base));
/* harmony default export */ var esm_shape_circle = (esm_shape_circle_Circle);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/dom.js
/**
 * @fileoverview dom
 * @author dengfuping_develop@163.com
 */




var Dom = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Dom, _super);
    function Dom() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'dom';
        _this.canFill = false;
        _this.canStroke = false;
        return _this;
    }
    Dom.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
        if (typeof attrs['html'] === 'function') {
            var element = attrs['html'].call(this, attrs);
            if (element instanceof Element || element instanceof HTMLDocument) {
                var children = el.childNodes;
                for (var i = children.length - 1; i >= 0; i--) {
                    el.removeChild(children[i]);
                }
                el.appendChild(element); // append to el if it's an element
            }
            else {
                el.innerHTML = element; // set innerHTML
            }
        }
        else {
            el.innerHTML = attrs['html']; // set innerHTML
        }
    };
    return Dom;
}(esm_shape_base));
/* harmony default export */ var dom = (Dom);
//# sourceMappingURL=dom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/ellipse.js
/**
 * @fileoverview ellipse
 * @author dengfuping_develop@163.com
 */




var ellipse_Ellipse = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Ellipse, _super);
    function Ellipse() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'ellipse';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Ellipse.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            // \u5706\u548C\u692D\u5706\u7684\u70B9\u5750\u6807\u5C5E\u6027\u4E0D\u662F x, y\uFF0C\u800C\u662F cx, cy
            if (attr === 'x' || attr === 'y') {
                el.setAttribute("c" + attr, value);
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    return Ellipse;
}(esm_shape_base));
/* harmony default export */ var shape_ellipse = (ellipse_Ellipse);
//# sourceMappingURL=ellipse.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/image.js
/**
 * @fileoverview image
 * @author dengfuping_develop@163.com
 */




var image_Image = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Image, _super);
    function Image() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'image';
        _this.canFill = false;
        _this.canStroke = false;
        return _this;
    }
    Image.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image.prototype.createPath = function (context, targetAttrs) {
        var _this = this;
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'img') {
                _this._setImage(attrs.img);
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    Image.prototype.setAttr = function (name, value) {
        this.attrs[name] = value;
        if (name === 'img') {
            this._setImage(value);
        }
    };
    Image.prototype._setImage = function (img) {
        var attrs = this.attr();
        var el = this.get('el');
        if ((0,esm/* isString */.HD)(img)) {
            el.setAttribute('href', img);
        }
        else if (img instanceof window.Image) {
            if (!attrs.width) {
                el.setAttribute('width', img.width);
                this.attr('width', img.width);
            }
            if (!attrs.height) {
                el.setAttribute('height', img.height);
                this.attr('height', img.height);
            }
            el.setAttribute('href', img.src);
        }
        else if (img instanceof HTMLElement && (0,esm/* isString */.HD)(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
            // @ts-ignore
            el.setAttribute('href', img.toDataURL());
        }
        else if (img instanceof ImageData) {
            var canvas = document.createElement('canvas');
            canvas.setAttribute('width', "" + img.width);
            canvas.setAttribute('height', "" + img.height);
            canvas.getContext('2d').putImageData(img, 0, 0);
            if (!attrs.width) {
                el.setAttribute('width', "" + img.width);
                this.attr('width', img.width);
            }
            if (!attrs.height) {
                el.setAttribute('height', "" + img.height);
                this.attr('height', img.height);
            }
            el.setAttribute('href', canvas.toDataURL());
        }
    };
    return Image;
}(esm_shape_base));
/* harmony default export */ var esm_shape_image = (image_Image);
//# sourceMappingURL=image.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/line.js

/**
 * @fileoverview line
 * @author dengfuping_develop@163.com
 */




var esm_shape_line_Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'line';
        _this.canFill = false;
        _this.canStroke = true;
        return _this;
    }
    Line.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'startArrow' || attr === 'endArrow') {
                if (value) {
                    var id = (0,esm/* isObject */.Kn)(value)
                        ? context.addArrow(attrs, SVG_ATTR_MAP[attr])
                        : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
                    el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
                }
                else {
                    el.removeAttribute(SVG_ATTR_MAP[attr]);
                }
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    /**
     * Use math calculation to get length of line
     * @return {number} length
     */
    Line.prototype.getTotalLength = function () {
        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
        return g_math_esm/* Line.length */.x1.length(x1, y1, x2, y2);
    };
    /**
     * Use math calculation to get point according to ratio as same sa Canvas version
     * @param {number} ratio
     * @return {Point} point
     */
    Line.prototype.getPoint = function (ratio) {
        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
        return g_math_esm/* Line.pointAt */.x1.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line;
}(esm_shape_base));
/* harmony default export */ var g_svg_esm_shape_line = (esm_shape_line_Line);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var symbols_Symbols = {
    // \u5706
    circle: function (x, y, r) {
        return [
            ['M', x, y],
            ['m', -r, 0],
            ['a', r, r, 0, 1, 0, r * 2, 0],
            ['a', r, r, 0, 1, 0, -r * 2, 0],
        ];
    },
    // \u6B63\u65B9\u5F62
    square: function (x, y, r) {
        return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
    },
    // \u83F1\u5F62
    diamond: function (x, y, r) {
        return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
    },
    // \u4E09\u89D2\u5F62
    triangle: function (x, y, r) {
        var diffY = r * Math.sin((1 / 3) * Math.PI);
        return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];
    },
    // \u5012\u4E09\u89D2\u5F62
    triangleDown: function (x, y, r) {
        var diffY = r * Math.sin((1 / 3) * Math.PI);
        return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
    },
};
/* harmony default export */ var symbols = ({
    get: function (type) {
        return symbols_Symbols[type];
    },
    register: function (type, func) {
        symbols_Symbols[type] = func;
    },
    remove: function (type) {
        delete symbols_Symbols[type];
    },
    getAll: function () {
        return symbols_Symbols;
    },
});
//# sourceMappingURL=symbols.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/marker/index.js
/**
 * @fileoverview marker
 * @author dengfuping_develop@163.com
 */




var marker_Marker = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Marker, _super);
    function Marker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'marker';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Marker.prototype.createPath = function (context) {
        var el = this.get('el');
        el.setAttribute('d', this._assembleMarker());
    };
    Marker.prototype._assembleMarker = function () {
        var d = this._getPath();
        if ((0,esm/* isArray */.kJ)(d)) {
            return d
                .map(function (path) {
                return path.join(' ');
            })
                .join('');
        }
        return d;
    };
    Marker.prototype._getPath = function () {
        var attrs = this.attr();
        var x = attrs.x, y = attrs.y;
        // \u517C\u5BB9 r \u548C radius \u4E24\u79CD\u5199\u6CD5\uFF0C\u63A8\u8350\u4F7F\u7528 r
        var r = attrs.r || attrs.radius;
        var symbol = attrs.symbol || 'circle';
        var method;
        if ((0,esm/* isFunction */.mf)(symbol)) {
            method = symbol;
        }
        else {
            method = symbols.get(symbol);
        }
        if (!method) {
            console.warn(method + " symbol is not exist.");
            return null;
        }
        return method(x, y, r);
    };
    // \u4F5C\u4E3A\u5176\u9759\u6001\u5C5E\u6027
    Marker.symbolsFactory = symbols;
    return Marker;
}(esm_shape_base));
/* harmony default export */ var shape_marker = (marker_Marker);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/path.js




var path_Path = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Path, _super);
    function Path() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'path';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Path.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { startArrow: false, endArrow: false });
    };
    Path.prototype.createPath = function (context, targetAttrs) {
        var _this = this;
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'path' && (0,esm/* isArray */.kJ)(value)) {
                el.setAttribute('d', _this._formatPath(value));
            }
            else if (attr === 'startArrow' || attr === 'endArrow') {
                if (value) {
                    var id = (0,esm/* isObject */.Kn)(value)
                        ? context.addArrow(attrs, SVG_ATTR_MAP[attr])
                        : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
                    el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
                }
                else {
                    el.removeAttribute(SVG_ATTR_MAP[attr]);
                }
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    Path.prototype._formatPath = function (value) {
        var newValue = value
            .map(function (path) {
            return path.join(' ');
        })
            .join('');
        if (~newValue.indexOf('NaN')) {
            return '';
        }
        return newValue;
    };
    /**
     * Get total length of path
     * \u5C3D\u7BA1\u901A\u8FC7\u6D4F\u89C8\u5668\u7684 SVGPathElement.getTotalLength() \u63A5\u53E3\u83B7\u53D6\u7684 path \u957F\u5EA6\uFF0C
     * \u4E0E Canvas \u7248\u672C\u901A\u8FC7\u6570\u5B66\u8BA1\u7B97\u7684\u65B9\u5F0F\u5F97\u5230\u7684\u957F\u5EA6\u6709\u4E00\u4E9B\u7EC6\u5FAE\u5DEE\u5F02\uFF0C\u4F46\u6700\u5927\u8BEF\u5DEE\u5728\u4E2A\u4F4D\u6570\u50CF\u7D20\uFF0C\u7CBE\u5EA6\u4E0A\u53EF\u4EE5\u80FD\u63A5\u53D7
     * @return {number} length
     */
    Path.prototype.getTotalLength = function () {
        var el = this.get('el');
        return el ? el.getTotalLength() : null;
    };
    /**
     * Get point according to ratio
     * @param {number} ratio
     * @return {Point} point
     */
    Path.prototype.getPoint = function (ratio) {
        var el = this.get('el');
        var totalLength = this.getTotalLength();
        // @see https://github.com/antvis/g/issues/634
        if (totalLength === 0) {
            return null;
        }
        var point = el ? el.getPointAtLength(ratio * totalLength) : null;
        return point
            ? {
                x: point.x,
                y: point.y,
            }
            : null;
    };
    return Path;
}(esm_shape_base));
/* harmony default export */ var shape_path = (path_Path);
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/polygon.js

/**
 * @fileoverview polygon
 * @author dengfuping_develop@163.com
 */



var polygon_Polygon = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Polygon, _super);
    function Polygon() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'polygon';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Polygon.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'points' && (0,esm/* isArray */.kJ)(value) && value.length >= 2) {
                el.setAttribute('points', value.map(function (point) { return point[0] + "," + point[1]; }).join(' '));
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    return Polygon;
}(esm_shape_base));
/* harmony default export */ var shape_polygon = (polygon_Polygon);
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/polyline.js






var Polyline = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Polyline, _super);
    function Polyline() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'polyline';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Polyline.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { startArrow: false, endArrow: false });
    };
    // \u66F4\u65B0\u5C5E\u6027\u65F6\uFF0C\u68C0\u6D4B\u662F\u5426\u66F4\u6539\u4E86 points
    Polyline.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        if (['points'].indexOf(name) !== -1) {
            this._resetCache();
        }
    };
    Polyline.prototype._resetCache = function () {
        this.set('totalLength', null);
        this.set('tCache', null);
    };
    Polyline.prototype.createPath = function (context, targetAttrs) {
        var attrs = this.attr();
        var el = this.get('el');
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'points' && (0,esm/* isArray */.kJ)(value) && value.length >= 2) {
                el.setAttribute('points', value.map(function (point) { return point[0] + "," + point[1]; }).join(' '));
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    /**
     * Get length of polyline
     * @return {number} length
     */
    Polyline.prototype.getTotalLength = function () {
        var points = this.attr().points;
        // get totalLength from cache
        var totalLength = this.get('totalLength');
        if (!(0,esm/* isNil */.UM)(totalLength)) {
            return totalLength;
        }
        this.set('totalLength', g_math_esm/* Polyline.length */.aH.length(points));
        return this.get('totalLength');
    };
    /**
     * Get point according to ratio
     * @param {number} ratio
     * @return {Point} point
     */
    Polyline.prototype.getPoint = function (ratio) {
        var points = this.attr().points;
        // get tCache from cache
        var tCache = this.get('tCache');
        if (!tCache) {
            this._setTcache();
            tCache = this.get('tCache');
        }
        var subt;
        var index;
        (0,esm/* each */.S6)(tCache, function (v, i) {
            if (ratio >= v[0] && ratio <= v[1]) {
                subt = (ratio - v[0]) / (v[1] - v[0]);
                index = i;
            }
        });
        return g_math_esm/* Line.pointAt */.x1.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    Polyline.prototype._setTcache = function () {
        var points = this.attr().points;
        if (!points || points.length === 0) {
            return;
        }
        var totalLength = this.getTotalLength();
        if (totalLength <= 0) {
            return;
        }
        var tempLength = 0;
        var tCache = [];
        var segmentT;
        var segmentL;
        (0,esm/* each */.S6)(points, function (p, i) {
            if (points[i + 1]) {
                segmentT = [];
                segmentT[0] = tempLength / totalLength;
                segmentL = g_math_esm/* Line.length */.x1.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
                tempLength += segmentL;
                segmentT[1] = tempLength / totalLength;
                tCache.push(segmentT);
            }
        });
        this.set('tCache', tCache);
    };
    /**
     * Get start tangent vector
     * @return {Array}
     */
    Polyline.prototype.getStartTangent = function () {
        var points = this.attr().points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
    };
    /**
     * Get end tangent vector
     * @return {Array}
     */
    Polyline.prototype.getEndTangent = function () {
        var points = this.attr().points;
        var l = points.length - 1;
        var result = [];
        result.push([points[l - 1][0], points[l - 1][1]]);
        result.push([points[l][0], points[l][1]]);
        return result;
    };
    return Polyline;
}(esm_shape_base));
/* harmony default export */ var shape_polyline = (Polyline);
//# sourceMappingURL=polyline.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/util/format.js

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
var regexDot = /[^\\s,]+/gi;
function format_parseRadius(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if ((0,esm/* isArray */.kJ)(radius)) {
        if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
        }
        else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
        }
        else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
        }
        else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = radius;
    }
    return {
        r1: r1,
        r2: r2,
        r3: r3,
        r4: r4,
    };
}
function parsePath(path) {
    path = path || [];
    if (isArray(path)) {
        return path;
    }
    if (isString(path)) {
        path = path.match(regexTags);
        each(path, function (item, index) {
            item = item.match(regexDot);
            if (item[0].length > 1) {
                var tag = item[0].charAt(0);
                item.splice(1, 0, item[0].substr(1));
                item[0] = tag;
            }
            each(item, function (sub, i) {
                if (!isNaN(sub)) {
                    item[i] = +sub;
                }
            });
            path[index] = item;
        });
        return path;
    }
}
//# sourceMappingURL=format.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/rect.js
/**
 * @fileoverview rect
 * @author dengfuping_develop@163.com
 */





var rect_Rect = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Rect, _super);
    function Rect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'rect';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Rect.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect.prototype.createPath = function (context, targetAttrs) {
        var _this = this;
        var attrs = this.attr();
        var el = this.get('el');
        // \u52A0\u4E0A\u72B6\u6001\u91CF\uFF0C\u7528\u6765\u6807\u8BB0 path \u662F\u5426\u5DF2\u7EC4\u88C5
        var completed = false;
        // \u548C\u7EC4\u88C5 path \u76F8\u5173\u7684\u7ED8\u56FE\u5C5E\u6027
        var pathRelatedAttrs = ['x', 'y', 'width', 'height', 'radius'];
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
                el.setAttribute('d', _this._assembleRect(attrs));
                completed = true;
            }
            else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
    };
    Rect.prototype._assembleRect = function (attrs) {
        var x = attrs.x;
        var y = attrs.y;
        var w = attrs.width;
        var h = attrs.height;
        var radius = attrs.radius;
        if (!radius) {
            return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
        }
        var r = format_parseRadius(radius);
        if ((0,esm/* isArray */.kJ)(radius)) {
            if (radius.length === 1) {
                r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
            }
            else if (radius.length === 2) {
                r.r1 = r.r3 = radius[0];
                r.r2 = r.r4 = radius[1];
            }
            else if (radius.length === 3) {
                r.r1 = radius[0];
                r.r2 = r.r4 = radius[1];
                r.r3 = radius[2];
            }
            else {
                r.r1 = radius[0];
                r.r2 = radius[1];
                r.r3 = radius[2];
                r.r4 = radius[3];
            }
        }
        else {
            r.r1 = r.r2 = r.r3 = r.r4 = radius;
        }
        var d = [
            ["M " + (x + r.r1) + "," + y],
            ["l " + (w - r.r1 - r.r2) + ",0"],
            ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
            ["l 0," + (h - r.r2 - r.r3)],
            ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
            ["l " + (r.r3 + r.r4 - w) + ",0"],
            ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
            ["l 0," + (r.r4 + r.r1 - h)],
            ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
            ['z'],
        ];
        return d.join(' ');
    };
    return Rect;
}(esm_shape_base));
/* harmony default export */ var shape_rect = (rect_Rect);
//# sourceMappingURL=rect.js.map
// EXTERNAL MODULE: ./node_modules/detect-browser/es/index.js
var es = __webpack_require__(43631);
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/text.js
/**
 * @fileoverview text
 * @author dengfuping_develop@163.com
 */






var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
    top: 'before-edge',
    middle: 'central',
    bottom: 'after-edge',
    alphabetic: 'baseline',
    hanging: 'hanging',
};
// for FireFox
var BASELINE_MAP_FOR_FIREFOX = {
    top: 'text-before-edge',
    middle: 'central',
    bottom: 'text-after-edge',
    alphabetic: 'alphabetic',
    hanging: 'hanging',
};
var ANCHOR_MAP = {
    left: 'left',
    start: 'left',
    center: 'middle',
    right: 'end',
    end: 'end',
};
var text_Text = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'text';
        _this.canFill = true;
        _this.canStroke = true;
        return _this;
    }
    Text.prototype.getDefaultAttrs = function () {
        var attrs = _super.prototype.getDefaultAttrs.call(this);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });
    };
    Text.prototype.createPath = function (context, targetAttrs) {
        var _this = this;
        var attrs = this.attr();
        var el = this.get('el');
        this._setFont();
        (0,esm/* each */.S6)(targetAttrs || attrs, function (value, attr) {
            if (attr === 'text') {
                _this._setText("" + value);
            }
            else if (attr === 'matrix' && value) {
                setTransform(_this);
            }
            else if (SVG_ATTR_MAP[attr]) {
                el.setAttribute(SVG_ATTR_MAP[attr], value);
            }
        });
        el.setAttribute('paint-order', 'stroke');
        el.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');
    };
    Text.prototype._setFont = function () {
        var el = this.get('el');
        var _a = this.attr(), textBaseline = _a.textBaseline, textAlign = _a.textAlign;
        var browser = (0,es/* detect */.qY)();
        if (browser && browser.name === 'firefox') {
            // compatible with FireFox browser, ref: https://github.com/antvis/g/issues/119
            el.setAttribute('dominant-baseline', BASELINE_MAP_FOR_FIREFOX[textBaseline] || 'alphabetic');
        }
        else {
            el.setAttribute('alignment-baseline', BASELINE_MAP[textBaseline] || 'baseline');
        }
        el.setAttribute('text-anchor', ANCHOR_MAP[textAlign] || 'left');
    };
    Text.prototype._setText = function (text) {
        var el = this.get('el');
        var _a = this.attr(), x = _a.x, _b = _a.textBaseline, baseline = _b === void 0 ? 'bottom' : _b;
        if (!text) {
            el.innerHTML = '';
        }
        else if (~text.indexOf('\\n')) {
            var textArr = text.split('\\n');
            var textLen_1 = textArr.length - 1;
            var arr_1 = '';
            (0,esm/* each */.S6)(textArr, function (segment, i) {
                if (i === 0) {
                    if (baseline === 'alphabetic') {
                        arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"" + -textLen_1 + "em\\">" + segment + "</tspan>";
                    }
                    else if (baseline === 'top') {
                        arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"0.9em\\">" + segment + "</tspan>";
                    }
                    else if (baseline === 'middle') {
                        arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"" + -(textLen_1 - 1) / 2 + "em\\">" + segment + "</tspan>";
                    }
                    else if (baseline === 'bottom') {
                        arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"-" + (textLen_1 + LETTER_SPACING) + "em\\">" + segment + "</tspan>";
                    }
                    else if (baseline === 'hanging') {
                        arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"" + (-(textLen_1 - 1) - LETTER_SPACING) + "em\\">" + segment + "</tspan>";
                    }
                }
                else {
                    arr_1 += "<tspan x=\\"" + x + "\\" dy=\\"1em\\">" + segment + "</tspan>";
                }
            });
            el.innerHTML = arr_1;
        }
        else {
            el.innerHTML = text;
        }
    };
    return Text;
}(esm_shape_base));
/* harmony default export */ var esm_shape_text = (text_Text);
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/shape/index.js












//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/gradient.js
/**
 * @fileoverview gradient
 * @author dengfuping_develop@163.com
 */


var gradient_regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var gradient_regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;
var gradient_regexColorStop = /[\\d.]+:(#[^\\s]+|[^)]+\\))/gi;
function gradient_addStop(steps) {
    var arr = steps.match(gradient_regexColorStop);
    if (!arr) {
        return '';
    }
    var stops = '';
    arr.sort(function (a, b) {
        a = a.split(':');
        b = b.split(':');
        return Number(a[0]) - Number(b[0]);
    });
    (0,esm/* each */.S6)(arr, function (item) {
        item = item.split(':');
        stops += "<stop offset=\\"" + item[0] + "\\" stop-color=\\"" + item[1] + "\\"></stop>";
    });
    return stops;
}
function gradient_parseLineGradient(color, el) {
    var arr = gradient_regexLG.exec(color);
    var angle = (0,esm/* mod */.wQ)((0,esm/* toRadian */.c$)(parseFloat(arr[1])), Math.PI * 2);
    var steps = arr[2];
    var start;
    var end;
    if (angle >= 0 && angle < 0.5 * Math.PI) {
        start = {
            x: 0,
            y: 0,
        };
        end = {
            x: 1,
            y: 1,
        };
    }
    else if (0.5 * Math.PI <= angle && angle < Math.PI) {
        start = {
            x: 1,
            y: 0,
        };
        end = {
            x: 0,
            y: 1,
        };
    }
    else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
        start = {
            x: 1,
            y: 1,
        };
        end = {
            x: 0,
            y: 0,
        };
    }
    else {
        start = {
            x: 0,
            y: 1,
        };
        end = {
            x: 1,
            y: 0,
        };
    }
    var tanTheta = Math.tan(angle);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;
    el.setAttribute('x1', start.x);
    el.setAttribute('y1', start.y);
    el.setAttribute('x2', x);
    el.setAttribute('y2', y);
    el.innerHTML = gradient_addStop(steps);
}
function gradient_parseRadialGradient(color, self) {
    var arr = gradient_regexRG.exec(color);
    var cx = parseFloat(arr[1]);
    var cy = parseFloat(arr[2]);
    var r = parseFloat(arr[3]);
    var steps = arr[4];
    self.setAttribute('cx', cx);
    self.setAttribute('cy', cy);
    self.setAttribute('r', r);
    self.innerHTML = gradient_addStop(steps);
}
var Gradient = /** @class */ (function () {
    function Gradient(cfg) {
        this.cfg = {};
        var el = null;
        var id = (0,esm/* uniqueId */.EL)('gradient_');
        if (cfg.toLowerCase()[0] === 'l') {
            el = createSVGElement('linearGradient');
            gradient_parseLineGradient(cfg, el);
        }
        else {
            el = createSVGElement('radialGradient');
            gradient_parseRadialGradient(cfg, el);
        }
        el.setAttribute('id', id);
        this.el = el;
        this.id = id;
        this.cfg = cfg;
        return this;
    }
    Gradient.prototype.match = function (type, attr) {
        return this.cfg === attr;
    };
    return Gradient;
}());
/* harmony default export */ var defs_gradient = (Gradient);
//# sourceMappingURL=gradient.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/shadow.js
/**
 * @fileoverview shadow
 * @author dengfuping_develop@163.com
 */


var ATTR_MAP = {
    shadowColor: 'color',
    shadowOpacity: 'opacity',
    shadowBlur: 'blur',
    shadowOffsetX: 'dx',
    shadowOffsetY: 'dy',
};
var SHADOW_DIMENSION = {
    x: '-40%',
    y: '-40%',
    width: '200%',
    height: '200%',
};
var Shadow = /** @class */ (function () {
    function Shadow(cfg) {
        this.type = 'filter';
        this.cfg = {};
        this.type = 'filter';
        var el = createSVGElement('filter');
        // expand the filter region to fill in shadows
        (0,esm/* each */.S6)(SHADOW_DIMENSION, function (v, k) {
            el.setAttribute(k, v);
        });
        this.el = el;
        this.id = (0,esm/* uniqueId */.EL)('filter_');
        this.el.id = this.id;
        this.cfg = cfg;
        this._parseShadow(cfg, el);
        return this;
    }
    Shadow.prototype.match = function (type, cfg) {
        if (this.type !== type) {
            return false;
        }
        var flag = true;
        var config = this.cfg;
        (0,esm/* each */.S6)(Object.keys(config), function (attr) {
            if (config[attr] !== cfg[attr]) {
                flag = false;
                return false;
            }
        });
        return flag;
    };
    Shadow.prototype.update = function (name, value) {
        var config = this.cfg;
        config[ATTR_MAP[name]] = value;
        this._parseShadow(config, this.el);
        return this;
    };
    Shadow.prototype._parseShadow = function (config, el) {
        var child = "<feDropShadow\\n      dx=\\"" + (config.dx || 0) + "\\"\\n      dy=\\"" + (config.dy || 0) + "\\"\\n      stdDeviation=\\"" + (config.blur ? config.blur / 10 : 0) + "\\"\\n      flood-color=\\"" + (config.color ? config.color : '#000') + "\\"\\n      flood-opacity=\\"" + (config.opacity ? config.opacity : 1) + "\\"\\n      />";
        el.innerHTML = child;
    };
    return Shadow;
}());
/* harmony default export */ var defs_shadow = (Shadow);
//# sourceMappingURL=shadow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/arrow.js
/**
 * @fileoverview arrow
 * @author dengfuping_develop@163.com
 */


var Arrow = /** @class */ (function () {
    function Arrow(attrs, type) {
        this.cfg = {};
        var el = createSVGElement('marker');
        var id = (0,esm/* uniqueId */.EL)('marker_');
        el.setAttribute('id', id);
        var shape = createSVGElement('path');
        shape.setAttribute('stroke', attrs.stroke || 'none');
        shape.setAttribute('fill', attrs.fill || 'none');
        el.appendChild(shape);
        el.setAttribute('overflow', 'visible');
        el.setAttribute('orient', 'auto-start-reverse');
        this.el = el;
        this.child = shape;
        this.id = id;
        var cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];
        this.stroke = attrs.stroke || '#000';
        if (cfg === true) {
            this._setDefaultPath(type, shape);
        }
        else {
            this.cfg = cfg; // when arrow config exists
            this._setMarker(attrs.lineWidth, shape);
        }
        return this;
    }
    Arrow.prototype.match = function () {
        return false;
    };
    Arrow.prototype._setDefaultPath = function (type, el) {
        var parent = this.el;
        // \u9ED8\u8BA4\u7BAD\u5934\u7684\u8FB9\u957F\u4E3A 10\uFF0C\u5939\u89D2\u4E3A 60 \u5EA6
        el.setAttribute('d', "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
        parent.setAttribute('refX', "" + 10 * Math.cos(Math.PI / 6));
        parent.setAttribute('refY', "" + 5);
    };
    Arrow.prototype._setMarker = function (r, el) {
        var parent = this.el;
        var path = this.cfg.path;
        var d = this.cfg.d;
        if ((0,esm/* isArray */.kJ)(path)) {
            path = path
                .map(function (segment) {
                return segment.join(' ');
            })
                .join('');
        }
        el.setAttribute('d', path);
        parent.appendChild(el);
        if (d) {
            parent.setAttribute('refX', "" + d / r);
        }
    };
    Arrow.prototype.update = function (fill) {
        var child = this.child;
        if (child.attr) {
            child.attr('fill', fill);
        }
        else {
            child.setAttribute('fill', fill);
        }
    };
    return Arrow;
}());
/* harmony default export */ var defs_arrow = (Arrow);
//# sourceMappingURL=arrow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/clip.js
/**
 * @fileoverview clip
 * @author dengfuping_develop@163.com
 */


var Clip = /** @class */ (function () {
    function Clip(cfg) {
        this.type = 'clip';
        this.cfg = {};
        var el = createSVGElement('clipPath');
        this.el = el;
        this.id = (0,esm/* uniqueId */.EL)('clip_');
        el.id = this.id;
        var shapeEl = cfg.cfg.el;
        el.appendChild(shapeEl);
        this.cfg = cfg;
        return this;
    }
    Clip.prototype.match = function () {
        return false;
    };
    Clip.prototype.remove = function () {
        var el = this.el;
        el.parentNode.removeChild(el);
    };
    return Clip;
}());
/* harmony default export */ var defs_clip = (Clip);
//# sourceMappingURL=clip.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/pattern.js
/**
 * @fileoverview pattern
 * @author dengfuping_develop@163.com
 */


var pattern_regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;
var Pattern = /** @class */ (function () {
    function Pattern(cfg) {
        this.cfg = {};
        var el = createSVGElement('pattern');
        el.setAttribute('patternUnits', 'userSpaceOnUse');
        var child = createSVGElement('image');
        el.appendChild(child);
        var id = (0,esm/* uniqueId */.EL)('pattern_');
        el.id = id;
        this.el = el;
        this.id = id;
        this.cfg = cfg;
        var arr = pattern_regexPR.exec(cfg);
        var source = arr[2];
        child.setAttribute('href', source);
        var img = new Image();
        if (!source.match(/^data:/i)) {
            img.crossOrigin = 'Anonymous';
        }
        img.src = source;
        function onload() {
            el.setAttribute('width', "" + img.width);
            el.setAttribute('height', "" + img.height);
        }
        if (img.complete) {
            onload();
        }
        else {
            img.onload = onload;
            // Fix onload() bug in IE9
            img.src = img.src;
        }
        return this;
    }
    Pattern.prototype.match = function (type, attr) {
        return this.cfg === attr;
    };
    return Pattern;
}());
/* harmony default export */ var defs_pattern = (Pattern);
//# sourceMappingURL=pattern.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/defs/index.js
/**
 * @fileoverview defs
 * @author dengfuping_develop@163.com
 */







var Defs = /** @class */ (function () {
    function Defs(canvas) {
        var el = createSVGElement('defs');
        var id = (0,esm/* uniqueId */.EL)('defs_');
        el.id = id;
        canvas.appendChild(el);
        this.children = [];
        this.defaultArrow = {};
        this.el = el;
        this.canvas = canvas;
    }
    Defs.prototype.find = function (type, attr) {
        var children = this.children;
        var result = null;
        for (var i = 0; i < children.length; i++) {
            if (children[i].match(type, attr)) {
                result = children[i].id;
                break;
            }
        }
        return result;
    };
    Defs.prototype.findById = function (id) {
        var children = this.children;
        var flag = null;
        for (var i = 0; i < children.length; i++) {
            if (children[i].id === id) {
                flag = children[i];
                break;
            }
        }
        return flag;
    };
    Defs.prototype.add = function (item) {
        this.children.push(item);
        item.canvas = this.canvas;
        item.parent = this;
    };
    Defs.prototype.getDefaultArrow = function (attrs, name) {
        var stroke = attrs.stroke || attrs.strokeStyle;
        if (this.defaultArrow[stroke]) {
            return this.defaultArrow[stroke].id;
        }
        var arrow = new defs_arrow(attrs, name);
        this.defaultArrow[stroke] = arrow;
        this.el.appendChild(arrow.el);
        this.add(arrow);
        return arrow.id;
    };
    Defs.prototype.addGradient = function (cfg) {
        var gradient = new defs_gradient(cfg);
        this.el.appendChild(gradient.el);
        this.add(gradient);
        return gradient.id;
    };
    Defs.prototype.addArrow = function (attrs, name) {
        var arrow = new defs_arrow(attrs, name);
        this.el.appendChild(arrow.el);
        this.add(arrow);
        return arrow.id;
    };
    Defs.prototype.addShadow = function (cfg) {
        var shadow = new defs_shadow(cfg);
        this.el.appendChild(shadow.el);
        this.add(shadow);
        return shadow.id;
    };
    Defs.prototype.addPattern = function (cfg) {
        var pattern = new defs_pattern(cfg);
        this.el.appendChild(pattern.el);
        this.add(pattern);
        return pattern.id;
    };
    Defs.prototype.addClip = function (cfg) {
        var clip = new defs_clip(cfg);
        this.el.appendChild(clip.el);
        this.add(clip);
        return clip.id;
    };
    return Defs;
}());
/* harmony default export */ var defs = (Defs);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/canvas.js









var canvas_Canvas = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Canvas, _super);
    function Canvas(cfg) {
        return _super.call(this, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { autoDraw: true, 
            // \u8BBE\u7F6E\u6E32\u67D3\u5F15\u64CE\u4E3A canvas\uFF0C\u53EA\u8BFB\u5C5E\u6027
            renderer: 'svg' })) || this;
    }
    Canvas.prototype.getShapeBase = function () {
        return g_svg_esm_shape_namespaceObject;
    };
    Canvas.prototype.getGroupBase = function () {
        return g_svg_esm_group;
    };
    // \u8986\u76D6 Container \u4E2D\u901A\u8FC7\u904D\u5386\u7684\u65B9\u5F0F\u83B7\u53D6 shape \u5BF9\u8C61\u7684\u903B\u8F91\uFF0C\u76F4\u63A5\u8D70 SVG \u7684 dom \u62FE\u53D6\u5373\u53EF
    Canvas.prototype.getShape = function (x, y, ev) {
        var target = ev.target || ev.srcElement;
        if (!SHAPE_TO_TAGS[target.tagName]) {
            var parent_1 = target.parentNode;
            while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
                parent_1 = parent_1.parentNode;
            }
            target = parent_1;
        }
        return this.find(function (child) { return child.get('el') === target; });
    };
    // \u590D\u5199\u57FA\u7C7B\u7684\u65B9\u6CD5\u751F\u6210\u6807\u7B7E
    Canvas.prototype.createDom = function () {
        var element = createSVGElement('svg');
        var context = new defs(element);
        element.setAttribute('width', "" + this.get('width'));
        element.setAttribute('height', "" + this.get('height'));
        // \u7F13\u5B58 context \u5BF9\u8C61
        this.set('context', context);
        return element;
    };
    /**
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    Canvas.prototype.onCanvasChange = function (changeType) {
        var context = this.get('context');
        var el = this.get('el');
        if (changeType === 'sort') {
            var children_1 = this.get('children');
            if (children_1 && children_1.length) {
                sortDom(this, function (a, b) {
                    return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
                });
            }
        }
        else if (changeType === 'clear') {
            // el maybe null for canvas
            if (el) {
                // \u6E05\u7A7A SVG \u5143\u7D20
                el.innerHTML = '';
                var defsEl = context.el;
                // \u6E05\u7A7A defs \u5143\u7D20
                defsEl.innerHTML = '';
                // \u5C06\u6E05\u7A7A\u540E\u7684 defs \u5143\u7D20\u6302\u8F7D\u5230 el \u4E0B
                el.appendChild(defsEl);
            }
        }
        else if (changeType === 'matrix') {
            setTransform(this);
        }
        else if (changeType === 'clip') {
            setClip(this, context);
        }
        else if (changeType === 'changeSize') {
            el.setAttribute('width', "" + this.get('width'));
            el.setAttribute('height', "" + this.get('height'));
        }
    };
    // \u590D\u5199\u57FA\u7C7B\u7684 draw \u65B9\u6CD5
    Canvas.prototype.draw = function () {
        var context = this.get('context');
        var children = this.getChildren();
        setClip(this, context);
        if (children.length) {
            draw_drawChildren(context, children);
        }
    };
    return Canvas;
}(g_base_esm.AbstractCanvas));
/* harmony default export */ var esm_canvas = (canvas_Canvas);
//# sourceMappingURL=canvas.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-svg/esm/index.js





var esm_version = '0.5.6';
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/path.js




/** \u5F15\u5165\u5BF9\u5E94\u7684 ShapeFactory */



/**
 * Path \u51E0\u4F55\u6807\u8BB0\u3002
 * \u7528\u4E8E\u7ED8\u5236\u8DEF\u5F84\u56FE\u7B49\u3002
 */
var geometry_path_Path = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Path, _super);
    function Path(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'path';
        _this.shapeType = 'line';
        var _a = cfg.connectNulls, connectNulls = _a === void 0 ? false : _a, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
        _this.connectNulls = connectNulls;
        _this.showSinglePoint = showSinglePoint;
        return _this;
    }
    /**
     * \u521B\u5EFA\u6240\u6709\u7684 Element \u5B9E\u4F8B\uFF0C\u5BF9\u4E8E Path\u3001Line\u3001Area\uFF0C\u4E00\u7EC4\u6570\u636E\u5BF9\u5E94\u4E00\u4E2A Element\u3002
     * @param mappingData
     * @param [isUpdate]
     * @returns elements
     */
    Path.prototype.updateElements = function (mappingDataArray, isUpdate) {
        var e_1, _a, e_2, _b, e_3, _c;
        if (isUpdate === void 0) { isUpdate = false; }
        // Path \u7684\u6BCF\u4E2A element \u5BF9\u5E94\u4E00\u7EC4\u6570\u636E
        var keyData = new Map();
        var keyIndex = new Map();
        var keys = [];
        var index = 0;
        for (var i = 0; i < mappingDataArray.length; i++) {
            var mappingData = mappingDataArray[i];
            var key = this.getElementId(mappingData);
            keys.push(key);
            keyData.set(key, mappingData);
            keyIndex.set(key, index);
            index++;
        }
        this.elements = new Array(index);
        var _d = diff(this.lastElementsMap, keys), added = _d.added, updated = _d.updated, removed = _d.removed;
        try {
            for (var added_1 = (0,tslib_es6/* __values */.XA)(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
                var key = added_1_1.value;
                var mappingData = keyData.get(key);
                var shapeFactory = this.getShapeFactory();
                var shapeCfg = this.getShapeInfo(mappingData);
                var i = keyIndex.get(key);
                var element = new geometry_element({
                    shapeFactory: shapeFactory,
                    container: this.container,
                    offscreenGroup: this.getOffscreenGroup(),
                    elementIndex: i,
                });
                element.geometry = this;
                element.animate = this.animateOption;
                element.draw(shapeCfg, isUpdate); // \u7ED8\u5236 shape
                this.elementsMap[key] = element;
                this.elements[i] = element;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (added_1_1 && !added_1_1.done && (_a = added_1.return)) _a.call(added_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var updated_1 = (0,tslib_es6/* __values */.XA)(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
                var key = updated_1_1.value;
                var mappingData = keyData.get(key);
                var element = this.lastElementsMap[key];
                var i = keyIndex.get(key);
                var shapeCfg = this.getShapeInfo(mappingData);
                var preShapeCfg = element.getModel();
                if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
                    element.animate = this.animateOption;
                    // \u901A\u8FC7\u7ED8\u5236\u6570\u636E\u7684\u53D8\u66F4\u6765\u5224\u65AD\u662F\u5426\u9700\u8981\u66F4\u65B0\uFF0C\u56E0\u4E3A\u7528\u6237\u6709\u53EF\u80FD\u4F1A\u4FEE\u6539\u56FE\u5F62\u5C5E\u6027\u6620\u5C04
                    element.update(shapeCfg); // \u66F4\u65B0\u5BF9\u5E94\u7684 element
                }
                this.elementsMap[key] = element;
                this.elements[i] = element;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var removed_1 = (0,tslib_es6/* __values */.XA)(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
                var key = removed_1_1.value;
                var element = this.lastElementsMap[key];
                // \u66F4\u65B0\u52A8\u753B\u914D\u7F6E\uFF0C\u7528\u6237\u6709\u53EF\u80FD\u5728\u66F4\u65B0\u4E4B\u524D\u6709\u5BF9\u52A8\u753B\u8FDB\u884C\u914D\u7F6E\u64CD\u4F5C
                element.animate = this.animateOption;
                element.destroy();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    /**
     * \u83B7\u53D6\u7EC4\u6210\u4E00\u6761\u7EBF\uFF08\u4E00\u7EC4\u6570\u636E\uFF09\u7684\u6240\u6709\u70B9\u4EE5\u53CA\u6570\u636E
     * @param mappingData \u6620\u5C04\u540E\u7684\u6570\u7EC4
     */
    Path.prototype.getPointsAndData = function (mappingData) {
        var points = [];
        var data = [];
        for (var i = 0, len = mappingData.length; i < len; i++) {
            var obj = mappingData[i];
            points.push({
                x: obj.x,
                y: obj.y,
            });
            data.push(obj[FIELD_ORIGIN]);
        }
        return {
            points: points,
            data: data,
        };
    };
    Path.prototype.getShapeInfo = function (mappingData) {
        var shapeCfg = this.getDrawCfg(mappingData[0]);
        var _a = this.getPointsAndData(mappingData), points = _a.points, data = _a.data;
        shapeCfg.mappingData = mappingData;
        shapeCfg.data = data;
        shapeCfg.isStack = !!this.getAdjust('stack');
        shapeCfg.points = points;
        shapeCfg.connectNulls = this.connectNulls;
        shapeCfg.showSinglePoint = this.showSinglePoint;
        return shapeCfg;
    };
    return Path;
}(geometry_base));
/* harmony default export */ var geometry_path = (geometry_path_Path);
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/area/util.js




function util_getPath(points, isInCircle, smooth, registeredShape, constraint) {
    var path = [];
    if (points.length) {
        var topLinePoints_1 = []; // area \u533A\u57DF\u4E0A\u90E8\u5206
        var bottomLinePoints_1 = []; // area \u533A\u57DF\u4E0B\u90E8\u5206
        for (var i = 0, len = points.length; i < len; i++) {
            var point = points[i];
            topLinePoints_1.push(point[1]);
            bottomLinePoints_1.push(point[0]);
        }
        bottomLinePoints_1 = bottomLinePoints_1.reverse();
        (0,esm/* each */.S6)([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {
            var subPath = [];
            var parsedPoints = registeredShape.parsePoints(pointsData);
            var p1 = parsedPoints[0];
            if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
                // \u90FD\u53EA\u6709\u4E00\u4E2A\u70B9\uFF0C\u7ED8\u5236\u4E00\u6761\u7AD6\u7EBF
                subPath =
                    index === 0
                        ? [
                            ['M', p1.x - 0.5, p1.y],
                            ['L', p1.x + 0.5, p1.y],
                        ]
                        : [
                            ['L', p1.x + 0.5, p1.y],
                            ['L', p1.x - 0.5, p1.y],
                        ];
            }
            else {
                if (isInCircle) {
                    parsedPoints.push({ x: p1.x, y: p1.y });
                }
                if (smooth) {
                    subPath = getSplinePath(parsedPoints, false, constraint);
                }
                else {
                    subPath = path_getLinePath(parsedPoints, false);
                }
                if (index > 0) {
                    subPath[0][0] = 'L';
                }
            }
            path = path.concat(subPath);
        });
        path.push(['Z']);
    }
    return path;
}
/**
 * @ignore
 * Gets shape attrs
 * @param cfg
 * @param isStroke
 * @param smooth
 * @param registeredShape
 * @param [constraint]
 * @returns
 */
function util_getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
    var attrs = get_style_getStyle(cfg, isStroke, !isStroke, 'lineWidth');
    var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
    var pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // \u6839\u636E connectNulls \u914D\u7F6E\u83B7\u53D6\u56FE\u5F62\u5173\u952E\u70B9
    var path = [];
    for (var i = 0, len = pathPoints.length; i < len; i++) {
        var eachPoints = pathPoints[i];
        path = path.concat(util_getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));
    }
    attrs.path = path;
    return attrs;
}
/**
 * @ignore
 * Gets constraint
 * @param coordinate
 * @returns constraint
 */
function getConstraint(coordinate) {
    var start = coordinate.start, end = coordinate.end;
    return [
        [start.x, end.y],
        [end.x, start.y],
    ];
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/area/index.js



var AreaShapeFactory = registerShapeFactory('area', {
    defaultShapeType: 'area',
    getDefaultPoints: function (pointInfo) {
        // area \u57FA\u672C\u6807\u8BB0\u7684\u7ED8\u5236\u9700\u8981\u83B7\u53D6\u4E0A\u4E0B\u4E24\u8FB9\u7684\u9876\u70B9
        var x = pointInfo.x, y0 = pointInfo.y0;
        var y = (0,esm/* isArray */.kJ)(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
        return y.map(function (yItem) {
            return {
                x: x,
                y: yItem,
            };
        });
    },
});
// Area \u51E0\u4F55\u6807\u8BB0\u9ED8\u8BA4\u7684 shape\uFF1A\u586B\u5145\u7684\u533A\u57DF\u56FE
registerShape('area', 'area', {
    draw: function (cfg, container) {
        var attrs = util_getShapeAttrs(cfg, false, false, this);
        var shape = container.addShape({
            type: 'path',
            attrs: attrs,
            name: 'area',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                if (r === void 0) { r = 5.5; }
                return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
            },
            style: {
                r: 5,
                fill: color,
                fillOpacity: 1,
            },
        };
    },
});
/* harmony default export */ var shape_area = ((/* unused pure expression or super */ null && (AreaShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/area.js




/**
 * Area \u51E0\u4F55\u6807\u8BB0\u7C7B\u3002
 * \u5E38\u7528\u4E8E\u7ED8\u5236\u9762\u79EF\u56FE\u3002
 */
var Area = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Area, _super);
    function Area(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'area';
        _this.shapeType = 'area';
        /** \u751F\u6210\u56FE\u5F62\u5173\u952E\u70B9 */
        _this.generatePoints = true;
        /**
         * \u9762\u79EF\u56FE\u662F\u5426\u4ECE 0 \u57FA\u51C6\u7EBF\u5F00\u59CB\u586B\u5145\u3002
         * 1. \u9ED8\u8BA4\u503C\u4E3A \`true\`\uFF0C\u8868\u73B0\u5982\u4E0B\uFF1A
         * ![image](https://gw.alipayobjects.com/zos/rmsportal/ZQqwUCczalrKqGgagOVp.png)
         * 2. \u5F53\u503C\u4E3A \`false\` \u65F6\uFF0C\u8868\u73B0\u5982\u4E0B\uFF1A
         * ![image](https://gw.alipayobjects.com/zos/rmsportal/yPswkaXvUpCYOdhocGwB.png)
         */
        _this.startOnZero = true;
        var _a = cfg.startOnZero, startOnZero = _a === void 0 ? true : _a, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
        _this.startOnZero = startOnZero; // \u9ED8\u8BA4\u4E3A true
        _this.sortable = sortable; // \u5173\u95ED\u9ED8\u8BA4\u7684 X \u8F74\u6570\u636E\u6392\u5E8F
        _this.showSinglePoint = showSinglePoint;
        return _this;
    }
    /**
     * \u83B7\u53D6\u56FE\u5F62\u7ED8\u5236\u7684\u5173\u952E\u70B9\u4EE5\u53CA\u6570\u636E
     * @param mappingData \u6620\u5C04\u540E\u7684\u6570\u636E
     */
    Area.prototype.getPointsAndData = function (mappingData) {
        var points = [];
        var data = [];
        for (var i = 0, len = mappingData.length; i < len; i++) {
            var obj = mappingData[i];
            points.push(obj.points);
            data.push(obj[FIELD_ORIGIN]);
        }
        return {
            points: points,
            data: data,
        };
    };
    /**
     * \u83B7\u53D6 Y \u8F74\u4E0A\u7684\u6700\u5C0F\u503C
     * @returns y \u5B57\u6BB5\u6700\u5C0F\u503C
     */
    Area.prototype.getYMinValue = function () {
        if (this.startOnZero) {
            return _super.prototype.getYMinValue.call(this);
        }
        var yScale = this.getYScale();
        return yScale.min;
    };
    return Area;
}(geometry_path));
/* harmony default export */ var geometry_area = (Area);
//# sourceMappingURL=area.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/edge/index.js





var EdgeShapeFactory = registerShapeFactory('edge', {
    defaultShapeType: 'line',
    getDefaultPoints: function (pointInfo) {
        return splitPoints(pointInfo);
    },
});
registerShape('edge', 'line', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false, 'lineWidth');
        var path = path_getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        return {
            symbol: 'circle',
            style: {
                r: 4.5,
                fill: markerCfg.color,
            },
        };
    },
});
/* harmony default export */ var edge = ((/* unused pure expression or super */ null && (EdgeShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/edge.js



/**
 * Edge \u51E0\u4F55\u6807\u8BB0\uFF0C\u7528\u4E8E\u7ED8\u5236\u5173\u7CFB\u56FE\u4E2D\u7684**\u8FB9**\u56FE\u5F62\uFF0C\u5982\uFF1A
 * 1. \u6D41\u7A0B\u56FE
 * 2. \u6811
 * 3. \u5F27\u957F\u8FDE\u63A5\u56FE
 * 4. \u548C\u5F26\u56FE
 * 5. \u6851\u57FA\u56FE
 */
var Edge = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Edge, _super);
    function Edge() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'edge';
        _this.shapeType = 'edge';
        _this.generatePoints = true;
        return _this;
    }
    return Edge;
}(geometry_base));
/* harmony default export */ var geometry_edge = (Edge);
//# sourceMappingURL=edge.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/heatmap.js





/**
 * \u7528\u4E8E\u7ED8\u5236\u70ED\u529B\u56FE\u3002
 */
var Heatmap = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Heatmap, _super);
    function Heatmap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'heatmap';
        _this.paletteCache = {};
        return _this;
    }
    Heatmap.prototype.updateElements = function (mappingDataArray, isUpdate) {
        if (isUpdate === void 0) { isUpdate = false; }
        for (var i = 0; i < mappingDataArray.length; i++) {
            var mappingData = mappingDataArray[i];
            var range = this.prepareRange(mappingData);
            var radius = this.prepareSize();
            var blur_1 = (0,esm/* get */.U2)(this.styleOption, ['cfg', 'shadowBlur']);
            if (!(0,esm/* isNumber */.hj)(blur_1)) {
                blur_1 = radius / 2;
            }
            this.prepareGreyScaleBlurredCircle(radius, blur_1);
            this.drawWithRange(mappingData, range, radius, blur_1);
        }
    };
    /** \u70ED\u529B\u56FE\u6682\u65F6\u4E0D\u652F\u6301 callback \u56DE\u8C03\uFF08\u6587\u6863\u9700\u8981\u8BF4\u660E\u4E0B\uFF09 */
    Heatmap.prototype.color = function (field, cfg) {
        this.createAttrOption('color', field, typeof cfg !== 'function' ? cfg : '');
        return this;
    };
    /**
     * clear
     */
    Heatmap.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.clearShadowCanvasCtx();
        this.paletteCache = {};
    };
    Heatmap.prototype.prepareRange = function (data) {
        var colorAttr = this.getAttribute('color');
        var colorField = colorAttr.getFields()[0];
        var min = Infinity;
        var max = -Infinity;
        data.forEach(function (row) {
            var value = row[FIELD_ORIGIN][colorField];
            if (value > max) {
                max = value;
            }
            if (value < min) {
                min = value;
            }
        });
        if (min === max) {
            min = max - 1;
        }
        return [min, max];
    };
    Heatmap.prototype.prepareSize = function () {
        var radius = this.getDefaultValue('size');
        if (!(0,esm/* isNumber */.hj)(radius)) {
            radius = this.getDefaultSize();
        }
        return radius;
    };
    Heatmap.prototype.prepareGreyScaleBlurredCircle = function (radius, blur) {
        var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
        var r2 = radius + blur;
        var ctx = grayScaleBlurredCanvas.getContext('2d');
        grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
        ctx.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
        ctx.shadowBlur = blur;
        ctx.shadowColor = 'black';
        ctx.beginPath();
        ctx.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
    };
    Heatmap.prototype.drawWithRange = function (data, range, radius, blur) {
        var e_1, _a;
        // canvas size
        var _b = this.coordinate, start = _b.start, end = _b.end;
        var width = this.coordinate.getWidth();
        var height = this.coordinate.getHeight();
        // value, range, etc
        var colorAttr = this.getAttribute('color');
        var valueField = colorAttr.getFields()[0];
        // prepare shadow canvas context
        this.clearShadowCanvasCtx();
        var ctx = this.getShadowCanvasCtx();
        // filter data
        if (range) {
            data = data.filter(function (row) {
                return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
            });
        }
        // step1. draw points with shadow
        var scale = this.scales[valueField];
        try {
            for (var data_1 = (0,tslib_es6/* __values */.XA)(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var obj = data_1_1.value;
                var _c = this.getDrawCfg(obj), x = _c.x, y = _c.y;
                var alpha = scale.scale(obj[FIELD_ORIGIN][valueField]);
                this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // step2. convert pixels
        var colored = ctx.getImageData(0, 0, width, height);
        this.clearShadowCanvasCtx();
        this.colorize(colored);
        ctx.putImageData(colored, 0, 0);
        var imageShape = this.getImageShape();
        imageShape.attr('x', start.x);
        imageShape.attr('y', end.y);
        imageShape.attr('width', width);
        imageShape.attr('height', height);
        imageShape.attr('img', ctx.canvas);
        imageShape.set('origin', this.getShapeInfo(data)); // \u5B58\u50A8\u7ED8\u56FE\u4FE1\u606F\u6570\u636E
    };
    Heatmap.prototype.getDefaultSize = function () {
        var position = this.getAttribute('position');
        var coordinate = this.coordinate;
        return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
    };
    Heatmap.prototype.clearShadowCanvasCtx = function () {
        var ctx = this.getShadowCanvasCtx();
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    };
    Heatmap.prototype.getShadowCanvasCtx = function () {
        var canvas = this.shadowCanvas;
        if (!canvas) {
            canvas = document.createElement('canvas');
            this.shadowCanvas = canvas;
        }
        canvas.width = this.coordinate.getWidth();
        canvas.height = this.coordinate.getHeight();
        return canvas.getContext('2d');
    };
    Heatmap.prototype.getGrayScaleBlurredCanvas = function () {
        if (!this.grayScaleBlurredCanvas) {
            this.grayScaleBlurredCanvas = document.createElement('canvas');
        }
        return this.grayScaleBlurredCanvas;
    };
    Heatmap.prototype.drawGrayScaleBlurredCircle = function (x, y, r, alpha, ctx) {
        var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
        ctx.globalAlpha = alpha;
        ctx.drawImage(grayScaleBlurredCanvas, x - r, y - r);
    };
    Heatmap.prototype.colorize = function (img) {
        var colorAttr = this.getAttribute('color');
        var pixels = img.data;
        var paletteCache = this.paletteCache;
        for (var i = 3; i < pixels.length; i += 4) {
            var alpha = pixels[i]; // get gradient color from opacity value
            if ((0,esm/* isNumber */.hj)(alpha)) {
                var palette = paletteCache[alpha] ? paletteCache[alpha] : color_util_esm.rgb2arr(colorAttr.gradient(alpha / 256));
                pixels[i - 3] = palette[0];
                pixels[i - 2] = palette[1];
                pixels[i - 1] = palette[2];
                pixels[i] = alpha;
            }
        }
    };
    Heatmap.prototype.getImageShape = function () {
        var imageShape = this.imageShape;
        if (imageShape) {
            return imageShape;
        }
        var container = this.container;
        imageShape = container.addShape({
            type: 'image',
            attrs: {},
        });
        this.imageShape = imageShape;
        return imageShape;
    };
    Heatmap.prototype.getShapeInfo = function (mappingData) {
        var shapeCfg = this.getDrawCfg(mappingData[0]);
        var data = mappingData.map(function (obj) {
            return obj[FIELD_ORIGIN];
        });
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeCfg), { mappingData: mappingData, data: data });
    };
    return Heatmap;
}(geometry_base));
/* harmony default export */ var heatmap = (Heatmap);
//# sourceMappingURL=heatmap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/util.js



/**
 * @ignore
 * \u6839\u636E\u6570\u636E\u70B9\u751F\u6210\u77E9\u5F62\u7684\u56DB\u4E2A\u5173\u952E\u70B9
 * @param pointInfo \u6570\u636E\u70B9\u4FE1\u606F
 * @param [isPyramid] \u662F\u5426\u4E3A\u5C16\u5E95\u6F0F\u6597\u56FE
 * @returns rect points \u8FD4\u56DE\u77E9\u5F62\u56DB\u4E2A\u9876\u70B9\u4FE1\u606F
 */
function getRectPoints(pointInfo) {
    var _a, _b;
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size = pointInfo.size;
    // \u6709 4 \u79CD\u60C5\u51B5\uFF0C
    // 1. x, y \u90FD\u4E0D\u662F\u6570\u7EC4
    // 2. y\u662F\u6570\u7EC4\uFF0Cx\u4E0D\u662F
    // 3. x\u662F\u6570\u7EC4\uFF0Cy\u4E0D\u662F
    // 4. x, y \u90FD\u662F\u6570\u7EC4
    var yMin;
    var yMax;
    if ((0,esm/* isArray */.kJ)(y)) {
        _a = (0,tslib_es6/* __read */.CR)(y, 2), yMin = _a[0], yMax = _a[1];
    }
    else {
        yMin = y0;
        yMax = y;
    }
    var xMin;
    var xMax;
    if ((0,esm/* isArray */.kJ)(x)) {
        _b = (0,tslib_es6/* __read */.CR)(x, 2), xMin = _b[0], xMax = _b[1];
    }
    else {
        xMin = x - size / 2;
        xMax = x + size / 2;
    }
    var points = [
        { x: xMin, y: yMin },
        { x: xMin, y: yMax },
    ];
    // \u77E9\u5F62\u7684\u56DB\u4E2A\u5173\u952E\u70B9\uFF0C\u7ED3\u6784\u5982\u4E0B\uFF08\u5DE6\u4E0B\u89D2\u987A\u65F6\u9488\u8FDE\u63A5\uFF09
    // 1 ---- 2
    // |      |
    // 0 ---- 3
    points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
    return points;
}
/**
 * @ignore
 * \u6839\u636E\u77E9\u5F62\u5173\u952E\u70B9\u7ED8\u5236 path
 * @param points \u5173\u952E\u70B9\u6570\u7EC4
 * @param isClosed path \u662F\u5426\u9700\u8981\u95ED\u5408
 * @returns \u8FD4\u56DE\u77E9\u5F62\u7684 path
 */
function getRectPath(points, isClosed) {
    if (isClosed === void 0) { isClosed = true; }
    var path = [];
    var firstPoint = points[0];
    path.push(['M', firstPoint.x, firstPoint.y]);
    for (var i = 1, len = points.length; i < len; i++) {
        path.push(['L', points[i].x, points[i].y]);
    }
    // \u5BF9\u4E8E shape="line" path \u4E0D\u5E94\u8BE5\u95ED\u5408\uFF0C\u5426\u5219\u4F1A\u9020\u6210 lineCap \u7ED8\u56FE\u5C5E\u6027\u5931\u6548
    if (isClosed) {
        path.push(['L', firstPoint.x, firstPoint.y]); // \u9700\u8981\u95ED\u5408
        path.push(['z']);
    }
    return path;
}
/**
 * \u5904\u7406 rect path \u7684 radius
 * @returns \u8FD4\u56DE\u77E9\u5F62 path \u7684\u56DB\u4E2A\u89D2\u7684 arc \u534A\u5F84
 */
function util_parseRadius(radius, minLength) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if ((0,esm/* isArray */.kJ)(radius)) {
        if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
        }
        else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
        }
        else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
        }
        else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = radius;
    }
    // \u5904\u7406 \u8FB9\u754C\u503C
    if (r1 + r2 > minLength) {
        r1 = r1 ? minLength / (1 + r2 / r1) : 0;
        r2 = minLength - r1;
    }
    if (r3 + r4 > minLength) {
        r3 = r3 ? minLength / (1 + r4 / r3) : 0;
        r4 = minLength - r3;
    }
    return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
/**
 * \u83B7\u53D6 interval \u77E9\u5F62\u80CC\u666F\u7684 path
 * @param cfg \u5173\u952E\u70B9\u7684\u4FE1\u606F
 * @param points \u5DF2\u8F6C\u5316\u4E3A\u753B\u5E03\u5750\u6807\u7684 4 \u4E2A\u5173\u952E\u70B9
 * @param coordinate \u5750\u6807\u7CFB
 * @returns \u8FD4\u56DE\u77E9\u5F62\u80CC\u666F\u7684 path
 */
function getBackgroundRectPath(cfg, points, coordinate) {
    var path = [];
    if (coordinate.isRect) {
        var p0 = coordinate.isTransposed
            ? { x: coordinate.start.x, y: points[0].y }
            : { x: points[0].x, y: coordinate.start.y };
        var p1 = coordinate.isTransposed
            ? { x: coordinate.end.x, y: points[2].y }
            : { x: points[3].x, y: coordinate.end.y };
        // corner radius of background shape works only in \u7B1B\u5361\u5C14\u5750\u6807\u7CFB
        var radius = (0,esm/* get */.U2)(cfg, ['background', 'style', 'radius']);
        if (radius) {
            var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
            var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();
            var _a = (0,tslib_es6/* __read */.CR)(util_parseRadius(radius, Math.min(width, height)), 4), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];
            // \u540C\u65F6\u5B58\u5728 \u5750\u6807\u7CFB\u662F\u5426\u53D1\u751F\u8F6C\u7F6E \u548C y \u955C\u50CF\u7684\u65F6\u5019
            var isReflectYTransposed_1 = (coordinate.isTransposed && coordinate.isReflect('y'));
            var bump = isReflectYTransposed_1 ? 0 : 1;
            var opposite = function (r) { return isReflectYTransposed_1 ? -r : r; };
            path.push(['M', p0.x, p1.y + opposite(r1)]);
            r1 !== 0 && path.push(['A', r1, r1, 0, 0, bump, p0.x + r1, p1.y]);
            path.push(['L', p1.x - r2, p1.y]);
            r2 !== 0 && path.push(['A', r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);
            path.push(['L', p1.x, p0.y - opposite(r3)]);
            r3 !== 0 && path.push(['A', r3, r3, 0, 0, bump, p1.x - r3, p0.y]);
            path.push(['L', p0.x + r4, p0.y]);
            r4 !== 0 && path.push(['A', r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);
        }
        else {
            path.push(['M', p0.x, p0.y]);
            path.push(['L', p1.x, p0.y]);
            path.push(['L', p1.x, p1.y]);
            path.push(['L', p0.x, p1.y]);
            path.push(['L', p0.x, p0.y]);
        }
        path.push(['z']);
    }
    if (coordinate.isPolar) {
        var center = coordinate.getCenter();
        var _b = getAngle(cfg, coordinate), startAngle = _b.startAngle, endAngle = _b.endAngle;
        if (coordinate.type !== 'theta' && !coordinate.isTransposed) {
            // \u83B7\u53D6\u6247\u5F62 path
            path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
        }
        else {
            var pow = function (v) { return Math.pow(v, 2); };
            var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));
            var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));
            // \u83B7\u53D6\u6247\u5F62 path\uFF08\u5176\u5B9E\u662F\u4E00\u4E2A\u5706\u73AF\uFF0C\u4ECE coordinate \u7684\u8D77\u59CB\u89D2\u5EA6\u5230\u7ED3\u675F\u89D2\u5EA6\uFF09
            path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
        }
    }
    return path;
}
/**
 * @ignore
 * \u6839\u636E\u77E9\u5F62\u5173\u952E\u70B9\u7ED8\u5236 path
 * @param points \u5173\u952E\u70B9\u6570\u7EC4
 * @param lineCap 'round'\u5706\u89D2\u6837\u5F0F
 * @param coor \u5750\u6807
 * @returns \u8FD4\u56DE\u77E9\u5F62\u7684 path
 */
function getIntervalRectPath(points, lineCap, coor) {
    var width = coor.getWidth();
    var height = coor.getHeight();
    var isRect = coor.type === 'rect';
    var path = [];
    var r = (points[2].x - points[1].x) / 2;
    var ry = coor.isTransposed ? (r * height) / width : (r * width) / height;
    if (lineCap === 'round') {
        if (isRect) {
            path.push(['M', points[0].x, points[0].y + ry]);
            path.push(['L', points[1].x, points[1].y - ry]);
            path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
            path.push(['L', points[3].x, points[3].y + ry]);
            path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
        }
        else {
            path.push(['M', points[0].x, points[0].y]);
            path.push(['L', points[1].x, points[1].y]);
            path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);
            path.push(['L', points[3].x, points[3].y]);
            path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);
        }
        path.push(['z']);
    }
    else {
        path = getRectPath(points);
    }
    return path;
}
/**
 * @ignore
 * \u6839\u636E funnel \u5173\u952E\u70B9\u7ED8\u5236\u6F0F\u6597\u56FE\u7684 path
 * @param points \u56FE\u5F62\u5173\u952E\u70B9\u4FE1\u606F
 * @param nextPoints \u4E0B\u4E00\u4E2A\u6570\u636E\u7684\u56FE\u5F62\u5173\u952E\u70B9\u4FE1\u606F
 * @param isPyramid \u662F\u5426\u4E3A\u5C16\u5E95\u6F0F\u6597\u56FE
 * @returns \u8FD4\u56DE\u6F0F\u6597\u56FE\u7684\u56FE\u5F62 path
 */
function getFunnelPath(points, nextPoints, isPyramid) {
    var path = [];
    if (!(0,esm/* isNil */.UM)(nextPoints)) {
        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);
    }
    else if (isPyramid) {
        // \u91D1\u5B57\u5854\u6700\u5E95\u90E8
        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ['Z']);
    }
    else {
        // \u6F0F\u6597\u56FE\u6700\u5E95\u90E8
        path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);
    }
    return path;
}
/**
 * \u4EA4\u6362\u4E24\u4E2A\u5BF9\u8C61
 */
function swap(p0, p1) {
    return [p1, p0];
}
/**
 * \u83B7\u53D6 \u5012\u89D2 \u77E9\u5F62
 * - \u76EE\u524D\u53EA\u9002\u7528\u4E8E\u7B1B\u5361\u5C14\u5750\u6807\u7CFB\u4E0B
 */
function getRectWithCornerRadius(points, coordinate, radius) {
    var _a, _b, _c, _d, _e, _f, _g;
    // \u83B7\u53D6 \u56DB\u4E2A\u5173\u952E\u70B9
    var _h = (0,tslib_es6/* __read */.CR)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(points), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
    var _j = (0,tslib_es6/* __read */.CR)(typeof radius === 'number' ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
    if (coordinate.isTransposed) {
        _a = (0,tslib_es6/* __read */.CR)(swap(p1, p3), 2), p1 = _a[0], p3 = _a[1];
    }
    /**
     * \u5B58\u5728\u955C\u50CF
     */
    if (coordinate.isReflect('y')) {
        _b = (0,tslib_es6/* __read */.CR)(swap(p0, p1), 2), p0 = _b[0], p1 = _b[1];
        _c = (0,tslib_es6/* __read */.CR)(swap(p2, p3), 2), p2 = _c[0], p3 = _c[1];
    }
    if (coordinate.isReflect('x')) {
        _d = (0,tslib_es6/* __read */.CR)(swap(p0, p3), 2), p0 = _d[0], p3 = _d[1];
        _e = (0,tslib_es6/* __read */.CR)(swap(p1, p2), 2), p1 = _e[0], p2 = _e[1];
    }
    var path = [];
    /**
     *  p1 \u2192 p2
     *  \u2191    \u2193
     *  p0 \u2190 p3
     *
     *  \u8D1F\u6570\u7684\u60C5\u51B5\uFF0C\u5173\u952E\u70B9\u4F1A\u53D8\u6210\u4E0B\u9762\u7684\u5F62\u5F0F
     *
     *  p0 \u2190 p3               p2 \u2190 p1
     *  \u2193    \u2191                \u2193     \u2191
     *  p1 \u2192 p2  --> (\u8F6C\u7F6E\u4E0B)  p3 \u2192 p0
     */
    var abs = function (v) { return Math.abs(v); };
    _f = (0,tslib_es6/* __read */.CR)(util_parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function (d) { return abs(d); }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
    if (coordinate.isTransposed) {
        _g = (0,tslib_es6/* __read */.CR)([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
    }
    if (p0.y < p1.y /** \u8D1F\u6570\u60C5\u51B5 */) {
        path.push(['M', p3.x, p3.y + r3]);
        r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x - r3, p3.y]);
        path.push(['L', p0.x + r4, p0.y]);
        r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y + r4]);
        path.push(['L', p1.x, p1.y - r1]);
        r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0 /** \u9006\u65F6\u9488 */, p1.x + r1, p1.y]);
        path.push(['L', p2.x - r2, p2.y]);
        r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y - r2]);
        path.push(['L', p3.x, p3.y + r3]);
        path.push(['z']);
    }
    else if (p3.x < p0.x) {
        path.push(['M', p2.x + r2, p2.y]);
        r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y + r2]);
        path.push(['L', p3.x, p3.y - r3]);
        r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x + r3, p3.y]);
        path.push(['L', p0.x - r4, p0.y]);
        r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y - r4]);
        path.push(['L', p1.x, p1.y + r1]);
        r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0, p1.x - r1, p1.y]);
        path.push(['L', p2.x + r2, p2.y]);
        path.push(['z']);
    }
    else {
        path.push(['M', p1.x, p1.y + r1]);
        r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
        path.push(['L', p2.x - r2, p2.y]);
        r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
        path.push(['L', p3.x, p3.y - r3]);
        r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
        path.push(['L', p0.x + r4, p0.y]);
        r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
        path.push(['L', p1.x, p1.y + r1]);
        path.push(['z']);
    }
    return path;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/index.js





/** Interval \u7684 shape \u5DE5\u5382 */
var IntervalShapeFactory = registerShapeFactory('interval', {
    defaultShapeType: 'rect',
    getDefaultPoints: function (pointInfo) {
        return getRectPoints(pointInfo);
    },
});
/** Inerval \u9ED8\u8BA4 shape\uFF0C\u586B\u5145\u7684\u77E9\u5F62 */
registerShape('interval', 'rect', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, false, true);
        var group = container;
        var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
        if (backgroundCfg) {
            group = container.addGroup({
                name: 'interval-group',
            });
            var backgroundStyle = getBackgroundRectStyle(cfg);
            var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
            group.addShape('path', {
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, backgroundStyle), { path: backgroundPath }),
                capture: false,
                zIndex: -1,
                name: BACKGROUND_SHAPE,
            });
        }
        var path;
        if (style.radius && this.coordinate.isRect) {
            path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
        }
        else {
            path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
        }
        var shape = group.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            name: 'interval',
        });
        return backgroundCfg ? group : shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color, isInPolar = markerCfg.isInPolar;
        if (isInPolar) {
            return {
                symbol: 'circle',
                style: {
                    r: 4.5,
                    fill: color,
                },
            };
        }
        return {
            symbol: 'square',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
/* harmony default export */ var interval = ((/* unused pure expression or super */ null && (IntervalShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/util/shape-size.js


// \u5DF2\u7ECF\u6392\u5E8F\u540E\u7684\u6570\u636E\u67E5\u627E\u8DDD\u79BB\u6700\u5C0F\u7684
function findMinDistance(arr, scale) {
    var count = arr.length;
    var sourceArr = arr;
    if ((0,esm/* isString */.HD)(sourceArr[0])) {
        // \u65E5\u671F\u7C7B\u578B\u7684 values \u7ECF\u5E38\u4E0A\u6587\u672C\u7C7B\u578B\uFF0C\u6240\u4EE5\u9700\u8981\u8F6C\u6362\u4E00\u4E0B
        sourceArr = arr.map(function (v) {
            return scale.translate(v);
        });
    }
    var distance = sourceArr[1] - sourceArr[0];
    for (var i = 2; i < count; i++) {
        var tmp = sourceArr[i] - sourceArr[i - 1];
        if (distance > tmp) {
            distance = tmp;
        }
    }
    return distance;
}
function getDodgeCount(dataArray, dodgeBy) {
    if (dodgeBy) {
        var mergeData = (0,esm/* flatten */.xH)(dataArray);
        var values = (0,esm/* valuesOfKey */.I)(mergeData, dodgeBy);
        return values.length;
    }
    return dataArray.length;
}
/** @ignore */
function getDefaultSize(geometry) {
    var theme = geometry.theme;
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var xValues = xScale.values;
    var dataArray = geometry.beforeMappingData;
    var count = xValues.length;
    var xDimensionLength = getXDimensionLength(geometry.coordinate);
    // \u83B7\u53D6\u67F1\u5BBD\u76F8\u5173\u914D\u7F6E\u9879
    var intervalPadding = geometry.intervalPadding, dodgePadding = geometry.dodgePadding;
    // \u517C\u5BB9theme\u914D\u7F6E
    var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
    var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
    var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;
    // \u7EBF\u6027\u60C5\u51B5\u4E0Bcount\u503C
    if (xScale.isLinear && xValues.length > 1) {
        // Linear \u7C7B\u578B\u7528\u6237\u6709\u53EF\u80FD\u8BBE\u7F6E\u4E86 min, max \u8303\u56F4\u6240\u4EE5\u9700\u8981\u6839\u636E\u6570\u636E\u6700\u5C0F\u533A\u95F4\u8BA1\u7B97 count
        xValues.sort();
        var interval = findMinDistance(xValues, xScale);
        count = (xScale.max - xScale.min) / interval;
        if (xValues.length > count) {
            count = xValues.length;
        }
    }
    var range = xScale.range;
    var normalizedSize = 1 / count;
    var wr = 1;
    if (coordinate.isPolar) {
        // \u6781\u5750\u6807\u573A\u666F
        if (coordinate.isTransposed && count > 1) {
            // \u6781\u5750\u6807\u4E0B\u591A\u5C42\u73AF\u56FE
            wr = multiplePieWidthRatio;
        }
        else {
            wr = roseWidthRatio;
        }
    }
    else {
        // \u975E\u6781\u5750\u6807\u573A\u666F
        if (xScale.isLinear) {
            normalizedSize *= range[1] - range[0];
        }
        wr = columnWidthRatio;
    }
    // \u57FA\u7840\u67F1\u72B6\u56FE
    if (!(0,esm/* isNil */.UM)(intervalPadding) && intervalPadding >= 0) {
        // \u914D\u7F6E\u7EC4\u95F4\u8DDD\u60C5\u51B5
        var normalizedIntervalPadding = intervalPadding / xDimensionLength;
        normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
    }
    else {
        // \u9ED8\u8BA4\u60C5\u51B5
        normalizedSize *= wr;
    }
    // \u5206\u7EC4\u67F1\u72B6\u56FE
    if (geometry.getAdjust('dodge')) {
        var dodgeAdjust = geometry.getAdjust('dodge');
        var dodgeBy = dodgeAdjust.dodgeBy;
        var dodgeCount = getDodgeCount(dataArray, dodgeBy);
        if (!(0,esm/* isNil */.UM)(dodgePadding) && dodgePadding >= 0) {
            // \u4EC5\u914D\u7F6E\u7EC4\u5185\u95F4\u8DDD\u60C5\u51B5
            var normalizedDodgePadding = dodgePadding / xDimensionLength;
            normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
        }
        else if (!(0,esm/* isNil */.UM)(intervalPadding) && intervalPadding >= 0) {
            // \u8BBE\u7F6E\u7EC4\u95F4\u8DDD\u4F46\u672A\u8BBE\u7F6E\u7EC4\u5185\u95F4\u8DDD\u60C5\u51B5\uFF0C\u907F\u514D\u7EC4\u95F4\u8DDD\u8FC7\u5C0F\u5BFC\u81F4\u56FE\u5F62\u91CD\u53E0\uFF0C\u9700\u4E58\u4EE5wr
            normalizedSize *= wr;
            normalizedSize = normalizedSize / dodgeCount;
        }
        else {
            // \u7EC4\u95F4\u8DDD\u548C\u7EC4\u5185\u95F4\u8DDD\u5747\u672A\u914D\u7F6E
            normalizedSize = normalizedSize / dodgeCount;
        }
        normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
    }
    // \u6700\u5927\u548C\u6700\u5C0F\u9650\u5236
    if (!(0,esm/* isNil */.UM)(maxColumnWidth) && maxColumnWidth >= 0) {
        var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
        if (normalizedSize > normalizedMaxColumnWidth) {
            normalizedSize = normalizedMaxColumnWidth;
        }
    }
    // \bminColumnWidth\u53EF\u80FD\u8BBE\u7F6E\u4E3A0
    if (!(0,esm/* isNil */.UM)(minColumnWidth) && minColumnWidth >= 0) {
        var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
        if (normalizedSize < normalizedMinColumnWidth) {
            normalizedSize = normalizedMinColumnWidth;
        }
    }
    return normalizedSize;
}
//# sourceMappingURL=shape-size.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/interval.js




/** \u5F15\u5165\u5BF9\u5E94\u7684 ShapeFactory */



/**
 * Interval \u51E0\u4F55\u6807\u8BB0\u3002
 * \u7528\u4E8E\u7ED8\u5236\u67F1\u72B6\u56FE\u3001\u997C\u56FE\u3001\u6761\u5F62\u56FE\u3001\u73AB\u7470\u56FE\u7B49\u3002
 */
var Interval = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Interval, _super);
    function Interval(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'interval';
        _this.shapeType = 'interval';
        _this.generatePoints = true;
        var background = cfg.background;
        _this.background = background;
        return _this;
    }
    /**
     * \u83B7\u53D6\u6BCF\u6761\u6570\u636E\u7684 Shape \u7ED8\u5236\u4FE1\u606F
     * @param obj \u7ECF\u8FC7\u5206\u7EC4 -> \u6570\u5B57\u5316 -> adjust \u8C03\u6574\u540E\u7684\u6570\u636E\u8BB0\u5F55
     * @returns
     */
    Interval.prototype.createShapePointsCfg = function (obj) {
        var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
        // \u8BA1\u7B97\u6BCF\u4E2A shape \u7684 size
        var size;
        var sizeAttr = this.getAttribute('size');
        if (sizeAttr) {
            size = this.getAttributeValues(sizeAttr, obj)[0];
            // \u5F52\u4E00\u5316
            var coordinate = this.coordinate;
            var coordinateWidth = getXDimensionLength(coordinate);
            size = size / coordinateWidth;
        }
        else {
            if (!this.defaultSize) {
                this.defaultSize = getDefaultSize(this);
            }
            size = this.defaultSize;
        }
        cfg.size = size;
        return cfg;
    };
    /**
     * \u8C03\u6574 y \u8F74\u7684 scale \u8303\u56F4\u3002
     * \u5BF9\u4E8E Y \u8F74\u4E3A\u6570\u503C\u8F74\u67F1\u72B6\u56FE\uFF0C\u9ED8\u8BA4\u4ECE 0 \u5F00\u59CB \u751F\u957F\u3002
     */
    Interval.prototype.adjustScale = function () {
        _super.prototype.adjustScale.call(this);
        var yScale = this.getYScale();
        // \u7279\u6B8A\u903B\u8F91\uFF1A\u997C\u56FE\u9700\u8981\u586B\u5145\u6EE1\u6574\u4E2A\u7A7A\u95F4
        if (this.coordinate.type === 'theta') {
            yScale.change({
                nice: false,
                min: 0,
                // \u53D1\u751F\u8FC7 stack \u8C03\u6574\uFF0CyScale \u7684 max \u88AB\u8C03\u6574\u8FC7\uFF0Cthis.updateStackRange()
                max: getMaxScale(yScale),
            });
        }
        else {
            // \u67F1\u72B6\u56FE\u6570\u503C\u8F74\u9ED8\u8BA4\u4ECE 0 \u5F00\u59CB
            var scaleDefs = this.scaleDefs;
            var field = yScale.field, min = yScale.min, max = yScale.max, type = yScale.type;
            if (type !== 'time') {
                // time \u7C7B\u578B\u4E0D\u505A\u8C03\u6574
                // \u67F1\u72B6\u56FE\u7684 Y \u8F74\u8981\u4ECE 0 \u5F00\u59CB\u751F\u957F\uFF0C\u4F46\u662F\u5982\u679C\u7528\u6237\u8BBE\u7F6E\u4E86\u5219\u4EE5\u7528\u6237\u7684\u4E3A\u51C6
                if (min > 0 && !(0,esm/* get */.U2)(scaleDefs, [field, 'min'])) {
                    yScale.change({
                        min: 0,
                    });
                }
                // \u67F1\u5F53\u67F1\u72B6\u56FE\u5168\u4E3A\u8D1F\u503C\u65F6\u4E5F\u9700\u8981\u4ECE 0 \u5F00\u59CB\u751F\u957F\uFF0C\u4F46\u662F\u5982\u679C\u7528\u6237\u8BBE\u7F6E\u4E86\u5219\u4EE5\u7528\u6237\u7684\u4E3A\u51C6
                if (max <= 0 && !(0,esm/* get */.U2)(scaleDefs, [field, 'max'])) {
                    yScale.change({
                        max: 0,
                    });
                }
            }
        }
    };
    /**
     * @override
     */
    Interval.prototype.getDrawCfg = function (mappingData) {
        var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
        shapeCfg.background = this.background;
        return shapeCfg;
    };
    return Interval;
}(geometry_base));
/* harmony default export */ var geometry_interval = (Interval);
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/line.js


/** \u5F15\u5165 Path \u5BF9\u5E94\u7684 ShapeFactory */

/**
 * Line \u51E0\u4F55\u6807\u8BB0\u3002
 * \u5E38\u7528\u4E8E\u6298\u7EBF\u56FE\u7684\u7ED8\u5236\u3002
 */
var geometry_line_Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.type = 'line';
        var _a = cfg.sortable, sortable = _a === void 0 ? false : _a; // \u5173\u95ED\u9ED8\u8BA4\u7684 X \u8F74\u6570\u636E\u6392\u5E8F
        _this.sortable = sortable;
        return _this;
    }
    return Line;
}(geometry_path));
/* harmony default export */ var geometry_line = (geometry_line_Line);
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/point/util.js



var SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];
var HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line'];
/**
 * @ignore
 * Draws points
 * @param shape
 * @param cfg
 * @param container
 * @param shapeName
 * @param isStroke
 * @returns points
 */
function drawPoints(shape, cfg, container, shapeName, isStroke) {
    var e_1, _a;
    var style = get_style_getStyle(cfg, isStroke, !isStroke, 'r');
    var points = shape.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
        pointPosition = points[1];
    }
    else if (points.length > 1) {
        var group = container.addGroup();
        try {
            for (var points_1 = (0,tslib_es6/* __values */.XA)(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                var point = points_1_1.value;
                group.addShape({
                    type: 'marker',
                    attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point),
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return group;
    }
    return container.addShape({
        type: 'marker',
        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition),
    });
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/point/index.js





var PointShapeFactory = registerShapeFactory('point', {
    defaultShapeType: 'hollow-circle',
    getDefaultPoints: function (pointInfo) {
        return splitPoints(pointInfo);
    },
});
(0,esm/* each */.S6)(SHAPES, function (shapeName) {
    // \u6DFB\u52A0\u8BE5 shape \u5BF9\u5E94\u7684 hollow-shape
    registerShape('point', "hollow-".concat(shapeName), {
        draw: function (cfg, container) {
            return drawPoints(this, cfg, container, shapeName, true);
        },
        getMarker: function (markerCfg) {
            var color = markerCfg.color;
            return {
                symbol: MarkerSymbols[shapeName] || shapeName,
                style: {
                    r: 4.5,
                    stroke: color,
                    fill: null,
                },
            };
        },
    });
});
/* harmony default export */ var point = ((/* unused pure expression or super */ null && (PointShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/point.js


/** \u5F15\u5165 Point \u5BF9\u5E94\u7684 ShapeFactory */

/**
 * Point \u51E0\u4F55\u6807\u8BB0\u3002
 * \u5E38\u7528\u4E8E\u7ED8\u5236\u70B9\u56FE\u3002
 */
var Point = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Point, _super);
    function Point() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'point';
        _this.shapeType = 'point';
        _this.generatePoints = true;
        return _this;
    }
    /**
     * \u83B7\u53D6\u4E00\u4E2A\u70B9\u7684\u7ED8\u5236\u4FE1\u606F\u3002
     * @param mappingDatum
     * @returns draw cfg
     */
    Point.prototype.getDrawCfg = function (mappingDatum) {
        var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeCfg), { isStack: !!this.getAdjust('stack') });
    };
    return Point;
}(geometry_base));
/* harmony default export */ var geometry_point = (Point);
//# sourceMappingURL=point.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/polygon/index.js




function polygon_getPath(points) {
    var flag = points[0];
    var i = 1;
    var path = [['M', flag.x, flag.y]];
    while (i < points.length) {
        var c = points[i];
        if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
            path.push(['L', c.x, c.y]);
            if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
                flag = points[i + 1];
                path.push(['Z']);
                path.push(['M', flag.x, flag.y]);
                i++;
            }
        }
        i++;
    }
    if (!(0,esm/* isEqual */.Xy)((0,esm/* last */.Z$)(path), flag)) {
        path.push(['L', flag.x, flag.y]);
    }
    path.push(['Z']);
    return path;
}
var PolygonShapeFactory = registerShapeFactory('polygon', {
    defaultShapeType: 'polygon',
    getDefaultPoints: function (pointInfo) {
        var points = [];
        (0,esm/* each */.S6)(pointInfo.x, function (subX, index) {
            var subY = pointInfo.y[index];
            points.push({
                x: subX,
                y: subY,
            });
        });
        return points;
    },
});
registerShape('polygon', 'polygon', {
    draw: function (cfg, container) {
        if (!(0,esm/* isEmpty */.xb)(cfg.points)) {
            var shapeAttrs = get_style_getStyle(cfg, true, true);
            var path = this.parsePath(polygon_getPath(cfg.points));
            return container.addShape('path', {
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeAttrs), { path: path }),
                name: 'polygon',
            });
        }
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'square',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
/* harmony default export */ var geometry_shape_polygon = ((/* unused pure expression or super */ null && (PolygonShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/polygon.js



/** \u5F15\u5165 Path \u5BF9\u5E94\u7684 ShapeFactory */

/**
 * Polygon \u51E0\u4F55\u6807\u8BB0\u3002
 * \u5E38\u7528\u4E8E\u7ED8\u5236\u8272\u5757\u56FE\u3001\u65E5\u5386\u56FE\u7B49\u3002
 */
var geometry_polygon_Polygon = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Polygon, _super);
    function Polygon() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'polygon';
        _this.shapeType = 'polygon';
        _this.generatePoints = true;
        return _this;
    }
    /**
     * \u83B7\u53D6 Shape \u7684\u5173\u952E\u70B9\u6570\u636E\u3002
     * @param obj
     * @returns
     */
    Polygon.prototype.createShapePointsCfg = function (obj) {
        var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
        var x = cfg.x;
        var y = cfg.y;
        var temp;
        // x y \u90FD\u662F\u6570\u7EC4\u65F6\uFF0C\u4E0D\u505A\u5904\u7406
        if (!((0,esm/* isArray */.kJ)(x) && (0,esm/* isArray */.kJ)(y))) {
            var xScale = this.getXScale();
            var yScale = this.getYScale();
            var xCount = xScale.values.length;
            var yCount = yScale.values.length;
            var xOffset = (0.5 * 1) / xCount;
            var yOffset = (0.5 * 1) / yCount;
            if (xScale.isCategory && yScale.isCategory) {
                // \u5982\u679Cx,y\u90FD\u662F\u5206\u7C7B
                x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
                y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
            }
            else if ((0,esm/* isArray */.kJ)(x)) {
                // x \u662F\u6570\u7EC4
                temp = x;
                x = [temp[0], temp[0], temp[1], temp[1]];
                y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
            }
            else if ((0,esm/* isArray */.kJ)(y)) {
                // y \u662F\u6570\u7EC4
                temp = y;
                y = [temp[0], temp[1], temp[1], temp[0]];
                x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
            }
            cfg.x = x;
            cfg.y = y;
        }
        return cfg;
    };
    return Polygon;
}(geometry_base));
/* harmony default export */ var geometry_polygon = (geometry_polygon_Polygon);
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/schema/index.js

var SchemaShapeFactory = registerShapeFactory('schema', {
    defaultShapeType: '', // 'schema' is for some custom shapes, so will not specify defaultShapeType
});
/* harmony default export */ var schema = ((/* unused pure expression or super */ null && (SchemaShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/schema.js



/** \u5F15\u5165\u5BF9\u5E94\u7684 ShapeFactory */


/**
 * Schema \u51E0\u4F55\u6807\u8BB0\uFF0C\u7528\u4E8E\u4E00\u4E9B\u81EA\u5B9A\u4E49\u56FE\u5F62\u7684\u7ED8\u5236\uFF0C\u6BD4\u5982\u7BB1\u578B\u56FE\u3001\u80A1\u7968\u56FE\u7B49\u3002
 */
var Schema = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Schema, _super);
    function Schema() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'schema';
        _this.shapeType = 'schema';
        _this.generatePoints = true;
        return _this;
    }
    /**
     * \u83B7\u53D6 Shape \u7684\u5173\u952E\u70B9\u6570\u636E\u3002
     * @param record
     * @returns
     */
    Schema.prototype.createShapePointsCfg = function (record) {
        var cfg = _super.prototype.createShapePointsCfg.call(this, record);
        // \u8BA1\u7B97\u6BCF\u4E2A shape \u7684 size
        var size;
        var sizeAttr = this.getAttribute('size');
        if (sizeAttr) {
            size = this.getAttributeValues(sizeAttr, record)[0];
            // \u5F52\u4E00\u5316
            var coordinate = this.coordinate;
            var coordinateWidth = getXDimensionLength(coordinate);
            size = size / coordinateWidth;
        }
        else {
            if (!this.defaultSize) {
                this.defaultSize = getDefaultSize(this);
            }
            size = this.defaultSize;
        }
        cfg.size = size;
        return cfg;
    };
    return Schema;
}(geometry_base));
/* harmony default export */ var geometry_schema = (Schema);
//# sourceMappingURL=schema.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/violin/index.js





function normalizeSize(arr) {
    if (!(0,esm/* isArray */.kJ)(arr)) {
        return [];
    }
    var maxValue = (0,esm/* max */.Fp)(arr);
    return (0,esm/* map */.UI)(arr, function (num) { return num / maxValue; });
}
var ViolinShapeFactory = registerShapeFactory('violin', {
    defaultShapeType: 'violin',
    getDefaultPoints: function (pointInfo) {
        var radius = pointInfo.size / 2;
        var points = [];
        var sizeArr = normalizeSize(pointInfo._size);
        (0,esm/* each */.S6)(pointInfo.y, function (y, index) {
            var offset = sizeArr[index] * radius;
            var isMin = index === 0;
            var isMax = index === pointInfo.y.length - 1;
            points.push({
                isMin: isMin,
                isMax: isMax,
                x: pointInfo.x - offset,
                y: y,
            });
            points.unshift({
                isMin: isMin,
                isMax: isMax,
                x: pointInfo.x + offset,
                y: y,
            });
        });
        return points;
    },
});
registerShape('violin', 'violin', {
    draw: function (cfg, container) {
        var shapeAttrs = get_style_getStyle(cfg, true, true);
        var path = this.parsePath(getViolinPath(cfg.points));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeAttrs), { path: path }),
            name: 'violin',
        });
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
/* harmony default export */ var violin = ((/* unused pure expression or super */ null && (ViolinShapeFactory)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/violin.js






/** \u5F15\u5165 Path \u5BF9\u5E94\u7684 ShapeFactory */

/**
 * Violin \u51E0\u4F55\u6807\u8BB0\u3002
 * \u7528\u4E8E\u7ED8\u5236\u5C0F\u63D0\u7434\u56FE\u3002
 */
var Violin = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Violin, _super);
    function Violin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'violin';
        _this.shapeType = 'violin';
        _this.generatePoints = true;
        return _this;
    }
    /**
     * \u83B7\u53D6 Shape \u7684\u5173\u952E\u70B9\u6570\u636E\u3002
     * @param record
     * @returns
     */
    Violin.prototype.createShapePointsCfg = function (record) {
        var cfg = _super.prototype.createShapePointsCfg.call(this, record);
        // \u8BA1\u7B97\u6BCF\u4E2A shape \u7684 size
        var size;
        var sizeAttr = this.getAttribute('size');
        if (sizeAttr) {
            size = this.getAttributeValues(sizeAttr, record)[0];
            // \u5F52\u4E00\u5316
            var coordinate = this.coordinate;
            var coordinateWidth = getXDimensionLength(coordinate);
            size = size / coordinateWidth;
        }
        else {
            if (!this.defaultSize) {
                this.defaultSize = getDefaultSize(this);
            }
            size = this.defaultSize;
        }
        cfg.size = size;
        cfg._size = (0,esm/* get */.U2)(record[FIELD_ORIGIN], [this._sizeField]);
        return cfg;
    };
    /**
     * @override
     */
    Violin.prototype.initAttributes = function () {
        var attributeOption = this.attributeOption;
        var sizeField = attributeOption.size
            ? attributeOption.size.fields[0]
            : this._sizeField
                ? this._sizeField
                : 'size';
        this._sizeField = sizeField;
        // fixme \u5E72\u5565\u8981\u5220\u6389
        delete attributeOption.size;
        _super.prototype.initAttributes.call(this);
    };
    return Violin;
}(geometry_base));
/* harmony default export */ var geometry_violin = (Violin);
//# sourceMappingURL=violin.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/area/line.js


/**
 * \u63CF\u8FB9\u4F46\u4E0D\u586B\u5145\u7684\u533A\u57DF\u56FE
 */
registerShape('area', 'line', {
    draw: function (cfg, container) {
        var attrs = util_getShapeAttrs(cfg, true, false, this);
        var shape = container.addShape({
            type: 'path',
            attrs: attrs,
            name: 'area',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                if (r === void 0) { r = 5.5; }
                return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
            },
            style: {
                r: 5,
                stroke: color,
                fill: null,
            },
        };
    },
});
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/area/smooth.js


/**
 * \u586B\u5145\u7684\u5E73\u6ED1\u66F2\u9762\u56FE
 */
registerShape('area', 'smooth', {
    draw: function (cfg, container) {
        var coordinate = this.coordinate;
        var attrs = util_getShapeAttrs(cfg, false, true, this, getConstraint(coordinate));
        var shape = container.addShape({
            type: 'path',
            attrs: attrs,
            name: 'area',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                if (r === void 0) { r = 5.5; }
                return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
            },
            style: {
                r: 5,
                fill: color,
                fillOpacity: 1,
            },
        };
    },
});
//# sourceMappingURL=smooth.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js


/** \u63CF\u8FB9\u7684\u5E73\u6ED1\u66F2\u9762\u56FE */
registerShape('area', 'smooth-line', {
    draw: function (cfg, container) {
        var coordinate = this.coordinate;
        var attrs = util_getShapeAttrs(cfg, true, true, this, getConstraint(coordinate));
        var shape = container.addShape({
            type: 'path',
            attrs: attrs,
            name: 'area',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                if (r === void 0) { r = 5.5; }
                return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
            },
            style: {
                r: 5,
                stroke: color,
                fill: null,
            },
        };
    },
});
//# sourceMappingURL=smooth-line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/edge/util.js

/**
 * @ignore
 * Gets cpath
 * @param from
 * @param to
 * @returns
 */
function getCPath(from, to) {
    return ['C', (from.x * 1) / 2 + (to.x * 1) / 2, from.y, (from.x * 1) / 2 + (to.x * 1) / 2, to.y, to.x, to.y];
}
/**
 * @ignore
 * Gets qpath
 * @param to
 * @param center
 * @returns
 */
function getQPath(to, center) {
    var points = [];
    points.push({
        x: center.x,
        y: center.y,
    });
    points.push(to);
    var sub = ['Q'];
    (0,esm/* each */.S6)(points, function (point) {
        sub.push(point.x, point.y);
    });
    return sub;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/edge/arc.js





function getArcShapePath(from, to, center) {
    var sub = getQPath(to, center);
    var path = [['M', from.x, from.y]];
    path.push(sub);
    return path;
}
function getArcShapeWeightPath(points, center) {
    var arc1 = getQPath(points[1], center);
    var arc2 = getQPath(points[3], center);
    var path = [['M', points[0].x, points[0].y]];
    path.push(arc2);
    path.push(['L', points[3].x, points[3].y]);
    path.push(['L', points[2].x, points[2].y]);
    path.push(arc1);
    path.push(['L', points[1].x, points[1].y]);
    path.push(['L', points[0].x, points[0].y]);
    path.push(['Z']);
    return path;
}
// \u5F27\u7EBF\u5305\u62EC\u7B1B\u5361\u5C14\u5750\u6807\u7CFB\u4E0B\u7684\u534A\u5706\u5F27\u7EBF\u3001\u6781\u5750\u6807\u7CFB\u4E0B\u4EE5\u5706\u5FC3\u4E3A\u63A7\u5236\u70B9\u7684\u4E8C\u9636\u66F2\u7EBF\u3001\u7B1B\u5361\u5C14\u5750\u6807\u7CFB\u4E0B\u5E26\u6743\u91CD\u7684\u4E09\u9636\u66F2\u7EBF\u3001\u6781\u5750\u6807\u7CFB\u4E0B\u5E26\u6743\u91CD\u7684\u4EE5\u5706\u5FC3\u4E3A\u63A7\u5236\u70B9\u7684\u4E8C\u9636\u66F2\u7EBF
registerShape('edge', 'arc', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false, 'lineWidth');
        var points = cfg.points;
        var type = points.length > 2 ? 'weight' : 'normal';
        var path;
        if (cfg.isInCircle) {
            var center = { x: 0, y: 1 };
            if (type === 'normal') {
                path = getArcShapePath(points[0], points[1], center);
            }
            else {
                style.fill = style.stroke;
                path = getArcShapeWeightPath(points, center);
            }
            path = this.parsePath(path);
            return container.addShape('path', {
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            });
        }
        else {
            if (type === 'normal') {
                points = this.parsePoints(points);
                path = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
                return container.addShape('path', {
                    attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
                });
            }
            else {
                var c1 = getCPath(points[1], points[3]);
                var c2 = getCPath(points[2], points[0]);
                path = [
                    ['M', points[0].x, points[0].y],
                    ['L', points[1].x, points[1].y],
                    c1,
                    ['L', points[3].x, points[3].y],
                    ['L', points[2].x, points[2].y],
                    c2,
                    ['Z'],
                ];
                path = this.parsePath(path);
                style.fill = style.stroke;
                return container.addShape('path', {
                    attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
                });
            }
        }
    },
    getMarker: function (markerCfg) {
        return {
            symbol: 'circle',
            style: {
                r: 4.5,
                fill: markerCfg.color,
            },
        };
    },
});
//# sourceMappingURL=arc.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js




function getSmoothPath(from, to) {
    var sub = getCPath(from, to);
    var path = [['M', from.x, from.y]];
    path.push(sub);
    return path;
}
registerShape('edge', 'smooth', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false, 'lineWidth');
        var points = cfg.points;
        var path = this.parsePath(getSmoothPath(points[0], points[1]));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        return {
            symbol: 'circle',
            style: {
                r: 4.5,
                fill: markerCfg.color,
            },
        };
    },
});
//# sourceMappingURL=smooth.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js




var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
    var points = [];
    points.push({
        x: from.x,
        y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
    });
    points.push({
        x: to.x,
        y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,
    });
    points.push(to);
    var path = [['M', from.x, from.y]];
    (0,esm/* each */.S6)(points, function (point) {
        path.push(['L', point.x, point.y]);
    });
    return path;
}
registerShape('edge', 'vhv', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false, 'lineWidth');
        var points = cfg.points;
        var path = this.parsePath(getVHVPath(points[0], points[1]));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        return {
            symbol: 'circle',
            style: {
                r: 4.5,
                fill: markerCfg.color,
            },
        };
    },
});
//# sourceMappingURL=vhv.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js




/** \u6F0F\u6597\u56FE */
registerShape('interval', 'funnel', {
    getPoints: function (shapePoint) {
        shapePoint.size = shapePoint.size * 2; // \u6F0F\u6597\u56FE\u7684 size \u662F\u67F1\u72B6\u56FE\u7684\u4E24\u500D
        return getRectPoints(shapePoint);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, false, true);
        var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            name: 'interval',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'square',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
//# sourceMappingURL=funnel.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js





/** \u63CF\u8FB9\u67F1\u72B6\u56FE */
registerShape('interval', 'hollow-rect', {
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false);
        var group = container;
        var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
        if (backgroundCfg) {
            group = container.addGroup();
            var backgroundStyle = getBackgroundRectStyle(cfg);
            var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
            group.addShape('path', {
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, backgroundStyle), { path: backgroundPath }),
                capture: false,
                zIndex: -1,
                name: BACKGROUND_SHAPE,
            });
        }
        var path = this.parsePath(getRectPath(cfg.points));
        var shape = group.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            name: 'interval',
        });
        return backgroundCfg ? group : shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color, isInPolar = markerCfg.isInPolar;
        if (isInPolar) {
            return {
                symbol: 'circle',
                style: {
                    r: 4.5,
                    stroke: color,
                    fill: null,
                },
            };
        }
        return {
            symbol: 'square',
            style: {
                r: 4,
                stroke: color,
                fill: null,
            },
        };
    },
});
//# sourceMappingURL=hollow-rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/line.js






// \u6839\u636E\u6570\u636E\u70B9\u751F\u6210 Line \u7684\u4E24\u4E2A\u5173\u952E\u70B9
function getLinePoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
    if ((0,esm/* isArray */.kJ)(y)) {
        return y.map(function (yItem, idx) {
            return {
                x: (0,esm/* isArray */.kJ)(x) ? x[idx] : x,
                y: yItem,
            };
        });
    }
    // \u8D77\u59CB\u70B9\u4ECE y0 \u5F00\u59CB
    return [
        { x: x, y: y0 },
        { x: x, y: y },
    ];
}
registerShape('interval', 'line', {
    getPoints: function (shapePoint) {
        return getLinePoints(shapePoint);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false, 'lineWidth');
        var newStyle = omit((0,tslib_es6/* __assign */.pi)({}, style), ['fill']);
        var path = this.parsePath(getRectPath(cfg.points, false));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, newStyle), { path: path }),
            name: 'interval',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                return [
                    ['M', x, y - r],
                    ['L', x, y + r],
                ];
            },
            style: {
                r: 5,
                stroke: color,
            },
        };
    },
});
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js




/** \u91D1\u5B57\u5854\u56FE\uFF0C\u5C16\u5E95\u6F0F\u6597\u56FE */
registerShape('interval', 'pyramid', {
    getPoints: function (shapePoint) {
        shapePoint.size = shapePoint.size * 2; // \u6F0F\u6597\u56FE\u7684 size \u662F\u67F1\u72B6\u56FE\u7684\u4E24\u500D
        return getRectPoints(shapePoint);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, false, true);
        var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            name: 'interval',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'square',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
//# sourceMappingURL=pyramid.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/interval/tick.js




// \u6839\u636E\u6570\u636E\u70B9\u751F\u6210 tick shape \u7684 6 \u4E2A\u5173\u952E\u70B9
function getTickPoints(pointInfo) {
    var _a;
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size = pointInfo.size;
    var yMin;
    var yMax;
    if ((0,esm/* isArray */.kJ)(y)) {
        _a = (0,tslib_es6/* __read */.CR)(y, 2), yMin = _a[0], yMax = _a[1];
    }
    else {
        yMin = y0;
        yMax = y;
    }
    var xMax = x + size / 2;
    var xMin = x - size / 2;
    // tick \u5173\u952E\u70B9\u987A\u5E8F
    // 4 - 1 - 5
    //     |
    // 2 - 0 - 3
    return [
        { x: x, y: yMin },
        { x: x, y: yMax },
        { x: xMin, y: yMin },
        { x: xMax, y: yMin },
        { x: xMin, y: yMax },
        { x: xMax, y: yMax },
    ];
}
// \u6839\u636E tick \u5173\u952E\u70B9\u7ED8\u5236 path
function getTickPath(points) {
    return [
        ['M', points[0].x, points[0].y],
        ['L', points[1].x, points[1].y],
        ['M', points[2].x, points[2].y],
        ['L', points[3].x, points[3].y],
        ['M', points[4].x, points[4].y],
        ['L', points[5].x, points[5].y],
    ];
}
/** I \u5F62\u72B6\u67F1\u72B6\u56FE\uFF0C\u5E38\u7528\u4E8E error bar chart */
registerShape('interval', 'tick', {
    getPoints: function (shapePoint) {
        return getTickPoints(shapePoint);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false);
        var path = this.parsePath(getTickPath(cfg.points));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
            name: 'interval',
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                return [
                    ['M', x - r / 2, y - r],
                    ['L', x + r / 2, y - r],
                    ['M', x, y - r],
                    ['L', x, y + r],
                    ['M', x - r / 2, y + r],
                    ['L', x + r / 2, y + r],
                ];
            },
            style: {
                r: 5,
                stroke: color,
            },
        };
    },
});
//# sourceMappingURL=tick.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/line/step.js






var interpolateCallback = function (point, nextPoint, shapeType) {
    var x = point.x;
    var y = point.y;
    var nextX = nextPoint.x;
    var nextY = nextPoint.y;
    var result;
    switch (shapeType) {
        case 'hv':
            result = [{ x: nextX, y: y }];
            break;
        case 'vh':
            result = [{ x: x, y: nextY }];
            break;
        case 'hvh':
            var middleX = (nextX + x) / 2;
            result = [
                { x: middleX, y: y },
                { x: middleX, y: nextY },
            ];
            break;
        case 'vhv':
            var middleY = (y + nextY) / 2;
            result = [
                { x: x, y: middleY },
                { x: nextX, y: middleY },
            ];
            break;
        default:
            break;
    }
    return result;
};
function getInterpolatePoints(points, shapeType) {
    var result = [];
    (0,esm/* each */.S6)(points, function (point, index) {
        var nextPoint = points[index + 1];
        result.push(point);
        if (nextPoint) {
            var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
            result = result.concat(interpolatePoint);
        }
    });
    return result;
}
// \u63D2\u503C\u7684\u56FE\u5F62path\uFF0C\u4E0D\u8003\u8651null
function getInterpolatePath(points) {
    return points.map(function (point, index) {
        return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
    });
}
// \u63D2\u503C\u7684\u56FE\u5F62
function getInterpolateShapeAttrs(cfg, shapeType) {
    var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint); // \u6839\u636E connectNulls \u503C\u5904\u7406 points
    var path = [];
    (0,esm/* each */.S6)(points, function (eachLinePoints) {
        var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
        path = path.concat(getInterpolatePath(interpolatePoints));
    });
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, get_style_getStyle(cfg, true, false, 'lineWidth')), { path: path });
}
// step line
(0,esm/* each */.S6)(['hv', 'vh', 'hvh', 'vhv'], function (shapeType) {
    registerShape('line', shapeType, {
        draw: function (cfg, container) {
            var attrs = getInterpolateShapeAttrs(cfg, shapeType);
            var shape = container.addShape({
                type: 'path',
                attrs: attrs,
                name: 'line',
            });
            return shape;
        },
        getMarker: function (markerCfg) {
            return getLineMarker(markerCfg, shapeType);
        },
    });
});
//# sourceMappingURL=step.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/point/hollow.js




// \u6DFB\u52A0 hollowShape
(0,esm/* each */.S6)(HOLLOW_SHAPES, function (shapeName) {
    registerShape('point', shapeName, {
        draw: function (cfg, container) {
            return drawPoints(this, cfg, container, shapeName, true);
        },
        getMarker: function (markerCfg) {
            var color = markerCfg.color;
            return {
                symbol: MarkerSymbols[shapeName],
                style: {
                    r: 4.5,
                    stroke: color,
                    fill: null,
                },
            };
        },
    });
});
//# sourceMappingURL=hollow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/point/image.js



registerShape('point', 'image', {
    draw: function (cfg, container) {
        var e_1, _a;
        var size = get_style_getStyle(cfg, false, false, 'r').r;
        var points = this.parsePoints(cfg.points);
        var pointPosition = points[0];
        if (cfg.isStack) {
            pointPosition = points[1];
        }
        else if (points.length > 1) {
            var group = container.addGroup();
            try {
                for (var points_1 = (0,tslib_es6/* __values */.XA)(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                    var point = points_1_1.value;
                    group.addShape('image', {
                        attrs: {
                            x: point.x - size / 2,
                            y: point.y - size,
                            width: size,
                            height: size,
                            img: cfg.shape[1],
                        },
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return group;
        }
        return container.addShape('image', {
            attrs: {
                x: pointPosition.x - size / 2,
                y: pointPosition.y - size,
                width: size,
                height: size,
                img: cfg.shape[1],
            },
        });
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                r: 4.5,
                fill: color,
            },
        };
    },
});
//# sourceMappingURL=image.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/point/solid.js




// \u6240\u6709\u7684 SHAPES \u90FD\u6CE8\u518C\u4E00\u4E0B
(0,esm/* each */.S6)(SHAPES, function (shapeName) {
    registerShape('point', shapeName, {
        draw: function (cfg, container) {
            return drawPoints(this, cfg, container, shapeName, false);
        },
        getMarker: function (markerCfg) {
            var color = markerCfg.color;
            return {
                symbol: MarkerSymbols[shapeName] || shapeName,
                style: {
                    r: 4.5,
                    fill: color,
                },
            };
        },
    });
});
//# sourceMappingURL=solid.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/schema/box.js




function parseValue(value) {
    var array = !(0,esm/* isArray */.kJ)(value) ? [value] : value;
    var min = array[0]; // \u6700\u5C0F\u503C
    var max = array[array.length - 1]; // \u6700\u5927\u503C
    var min1 = array.length > 1 ? array[1] : min;
    var max1 = array.length > 3 ? array[3] : max;
    var median = array.length > 2 ? array[2] : min1;
    return {
        min: min,
        max: max,
        min1: min1,
        max1: max1,
        median: median,
    };
}
function getBoxPoints(x, y, size) {
    var halfSize = size / 2;
    var pointsArray;
    if ((0,esm/* isArray */.kJ)(y)) {
        // 2\u7EF4
        var _a = parseValue(y), min = _a.min, max = _a.max, median = _a.median, min1 = _a.min1, max1 = _a.max1;
        var minX = x - halfSize;
        var maxX = x + halfSize;
        pointsArray = [
            [minX, max],
            [maxX, max],
            [x, max],
            [x, max1],
            [minX, min1],
            [minX, max1],
            [maxX, max1],
            [maxX, min1],
            [x, min1],
            [x, min],
            [minX, min],
            [maxX, min],
            [minX, median],
            [maxX, median],
        ];
    }
    else {
        // \u53EA\u6709\u4E00\u4E2A\u7EF4\u5EA6
        y = (0,esm/* isNil */.UM)(y) ? 0.5 : y;
        var _b = parseValue(x), min = _b.min, max = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
        var minY = y - halfSize;
        var maxY = y + halfSize;
        pointsArray = [
            [min, minY],
            [min, maxY],
            [min, y],
            [min1, y],
            [min1, minY],
            [min1, maxY],
            [max1, maxY],
            [max1, minY],
            [max1, y],
            [max, y],
            [max, minY],
            [max, maxY],
            [median, minY],
            [median, maxY],
        ];
    }
    return pointsArray.map(function (arr) {
        return {
            x: arr[0],
            y: arr[1],
        };
    });
}
function getBoxPath(points) {
    return [
        ['M', points[0].x, points[0].y],
        ['L', points[1].x, points[1].y],
        ['M', points[2].x, points[2].y],
        ['L', points[3].x, points[3].y],
        ['M', points[4].x, points[4].y],
        ['L', points[5].x, points[5].y],
        ['L', points[6].x, points[6].y],
        ['L', points[7].x, points[7].y],
        ['L', points[4].x, points[4].y],
        ['Z'],
        ['M', points[8].x, points[8].y],
        ['L', points[9].x, points[9].y],
        ['M', points[10].x, points[10].y],
        ['L', points[11].x, points[11].y],
        ['M', points[12].x, points[12].y],
        ['L', points[13].x, points[13].y],
    ];
}
// box shape
registerShape('schema', 'box', {
    getPoints: function (shapePoint) {
        var x = shapePoint.x, y = shapePoint.y, size = shapePoint.size;
        return getBoxPoints(x, y, size);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, false);
        var path = this.parsePath(getBoxPath(cfg.points));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path, name: 'schema' }),
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                var yValues = [y - 6, y - 3, y, y + 3, y + 6];
                var points = getBoxPoints(x, yValues, r);
                return [
                    ['M', points[0].x + 1, points[0].y],
                    ['L', points[1].x - 1, points[1].y],
                    ['M', points[2].x, points[2].y],
                    ['L', points[3].x, points[3].y],
                    ['M', points[4].x, points[4].y],
                    ['L', points[5].x, points[5].y],
                    ['L', points[6].x, points[6].y],
                    ['L', points[7].x, points[7].y],
                    ['L', points[4].x, points[4].y],
                    ['Z'],
                    ['M', points[8].x, points[8].y],
                    ['L', points[9].x, points[9].y],
                    ['M', points[10].x + 1, points[10].y],
                    ['L', points[11].x - 1, points[11].y],
                    ['M', points[12].x, points[12].y],
                    ['L', points[13].x, points[13].y],
                ];
            },
            style: {
                r: 6,
                lineWidth: 1,
                stroke: color,
            },
        };
    },
});
//# sourceMappingURL=box.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/schema/candle.js





function getCandleYValues(value) {
    var array = !(0,esm/* isArray */.kJ)(value) ? [value] : value;
    // \u4ECE\u5927\u5230\u5C0F\u6392\u5E8F
    var sorted = array.sort(function (a, b) { return b - a; });
    return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
// get candle shape's key points
function getCandlePoints(x, y, size) {
    var yValues = getCandleYValues(y);
    return [
        { x: x, y: yValues[0] },
        { x: x, y: yValues[1] },
        { x: x - size / 2, y: yValues[2] },
        { x: x - size / 2, y: yValues[1] },
        { x: x + size / 2, y: yValues[1] },
        { x: x + size / 2, y: yValues[2] },
        { x: x, y: yValues[2] },
        { x: x, y: yValues[3] },
    ];
}
function getCandlePath(points) {
    return [
        ['M', points[0].x, points[0].y],
        ['L', points[1].x, points[1].y],
        ['M', points[2].x, points[2].y],
        ['L', points[3].x, points[3].y],
        ['L', points[4].x, points[4].y],
        ['L', points[5].x, points[5].y],
        ['Z'],
        ['M', points[6].x, points[6].y],
        ['L', points[7].x, points[7].y],
    ];
}
// k line shape
registerShape('schema', 'candle', {
    getPoints: function (shapePoint) {
        var x = shapePoint.x, y = shapePoint.y, size = shapePoint.size;
        return getCandlePoints(x, y, size);
    },
    draw: function (cfg, container) {
        var style = get_style_getStyle(cfg, true, true);
        var path = this.parsePath(getCandlePath(cfg.points));
        var shape = container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path, name: 'schema' }),
        });
        return shape;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: function (x, y, r) {
                var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
                var points = getCandlePoints(x, yValues, r);
                return [
                    ['M', points[0].x, points[0].y],
                    ['L', points[1].x, points[1].y],
                    ['M', points[2].x, points[2].y],
                    ['L', points[3].x, points[3].y],
                    ['L', points[4].x, points[4].y],
                    ['L', points[5].x, points[5].y],
                    ['Z'],
                    ['M', points[6].x, points[6].y],
                    ['L', points[7].x, points[7].y],
                ];
            },
            style: {
                lineWidth: 1,
                stroke: color,
                fill: color,
                r: 6,
            },
        };
    },
});
//# sourceMappingURL=candle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/polygon/square.js




function getRectAttrs(points, size) {
    var width = Math.abs(points[0].x - points[2].x);
    var height = Math.abs(points[0].y - points[2].y);
    var len = Math.min(width, height);
    if (size) {
        len = (0,esm/* clamp */.uZ)(size, 0, Math.min(width, height));
    }
    len = len / 2;
    var centerX = (points[0].x + points[2].x) / 2;
    var centerY = (points[0].y + points[2].y) / 2;
    return {
        x: centerX - len,
        y: centerY - len,
        width: len * 2,
        height: len * 2,
    };
}
registerShape('polygon', 'square', {
    draw: function (cfg, container) {
        if (!(0,esm/* isEmpty */.xb)(cfg.points)) {
            var shapeAttrs = get_style_getStyle(cfg, true, true);
            var points = this.parsePoints(cfg.points); // \u8F6C\u6362\u4E3A\u753B\u5E03\u5750\u6807
            return container.addShape('rect', {
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, shapeAttrs), getRectAttrs(points, cfg.size)),
                name: 'polygon',
            });
        }
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'square',
            style: {
                r: 4,
                fill: color,
            },
        };
    },
});
//# sourceMappingURL=square.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js




/**
 * \u5E73\u6ED1\u8FB9\u754C\u7684\u5C0F\u63D0\u7434\u56FE
 */
registerShape('violin', 'smooth', {
    draw: function (cfg, container) {
        var attrs = get_style_getStyle(cfg, true, true);
        var path = this.parsePath(getSmoothViolinPath(cfg.points));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                stroke: null,
                r: 4,
                fill: color,
            },
        };
    },
});
//# sourceMappingURL=smooth.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js




/**
 * \u7A7A\u5FC3\u5C0F\u63D0\u7434\u56FE
 */
registerShape('violin', 'hollow', {
    draw: function (cfg, container) {
        var attrs = get_style_getStyle(cfg, true, false);
        var path = this.parsePath(getViolinPath(cfg.points));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                r: 4,
                fill: null,
                stroke: color,
            },
        };
    },
});
/**
 * \u5E73\u6ED1\u8FB9\u754C\u7684\u7A7A\u5FC3\u5C0F\u63D0\u7434\u56FE
 */
registerShape('violin', 'hollow-smooth', {
    draw: function (cfg, container) {
        var attrs = get_style_getStyle(cfg, true, false);
        var path = this.parsePath(getSmoothViolinPath(cfg.points));
        return container.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, attrs), { path: path }),
        });
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                r: 4,
                fill: null,
                stroke: color,
            },
        };
    },
});
//# sourceMappingURL=hollow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/interval.js



/**
 * \u67F1\u72B6\u56FE label
 */
var IntervalLabel = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(IntervalLabel, _super);
    function IntervalLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u83B7\u53D6 interval label \u7684\u65B9\u5411\uFF0C\u53D6\u51B3\u4E8E value \u7684\u503C\u662F\u6B63\u8FD8\u662F\u8D1F
     * @param labelCfg
     */
    IntervalLabel.prototype.getLabelValueDir = function (mappingData) {
        // points \u4E2D\u7684 x/y \u548C transpose \u65E0\u5173
        var dim = 'y';
        var points = mappingData.points;
        return points[0][dim] <= points[2][dim] ? 1 : -1;
    };
    /**
     * \u91CD\u8F7D\uFF1A\u6839\u636E interval \u503C\u7684\u6B63\u8D1F\u6765\u8C03\u6574 label \u504F\u79FB\u91CF
     * @param labelCfg
     * @param index
     * @param total
     */
    IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {
        var _a;
        var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var dim = transposed ? 'x' : 'y';
        var dir = this.getLabelValueDir(labelCfg.mappingData);
        point = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));
        if (coordinate.isReflect('x')) {
            point = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, point), { x: point.x * -1 });
        }
        if (coordinate.isReflect('y')) {
            point = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, point), { y: point.y * -1 });
        }
        return point;
    };
    /**
     * \u91CD\u8F7D\uFF1A\u5B9A\u5236 interval label \u7684\u9ED8\u8BA4\u4E3B\u9898\u914D\u7F6E
     * @param labelCfg
     */
    IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {
        var geometry = this.geometry;
        var defaultLabelCfg = this.getDefaultLabelCfg();
        var theme = geometry.theme;
        // \u5982\u679C interval label position \u8BBE\u7F6E\u4E3A middle\uFF0C\u5219\u5C06\u4E3B\u9898\u4E2D\u7684 offset \u8986\u76D6\u4E3A 0
        return (0,esm/* deepMix */.b$)({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
        var coordinate = this.getCoordinate();
        var transposed = coordinate.isTransposed;
        var shapePoints = mappingData.points;
        var point0 = coordinate.convert(shapePoints[0]);
        var point2 = coordinate.convert(shapePoints[2]);
        var dir = this.getLabelValueDir(mappingData);
        var top;
        var right;
        var bottom;
        var left;
        var shape = (0,esm/* isArray */.kJ)(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
        if (shape === 'funnel' || shape === 'pyramid') {
            // \u5904\u7406\u6F0F\u6597\u56FE
            var nextPoints = (0,esm/* get */.U2)(mappingData, 'nextPoints');
            var points = (0,esm/* get */.U2)(mappingData, 'points');
            if (nextPoints) {
                // \u975E\u6F0F\u6597\u56FE\u5E95\u90E8
                var p0 = coordinate.convert(points[0]);
                var p1 = coordinate.convert(points[1]);
                var nextP0 = coordinate.convert(nextPoints[0]);
                var nextP1 = coordinate.convert(nextPoints[1]);
                // TODO: \u4F7F\u7528\u5305\u56F4\u76D2\u7684\u8BA1\u7B97\u65B9\u6CD5
                if (transposed) {
                    top = Math.min(nextP0.y, p0.y);
                    bottom = Math.max(nextP0.y, p0.y);
                    right = (p1.x + nextP1.x) / 2;
                    left = (p0.x + nextP0.x) / 2;
                }
                else {
                    top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
                    bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
                    right = nextP1.x;
                    left = p0.x;
                }
            }
            else {
                top = Math.min(point2.y, point0.y);
                bottom = Math.max(point2.y, point0.y);
                right = point2.x;
                left = point0.x;
            }
        }
        else {
            top = Math.min(point2.y, point0.y);
            bottom = Math.max(point2.y, point0.y);
            right = point2.x;
            left = point0.x;
        }
        switch (position) {
            case 'right':
                labelPointCfg.x = right;
                labelPointCfg.y = (top + bottom) / 2;
                labelPointCfg.textAlign = (0,esm/* get */.U2)(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
                break;
            case 'left':
                labelPointCfg.x = left;
                labelPointCfg.y = (top + bottom) / 2;
                labelPointCfg.textAlign = (0,esm/* get */.U2)(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
                break;
            case 'bottom':
                if (transposed) {
                    labelPointCfg.x = (right + left) / 2;
                }
                labelPointCfg.y = bottom;
                labelPointCfg.textAlign = (0,esm/* get */.U2)(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = (0,esm/* get */.U2)(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
                break;
            case 'middle':
                if (transposed) {
                    labelPointCfg.x = (right + left) / 2;
                }
                labelPointCfg.y = (top + bottom) / 2;
                labelPointCfg.textAlign = (0,esm/* get */.U2)(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = (0,esm/* get */.U2)(labelPointCfg, 'textBaseline', 'middle');
                break;
            case 'top':
                if (transposed) {
                    labelPointCfg.x = (right + left) / 2;
                }
                labelPointCfg.y = top;
                labelPointCfg.textAlign = (0,esm/* get */.U2)(labelPointCfg, 'textAlign', 'center');
                labelPointCfg.textBaseline = (0,esm/* get */.U2)(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
                break;
            default:
                break;
        }
    };
    return IntervalLabel;
}(label_base));
/* harmony default export */ var label_interval = (IntervalLabel);
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/polar.js





var HALF_PI = Math.PI / 2;
/**
 * \u6781\u5750\u6807\u4E0B\u7684\u56FE\u5F62 label
 */
var PolarLabel = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PolarLabel, _super);
    function PolarLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @override
     * @desc \u83B7\u53D6 label offset
     * polar & theta coordinate support\u300Cstring\u300Dtype, should transform to \u300Cnumber\u300D
     */
    PolarLabel.prototype.getLabelOffset = function (offset) {
        var coordinate = this.getCoordinate();
        var actualOffset = 0;
        if ((0,esm/* isNumber */.hj)(offset)) {
            actualOffset = offset;
        }
        else if ((0,esm/* isString */.HD)(offset) && offset.indexOf('%') !== -1) {
            var r = coordinate.getRadius();
            if (coordinate.innerRadius > 0) {
                r = r * (1 - coordinate.innerRadius);
            }
            actualOffset = parseFloat(offset) * 0.01 * r;
        }
        return actualOffset;
    };
    /**
     * @override
     * \u83B7\u53D6 labelItems, \u589E\u52A0\u5207\u7247 percent
     * @param mapppingArray
     */
    PolarLabel.prototype.getLabelItems = function (mapppingArray) {
        var items = _super.prototype.getLabelItems.call(this, mapppingArray);
        var yScale = this.geometry.getYScale();
        return (0,esm/* map */.UI)(items, function (item) {
            if (item && yScale) {
                var percent = yScale.scale((0,esm/* get */.U2)(item.data, yScale.field));
                return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { percent: percent });
            }
            return item;
        });
    };
    /**
     * @override
     * \u83B7\u53D6\u6587\u672C\u7684\u5BF9\u9F50\u65B9\u5F0F
     * @param point
     */
    PolarLabel.prototype.getLabelAlign = function (point) {
        var coordinate = this.getCoordinate();
        var align;
        if (point.labelEmit) {
            align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';
        }
        else if (!coordinate.isTransposed) {
            align = 'center';
        }
        else {
            var center = coordinate.getCenter();
            var offset = point.offset;
            if (Math.abs(point.x - center.x) < 1) {
                align = 'center';
            }
            else if (point.angle > Math.PI || point.angle <= 0) {
                align = offset > 0 ? 'left' : 'right';
            }
            else {
                align = offset > 0 ? 'right' : 'left';
            }
        }
        return align;
    };
    /**
     * @override
     * \u83B7\u53D6 label \u7684\u4F4D\u7F6E
     * @param labelCfg
     * @param mappingData
     * @param index
     */
    PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
        var factor = 1;
        var arcPoint;
        var content = labelCfg.content[index];
        if (this.isToMiddle(mappingData)) {
            arcPoint = this.getMiddlePoint(mappingData.points);
        }
        else {
            if (labelCfg.content.length === 1 && index === 0) {
                index = 1;
            }
            else if (index === 0) {
                factor = -1;
            }
            arcPoint = this.getArcPoint(mappingData, index);
        }
        var offset = labelCfg.offset * factor;
        var middleAngle = this.getPointAngle(arcPoint);
        var isLabelEmit = labelCfg.labelEmit;
        var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
        if (labelPositionCfg.r === 0) {
            // \u5982\u679C\u6587\u672C\u4F4D\u7F6E\u4F4D\u4E8E\u5706\u5FC3\uFF0C\u5219\u4E0D\u5C55\u793A
            labelPositionCfg.content = '';
        }
        else {
            labelPositionCfg.content = content;
            labelPositionCfg.angle = middleAngle;
            labelPositionCfg.color = mappingData.color;
        }
        labelPositionCfg.rotate = labelCfg.autoRotate
            ? this.getLabelRotate(middleAngle, offset, isLabelEmit)
            : labelCfg.rotate;
        labelPositionCfg.start = {
            x: arcPoint.x,
            y: arcPoint.y,
        };
        return labelPositionCfg;
    };
    /**
     * \u83B7\u53D6\u5706\u5F27\u7684\u4F4D\u7F6E
     */
    PolarLabel.prototype.getArcPoint = function (mappingData, index) {
        if (index === void 0) { index = 0; }
        if (!(0,esm/* isArray */.kJ)(mappingData.x) && !(0,esm/* isArray */.kJ)(mappingData.y)) {
            return {
                x: mappingData.x,
                y: mappingData.y,
            };
        }
        return {
            x: (0,esm/* isArray */.kJ)(mappingData.x) ? mappingData.x[index] : mappingData.x,
            y: (0,esm/* isArray */.kJ)(mappingData.y) ? mappingData.y[index] : mappingData.y,
        };
    };
    /**
     * \u8BA1\u7B97\u5750\u6807\u7EBF\u70B9\u5728\u6781\u5750\u6807\u7CFB\u4E0B\u89D2\u5EA6
     * @param point
     */
    PolarLabel.prototype.getPointAngle = function (point) {
        return getAngleByPoint(this.getCoordinate(), point);
    };
    /**
     * \u83B7\u53D6\u5750\u6807\u70B9\u4E0E\u5706\u5FC3\u5F62\u6210\u7684\u5706\u7684\u4F4D\u7F6E\u4FE1\u606F
     * @param angle
     * @param offset
     * @param point
     * @param isLabelEmit
     */
    PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {
        var coordinate = this.getCoordinate();
        var center = coordinate.getCenter();
        var r = getDistanceToCenter(coordinate, point);
        if (r === 0) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, center), { r: r });
        }
        var labelAngle = angle;
        if (coordinate.isTransposed && r > offset && !isLabelEmit) {
            var appendAngle = Math.asin(offset / (2 * r));
            labelAngle = angle + appendAngle * 2;
        }
        else {
            r = r + offset;
        }
        return {
            x: center.x + r * Math.cos(labelAngle),
            y: center.y + r * Math.sin(labelAngle),
            r: r,
        };
    };
    /**
     * \u83B7\u53D6 label \u7684\u65CB\u8F6C\u89D2\u5EA6
     * @param angle
     * @param offset
     * @param isLabelEmit
     */
    PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {
        var rotate = angle + HALF_PI;
        if (isLabelEmit) {
            rotate -= HALF_PI;
        }
        if (rotate) {
            if (rotate > HALF_PI) {
                rotate = rotate - Math.PI;
            }
            else if (rotate < -HALF_PI) {
                rotate = rotate + Math.PI;
            }
        }
        return rotate;
    };
    // \u83B7\u53D6\u4E2D\u5FC3\u7684\u4F4D\u7F6E
    PolarLabel.prototype.getMiddlePoint = function (points) {
        var coordinate = this.getCoordinate();
        var count = points.length;
        var middlePoint = {
            x: 0,
            y: 0,
        };
        (0,esm/* each */.S6)(points, function (point) {
            middlePoint.x += point.x;
            middlePoint.y += point.y;
        });
        middlePoint.x /= count;
        middlePoint.y /= count;
        middlePoint = coordinate.convert(middlePoint);
        return middlePoint;
    };
    // \u662F\u5426\u5C45\u4E2D
    PolarLabel.prototype.isToMiddle = function (mappingData) {
        return mappingData.x.length > 2;
    };
    return PolarLabel;
}(label_base));
/* harmony default export */ var label_polar = (PolarLabel);
//# sourceMappingURL=polar.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/pie.js





/**
 * \u997C\u56FE label
 */
var PieLabel = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PieLabel, _super);
    function PieLabel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.defaultLayout = 'distribute';
        return _this;
    }
    PieLabel.prototype.getDefaultLabelCfg = function (offset, position) {
        var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
        return (0,esm/* deepMix */.b$)({}, cfg, (0,esm/* get */.U2)(this.geometry.theme, 'pieLabels', {}));
    };
    /** @override */
    PieLabel.prototype.getLabelOffset = function (offset) {
        return _super.prototype.getLabelOffset.call(this, offset) || 0;
    };
    PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {
        var rotate;
        if (offset < 0) {
            rotate = angle;
            if (rotate > Math.PI / 2) {
                rotate = rotate - Math.PI;
            }
            if (rotate < -Math.PI / 2) {
                rotate = rotate + Math.PI;
            }
        }
        return rotate;
    };
    PieLabel.prototype.getLabelAlign = function (point) {
        var coordinate = this.getCoordinate();
        var center = coordinate.getCenter();
        var align;
        if (point.angle <= Math.PI / 2 && point.x >= center.x) {
            align = 'left';
        }
        else {
            align = 'right';
        }
        if (point.offset <= 0) {
            if (align === 'right') {
                align = 'left';
            }
            else {
                align = 'right';
            }
        }
        return align;
    };
    PieLabel.prototype.getArcPoint = function (point) {
        return point;
    };
    PieLabel.prototype.getPointAngle = function (point) {
        var coordinate = this.getCoordinate();
        var startPoint = {
            x: (0,esm/* isArray */.kJ)(point.x) ? point.x[0] : point.x,
            y: point.y[0],
        };
        var endPoint = {
            x: (0,esm/* isArray */.kJ)(point.x) ? point.x[1] : point.x,
            y: point.y[1],
        };
        var angle;
        var startAngle = getAngleByPoint(coordinate, startPoint);
        if (point.points && point.points[0].y === point.points[1].y) {
            angle = startAngle;
        }
        else {
            var endAngle = getAngleByPoint(coordinate, endPoint);
            if (startAngle >= endAngle) {
                // 100% pie slice
                endAngle = endAngle + Math.PI * 2;
            }
            angle = startAngle + (endAngle - startAngle) / 2;
        }
        return angle;
    };
    /** @override */
    PieLabel.prototype.getCirclePoint = function (angle, offset) {
        var coordinate = this.getCoordinate();
        var center = coordinate.getCenter();
        var r = coordinate.getRadius() + offset;
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, polarToCartesian(center.x, center.y, r, angle)), { angle: angle, r: r });
    };
    return PieLabel;
}(label_polar));
/* harmony default export */ var pie = (PieLabel);
//# sourceMappingURL=pie.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js



/** label text\u548Cline\u8DDD\u79BB 4px */
var MARGIN = 4;
function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
    var e_1, _a;
    // adjust y position of labels to avoid overlapping
    var overlapping = true;
    var start = plotRange.start;
    var end = plotRange.end;
    var startY = Math.min(start.y, end.y);
    var totalHeight = Math.abs(start.y - end.y);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function (label) {
        if (label.y > maxY) {
            maxY = label.y;
        }
        if (label.y < minY) {
            minY = label.y;
        }
        return {
            size: lineHeight,
            targets: [label.y - startY],
        };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
        totalHeight = maxY - startY;
    }
    while (overlapping) {
        /* eslint no-loop-func: 0 */
        boxes.forEach(function (box) {
            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
            // box.pos = Math.max(0, target - box.size / 2);
        });
        // detect overlapping and join boxes
        overlapping = false;
        i = boxes.length;
        while (i--) {
            if (i > 0) {
                var previousBox = boxes[i - 1];
                var box = boxes[i];
                if (previousBox.pos + previousBox.size > box.pos) {
                    // overlapping
                    previousBox.size += box.size;
                    previousBox.targets = previousBox.targets.concat(box.targets);
                    // overflow, shift up
                    if (previousBox.pos + previousBox.size > totalHeight) {
                        previousBox.pos = totalHeight - previousBox.size;
                    }
                    boxes.splice(i, 1); // removing box
                    overlapping = true;
                }
            }
        }
    }
    i = 0;
    // step 4: normalize y and adjust x
    boxes.forEach(function (b) {
        var posInCompositeBox = startY + lineHeight / 2; // middle of the label
        b.targets.forEach(function () {
            labels[i].y = b.pos + posInCompositeBox;
            posInCompositeBox += lineHeight;
            i++;
        });
    });
    var labelsMap = {};
    try {
        for (var labelShapes_1 = (0,tslib_es6/* __values */.XA)(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
            var labelShape = labelShapes_1_1.value;
            labelsMap[labelShape.get('id')] = labelShape;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (labelShapes_1_1 && !labelShapes_1_1.done && (_a = labelShapes_1.return)) _a.call(labelShapes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // (x - cx)^2 + (y - cy)^2 = totalR^2
    labels.forEach(function (label) {
        var rPow2 = label.r * label.r;
        var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
        if (rPow2 < dyPow2) {
            label.x = center.x;
        }
        else {
            var dx = Math.sqrt(rPow2 - dyPow2);
            if (!isRight) {
                // left
                label.x = center.x - dx;
            }
            else {
                // right
                label.x = center.x + dx;
            }
        }
        // adjust labelShape
        var labelShape = labelsMap[label.id];
        labelShape.attr('x', label.x);
        labelShape.attr('y', label.y);
        // because group could not effect text-shape, should set text-shape position manually
        var textShape = (0,esm/* find */.sE)(labelShape.getChildren(), function (ele) { return ele.get('type') === 'text'; });
        // @ts-ignore
        if (textShape) {
            textShape.attr('y', label.y);
            textShape.attr('x', label.x);
        }
    });
}
function distribute(items, labels, shapes, region) {
    if (!items.length || !labels.length) {
        return;
    }
    var offset = items[0] ? items[0].offset : 0;
    var coordinate = labels[0].get('coordinate');
    var radius = coordinate.getRadius();
    var center = coordinate.getCenter();
    if (offset > 0) {
        // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);
        var lineHeight_1 = 14; // TODO
        var totalR = radius + offset;
        var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
        var plotRange_1 = {
            start: coordinate.start,
            end: coordinate.end,
        };
        // step 1: separate labels
        var halves_1 = [
            [],
            [], // right
        ];
        items.forEach(function (labelItem) {
            if (!labelItem) {
                return;
            }
            if (labelItem.textAlign === 'right') {
                // left
                halves_1[0].push(labelItem);
            }
            else {
                // right or center will be put on the right side
                halves_1[1].push(labelItem);
            }
        });
        halves_1.forEach(function (half, index) {
            // step 2: reduce labels
            var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
            if (half.length > maxLabelsCountForOneSide) {
                half.sort(function (a, b) {
                    // sort by percentage DESC
                    return b['..percent'] - a['..percent'];
                });
                half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
            }
            // step 3: distribute position (x and y)
            half.sort(function (a, b) {
                // sort by y ASC
                return a.y - b.y;
            });
            antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
        });
    }
    // \u914D\u7F6E labelLine
    (0,esm/* each */.S6)(items, function (item) {
        if (item && item.labelLine) {
            var distance = item.offset;
            var angle = item.angle;
            // \u8D34\u8FD1\u5706\u5468
            var startPoint = polarToCartesian(center.x, center.y, radius, angle);
            var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);
            var itemX = item.x + (0,esm/* get */.U2)(item, 'offsetX', 0);
            var itemY = item.y + (0,esm/* get */.U2)(item, 'offsetY', 0);
            var endPoint = {
                x: itemX - Math.cos(angle) * MARGIN,
                y: itemY - Math.sin(angle) * MARGIN,
            };
            if (!(0,esm/* isObject */.Kn)(item.labelLine)) {
                // labelLine: true
                item.labelLine = {};
            }
            item.labelLine.path = [
                "M ".concat(startPoint.x),
                "".concat(startPoint.y, " Q").concat(innerPoint.x),
                "".concat(innerPoint.y, " ").concat(endPoint.x),
                endPoint.y,
            ].join(',');
        }
    });
}
//# sourceMappingURL=distribute.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
/**
 * \u78B0\u649E\u68C0\u6D4B\u7B97\u6CD5
 */
function util_antiCollision(items, labelHeight, plotRange) {
    var labels = items.filter(function (item) { return !item.invisible; });
    // sorted by y, mutable
    labels.sort(function (a, b) { return a.y - b.y; });
    // adjust y position of labels to avoid overlapping
    var overlapping = true;
    var startY = plotRange.minY;
    var endY = plotRange.maxY;
    var totalHeight = Math.abs(startY - endY);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function (label) {
        if (label.y > maxY) {
            maxY = label.y;
        }
        if (label.y < minY) {
            minY = label.y;
        }
        return {
            content: label.content,
            size: labelHeight,
            targets: [label.y - startY],
            pos: null,
        };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
        totalHeight = maxY - startY;
    }
    while (overlapping) {
        /* eslint no-loop-func: 0 */
        boxes.forEach(function (box) {
            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
            box.pos = Math.max(0, box.pos);
        });
        // detect overlapping and join boxes
        overlapping = false;
        i = boxes.length;
        while (i--) {
            if (i > 0) {
                var previousBox = boxes[i - 1];
                var box = boxes[i];
                if (previousBox.pos + previousBox.size > box.pos) {
                    // overlapping
                    previousBox.size += box.size;
                    previousBox.targets = previousBox.targets.concat(box.targets);
                    // overflow, shift up
                    if (previousBox.pos + previousBox.size > totalHeight) {
                        previousBox.pos = totalHeight - previousBox.size;
                    }
                    boxes.splice(i, 1); // removing box
                    overlapping = true;
                }
            }
        }
    }
    i = 0;
    // step 4: normalize y and adjust x
    boxes.forEach(function (b) {
        var posInCompositeBox = startY + labelHeight / 2; // middle of the label
        b.targets.forEach(function () {
            labels[i].y = b.pos + posInCompositeBox;
            posInCompositeBox += labelHeight;
            i++;
        });
    });
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js




/** label text\u548Cline\u8DDD\u79BB 4px */
var outer_MARGIN = 4;
/**
 * \u914D\u7F6E labelline
 * @param item PolarLabelItem
 */
function drawLabelline(item /** PolarLabelItem */, coordinate) {
    /** \u5750\u6807\u5706\u5FC3 */
    var center = coordinate.getCenter();
    /** \u5706\u534A\u5F84 */
    var radius = coordinate.getRadius();
    if (item && item.labelLine) {
        var angle = item.angle, labelOffset = item.offset;
        // \u8D34\u8FD1\u5706\u5468
        var startPoint = polarToCartesian(center.x, center.y, radius, angle);
        var itemX = item.x + (0,esm/* get */.U2)(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);
        var itemY = item.y + (0,esm/* get */.U2)(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);
        var endPoint = {
            x: itemX - Math.cos(angle) * outer_MARGIN,
            y: itemY - Math.sin(angle) * outer_MARGIN,
        };
        var smoothConnector = item.labelLine.smooth;
        var path = [];
        var dx = endPoint.x - center.x;
        var dy = endPoint.y - center.y;
        var endAngle = Math.atan(dy / dx);
        // \u7B2C\u4E09\u8C61\u9650 & \u7B2C\u56DB\u8C61\u9650
        if (dx < 0) {
            endAngle += Math.PI;
        }
        // \u9ED8\u8BA4 smooth, undefined \u4E5F\u4E3A smooth
        if (smoothConnector === false) {
            if (!(0,esm/* isObject */.Kn)(item.labelLine)) {
                // labelLine: true
                item.labelLine = {};
            }
            // \u8868\u793A\u5F27\u7EBF\u7684\u65B9\u5411\uFF0C0 \u8868\u793A\u4ECE\u8D77\u70B9\u5230\u7EC8\u70B9\u6CBF\u9006\u65F6\u9488\u753B\u5F27, 1 \u8868\u793A\u987A\u65F6\u9488
            var sweepFlag = 0;
            // \u7B2C\u4E00\u8C61\u9650
            if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {
                if (endPoint.y > startPoint.y) {
                    sweepFlag = 1;
                }
            }
            // \u7B2C\u4E8C\u8C61\u9650
            if (angle >= 0 && angle < Math.PI / 2) {
                if (endPoint.y > startPoint.y) {
                    sweepFlag = 1;
                }
            }
            // \u7B2C\u4E09\u8C61\u9650
            if (angle >= Math.PI / 2 && angle < Math.PI) {
                if (startPoint.y > endPoint.y) {
                    sweepFlag = 1;
                }
            }
            // \u7B2C\u56DB\u8C61\u9650
            if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {
                if (startPoint.y > endPoint.y) {
                    sweepFlag = 1;
                }
            }
            var distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
            var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);
            // \u5706\u5F27\u7684\u7ED3\u675F\u70B9
            var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);
            /**
             * @example
             * M 100 100 L100 90 A 50 50 0 0 0 150 50
             * \u79FB\u52A8\u81F3 (100, 100), \u8FDE\u63A5\u5230 (100, 90), \u4EE5 (50, 50) \u4E3A\u5706\u5FC3\uFF0C\u7ED8\u5236\u5706\u5F27\u81F3 (150, 50);
             * A \u547D\u4EE4\u7684\u7B2C 4 \u4E2A\u53C2\u6570 large-arc-flag, \u51B3\u5B9A\u5F27\u7EBF\u662F\u5927\u4E8E\u8FD8\u662F\u5C0F\u4E8E 180 \u5EA6: 0 \u8868\u793A\u5C0F\u89D2\u5EA6\u5F27\uFF0C1 \u8868\u793A\u5927\u89D2
             * \u7B2C 5 \u4E2A\u53C2\u6570: \u662F\u5426\u987A\u65F6\u9488\u7ED8\u5236
             */
            // \u9ED8\u8BA4\u5C0F\u5F27
            var largeArcFlag = 0;
            // step1: \u79FB\u52A8\u81F3\u8D77\u70B9
            path.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
            // step2: \u8FDE\u63A5\u62D0\u70B9
            path.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
            // step3: \u7ED8\u5236\u5706\u5F27 \u81F3 \u7ED3\u675F\u70B9
            path.push("A ".concat(center.x, " ").concat(center.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
            // step4: \u8FDE\u63A5\u7ED3\u675F\u70B9
            path.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
        }
        else {
            var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle);
            // G2 \u65E7\u7684\u62C9\u7EBF
            // path.push('Q', \`\${breakPoint.x}\`, \`\${breakPoint.y}\`, \`\${endPoint.x}\`, \`\${endPoint.y}\`);
            var xSign = startPoint.x < center.x ? 1 : -1;
            // step1: \u8FDE\u63A5\u7ED3\u675F\u70B9
            path.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
            var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
            var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);
            if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
                // step2: \u7ED8\u5236 curve line (\u8D77\u70B9 & \u7ED3\u5408\u70B9\u4E0E\u5706\u5FC3\u7684\u659C\u7387\u4E0D\u7B49\u65F6, \u7531\u4E8E\u5B58\u5728\u8BEF\u5DEE, \u4F7F\u7528\u8FD1\u4F3C\u5904\u7406)
                path.push.apply(path, [
                    'C',
                    endPoint.x + xSign * 4,
                    endPoint.y,
                    2 * breakPoint.x - startPoint.x,
                    2 * breakPoint.y - startPoint.y,
                    startPoint.x,
                    startPoint.y,
                ]);
            }
            // step3: \u8FDE\u63A5\u81F3\u8D77\u70B9
            path.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
        }
        item.labelLine.path = path.join(' ');
    }
}
/**
 * \u997C\u56FE outer-label \u5E03\u5C40, \u9002\u7528\u4E8E type = pie \u4E14 label offset > 0 \u7684\u6807\u7B7E
 */
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
    var e_1, _a;
    var items = (0,esm/* filter */.hX)(originalItems, function (item) { return !(0,esm/* isNil */.UM)(item); });
    /** \u5750\u6807\u7CFB */
    var coordinate = labels[0] && labels[0].get('coordinate');
    if (!coordinate) {
        return;
    }
    /** \u5750\u6807\u5706\u5FC3 */
    var center = coordinate.getCenter();
    /** \u5706\u534A\u5F84 */
    var radius = coordinate.getRadius();
    /** label shapes */
    var labelsMap = {};
    try {
        for (var labels_1 = (0,tslib_es6/* __values */.XA)(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
            var labelShape = labels_1_1.value;
            labelsMap[labelShape.get('id')] = labelShape;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // note labelHeight \u53EF\u4EE5\u63A7\u5236 label \u7684\u884C\u9AD8
    var labelHeight = (0,esm/* get */.U2)(items[0], 'labelHeight', 14);
    var labelOffset = (0,esm/* get */.U2)(items[0], 'offset', 0);
    if (labelOffset <= 0) {
        return;
    }
    var LEFT_HALF_KEY = 'left';
    var RIGHT_HALF_KEY = 'right';
    // step 1: separate labels
    var separateLabels = (0,esm/* groupBy */.vM)(items, function (item) { return (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY); });
    var start = coordinate.start, end = coordinate.end;
    // step2: calculate totalHeight
    var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());
    var totalR = totalHeight / 2;
    /** labels \u5BB9\u5668\u7684\u8303\u56F4(\u540E\u7EED\u6839\u636E\u7EC4\u4EF6\u7684\u5E03\u5C40\u8BBE\u8BA1\u8FDB\u884C\u8C03\u6574) */
    var labelsContainerRange = {
        minX: start.x,
        maxX: end.x,
        minY: center.y - totalR,
        maxY: center.y + totalR,
    };
    // step 3: antiCollision
    (0,esm/* each */.S6)(separateLabels, function (half, key) {
        var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
        if (half.length > maxLabelsCountForOneSide) {
            half.sort(function (a, b) {
                // sort by percentage DESC
                return b.percent - a.percent;
            });
            (0,esm/* each */.S6)(half, function (labelItem, idx) {
                if (idx + 1 > maxLabelsCountForOneSide) {
                    labelsMap[labelItem.id].set('visible', false);
                    labelItem.invisible = true;
                }
            });
        }
        util_antiCollision(half, labelHeight, labelsContainerRange);
    });
    (0,esm/* each */.S6)(separateLabels, function (half, key) {
        (0,esm/* each */.S6)(half, function (item) {
            var isRight = key === RIGHT_HALF_KEY;
            var labelShape = labelsMap[item.id];
            // because group could not effect content-shape, should set content-shape position manually
            var content = labelShape.getChildByIndex(0);
            // textShape \u53D1\u751F\u8FC7\u8C03\u6574
            if (content) {
                var r = radius + labelOffset;
                // (x - cx)^2 + (y - cy)^2 = totalR^2
                var dy = item.y - center.y;
                var rPow2 = Math.pow(r, 2);
                var dyPow2 = Math.pow(dy, 2);
                var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
                var dx = Math.sqrt(dxPow2);
                var dx_offset = Math.abs(Math.cos(item.angle) * r);
                if (!isRight) {
                    // left
                    item.x = center.x - Math.max(dx, dx_offset);
                }
                else {
                    // right
                    item.x = center.x + Math.max(dx, dx_offset);
                }
            }
            // adjust labelShape
            if (content) {
                content.attr('y', item.y);
                content.attr('x', item.x);
            }
            drawLabelline(item, coordinate);
        });
    });
}
//# sourceMappingURL=outer.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js





/** \u62D0\u70B9\u504F\u79FB\u91CF, \u6682\u4E0D\u53EF\u914D\u7F6E */
var INFLECTION_OFFSET = 4;
/** \u6807\u7B7E\u504F\u79FB\u91CF, distance between label and edge: offsetX */
var LABEL_OFFSET_X = 4;
/** \u6807\u7B7E\u4E0E\u7275\u5F15\u7EBF\u7684\u504F\u79FB\u91CF */
var LABEL_TEXT_LINE_OFFSET = 4;
function spider_drawLabelline(item, coordinate, inRight) {
    /** \u5750\u6807\u5706\u5FC3 */
    var center = coordinate.getCenter();
    /** \u5706\u534A\u5F84 */
    var radius = coordinate.getRadius();
    var startPoint = {
        x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
        y: item.y,
    };
    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
    var p1 = { x: startPoint.x, y: startPoint.y };
    var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
    var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);
    var path = '';
    // \u6587\u672C\u88AB\u8C03\u6574\u4E0B\u53BB\u4E86\uFF0C\u5219\u6DFB\u52A0\u62D0\u70B9\u8FDE\u63A5\u7EBF
    if (startPoint.y !== inflectionPoint.y) {
        var offset = inRight ? 4 : -4;
        p1.y = startPoint.y;
        /** \u662F\u5426\u5728\u7B2C\u4E00\u8C61\u9650 */
        if (item.angle < 0 && item.angle >= -Math.PI / 2) {
            p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
            if (startPoint.y < inflectionPoint.y) {
                p2.y = p1.y;
            }
            else {
                p2.y = inflectionPoint.y;
                p2.x = Math.max(p2.x, p1.x - offset);
            }
        }
        /** \u662F\u5426\u5728 \u7B2C\u4E8C\u8C61\u9650 */
        if (item.angle > 0 && item.angle < Math.PI / 2) {
            p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
            if (startPoint.y > inflectionPoint.y) {
                p2.y = p1.y;
            }
            else {
                p2.y = inflectionPoint.y;
                p2.x = Math.max(p2.x, p1.x - offset);
            }
        }
        /** \u662F\u5426\u5728 \u7B2C\u4E09\u8C61\u9650 */
        if (item.angle > Math.PI / 2) {
            p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
            if (startPoint.y > inflectionPoint.y) {
                p2.y = p1.y;
            }
            else {
                p2.y = inflectionPoint.y;
                p2.x = Math.min(p2.x, p1.x - offset);
            }
        }
        /** \u662F\u5426\u5728 \u7B2C\u56DB\u8C61\u9650 */
        if (item.angle < -Math.PI / 2) {
            p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
            if (startPoint.y < inflectionPoint.y) {
                p2.y = p1.y;
            }
            else {
                p2.y = inflectionPoint.y;
                p2.x = Math.min(p2.x, p1.x - offset);
            }
        }
    }
    path = [
        "M ".concat(startPoint.x, ",").concat(startPoint.y),
        "L ".concat(p1.x, ",").concat(p1.y),
        "L ".concat(p2.x, ",").concat(p2.y),
        "L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
        "L ".concat(endPoint.x, ",").concat(endPoint.y),
    ].join(' ');
    item.labelLine = (0,esm/* deepMix */.b$)({}, item.labelLine, { path: path });
}
/**
 * \u997C\u56FE\u6807\u7B7E spider \u5E03\u5C40, \u53EA\u9002\u7528\u4E8E pie-spider \u7684\u6807\u7B7E\u7C7B\u578B
 * region \u5E94\u8BE5\u662F labelsRenderer \u5BB9\u5668\u7684\u8303\u56F4\u9650\u5236(\u4FBF\u4E8E\u540E\u7EED\u7EC4\u4EF6\u95F4\u5E03\u5C40)
 */
function pieSpiderLabelLayout(items, labels, shapes, region) {
    var e_1, _a;
    /** \u5750\u6807\u7CFB */
    var coordinate = labels[0] && labels[0].get('coordinate');
    if (!coordinate) {
        return;
    }
    /** \u5750\u6807\u5706\u5FC3 */
    var center = coordinate.getCenter();
    /** \u5706\u534A\u5F84 */
    var radius = coordinate.getRadius();
    /** label shapes */
    var labelsMap = {};
    try {
        for (var labels_1 = (0,tslib_es6/* __values */.XA)(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
            var labelShape = labels_1_1.value;
            labelsMap[labelShape.get('id')] = labelShape;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var labelHeight = (0,esm/* get */.U2)(items[0], 'labelHeight', 14);
    var labelOffset = Math.max((0,esm/* get */.U2)(items[0], 'offset', 0), INFLECTION_OFFSET);
    // step 1: adjust items to spider
    (0,esm/* each */.S6)(items, function (item) {
        if (!item)
            return;
        var label = (0,esm/* get */.U2)(labelsMap, [item.id]);
        if (!label)
            return;
        var inRight = item.x > center.x || (item.x === center.x && item.y > center.y);
        var offsetX = !(0,esm/* isNil */.UM)(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
        var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
        var totalOffset = labelOffset + offsetX;
        item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);
        item.y = inflectionPoint.y;
    });
    var start = coordinate.start, end = coordinate.end;
    var LEFT_HALF_KEY = 'left';
    var RIGHT_HALF_KEY = 'right';
    // step 1: separate labels
    var separateLabels = (0,esm/* groupBy */.vM)(items, function (item) { return (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY); });
    // step2: calculate totalHeight
    var totalHeight = (radius + labelOffset) * 2 + labelHeight;
    (0,esm/* each */.S6)(separateLabels, function (half) {
        var halfHeight = half.length * labelHeight;
        if (halfHeight > totalHeight) {
            totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
        }
    });
    /** labels \u5BB9\u5668\u7684\u8303\u56F4(\u540E\u7EED\u6839\u636E\u7EC4\u4EF6\u7684\u5E03\u5C40\u8BBE\u8BA1\u8FDB\u884C\u8C03\u6574) */
    var labelsContainerRange = {
        minX: start.x,
        maxX: end.x,
        minY: center.y - totalHeight / 2,
        maxY: center.y + totalHeight / 2,
    };
    // step 3: antiCollision
    (0,esm/* each */.S6)(separateLabels, function (half, key) {
        var maxLabelsCountForOneSide = totalHeight / labelHeight;
        if (half.length > maxLabelsCountForOneSide) {
            half.sort(function (a, b) {
                // sort by percentage DESC
                return b.percent - a.percent;
            });
            (0,esm/* each */.S6)(half, function (labelItem, idx) {
                if (idx > maxLabelsCountForOneSide) {
                    labelsMap[labelItem.id].set('visible', false);
                    labelItem.invisible = true;
                }
            });
        }
        util_antiCollision(half, labelHeight, labelsContainerRange);
    });
    var startY = labelsContainerRange.minY;
    var endY = labelsContainerRange.maxY;
    // step4: applyTo labels and adjust labelLines
    (0,esm/* each */.S6)(separateLabels, function (half, key) {
        var inRight = key === RIGHT_HALF_KEY;
        (0,esm/* each */.S6)(half, function (item) {
            var label = (0,esm/* get */.U2)(labelsMap, item && [item.id]);
            if (!label) {
                return;
            }
            // out of range, hidden
            if (item.y < startY || item.y > endY) {
                label.set('visible', false);
                return;
            }
            var labelContent = label.getChildByIndex(0);
            var box = labelContent.getCanvasBBox();
            var originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };
            translate(labelContent, item.x - originalPos.x /** \u4ECE pos.x \u79FB\u52A8\u5230 item.x */, item.y - originalPos.y);
            // adjust labelLines
            if (item.labelLine) {
                spider_drawLabelline(item, coordinate, inRight);
            }
        });
    });
}
//# sourceMappingURL=spider.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js


/**
 * @ignore
 * \u5C06 label \u9650\u5236\u5728\u753B\u5E03\u8303\u56F4\u5185\uFF0C\u7B80\u5355\u5F97\u5C06\u8D85\u51FA\u753B\u5E03\u7684 label \u5F80\u753B\u5E03\u5185\u8C03\u6574
 * @param labels
 * @param cfg
 */
function limitInCanvas(items, labels, shapes, region) {
    (0,esm/* each */.S6)(labels, function (label) {
        var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
        var _a = label.getCanvasBBox(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var finalX = x;
        var finalY = y;
        if (minX < regionMinX || maxX < regionMinX) {
            // \u8D85\u51FA\u5DE6\u4FA7
            finalX = regionMinX;
        }
        if (minY < regionMinY || maxY < regionMinY) {
            // \u8D85\u51FA\u9876\u90E8
            finalY = regionMinY;
        }
        if (minX > regionMaxX) {
            // \u6574\u4F53\u8D85\u51FA\u53F3\u4FA7
            finalX = regionMaxX - width;
        }
        else if (maxX > regionMaxX) {
            // \u8D85\u51FA\u53F3\u4FA7
            finalX = finalX - (maxX - regionMaxX);
        }
        if (minY > regionMaxY) {
            // \u6574\u4F53\u8D85\u51FA\u9876\u90E8
            finalY = regionMaxY - height;
        }
        else if (maxY > regionMaxY) {
            // \u8D85\u51FA\u5E95\u90E8
            finalY = finalY - (maxY - regionMaxY);
        }
        if (finalX !== x || finalY !== y) {
            translate(label, finalX - x, finalY - y);
        }
    });
}
//# sourceMappingURL=limit-in-canvas.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js

/**
 * @ignore
 * \u6839\u636E\u56FE\u5F62\u5143\u7D20\u4EE5\u53CA label \u7684 bbox \u8FDB\u884C\u8C03\u6574\uFF0C\u5982\u679C label \u8D85\u51FA\u4E86 shape \u7684 bbox \u5219\u4E0D\u5C55\u793A
 */
function limitInShape(items, labels, shapes, region) {
    (0,esm/* each */.S6)(labels, function (label, index) {
        var labelBBox = label.getCanvasBBox(); // \u6587\u672C\u6709\u53EF\u80FD\u53D1\u751F\u65CB\u8F6C
        var shapeBBox = shapes[index].getBBox();
        if (labelBBox.minX < shapeBBox.minX ||
            labelBBox.minY < shapeBBox.minY ||
            labelBBox.maxX > shapeBBox.maxX ||
            labelBBox.maxY > shapeBBox.maxY) {
            label.remove(true); // \u8D85\u51FA\u5219\u4E0D\u5C55\u793A
        }
    });
}
//# sourceMappingURL=limit-in-shape.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/overlap.js

var MAX_TIMES = 100;
/**
 * @ignore
 * Greedy \u8D2A\u5A6A\u7B97\u6CD5
 */
var Greedy = /** @class */ (function () {
    function Greedy(cfg) {
        if (cfg === void 0) { cfg = {}; }
        this.bitmap = {};
        var _a = cfg.xGap, xGap = _a === void 0 ? 1 : _a, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
        this.xGap = xGap;
        this.yGap = yGap;
    }
    Greedy.prototype.hasGap = function (bbox) {
        var hasGap = true;
        var bitmap = this.bitmap;
        var minX = Math.round(bbox.minX);
        var maxX = Math.round(bbox.maxX);
        var minY = Math.round(bbox.minY);
        var maxY = Math.round(bbox.maxY);
        for (var i = minX; i <= maxX; i += 1) {
            if (!bitmap[i]) {
                bitmap[i] = {};
                continue;
            }
            if (i === minX || i === maxX) {
                for (var j = minY; j <= maxY; j++) {
                    if (bitmap[i][j]) {
                        hasGap = false;
                        break;
                    }
                }
            }
            else {
                if (bitmap[i][minY] || bitmap[i][maxY]) {
                    hasGap = false;
                    break;
                }
            }
        }
        return hasGap;
    };
    Greedy.prototype.fillGap = function (bbox) {
        var bitmap = this.bitmap;
        var minX = Math.round(bbox.minX);
        var maxX = Math.round(bbox.maxX);
        var minY = Math.round(bbox.minY);
        var maxY = Math.round(bbox.maxY);
        // filling grid
        for (var i = minX; i <= maxX; i += 1) {
            if (!bitmap[i]) {
                bitmap[i] = {};
            }
        }
        for (var i = minX; i <= maxX; i += this.xGap) {
            for (var j = minY; j <= maxY; j += this.yGap) {
                bitmap[i][j] = true;
            }
            bitmap[i][maxY] = true;
        }
        // filling y edges
        if (this.yGap !== 1) {
            for (var i = minY; i <= maxY; i += 1) {
                bitmap[minX][i] = true;
                bitmap[maxX][i] = true;
            }
        }
        // filling x edges
        if (this.xGap !== 1) {
            for (var i = minX; i <= maxX; i += 1) {
                bitmap[i][minY] = true;
                bitmap[i][maxY] = true;
            }
        }
    };
    Greedy.prototype.destroy = function () {
        this.bitmap = {};
    };
    return Greedy;
}());
function spiralFill(label, greedy, maxTimes) {
    if (maxTimes === void 0) { maxTimes = MAX_TIMES; }
    var dt = -1;
    var _a = label.attr(), x = _a.x, y = _a.y;
    var bbox = label.getCanvasBBox();
    var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
    var dxdy;
    var t = -dt;
    var dx = 0;
    var dy = 0;
    var f = function (param) {
        var nt = param * 0.1;
        return [nt * Math.cos(nt), nt * Math.sin(nt)];
    };
    if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        return true;
    }
    var canFill = false;
    var times = 0;
    var accessedCache = {};
    while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
        dxdy = f((t += dt));
        dx = ~~dxdy[0];
        dy = ~~dxdy[1];
        if ((!dx && !dy) || accessedCache["".concat(dx, "-").concat(dy)]) {
            continue;
        }
        label.attr({ x: x + dx, y: y + dy });
        if (dx + dy < 0) {
            label.attr('textAlign', 'right');
        }
        times++;
        if (greedy.hasGap(label.getCanvasBBox())) {
            greedy.fillGap(label.getCanvasBBox());
            canFill = true;
            accessedCache["".concat(dx, "-").concat(dy)] = true;
            break;
        }
    }
    return canFill;
}
/*
 *  \u6839\u636E\u5982\u4E0B\u89C4\u5219\u5C1D\u8BD5\u653E\u7F6Elabel
 *                5
 *        ------------------
 *        |    1   |   0   |
 *    8   \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u20144\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014   7
 *        |    2   |   3   |
 *        \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014
 *                 6
 */
function adjustLabelPosition(label, x, y, index) {
    var _a = label.getCanvasBBox(), width = _a.width, height = _a.height;
    var attrs = {
        x: x,
        y: y,
        textAlign: 'center',
    };
    switch (index) {
        case 0:
            attrs.y -= height + 1;
            attrs.x += 1;
            attrs.textAlign = 'left';
            break;
        case 1:
            attrs.y -= height + 1;
            attrs.x -= 1;
            attrs.textAlign = 'right';
            break;
        case 2:
            attrs.y += height + 1;
            attrs.x -= 1;
            attrs.textAlign = 'right';
            break;
        case 3:
            attrs.y += height + 1;
            attrs.x += 1;
            attrs.textAlign = 'left';
            break;
        case 5:
            attrs.y -= height * 2 + 2;
            break;
        case 6:
            attrs.y += height * 2 + 2;
            break;
        case 7:
            attrs.x += width + 1;
            attrs.textAlign = 'left';
            break;
        case 8:
            attrs.x -= width + 1;
            attrs.textAlign = 'right';
            break;
        default:
            break;
    }
    label.attr(attrs);
    return label.getCanvasBBox();
}
/**
 * @ignore
 * label \u9632\u906E\u6321\u5E03\u5C40\uFF1A\u5728\u4E0D\u6539\u53D8 label \u4F4D\u7F6E\u7684\u60C5\u51B5\u4E0B\u5BF9\u76F8\u4E92\u91CD\u53E0\u7684 label \u8FDB\u884C\u8C03\u6574\u3002
 * \u4E0D\u540C\u4E8E 'overlap' \u7C7B\u578B\u7684\u5E03\u5C40\uFF0C\u8BE5\u5E03\u5C40\u4E0D\u4F1A\u5BF9 label \u7684\u4F4D\u7F6E\u8FDB\u884C\u504F\u79FB\u8C03\u6574\u3002
 * @param labels \u53C2\u4E0E\u5E03\u5C40\u8C03\u6574\u7684 label \u6570\u7EC4\u96C6\u5408
 */
function fixedOverlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    (0,esm/* each */.S6)(labels, function (label) {
        var labelShape = label.find(function (shape) { return shape.get('type') === 'text'; });
        if (!spiralFill(labelShape, greedy)) {
            label.remove(true);
        }
    });
    greedy.destroy();
}
/**
 * @ignore
 * label \u9632\u906E\u6321\u5E03\u5C40\uFF1A\u4E3A\u4E86\u9632\u6B62 label \u4E4B\u95F4\u76F8\u4E92\u8986\u76D6\u540C\u65F6\u4FDD\u8BC1\u5C3D\u53EF\u80FD\u591A \u7684 label \u5C55\u793A\uFF0C\u901A\u8FC7\u5C1D\u8BD5\u5C06 label \u5411**\u56DB\u5468\u504F\u79FB**\u6765\u5254\u9664\u653E\u4E0D\u4E0B\u7684 label
 * @param labels \u53C2\u4E0E\u5E03\u5C40\u8C03\u6574\u7684 label \u6570\u7EC4\u96C6\u5408
 */
function overlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    (0,esm/* each */.S6)(labels, function (label) {
        var labelShape = label.find(function (shape) { return shape.get('type') === 'text'; });
        var _a = labelShape.attr(), x = _a.x, y = _a.y;
        var canFill = false;
        for (var i = 0; i <= 8; i++) {
            var bbox = adjustLabelPosition(labelShape, x, y, i);
            if (greedy.hasGap(bbox)) {
                greedy.fillGap(bbox);
                canFill = true;
                break;
            }
        }
        if (!canFill) {
            label.remove(true);
        }
    });
    greedy.destroy();
}
//# sourceMappingURL=overlap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/collision-detect.js

function collision_detect_dot(a, b) {
    return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
}
/**
 * @private
 * 1. \u83B7\u53D6\u6295\u5F71\u8F74
 */
function getAxes(points /** \u591A\u8FB9\u5F62\u7684\u5173\u952E\u70B9 */) {
    // \u76EE\u524D\u5148\u5904\u7406 \u5E73\u884C\u77E9\u5F62 \u7684\u573A\u666F, \u5176\u4ED6\u591A\u8FB9\u5F62\u4E0D\u5904\u7406
    if (points.length > 4) {
        return [];
    }
    // \u83B7\u53D6\u5411\u91CF
    var vector = function (start, end) {
        return [end.x - start.x, end.y - start.y];
    };
    // \u7531\u4E8E \u77E9\u5F62\u7684\u5E73\u884C\u539F\u7406\uFF0C\u6240\u4EE5\u53EA\u6709 2 \u6761\u6295\u5F71\u8F74: A -> B, B -> C
    var AB = vector(points[0], points[1]);
    var BC = vector(points[1], points[2]);
    return [AB, BC];
}
/**
 * @private
 * \u7ED5\u6307\u5B9A\u70B9\u987A\u65F6\u9488\u65CB\u8F6C\u540E\u7684\u70B9\u5750\u6807
 * \u9ED8\u8BA4\u7ED5\u539F\u70B9\u65CB\u8F6C
 */
function rotateAtPoint(point, deg, origin) {
    if (deg === void 0) { deg = 0; }
    if (origin === void 0) { origin = { x: 0, y: 0 }; }
    var x = point.x, y = point.y;
    return {
        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,
    };
}
/**
 * @private
 * \u8F6C\u5316\u4E3A\u9876\u70B9\u5750\u6807\u6570\u7EC4
 *
 * @param {Object} box
 */
function collision_detect_getRectPoints(box) {
    var points = [
        { x: box.x, y: box.y },
        { x: box.x + box.width, y: box.y },
        { x: box.x + box.width, y: box.y + box.height },
        { x: box.x, y: box.y + box.height },
    ];
    var rotation = box.rotation;
    if (rotation) {
        return [
            rotateAtPoint(points[0], rotation, points[0]),
            rotateAtPoint(points[1], rotation, points[0]),
            rotateAtPoint(points[2], rotation, points[0]),
            rotateAtPoint(points[3], rotation, points[0]),
        ];
    }
    return points;
}
/**
 * @private
 * 2. \u83B7\u53D6\u591A\u8FB9\u5F62\u5728\u6295\u5F71\u8F74\u4E0A\u7684\u6295\u5F71
 *
 * \u5411\u91CF\u7684\u70B9\u79EF\u7684\u5176\u4E2D\u4E00\u4E2A\u51E0\u4F55\u542B\u4E49\u662F\uFF1A\u4E00\u4E2A\u5411\u91CF\u5728\u5E73\u884C\u4E8E\u53E6\u4E00\u4E2A\u5411\u91CF\u65B9\u5411\u4E0A\u7684\u6295\u5F71\u7684\u6570\u503C\u4E58\u79EF\u3002
 * \u7531\u4E8E\u6295\u5F71\u8F74\u662F\u5355\u4F4D\u5411\u91CF\uFF08\u957F\u5EA6\u4E3A1\uFF09\uFF0C\u6295\u5F71\u7684\u957F\u5EA6\u4E3A x1 * x2 + y1 * y2
 */
function getProjection(points /** \u591A\u8FB9\u5F62\u7684\u5173\u952E\u70B9 */, axis) {
    // \u76EE\u524D\u5148\u5904\u7406\u77E9\u5F62\u7684\u573A\u666F
    if (points.length > 4) {
        return { min: 0, max: 0 };
    }
    var scalars = [];
    points.forEach(function (point) {
        scalars.push(collision_detect_dot([point.x, point.y], axis));
    });
    return { min: Math.min.apply(Math, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(scalars), false)), max: Math.max.apply(Math, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(scalars), false)) };
}
function isProjectionOverlap(projection1, projection2) {
    return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
    return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box) {
    return ['x', 'y', 'width', 'height'].every(function (attr) { return isValidNumber(box[attr]); });
}
/**
 * \u5FEB\u901F\u5224\u65AD\u4E24\u4E2A\u65E0\u65CB\u8F6C\u77E9\u5F62\u662F\u5426\u906E\u6321
 */
function isIntersectRect(box1, box2, margin) {
    if (margin === void 0) { margin = 0; }
    return !(box2.x > box1.x + box1.width + margin ||
        box2.x + box2.width < box1.x - margin ||
        box2.y > box1.y + box1.height + margin ||
        box2.y + box2.height < box1.y - margin);
}
/**
 * detect whether two shape is intersected, useful when shape is been rotated
 * \u5224\u65AD\u4E24\u4E2A\u77E9\u5F62\u662F\u5426\u91CD\u53E0\uFF08\u76F8\u4EA4\u548C\u5305\u542B, \u662F\u5426\u65CB\u8F6C\uFF09
 *
 * - \u539F\u7406: \u5206\u79BB\u8F74\u5B9A\u5F8B
 */
function intersect(box1, box2, margin) {
    if (margin === void 0) { margin = 0; }
    // \u5982\u679C\u4E24\u4E2A box \u4E2D\u6709\u4E00\u4E2A\u662F\u4E0D\u5408\u6CD5\u7684 box\uFF0C\u4E5F\u5C31\u662F\u4E0D\u4F1A\u88AB\u6E32\u67D3\u51FA\u6765\u7684\uFF0C\u90A3\u4E48\u5B83\u4EEC\u5C31\u4E0D\u76F8\u4EA4\u3002
    if (!isValidBox(box1) || !isValidBox(box2))
        return false;
    // \u5982\u679C\u4E24\u4E2A\u77E9\u5F62\u6CA1\u6709\u65CB\u8F6C\uFF0C\u4F7F\u7528\u5FEB\u901F\u5224\u65AD
    if (!box1.rotation && !box2.rotation) {
        return isIntersectRect(box1, box2, margin);
    }
    // \u5206\u522B\u83B7\u53D6 4 \u4E2A\u5173\u952E\u70B9
    var rect1Points = collision_detect_getRectPoints(box1);
    var rect2Points = collision_detect_getRectPoints(box2);
    // \u83B7\u53D6\u6240\u6709\u6295\u5F71\u8F74
    var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
    for (var i = 0; i < axes.length; i++) {
        var axis = axes[i];
        var projection1 = getProjection(rect1Points, axis);
        var projection2 = getProjection(rect2Points, axis);
        // \u5224\u65AD\u6295\u5F71\u8F74\u4E0A\u7684\u6295\u5F71\u662F\u5426\u5B58\u5728\u91CD\u53E0\uFF0C\u82E5\u68C0\u6D4B\u5230\u5B58\u5728\u95F4\u9699\u5219\u7ACB\u523B\u9000\u51FA\u5224\u65AD\uFF0C\u6D88\u9664\u4E0D\u5FC5\u8981\u7684\u8FD0\u7B97\u3002
        if (!isProjectionOverlap(projection1, projection2)) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=collision-detect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/util/createWorker.js

var MyWorker = /** @class */ (function () {
    function MyWorker(url) {
        var _this = this;
        this.queue = [];
        this.worker = new Worker(url);
        this.worker.onmessage = function (e) {
            var _a;
            (_a = _this.queue.shift()) === null || _a === void 0 ? void 0 : _a.resolve(e);
        };
        this.worker.onmessageerror = function (e) {
            var _a;
            console.warn('[AntV G2] Web worker is not available');
            (_a = _this.queue.shift()) === null || _a === void 0 ? void 0 : _a.reject(e);
        };
    }
    MyWorker.prototype.post = function (params, onError) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.queue.push({ resolve: resolve, reject: reject });
            try {
                _this.worker.postMessage(params);
            }
            catch (e) {
                console.warn('[AntV G2] Web worker is not available');
                (0,esm/* isFunction */.mf)(onError) && onError();
            }
        });
    };
    MyWorker.prototype.destroy = function () {
        this.worker.terminate();
    };
    return MyWorker;
}());
function createWorker(f) {
    if (typeof window === 'undefined')
        return;
    var blob;
    try {
        blob = new Blob([f.toString()], { type: 'application/javascript' });
    }
    catch (e) {
        // @ts-ignore
        blob = new window.BlobBuilder();
        blob.append(f.toString());
        blob = blob.getBlob();
    }
    return new MyWorker(URL.createObjectURL(blob));
}
//# sourceMappingURL=createWorker.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/worker/hide-overlap.js
var onmessage = function (e) {
    // Copy from src/util/collision-detect.ts
    function generateUtils() {
        function dot(a, b) {
            return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
        }
        /**
         * 1. \u83B7\u53D6\u6295\u5F71\u8F74
         */
        function getAxes(points /** \u591A\u8FB9\u5F62\u7684\u5173\u952E\u70B9 */) {
            // \u76EE\u524D\u5148\u5904\u7406 \u5E73\u884C\u77E9\u5F62 \u7684\u573A\u666F, \u5176\u4ED6\u591A\u8FB9\u5F62\u4E0D\u5904\u7406
            if (points.length > 4) {
                return [];
            }
            // \u83B7\u53D6\u5411\u91CF
            var vector = function (start, end) {
                return [end.x - start.x, end.y - start.y];
            };
            // \u7531\u4E8E \u77E9\u5F62\u7684\u5E73\u884C\u539F\u7406\uFF0C\u6240\u4EE5\u53EA\u6709 2 \u6761\u6295\u5F71\u8F74: A -> B, B -> C
            var AB = vector(points[0], points[1]);
            var BC = vector(points[1], points[2]);
            return [AB, BC];
        }
        /**
         * \u7ED5\u6307\u5B9A\u70B9\u987A\u65F6\u9488\u65CB\u8F6C\u540E\u7684\u70B9\u5750\u6807
         * \u9ED8\u8BA4\u7ED5\u539F\u70B9\u65CB\u8F6C
         */
        function rotateAtPoint(point, deg, origin) {
            if (deg === void 0) { deg = 0; }
            if (origin === void 0) { origin = { x: 0, y: 0 }; }
            var x = point.x, y = point.y;
            return {
                x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
                y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,
            };
        }
        /**
         * @private
         * \u8F6C\u5316\u4E3A\u9876\u70B9\u5750\u6807\u6570\u7EC4
         *
         * @param {Object} box
         */
        function getRectPoints(box) {
            var points = [
                { x: box.x, y: box.y },
                { x: box.x + box.width, y: box.y },
                { x: box.x + box.width, y: box.y + box.height },
                { x: box.x, y: box.y + box.height },
            ];
            var rotation = box.rotation;
            if (rotation) {
                return [
                    rotateAtPoint(points[0], rotation, points[0]),
                    rotateAtPoint(points[1], rotation, points[0]),
                    rotateAtPoint(points[2], rotation, points[0]),
                    rotateAtPoint(points[3], rotation, points[0]),
                ];
            }
            return points;
        }
        /**
         * 2. \u83B7\u53D6\u591A\u8FB9\u5F62\u5728\u6295\u5F71\u8F74\u4E0A\u7684\u6295\u5F71
         *
         * \u5411\u91CF\u7684\u70B9\u79EF\u7684\u5176\u4E2D\u4E00\u4E2A\u51E0\u4F55\u542B\u4E49\u662F\uFF1A\u4E00\u4E2A\u5411\u91CF\u5728\u5E73\u884C\u4E8E\u53E6\u4E00\u4E2A\u5411\u91CF\u65B9\u5411\u4E0A\u7684\u6295\u5F71\u7684\u6570\u503C\u4E58\u79EF\u3002
         * \u7531\u4E8E\u6295\u5F71\u8F74\u662F\u5355\u4F4D\u5411\u91CF\uFF08\u957F\u5EA6\u4E3A1\uFF09\uFF0C\u6295\u5F71\u7684\u957F\u5EA6\u4E3A x1 * x2 + y1 * y2
         */
        function getProjection(points /** \u591A\u8FB9\u5F62\u7684\u5173\u952E\u70B9 */, axis) {
            // \u76EE\u524D\u5148\u5904\u7406\u77E9\u5F62\u7684\u573A\u666F
            if (points.length > 4) {
                return { min: 0, max: 0 };
            }
            var scalars = [];
            points.forEach(function (point) {
                scalars.push(dot([point.x, point.y], axis));
            });
            return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };
        }
        function isProjectionOverlap(projection1, projection2) {
            return projection1.max > projection2.min && projection1.min < projection2.max;
        }
        function isValidNumber(d) {
            return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
        }
        function isValidBox(box) {
            return ['x', 'y', 'width', 'height'].every(function (attr) { return isValidNumber(box[attr]); });
        }
        function isIntersectRect(box1, box2, margin) {
            if (margin === void 0) { margin = 0; }
            return !(box2.x > box1.x + box1.width + margin ||
                box2.x + box2.width < box1.x - margin ||
                box2.y > box1.y + box1.height + margin ||
                box2.y + box2.height < box1.y - margin);
        }
        function intersect(box1, box2, margin) {
            if (margin === void 0) { margin = 0; }
            if (!isValidBox(box1) || !isValidBox(box2))
                return false;
            // Quick detect, if rotation is null or zero.
            if (!box1.rotation && !box2.rotation) {
                return isIntersectRect(box1, box2, margin);
            }
            // \u5206\u522B\u83B7\u53D6 4 \u4E2A\u5173\u952E\u70B9
            var rect1Points = getRectPoints(box1);
            var rect2Points = getRectPoints(box2);
            // \u83B7\u53D6\u6240\u6709\u6295\u5F71\u8F74
            var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
            for (var i = 0; i < axes.length; i++) {
                var axis = axes[i];
                var projection1 = getProjection(rect1Points, axis);
                var projection2 = getProjection(rect2Points, axis);
                if (!isProjectionOverlap(projection1, projection2))
                    return false;
            }
            return true;
        }
        return { intersect: intersect };
    }
    var intersect = generateUtils().intersect;
    // Label layouts.
    function hideOverlap(items) {
        var boxes = items.slice();
        for (var i = 0; i < boxes.length; i++) {
            var box1 = boxes[i];
            if (box1.visible) {
                for (var j = i + 1; j < boxes.length; j++) {
                    var box2 = boxes[j];
                    if (box1 !== box2 && box2.visible) {
                        if (intersect(box1, box2)) {
                            box2.visible = false;
                        }
                    }
                }
            }
        }
        return boxes;
    }
    var methods = {
        'hide-overlap': hideOverlap,
    };
    // Main
    try {
        var eventData = JSON.parse(e.data);
        if (!eventData || !eventData.type || !methods[eventData.type])
            return;
        var type = eventData.type, items = eventData.items;
        var result = methods[type](items);
        self.postMessage(result);
    }
    catch (e) {
        throw e;
    }
};
var code = "\\n   self.onmessage = ".concat(onmessage.toString(), "\\n");

//# sourceMappingURL=hide-overlap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js






var layout = function (items) {
    var boxes = items.slice();
    for (var i = 0; i < boxes.length; i++) {
        var box1 = boxes[i];
        if (box1.visible) {
            for (var j = i + 1; j < boxes.length; j++) {
                var box2 = boxes[j];
                if (box1 !== box2 && box2.visible) {
                    if (intersect(box1, box2)) {
                        box2.visible = false;
                    }
                }
            }
        }
    }
    return boxes;
};
var cache = new Map();
var worker = createWorker(code);
/**
 * label \u9632\u906E\u6321\u5E03\u5C40\uFF1A\u5728\u4E0D\u6539\u53D8 label \u4F4D\u7F6E\u7684\u60C5\u51B5\u4E0B\u5BF9\u76F8\u4E92\u91CD\u53E0\u7684 label \u8FDB\u884C\u9690\u85CF\uFF08\u975E\u79FB\u9664\uFF09
 * \u4E0D\u540C\u4E8E 'overlap' \u7C7B\u578B\u7684\u5E03\u5C40\uFF0C\u8BE5\u5E03\u5C40\u4E0D\u4F1A\u5BF9 label \u7684\u4F4D\u7F6E\u8FDB\u884C\u504F\u79FB\u8C03\u6574\u3002
 * @param labels \u53C2\u4E0E\u5E03\u5C40\u8C03\u6574\u7684 label \u6570\u7EC4\u96C6\u5408
 */
function hideOverlap(labelItems, labels, shapes, region) {
    return (0,tslib_es6/* __awaiter */.mG)(this, void 0, void 0, function () {
        var boxes, memoKey, cb, params, res, e_1;
        return (0,tslib_es6/* __generator */.Jh)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    boxes = labels.map(function (d, idx) { return ((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, getLabelBackgroundInfo(d, labelItems[idx], (0,esm/* get */.U2)(labelItems[idx], 'background.padding'))), { visible: true })); });
                    memoKey = JSON.stringify(boxes);
                    cb = function (items) {
                        cache.set(memoKey, items);
                        (0,esm/* each */.S6)(items, function (_a, idx) {
                            var visible = _a.visible;
                            var labelShape = labels[idx];
                            if (visible) {
                                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();
                            }
                            else {
                                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();
                            }
                        });
                        return items;
                    };
                    if (!cache.get(memoKey)) return [3 /*break*/, 1];
                    cb(cache.get(memoKey));
                    return [3 /*break*/, 7];
                case 1:
                    if (!worker) return [3 /*break*/, 6];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    params = JSON.stringify({ type: 'hide-overlap', items: boxes });
                    return [4 /*yield*/, worker.post(params, function () { return cb(layout(boxes)); })];
                case 3:
                    res = _a.sent();
                    cb(Array.isArray(res.data) ? res.data : []);
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _a.sent();
                    console.error(e_1);
                    cb(layout(boxes));
                    return [3 /*break*/, 5];
                case 5: return [3 /*break*/, 7];
                case 6:
                    // Normal layout in main thread.
                    cb(layout(boxes));
                    _a.label = 7;
                case 7: return [2 /*return*/];
            }
        });
    });
}
//# sourceMappingURL=hide-overlap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/color.js


// \u5185\u7F6E\u7684\u4E00\u4E9B\u7279\u6B8A\u8BBE\u7F6E
var preset = {
    '#5B8FF9': true,
};
// \u6839\u636EYIQ\u4EAE\u5EA6\u5224\u65AD\u6307\u5B9A\u989C\u8272\u53D6\u53CD\u8272\u662F\u4E0D\u662F\u767D\u8272
// http://24ways.org/2010/calculating-color-contrast
// http://www.w3.org/TR/AERT#color-contrast
var isContrastColorWhite = function (color) {
    var rgb = color_util_esm.toRGB(color).toUpperCase();
    if (preset[rgb]) {
        return preset[rgb];
    }
    var _a = (0,tslib_es6/* __read */.CR)(color_util_esm.rgb2arr(rgb), 3), r = _a[0], g = _a[1], b = _a[2];
    var isDark = (r * 299 + g * 587 + b * 114) / 1000 < 128;
    return isDark;
};
//# sourceMappingURL=color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js


function adjustColor(items, labels, shapes) {
    if (shapes.length === 0) {
        return;
    }
    var element = shapes[0].get('element');
    var theme = element.geometry.theme;
    var _a = theme.labels || {}, fillColorLight = _a.fillColorLight, fillColorDark = _a.fillColorDark;
    shapes.forEach(function (shape, index) {
        var label = labels[index];
        var textShape = label.find(function (el) { return el.get('type') === 'text'; });
        var shapeBBox = BBox.fromObject(shape.getBBox());
        var textBBox = BBox.fromObject(textShape.getCanvasBBox());
        var overflow = !shapeBBox.contains(textBBox);
        var bgColor = shape.attr('fill');
        var fillWhite = isContrastColorWhite(bgColor);
        if (!overflow) {
            if (fillWhite) {
                if (fillColorLight) {
                    textShape.attr('fill', fillColorLight);
                }
            }
            else {
                if (fillColorDark) {
                    textShape.attr('fill', fillColorDark);
                }
            }
        }
        else {
            // \u51FA\u73B0\u6EA2\u51FA\u76F4\u63A5\u5E94\u7528 overflowLabel \u6837\u5F0F
            textShape.attr(theme.overflowLabels.style);
        }
    });
}
//# sourceMappingURL=adjust-color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js


function shouldInShapeSingle(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var textShape = findLabelTextShape(label);
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var shapeBBox = BBox.fromObject(shape.getBBox());
    return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry, labels, shapes) {
    var isStack = !!geometry.getAdjust('stack');
    return (isStack ||
        labels.every(function (label, index) {
            var shape = shapes[index];
            return shouldInShapeSingle(geometry, label, shape);
        }));
}
function moveInShape(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textShape = findLabelTextShape(label);
    if (coordinate.isTransposed) {
        // \u6C34\u5E73\u65B9\u5411\uFF1A\u6761\u5F62\u56FE\u7CFB\u5217
        textShape.attr({
            x: shapeBBox.minX + shapeBBox.width / 2,
            textAlign: 'center',
        });
    }
    else {
        // \u5782\u76F4\u65B9\u5411\uFF1A\u67F1\u5F62\u56FE\u7CFB\u5217
        textShape.attr({
            y: shapeBBox.minY + shapeBBox.height / 2,
            textBaseline: 'middle',
        });
    }
}
/**
 * \u9002\u7528\u4E8E interval geometry \u7684\u6570\u636E\u6807\u7B7E\u4F4D\u7F6E\u81EA\u52A8\u8C03\u6574\u5E03\u5C40\u65B9\u6CD5
 * @param items
 * @param labels
 * @param shapes
 */
function intervalAdjustPosition(items, labels, shapes) {
    var _a;
    if (shapes.length === 0) {
        return;
    }
    var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== 'interval') {
        return;
    }
    var inShape = shouldInShape(geometry, labels, shapes);
    if (inShape) {
        shapes.forEach(function (shape, index) {
            var label = labels[index];
            moveInShape(geometry, label, shape);
        });
    }
}
//# sourceMappingURL=adjust-position.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js



function filterLabel(labels) {
    var MAX_CNT = 500; // \u6700\u591A\u663E\u793A 500 \u4E2A\u6570\u636E\u6807\u7B7E
    var filteredLabels = [];
    var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
    (0,esm/* each */.S6)(labels, function (label, idx) {
        if (idx % pages === 0) {
            filteredLabels.push(label);
        }
        else {
            label.set('visible', false);
        }
    });
    return filteredLabels;
}
/**
 * \u4E3A interval geometry \u5B9A\u5236\u7684\u6570\u636E\u6807\u7B7E\u91CD\u53E0\u81EA\u52A8\u9690\u85CF\u5E03\u5C40\u65B9\u6CD5
 * @param items
 * @param labels
 * @param shapes
 */
function intervalHideOverlap(items, labels, shapes) {
    var _a;
    if (shapes.length === 0) {
        return;
    }
    var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== 'interval') {
        return;
    }
    var filteredLabels = filterLabel(labels);
    var _b = (0,tslib_es6/* __read */.CR)(geometry.getXYFields(), 1), xField = _b[0];
    var dones = [];
    var todo = [];
    var groupedLabels = (0,esm/* groupBy */.vM)(filteredLabels, function (label) { return label.get('data')[xField]; });
    var xValues = (0,esm/* uniq */.jj)((0,esm/* map */.UI)(filteredLabels, function (label) { return label.get('data')[xField]; }));
    var xValue;
    filteredLabels.forEach(function (label) {
        label.set('visible', true);
    });
    var addCurrentGroup = function (curItems) {
        if (curItems) {
            if (curItems.length) {
                // \u6700\u540E\u4E00\u4E2A
                todo.push(curItems.pop());
            }
            todo.push.apply(todo, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(curItems), false));
        }
    };
    if ((0,esm/* size */.dp)(xValues) > 0) {
        // \u7B2C\u4E00\u7EC4
        xValue = xValues.shift();
        addCurrentGroup(groupedLabels[xValue]);
    }
    if ((0,esm/* size */.dp)(xValues) > 0) {
        // \u6700\u540E\u4E00\u7EC4
        xValue = xValues.pop();
        addCurrentGroup(groupedLabels[xValue]);
    }
    (0,esm/* each */.S6)(xValues.reverse(), function (val) {
        // \u5176\u4ED6\u7EC4
        addCurrentGroup(groupedLabels[val]);
    });
    while (todo.length > 0) {
        var cur = todo.shift();
        if (cur.get('visible')) {
            if (checkShapeOverlap(cur, dones)) {
                cur.set('visible', false);
            }
            else {
                dones.push(cur);
            }
        }
    }
}
//# sourceMappingURL=hide-overlap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js



/**
 * \u5BF9\u540C\u4E00\u7EC4(\u76F8\u540C xField )\u7684 Label \u8FDB\u884C\u6392\u5E8F\uFF1A\u7B2C\u4E00\u4E2A\u3001\u6700\u540E\u4E00\u4E2A\u3001\u5176\u4ED6...
 * @param geometry
 * @param labels
 */
function sortLabels(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function (left, right) { return left.get('data')[yField] - left.get('data')[yField]; });
    if (sortedLabels.length > 0) {
        result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
        result.push(sortedLabels.pop());
    }
    result.push.apply(result, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(sortedLabels), false));
    return result;
}
function hasSome(dones, current, compare) {
    return dones.some(function (done) { return compare(done, current); });
}
/**
 * \u8BA1\u7B97\u4E24\u4E2A\u77E9\u5F62\u4E4B\u95F4\u7684\u5806\u53E0\u533A\u57DF\u9762\u79EF
 */
function adjust_position_getOverlapArea(a, b, margin) {
    if (margin === void 0) { margin = 0; }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
}
/**
 * \u5224\u65AD\u65B0\u6DFB\u52A0\u7684 Label \u662F\u5426\u548C\u5DF2\u5B58\u5728\u7684\u53D1\u751F\u91CD\u53E0
 * @param dones
 * @param current
 */
function adjust_position_checkShapeOverlap(dones, current) {
    return hasSome(dones, current, function (left, right) {
        var leftText = findLabelTextShape(left);
        var rightText = findLabelTextShape(right);
        return adjust_position_getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
}
/**
 * \u9002\u7528\u4E8E point geometry \u7684\u6570\u636E\u6807\u7B7E\u4F4D\u7F6E\u81EA\u52A8\u8C03\u6574\u5E03\u5C40\u65B9\u6CD5
 * @param items
 * @param labels
 * @param shapes
 * @param region
 * @param cfg
 */
function pointAdjustPosition(items, labels, shapes, region, cfg) {
    var _a, _b;
    if (shapes.length === 0) {
        return;
    }
    var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== 'point') {
        return;
    }
    var _c = (0,tslib_es6/* __read */.CR)(geometry.getXYFields(), 2), xField = _c[0], yField = _c[1];
    var groupedLabels = (0,esm/* groupBy */.vM)(labels, function (label) { return label.get('data')[xField]; });
    var dones = [];
    var offset = (cfg && cfg.offset) || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    (0,esm/* map */.UI)((0,esm/* keys */.XP)(groupedLabels).reverse(), function (xValue) {
        var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);
        while (sortedCollections.length) {
            var current = sortedCollections.shift();
            var textShape = findLabelTextShape(current);
            if (hasSome(dones, current, function (left, right) {
                return left.get('data')[xField] === right.get('data')[xField] &&
                    left.get('data')[yField] === right.get('data')[yField];
            })) {
                // \u91CD\u590D\u4F4D\u7F6E\uFF0C\u76F4\u63A5\u9690\u85CF
                textShape.set('visible', false);
                continue;
            }
            var upFail = adjust_position_checkShapeOverlap(dones, current);
            var downFail = false;
            if (upFail) {
                textShape.attr('y', textShape.attr('y') + 2 * offset);
                downFail = adjust_position_checkShapeOverlap(dones, current);
            }
            if (downFail) {
                textShape.set('visible', false);
                continue;
            }
            dones.push(current);
        }
    });
}
//# sourceMappingURL=adjust-position.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js



/**
 * \u5BF9\u540C\u4E00\u7EC4(\u76F8\u540C xField )\u7684 Label \u8FDB\u884C\u6392\u5E8F\uFF1A\u7B2C\u4E00\u4E2A\u3001\u6700\u540E\u4E00\u4E2A\u3001\u5176\u4ED6...
 * @param geometry
 * @param labels
 */
function adjust_position_sortLabels(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function (left, right) { return left.get('data')[yField] - left.get('data')[yField]; });
    if (sortedLabels.length > 0) {
        result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
        result.push(sortedLabels.pop());
    }
    result.push.apply(result, (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(sortedLabels), false));
    return result;
}
function adjust_position_hasSome(dones, current, compare) {
    return dones.some(function (done) { return compare(done, current); });
}
/**
 * \u8BA1\u7B97\u4E24\u4E2A\u77E9\u5F62\u4E4B\u95F4\u7684\u5806\u53E0\u533A\u57DF\u9762\u79EF
 */
function path_adjust_position_getOverlapArea(a, b, margin) {
    if (margin === void 0) { margin = 0; }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
}
/**
 * \u5224\u65AD\u65B0\u6DFB\u52A0\u7684 Label \u662F\u5426\u548C\u5DF2\u5B58\u5728\u7684\u53D1\u751F\u91CD\u53E0
 * @param dones
 * @param current
 */
function path_adjust_position_checkShapeOverlap(dones, current) {
    return adjust_position_hasSome(dones, current, function (left, right) {
        var leftText = findLabelTextShape(left);
        var rightText = findLabelTextShape(right);
        return path_adjust_position_getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
}
/**
 * \u9002\u7528\u4E8E point geometry \u7684\u6570\u636E\u6807\u7B7E\u4F4D\u7F6E\u81EA\u52A8\u8C03\u6574\u5E03\u5C40\u65B9\u6CD5
 * @param items
 * @param labels
 * @param shapes
 * @param region
 * @param cfg
 */
function pathAdjustPosition(items, labels, shapes, region, cfg) {
    var _a, _b;
    if (shapes.length === 0) {
        return;
    }
    var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || ['path', 'line', 'area'].indexOf(geometry.type) < 0) {
        return;
    }
    var _c = (0,tslib_es6/* __read */.CR)(geometry.getXYFields(), 2), xField = _c[0], yField = _c[1];
    var groupedLabels = (0,esm/* groupBy */.vM)(labels, function (label) { return label.get('data')[xField]; });
    var dones = [];
    var offset = (cfg && cfg.offset) || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    (0,esm/* map */.UI)((0,esm/* keys */.XP)(groupedLabels).reverse(), function (xValue) {
        var sortedCollections = adjust_position_sortLabels(geometry, groupedLabels[xValue]);
        while (sortedCollections.length) {
            var current = sortedCollections.shift();
            var textShape = findLabelTextShape(current);
            if (adjust_position_hasSome(dones, current, function (left, right) {
                return left.get('data')[xField] === right.get('data')[xField] &&
                    left.get('data')[yField] === right.get('data')[yField];
            })) {
                // \u91CD\u590D\u4F4D\u7F6E\uFF0C\u76F4\u63A5\u9690\u85CF
                textShape.set('visible', false);
                continue;
            }
            var upFail = path_adjust_position_checkShapeOverlap(dones, current);
            var downFail = false;
            if (upFail) {
                textShape.attr('y', textShape.attr('y') + 2 * offset);
                downFail = path_adjust_position_checkShapeOverlap(dones, current);
            }
            if (downFail) {
                textShape.set('visible', false);
                continue;
            }
            dones.push(current);
        }
    });
}
//# sourceMappingURL=adjust-position.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/context.js
var ctx;
/**
 * \u83B7\u53D6 canvas context
 */
function getCanvasContext() {
    if (!ctx) {
        ctx = document.createElement('canvas').getContext('2d');
    }
    return ctx;
}
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/text.js



/**
 * \u8BA1\u7B97\u6587\u672C\u5728\u753B\u5E03\u4E2D\u7684\u5BBD\u5EA6
 */
var measureTextWidth = (0,esm/* memoize */.HP)(function (text, font) {
    if (font === void 0) { font = {}; }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    var ctx = getCanvasContext();
    ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(' ');
    return ctx.measureText((0,esm/* isString */.HD)(text) ? text : '').width;
}, function (text, font) {
    if (font === void 0) { font = {}; }
    return (0,tslib_es6/* __spreadArray */.ev)([text], (0,tslib_es6/* __read */.CR)((0,esm/* values */.VO)(font)), false).join('');
});
/**
 * \u83B7\u53D6\u6587\u672C\u7684 ... \u6587\u672C\u3002
 * \u7B97\u6CD5\uFF08\u51CF\u5C11\u6BCF\u6B21 measureText \u7684\u957F\u5EA6\uFF0CmeasureText \u7684\u6027\u80FD\u8DDF\u5B57\u7B26\u4E32\u65F6\u95F4\u76F8\u5173\uFF09\uFF1A
 * 1. \u5148\u901A\u8FC7 STEP \u9010\u6B65\u8BA1\u7B97\uFF0C\u627E\u5230\u6700\u540E\u4E00\u4E2A\u5C0F\u4E8E maxWidth \u7684\u5B57\u7B26\u4E32
 * 2. \u7136\u540E\u5BF9\u6700\u540E\u8FD9\u4E2A\u5B57\u7B26\u4E32\u4E8C\u5206\u8BA1\u7B97
 * @param text \u9700\u8981\u8BA1\u7B97\u7684\u6587\u672C, \u7531\u4E8E\u5386\u53F2\u539F\u56E0 \u9664\u4E86\u652F\u6301string\uFF0C\u8FD8\u652F\u6301\u7A7A\u503C,number\u548C\u6570\u7EC4\u7B49
 * @param maxWidth
 * @param font
 */
var getEllipsisText = function (text, maxWidth, font) {
    var STEP = 16; // \u6BCF\u6B21 16\uFF0C\u8C03\u53C2\u5DE5\u7A0B\u5E08
    var DOT_WIDTH = measureTextWidth('...', font);
    var leftText;
    if (!(0,esm/* isString */.HD)(text)) {
        leftText = (0,esm/* toString */.BB)(text);
    }
    else {
        leftText = text;
    }
    var leftWidth = maxWidth;
    var r = []; // \u6700\u7EC8\u7684\u5206\u6BB5\u5B57\u7B26\u4E32
    var currentText;
    var currentWidth;
    if (measureTextWidth(text, font) <= maxWidth) {
        return text;
    }
    // \u9996\u5148\u901A\u8FC7 step \u8BA1\u7B97\uFF0C\u627E\u51FA\u6700\u5927\u7684\u672A\u8D85\u51FA\u957F\u5EA6\u7684
    while (true) {
        // \u66F4\u65B0\u5B57\u7B26\u4E32
        currentText = leftText.substr(0, STEP);
        // \u8BA1\u7B97\u5BBD\u5EA6
        currentWidth = measureTextWidth(currentText, font);
        // \u8D85\u51FA\u5269\u4F59\u5BBD\u5EA6\uFF0C\u5219\u505C\u6B62
        if (currentWidth + DOT_WIDTH > leftWidth) {
            if (currentWidth > leftWidth) {
                break;
            }
        }
        r.push(currentText);
        // \u6CA1\u6709\u8D85\u51FA\uFF0C\u5219\u8BA1\u7B97\u5269\u4F59\u5BBD\u5EA6
        leftWidth -= currentWidth;
        leftText = leftText.substr(STEP);
        // \u5B57\u7B26\u4E32\u6574\u4F53\u6CA1\u6709\u8D85\u51FA
        if (!leftText) {
            return r.join('');
        }
    }
    // \u6700\u4E0B\u7684\u6700\u540E\u4E00\u4E2A STEP\uFF0C\u4F7F\u7528 1 \u9012\u589E\uFF08\u7528\u4E8C\u5206\u6548\u679C\u66F4\u9AD8\uFF09
    while (true) {
        // \u66F4\u65B0\u5B57\u7B26\u4E32
        currentText = leftText.substr(0, 1);
        // \u8BA1\u7B97\u5BBD\u5EA6
        currentWidth = measureTextWidth(currentText, font);
        // \u8D85\u51FA\u5269\u4F59\u5BBD\u5EA6\uFF0C\u5219\u505C\u6B62
        if (currentWidth + DOT_WIDTH > leftWidth) {
            break;
        }
        r.push(currentText);
        // \u6CA1\u6709\u8D85\u51FA\uFF0C\u5219\u8BA1\u7B97\u5269\u4F59\u5BBD\u5EA6
        leftWidth -= currentWidth;
        leftText = leftText.substr(1);
        if (!leftText) {
            return r.join('');
        }
    }
    return "".concat(r.join(''), "...");
};
//# sourceMappingURL=text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js




/**
 * @ignore
 * \u5C06 label \u9650\u5236\u5728 Plot \u8303\u56F4\u5185\uFF0C\u5C06\u8D85\u51FA Plot \u8303\u56F4\u7684 label \u53EF\u9009\u62E9\u8FDB\u884C\u9690\u85CF\u6216\u8005\u79FB\u52A8\u4F4D\u7F6E
 * @param labels
 * @param cfg
 */
function limitInPlot(items, labels, shapes, region, cfg) {
    if (labels.length <= 0) {
        return;
    }
    var direction = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ['top', 'right', 'bottom', 'left'];
    var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || 'translate';
    var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
    var coordinate = labels[0].get('coordinate');
    if (!coordinate) {
        return;
    }
    var _a = getCoordinateBBox(coordinate, margin), regionMinX = _a.minX, regionMinY = _a.minY, regionMaxX = _a.maxX, regionMaxY = _a.maxY;
    (0,esm/* each */.S6)(labels, function (label) {
        var _a = label.getCanvasBBox(), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var finalX = x;
        var finalY = y;
        if (direction.indexOf('left') >= 0 && (minX < regionMinX || maxX < regionMinX)) {
            // \u8D85\u51FA\u5DE6\u4FA7
            finalX = regionMinX;
        }
        if (direction.indexOf('top') >= 0 && (minY < regionMinY || maxY < regionMinY)) {
            // \u8D85\u51FA\u9876\u90E8
            finalY = regionMinY;
        }
        if (direction.indexOf('right') >= 0) {
            if (minX > regionMaxX) {
                // \u6574\u4F53\u8D85\u51FA\u53F3\u4FA7
                finalX = regionMaxX - width;
            }
            else if (maxX > regionMaxX) {
                // \u8D85\u51FA\u53F3\u4FA7
                finalX = finalX - (maxX - regionMaxX);
            }
        }
        if (direction.indexOf('bottom') >= 0) {
            if (minY > regionMaxY) {
                // \u6574\u4F53\u8D85\u51FA\u5E95\u90E8
                finalY = regionMaxY - height;
            }
            else if (maxY > regionMaxY) {
                // \u8D85\u51FA\u5E95\u90E8
                finalY = finalY - (maxY - regionMaxY);
            }
        }
        if (finalX !== x || finalY !== y) {
            var translateX_1 = finalX - x;
            if (action === 'translate') {
                translate(label, translateX_1, finalY - y);
            }
            else if (action === 'ellipsis') {
                var textShapes = label.findAll(function (shape) { return shape.get('type') === 'text'; });
                textShapes.forEach(function (textShape) {
                    var style = (0,esm/* pick */.ei)(textShape.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);
                    var textBox = textShape.getCanvasBBox();
                    var text = getEllipsisText(textShape.attr('text'), textBox.width - Math.abs(translateX_1), style);
                    textShape.attr('text', text);
                });
            }
            else {
                label.hide();
            }
        }
    });
}
//# sourceMappingURL=limit-in-plot.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/fade.js

/**
 * @ignore
 * \u5355\u4E2A shape \u52A8\u753B
 * \u6E10\u73B0\u52A8\u753B
 * @param shape \u6267\u884C\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function fadeIn(shape, animateCfg, cfg) {
    var endState = {
        fillOpacity: (0,esm/* isNil */.UM)(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity'),
        strokeOpacity: (0,esm/* isNil */.UM)(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity'),
        opacity: (0,esm/* isNil */.UM)(shape.attr('opacity')) ? 1 : shape.attr('opacity'),
    };
    shape.attr({
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0,
    });
    shape.animate(endState, animateCfg);
}
/**
 * @ignore
 * \u5355\u4E2A shape \u52A8\u753B
 * \u6E10\u9690\u52A8\u753B
 * @param shape \u6267\u884C\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function fadeOut(shape, animateCfg, cfg) {
    var endState = {
        fillOpacity: 0,
        strokeOpacity: 0,
        opacity: 0,
    };
    var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
    shape.animate(endState, duration, easing, function () {
        shape.remove(true);
    }, delay);
}
//# sourceMappingURL=fade.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/util.js


/**
 * @ignore
 * \u5BF9\u56FE\u5F62\u5143\u7D20\u8FDB\u884C\u77E9\u9635\u53D8\u6362\uFF0C\u540C\u65F6\u8FD4\u56DE\u53D8\u6362\u524D\u7684\u56FE\u5F62\u77E9\u9635
 * @param shape \u8FDB\u884C\u77E9\u9635\u53D8\u6362\u7684\u56FE\u5F62
 * @param vector \u77E9\u9635\u53D8\u6362\u7684\u4E2D\u5FC3\u70B9
 * @param direct \u77E9\u9635\u53D8\u6362\u7684\u7C7B\u578B
 */
function transformShape(shape, vector, direct) {
    var scaledMatrix;
    var _a = (0,tslib_es6/* __read */.CR)(vector, 2), x = _a[0], y = _a[1];
    shape.applyToMatrix([x, y, 1]);
    if (direct === 'x') {
        shape.setMatrix(ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 0.01, 1],
            ['t', x, y],
        ]));
        scaledMatrix = ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 100, 1],
            ['t', x, y],
        ]);
    }
    else if (direct === 'y') {
        shape.setMatrix(ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 1, 0.01],
            ['t', x, y],
        ]));
        scaledMatrix = ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 1, 100],
            ['t', x, y],
        ]);
    }
    else if (direct === 'xy') {
        shape.setMatrix(ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 0.01, 0.01],
            ['t', x, y],
        ]));
        scaledMatrix = ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 100, 100],
            ['t', x, y],
        ]);
    }
    return scaledMatrix;
}
/**
 * \u5BF9\u56FE\u5F62\u5143\u7D20\u8FDB\u884C\u526A\u5207\u52A8\u753B
 * @param element \u8FDB\u884C\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param coordinate \u5F53\u524D\u5750\u6807\u7CFB
 * @param yMinPoint y \u8F74\u7684\u6700\u5C0F\u503C\u5BF9\u5E94\u7684\u56FE\u5F62\u5750\u6807\u70B9
 * @param type \u526A\u5207\u52A8\u753B\u7684\u7C7B\u578B
 */
function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var x;
    var y;
    if (type === 'y') {
        x = start.x + width / 2;
        y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
    }
    else if (type === 'x') {
        x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
        y = start.y + height / 2;
    }
    else if (type === 'xy') {
        if (coordinate.isPolar) {
            x = coordinate.getCenter().x;
            y = coordinate.getCenter().y;
        }
        else {
            x = (start.x + end.x) / 2;
            y = (start.y + end.y) / 2;
        }
    }
    var endMatrix = transformShape(element, [x, y], type);
    element.animate({
        matrix: endMatrix,
    }, animateCfg);
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/grow-in.js

/**
 * @ignore
 * \u5165\u573A\u52A8\u753B
 * x \u65B9\u5411\u7684\u751F\u957F
 * @param element \u6267\u884C\u52A8\u753B\u7684\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function growInX(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'x');
}
/**
 * @ignore
 * \u5165\u573A\u52A8\u753B
 * y \u8F74\u65B9\u5411\u4E0A\u7684\u751F\u957F
 * @param element \u6267\u884C\u52A8\u753B\u7684\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function growInY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'y');
}
/**
 * @ignore
 * \u5165\u573A
 * \u4E2D\u5FC3\u70B9\u7684\u5411\u56DB\u5468\u7684\u751F\u957F\u52A8\u753B
 * @param element \u6267\u884C\u52A8\u753B\u7684\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function growInXY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'xy');
}
//# sourceMappingURL=grow-in.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/path-in.js
/**
 * @ignore
 * \u5165\u573A\u52A8\u753B
 * path \u7684\u5165\u573A\u52A8\u753B
 * @param element \u6267\u884C\u52A8\u753B\u7684\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function pathIn(element, animateCfg, cfg) {
    // @ts-ignore
    var length = element.getTotalLength();
    // \u8BBE\u7F6E\u865A\u7EBF\u6837\u5F0F
    element.attr('lineDash', [length]);
    element.animate(function (ratio) {
        return {
            // \u5BF9\u865A\u7EBF\u504F\u79FB\u91CF\u505A\u52A8\u753B
            lineDashOffset: (1 - ratio) * length,
        };
    }, animateCfg);
}
//# sourceMappingURL=path-in.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/position-update.js
/**
 * @ignore
 * \u5750\u6807\u79FB\u52A8\u52A8\u753B
 * @param shape \u56FE\u5F62
 * @param animateCfg
 * @param cfg
 */
function positionUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs;
    // @ts-ignore
    var x = toAttrs.x;
    // @ts-ignore
    var y = toAttrs.y;
    // @ts-ignore
    delete toAttrs.x;
    // @ts-ignore
    delete toAttrs.y;
    shape.attr(toAttrs);
    shape.animate({
        x: x,
        y: y,
    }, animateCfg);
}
//# sourceMappingURL=position-update.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/scale-in.js

/**
 * @ignore
 * \u6CBF\u7740 x \u65B9\u5411\u653E\u5927\u7684\u52A8\u753B
 * @param shape
 * @param animateCfg
 * @param shapeModel
 */
function scaleInX(shape, animateCfg, cfg) {
    var box = shape.getBBox();
    var mappingData = shape.get('origin').mappingData;
    var points = mappingData.points;
    // x \u6570\u503C\u5982\u679C\u4E3A\u8D1F\u503C\uFF0C\u90A3\u4E48\u5E94\u8BE5\u4ECE\u53F3\u5F80\u5DE6\u751F\u957F
    var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;
    var y = (box.minY + box.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext/* transform */.vs(shape.getMatrix(), [
        ['t', -x, -y],
        ['s', 0.01, 1],
        ['t', x, y],
    ]);
    shape.setMatrix(matrix);
    shape.animate({
        matrix: ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 100, 1],
            ['t', x, y],
        ]),
    }, animateCfg);
}
/**
 * @ignore
 * \u6CBF\u7740 y \u65B9\u5411\u653E\u5927\u7684\u52A8\u753B
 * @param shape
 * @param animateCfg
 * @param shapeModel
 */
function scaleInY(shape, animateCfg, cfg) {
    var box = shape.getBBox();
    var mappingData = shape.get('origin').mappingData;
    var x = (box.minX + box.maxX) / 2;
    var points = mappingData.points;
    // \u6570\u503C\u5982\u679C\u4E3A\u8D1F\u503C\uFF0C\u90A3\u4E48\u5E94\u8BE5\u4ECE\u4E0A\u5F80\u4E0B\u751F\u957F\uFF0C\u901A\u8FC7 shape \u7684\u5173\u952E\u70B9\u8FDB\u884C\u5224\u65AD
    var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext/* transform */.vs(shape.getMatrix(), [
        ['t', -x, -y],
        ['s', 1, 0.01],
        ['t', x, y],
    ]);
    shape.setMatrix(matrix);
    shape.animate({
        matrix: ext/* transform */.vs(shape.getMatrix(), [
            ['t', -x, -y],
            ['s', 1, 100],
            ['t', x, y],
        ]),
    }, animateCfg);
}
//# sourceMappingURL=scale-in.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/sector-path-update.js




function sector_path_update_getAngle(startPoint, arcPath) {
    var _a;
    var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (!(0,esm/* isNumberEqual */.vQ)(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
        startAngle += Math.PI * 2;
    }
    if (!(0,esm/* isNumberEqual */.vQ)(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
        endAngle += Math.PI * 2;
    }
    if (arcPath[5] === 0) {
        // \u9006\u65F6\u9488\uFF0C\u9700\u8981\u5C06 startAngle \u548C endAngle \u8F6C\u7F6E\uFF0C\u56E0\u4E3A G2 \u6781\u5750\u6807\u7CFB\u4E3A\u987A\u65F6\u9488\u65B9\u5411
        _a = (0,tslib_es6/* __read */.CR)([endAngle, startAngle], 2), startAngle = _a[0], endAngle = _a[1];
    }
    if ((0,esm/* isNumberEqual */.vQ)(startAngle, Math.PI * 1.5)) {
        startAngle = Math.PI * -0.5;
    }
    // \u5F53 startAngle, endAngle \u63A5\u8FD1\u76F8\u7B49\u65F6\uFF0C\u4E0D\u8FDB\u884C endAngle = Math.PI * 1.5 \u9632\u6B62\u53D8\u5316\u4ECE\u6574\u4E2A\u5706\u5F00\u59CB
    if ((0,esm/* isNumberEqual */.vQ)(endAngle, Math.PI * -0.5) && !(0,esm/* isNumberEqual */.vQ)(startAngle, endAngle)) {
        endAngle = Math.PI * 1.5;
    }
    return {
        startAngle: startAngle,
        endAngle: endAngle,
    };
}
function getArcStartPoint(path) {
    var startPoint;
    if (path[0] === 'M' || path[0] === 'L') {
        startPoint = [path[1], path[2]];
    }
    else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {
        startPoint = [path[path.length - 2], path[path.length - 1]];
    }
    return startPoint;
}
/**
 * path \u5B58\u5728\u4EE5\u4E0B\u60C5\u51B5
 * 1. \u997C\u56FE\u4E0D\u4E3A\u6574\u5706\u7684 path\uFF0C\u547D\u4EE4\u4E3A M, L, A, L, Z
 * 2. \u997C\u56FE\u4E3A\u6574\u5706\u7684 path\uFF0C\u547D\u4EE4\u4E3A M, M, A, A, M, Z
 * 3. \u73AF\u56FE\u4E0D\u4E3A\u6574\u5706\u7684 path\uFF0C\u547D\u4EE4\u4E3A M, A, L, A, L, Z
 * 4. \u73AF\u56FE\u4E3A\u6574\u5706\u7684 path\uFF0C\u547D\u4EE4\u4E3A M, A, A, M, A, A, M, Z
 * 5. radial-line, \u4E0D\u4E3A\u6574\u5706\u65F6\u7684 path, \u547D\u4EE4\u4E3A M, A, A, Z
 * 6. radial-line, \u4E3A\u6574\u5706\u65F6\u7684 path\uFF0C\u547D\u4EE4\u4E3A M, A, A, A, A, Z
 * @param path theta \u5750\u6807\u7CFB\u4E0B\u5706\u5F27\u7684 path \u547D\u4EE4
 */
function getArcInfo(path) {
    var _a;
    var startAngle;
    var endAngle;
    var arcPaths = path.filter(function (command) {
        return command[0] === 'A' || command[0] === 'a';
    });
    if (arcPaths.length === 0) {
        return {
            startAngle: 0,
            endAngle: 0,
            radius: 0,
            innerRadius: 0,
        };
    }
    var firstArcPathCommand = arcPaths[0];
    var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
    var firstIndex = path.indexOf(firstArcPathCommand);
    var lastIndex = path.indexOf(lastArcPathCommand);
    var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
    var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
    var _b = sector_path_update_getAngle(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
    var _c = sector_path_update_getAngle(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
    if ((0,esm/* isNumberEqual */.vQ)(firstStartAngle, lastStartAngle) && (0,esm/* isNumberEqual */.vQ)(firstEndAngle, lastEndAngle)) {
        startAngle = firstStartAngle;
        endAngle = firstEndAngle;
    }
    else {
        startAngle = Math.min(firstStartAngle, lastStartAngle);
        endAngle = Math.max(firstEndAngle, lastEndAngle);
    }
    var radius = firstArcPathCommand[1];
    var innerRadius = arcPaths[arcPaths.length - 1][1];
    if (radius < innerRadius) {
        _a = (0,tslib_es6/* __read */.CR)([innerRadius, radius], 2), radius = _a[0], innerRadius = _a[1];
    }
    else if (radius === innerRadius) {
        innerRadius = 0;
    }
    return {
        startAngle: startAngle,
        endAngle: endAngle,
        radius: radius,
        innerRadius: innerRadius,
    };
}
/**
 * @ignore
 * \u997C\u56FE\u66F4\u65B0\u52A8\u753B
 * @param shape \u6587\u672C\u56FE\u5F62
 * @param animateCfg
 * @param cfg
 */
function sectorPathUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs, coordinate = cfg.coordinate;
    var path = toAttrs.path || [];
    var pathCommands = path.map(function (command) { return command[0]; });
    if (path.length < 1)
        return;
    var _a = getArcInfo(path), curStartAngle = _a.startAngle, curEndAngle = _a.endAngle, radius = _a.radius, innerRadius = _a.innerRadius;
    var _b = getArcInfo(shape.attr('path')), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
    var center = coordinate.getCenter();
    var diffStartAngle = curStartAngle - preStartAngle;
    var diffEndAngle = curEndAngle - preEndAngle;
    // \u6CA1\u6709 diff \u65F6\u76F4\u63A5\u8FD4\u56DE\u6700\u7EC8 attrs\uFF0C\u4E0D\u9700\u8981\u989D\u5916\u52A8\u753B
    if (diffStartAngle === 0 && diffEndAngle === 0) {
        shape.attr('path', path);
        return;
    }
    shape.animate(function (ratio) {
        var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
        var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, toAttrs), { path: 
            // hack, \u517C\u5BB9 /examples/bar/basic/demo/radial-line.ts \u52A8\u753B
            (0,esm/* isEqual */.Xy)(pathCommands, ['M', 'A', 'A', 'Z'])
                ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle)
                : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
    }, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, animateCfg), { callback: function () {
            // \u5C06 path \u4FDD\u6301\u539F\u59CB\u6001\uFF0C\u5426\u5219\u4F1A\u5F71\u54CD setState() \u7684\u52A8\u753B
            shape.attr('path', path);
            (0,esm/* isFunction */.mf)(animateCfg.callback) && animateCfg.callback();
        } }));
}
//# sourceMappingURL=sector-path-update.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/wave-in.js



/**
 * @ignore
 * \u6574\u4F53\u52A8\u753B
 * \u5212\u5165\u5165\u573A\u52A8\u753B\u6548\u679C
 * @todo \u653E\u4E24\u5F20\u76F4\u89D2\u5750\u6807\u7CFB\u548C\u6781\u5750\u6807\u7CFB\u7684\u56FE
 * @param element \u53C2\u4E0E\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function waveIn(element, animateCfg, cfg) {
    var _a = getCoordinateClipCfg(cfg.coordinate, 20), type = _a.type, startState = _a.startState, endState = _a.endState; // \u6839\u636E\u5750\u6807\u7CFB\u7C7B\u578B\u83B7\u53D6\u6574\u4F53\u7684\u526A\u5207\u533A\u57DF\u914D\u7F6E\u4FE1\u606F
    var clipShape = element.setClip({
        type: type,
        attrs: startState,
    }); // \u4E3A shape \u8BBE\u7F6E\u526A\u5207\u533A\u57DF
    // \u66F4\u65B0 \u52A8\u753B \u83B7\u53D6\u4E86 toAttrs \u9700\u8981\u91CD\u65B0\u66F4\u65B0\u4E0A\u53BB
    if (cfg.toAttrs) {
        element.attr(cfg.toAttrs);
    }
    // \u5BF9\u526A\u5207\u56FE\u5F62\u505A\u52A8\u753B
    clipShape.animate(endState, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, animateCfg), { callback: function () {
            if (element && !element.get('destroyed')) {
                element.set('clipShape', null);
            }
            clipShape.remove(true); // \u52A8\u753B\u7ED3\u675F\u9700\u8981\u5C06\u526A\u5207\u56FE\u5F62\u9500\u6BC1
            (0,esm/* isFunction */.mf)(animateCfg.callback) && animateCfg.callback();
        } }));
}
//# sourceMappingURL=wave-in.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/animate/animation/zoom.js



function doShapeZoom(shape, animateCfg, type) {
    if (shape.isGroup()) {
        (0,esm/* each */.S6)(shape.getChildren(), function (child) {
            doShapeZoom(child, animateCfg, type);
        });
    }
    else {
        var bbox = shape.getBBox();
        var x = (bbox.minX + bbox.maxX) / 2;
        var y = (bbox.minY + bbox.maxY) / 2;
        shape.applyToMatrix([x, y, 1]);
        if (type === 'zoomIn') {
            // \u653E\u5927
            var matrix = ext/* transform */.vs(shape.getMatrix(), [
                ['t', -x, -y],
                ['s', 0.01, 0.01],
                ['t', x, y],
            ]);
            shape.setMatrix(matrix);
            shape.animate({
                matrix: ext/* transform */.vs(shape.getMatrix(), [
                    ['t', -x, -y],
                    ['s', 100, 100],
                    ['t', x, y],
                ]),
            }, animateCfg);
        }
        else {
            shape.animate({
                matrix: ext/* transform */.vs(shape.getMatrix(), [
                    ['t', -x, -y],
                    ['s', 0.01, 0.01],
                    ['t', x, y],
                ]),
            }, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, animateCfg), { callback: function () {
                    shape.remove(true);
                    (0,esm/* isFunction */.mf)(animateCfg.callback) && animateCfg.callback();
                } }));
        }
    }
}
/**
 * @ignore
 * \u5355\u4E2A shape \u52A8\u753B
 * shape \u4EE5\u81EA\u8EAB\u4E2D\u5FC3\u70B9\u9010\u6E10\u653E\u5927\u7684\u8FDB\u5165\u52A8\u753B
 * @param shape \u53C2\u4E0E\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function zoomIn(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, 'zoomIn');
}
/**
 * @ignore
 * \u5355\u4E2A shape \u52A8\u753B
 * \u6D88\u5931\u52A8\u753B\uFF0Cshape \u4EE5\u81EA\u8EAB\u4E3A\u4E2D\u5FC3\u70B9\u7684\u9010\u6E10\u7F29\u5C0F
 * @param shape \u53C2\u4E0E\u52A8\u753B\u7684\u56FE\u5F62\u5143\u7D20
 * @param animateCfg \u52A8\u753B\u914D\u7F6E
 * @param cfg \u989D\u5916\u4FE1\u606F
 */
function zoomOut(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, 'zoomOut');
}
//# sourceMappingURL=zoom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/facet.js

/**
 * @ignore
 * \u83B7\u53D6 facet title \u7684\u6700\u4F73\u9ED8\u8BA4\u914D\u7F6E\uFF0C\u9632\u6B62
 */
function getFactTitleConfig(direction) {
    if ([constant_DIRECTION.TOP, constant_DIRECTION.BOTTOM].includes(direction)) {
        return {
            offsetX: 0,
            offsetY: direction === constant_DIRECTION.TOP ? -8 : 8,
            style: {
                textAlign: 'center',
                textBaseline: direction === constant_DIRECTION.TOP ? 'bottom' : 'top',
            },
        };
    }
    if ([constant_DIRECTION.LEFT, constant_DIRECTION.RIGHT].includes(direction)) {
        return {
            offsetX: direction === constant_DIRECTION.LEFT ? -8 : 8,
            offsetY: 0,
            style: {
                textAlign: direction === constant_DIRECTION.LEFT ? 'right' : 'left',
                textBaseline: 'middle',
                rotate: Math.PI / 2, // \u6587\u672C\u9605\u8BFB\u4E60\u60EF\u4ECE\u4E0A\u5F80\u4E0B
            },
        };
    }
    return {};
}
/**
 * @ignore
 * \u6839\u636E\u89D2\u5EA6\uFF0C\u83B7\u53D6 \u25CB \u4E0A\u7684\u70B9
 * @param center
 * @param r
 * @param angle
 */
function getAnglePoint(center, r, angle) {
    return {
        x: center.x + r * Math.cos(angle),
        y: center.y + r * Math.sin(angle),
    };
}
//# sourceMappingURL=facet.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/circle.js





/**
 * @ignore
 * \u955C\u50CF\u5206\u9762
 */
var facet_circle_Circle = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'circle',
            showTitle: true,
            title: _super.prototype.getDefaultTitleCfg.call(this),
        });
    };
    Circle.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    /**
     * \u6839\u636E\u603B\u6570\u548C\u5F53\u524D\u7D22\u5F15\uFF0C\u8BA1\u7B97\u5206\u9762\u7684 region
     * @param count
     * @param index
     */
    Circle.prototype.getRegion = function (count, index) {
        var r = 1 / 2; // \u753B\u5E03\u534A\u5F84
        // \u753B\u5E03\u5706\u5FC3
        var center = { x: 0.5, y: 0.5 };
        // \u6BCF\u9694\u5206\u9762\u95F4\u9694\u7684\u5F27\u5EA6
        var avgAngle = (Math.PI * 2) / count;
        // \u5F53\u524D\u5206\u9762\u6240\u5728\u7684\u5F27\u5EA6
        var angle = (-1 * Math.PI) / 2 + avgAngle * index;
        // TODO \u6CA1\u770B\u61C2
        var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
        // \u5206\u9762\u7684\u4E2D\u5FC3\u70B9
        var middle = getAnglePoint(center, r - facetR, angle);
        var startAngle = (Math.PI * 5) / 4; // \u53F3\u4E0A\u89D2
        var endAngle = (Math.PI * 1) / 4; // \u5DE6\u4E0B\u89D2
        return {
            start: getAnglePoint(middle, facetR, startAngle),
            end: getAnglePoint(middle, facetR, endAngle),
        };
    };
    Circle.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    Circle.prototype.beforeEachView = function (view, facet) { };
    Circle.prototype.generateFacets = function (data) {
        var _this = this;
        var _a = this.cfg, fields = _a.fields, type = _a.type;
        var _b = (0,tslib_es6/* __read */.CR)(fields, 1), field = _b[0];
        if (!field) {
            throw new Error('No \`fields\` specified!');
        }
        var values = this.getFieldValues(data, field);
        var count = values.length;
        var rst = [];
        values.forEach(function (value, index) {
            var conditions = [{ field: field, value: value, values: values }];
            var facetData = (0,esm/* filter */.hX)(data, _this.getFacetDataFilter(conditions));
            var facet = {
                type: type,
                data: facetData,
                region: _this.getRegion(count, index),
                columnValue: value,
                columnField: field,
                columnIndex: index,
                columnValuesLength: count,
                rowValue: null,
                rowField: null,
                rowIndex: 0,
                rowValuesLength: 1,
            };
            rst.push(facet);
        });
        return rst;
    };
    Circle.prototype.getXAxisOption = function (x, axes, option, facet) {
        // \u4E0D\u505A\u4EFB\u4F55\u5904\u7406
        return option;
    };
    /**
     * \u8BBE\u7F6E y \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param y
     * @param axes
     * @param option
     * @param facet
     */
    Circle.prototype.getYAxisOption = function (y, axes, option, facet) {
        // \u4E0D\u505A\u4EFB\u4F55\u5904\u7406
        return option;
    };
    /**
     * facet title
     */
    Circle.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet) {
            var columnValue = facet.columnValue, view = facet.view;
            var formatter = (0,esm/* get */.U2)(_this.cfg.title, 'formatter');
            var config = (0,esm/* deepMix */.b$)({
                position: ['50%', '0%'],
                content: formatter ? formatter(columnValue) : columnValue,
            }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.title);
            view.annotation().text(config);
        });
    };
    return Circle;
}(Facet));
/* harmony default export */ var facet_circle = (facet_circle_Circle);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/list.js





/**
 * @ignore
 * \u955C\u50CF\u5206\u9762
 */
var List = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(List, _super);
    function List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    List.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'list',
            cols: null,
            showTitle: true,
            title: _super.prototype.getDefaultTitleCfg.call(this),
        });
    };
    List.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    List.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    List.prototype.beforeEachView = function (view, facet) { };
    List.prototype.generateFacets = function (data) {
        var _this = this;
        var fields = this.cfg.fields;
        var cols = this.cfg.cols;
        var _a = (0,tslib_es6/* __read */.CR)(fields, 1), columnField = _a[0];
        if (!columnField) {
            throw new Error('No \`fields\` specified!');
        }
        var colValues = this.getFieldValues(data, columnField);
        var count = colValues.length;
        cols = cols || count; // \u6BCF\u884C\u6709\u51E0\u5217\u6570\u636E
        // \u603B\u5171\u6709\u51E0\u884C
        var rows = this.getPageCount(count, cols);
        var rst = [];
        colValues.forEach(function (val, index) {
            // \u5F53\u524D index \u5728\u90A3\u4E2A\u884C\u5217
            var _a = _this.getRowCol(index, cols), row = _a.row, col = _a.col;
            var conditions = [{ field: columnField, value: val, values: colValues }];
            var facetData = (0,esm/* filter */.hX)(data, _this.getFacetDataFilter(conditions));
            var facet = {
                type: _this.cfg.type,
                data: facetData,
                region: _this.getRegion(rows, cols, col, row),
                columnValue: val,
                rowValue: val,
                columnField: columnField,
                rowField: null,
                columnIndex: col,
                rowIndex: row,
                columnValuesLength: cols,
                rowValuesLength: rows,
                total: count,
            };
            rst.push(facet);
        });
        return rst;
    };
    /**
     * \u8BBE\u7F6E x \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param x
     * @param axes
     * @param option
     * @param facet
     */
    List.prototype.getXAxisOption = function (x, axes, option, facet) {
        // \u5F53\u662F\u6700\u540E\u4E00\u884C\u6216\u8005\u4E0B\u9762\u6CA1\u6709 view \u65F6\u6587\u672C\u4E0D\u663E\u793A
        if (facet.rowIndex !== facet.rowValuesLength - 1 &&
            facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { label: null, title: null });
        }
        return option;
    };
    /**
     * \u8BBE\u7F6E y \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param y
     * @param axes
     * @param option
     * @param facet
     */
    List.prototype.getYAxisOption = function (y, axes, option, facet) {
        if (facet.columnIndex !== 0) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        return option;
    };
    /**
     * facet title
     */
    List.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet) {
            var columnValue = facet.columnValue, view = facet.view;
            var formatter = (0,esm/* get */.U2)(_this.cfg.title, 'formatter');
            var config = (0,esm/* deepMix */.b$)({
                position: ['50%', '0%'],
                content: formatter ? formatter(columnValue) : columnValue,
            }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.title);
            view.annotation().text(config);
        });
    };
    /**
     * \u8BA1\u7B97\u5206\u9875\u6570
     * @param total
     * @param pageSize
     */
    List.prototype.getPageCount = function (total, pageSize) {
        return Math.floor((total + pageSize - 1) / pageSize);
    };
    /**
     * \u7D22\u5F15\u503C\u5728\u54EA\u4E00\u9875
     * @param index
     * @param pageSize
     */
    List.prototype.getRowCol = function (index, pageSize) {
        var row = Math.floor(index / pageSize);
        var col = index % pageSize;
        return { row: row, col: col };
    };
    return List;
}(Facet));
/* harmony default export */ var list = (List);
//# sourceMappingURL=list.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/matrix.js





/**
 * @ignore
 * \u955C\u50CF\u5206\u9762
 */
var Matrix = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Matrix, _super);
    function Matrix() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Matrix.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'matrix',
            showTitle: false,
            columnTitle: (0,tslib_es6/* __assign */.pi)({}, _super.prototype.getDefaultTitleCfg.call(this)),
            rowTitle: (0,tslib_es6/* __assign */.pi)({}, _super.prototype.getDefaultTitleCfg.call(this)),
        });
    };
    Matrix.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    Matrix.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    Matrix.prototype.beforeEachView = function (view, facet) { };
    Matrix.prototype.generateFacets = function (data) {
        var _a = this.cfg, fields = _a.fields, type = _a.type;
        // \u77E9\u9635\u4E2D\u884C\u5217\u76F8\u7B49\uFF0C\u7B49\u4E8E\u6307\u5B9A\u7684\u5B57\u6BB5\u4E2A\u6570
        var rowValuesLength = fields.length;
        var columnValuesLength = rowValuesLength;
        var rst = [];
        for (var i = 0; i < columnValuesLength; i++) {
            var columnField = fields[i];
            for (var j = 0; j < rowValuesLength; j++) {
                var rowField = fields[j];
                var facet = {
                    type: type,
                    data: data,
                    region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
                    columnValue: columnField,
                    rowValue: rowField,
                    columnField: columnField,
                    rowField: rowField,
                    columnIndex: i,
                    rowIndex: j,
                    columnValuesLength: columnValuesLength,
                    rowValuesLength: rowValuesLength,
                };
                rst.push(facet);
            }
        }
        return rst;
    };
    /**
     * \u8BBE\u7F6E x \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param x
     * @param axes
     * @param option
     * @param facet
     */
    Matrix.prototype.getXAxisOption = function (x, axes, option, facet) {
        // \u6700\u540E\u4E00\u884C\u663E\u793A
        if (facet.rowIndex !== facet.rowValuesLength - 1) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { label: null, title: null });
        }
        return option;
    };
    /**
     * \u8BBE\u7F6E y \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param y
     * @param axes
     * @param option
     * @param facet
     */
    Matrix.prototype.getYAxisOption = function (y, axes, option, facet) {
        // \u7B2C\u4E00\u5217\u663E\u793A
        if (facet.columnIndex !== 0) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        return option;
    };
    /**
     * facet title
     */
    Matrix.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet, facetIndex) {
            var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, rowValuesLength = facet.rowValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
            // top
            if (rowIndex === 0) {
                var formatter = (0,esm/* get */.U2)(_this.cfg.columnTitle, 'formatter');
                var config = (0,esm/* deepMix */.b$)({
                    position: ['50%', '0%'],
                    content: formatter ? formatter(columnValue) : columnValue,
                }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.columnTitle);
                view.annotation().text(config);
            }
            // right
            if (columnIndex === columnValuesLength - 1) {
                var formatter = (0,esm/* get */.U2)(_this.cfg.rowTitle, 'formatter');
                var config = (0,esm/* deepMix */.b$)({
                    position: ['100%', '50%'],
                    content: formatter ? formatter(rowValue) : rowValue,
                }, getFactTitleConfig(constant_DIRECTION.RIGHT), _this.cfg.rowTitle);
                view.annotation().text(config);
            }
        });
    };
    return Matrix;
}(Facet));
/* harmony default export */ var matrix = (Matrix);
//# sourceMappingURL=matrix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/mirror.js





/**
 * @ignore
 * \u955C\u50CF\u5206\u9762
 */
var Mirror = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Mirror, _super);
    function Mirror() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Mirror.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'mirror',
            showTitle: true,
            title: _super.prototype.getDefaultTitleCfg.call(this),
            transpose: false,
        });
    };
    Mirror.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    Mirror.prototype.beforeEachView = function (view, facet) {
        // \u505A\u4E00\u4E0B\u5750\u6807\u7CFB\u8F6C\u5316
        if (this.cfg.transpose) {
            if (facet.columnIndex % 2 === 0) {
                view.coordinate().transpose().reflect('x');
            }
            else {
                view.coordinate().transpose();
            }
        }
        else {
            if (facet.rowIndex % 2 !== 0) {
                view.coordinate().reflect('y');
            }
        }
    };
    Mirror.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    Mirror.prototype.generateFacets = function (data) {
        var _this = this;
        var _a = (0,tslib_es6/* __read */.CR)(this.cfg.fields, 1), f = _a[0];
        var rst = [];
        var columnValuesLength = 1;
        var rowValuesLength = 1;
        var columnValues = [''];
        var rowValues = [''];
        var columnField;
        var rowField;
        if (this.cfg.transpose) {
            columnField = f;
            columnValues = this.getFieldValues(data, columnField).slice(0, 2); // \u955C\u50CF\u6700\u591A\u4E24\u4E2A
            columnValuesLength = columnValues.length;
        }
        else {
            rowField = f;
            rowValues = this.getFieldValues(data, rowField).slice(0, 2); // \u955C\u50CF\u6700\u591A\u4E24\u4E2A
            rowValuesLength = rowValues.length;
        }
        // \u83B7\u53D6\u6BCF\u4E2A\u7EF4\u5EA6\u5BF9\u5E94\u7684\u6570\u636E\u914D\u7F6E\u7247\u6BB5
        columnValues.forEach(function (xVal, xIndex) {
            rowValues.forEach(function (yVal, yIndex) {
                var conditions = [
                    { field: columnField, value: xVal, values: columnValues },
                    { field: rowField, value: yVal, values: rowValues },
                ];
                var facetData = (0,esm/* filter */.hX)(data, _this.getFacetDataFilter(conditions));
                var facet = {
                    type: _this.cfg.type,
                    data: facetData,
                    region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
                    columnValue: xVal,
                    rowValue: yVal,
                    columnField: columnField,
                    rowField: rowField,
                    columnIndex: xIndex,
                    rowIndex: yIndex,
                    columnValuesLength: columnValuesLength,
                    rowValuesLength: rowValuesLength,
                };
                rst.push(facet);
            });
        });
        return rst;
    };
    /**
     * \u8BBE\u7F6E x \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param x
     * @param axes
     * @param option
     * @param facet
     */
    Mirror.prototype.getXAxisOption = function (x, axes, option, facet) {
        // \u975E\u6700\u540E\u4E00\u884C
        // \u5F53\u662F\u6700\u540E\u4E00\u884C\u6216\u8005\u4E0B\u9762\u6CA1\u6709 view \u65F6\u6587\u672C\u4E0D\u663E\u793A
        if (facet.columnIndex === 1 || facet.rowIndex === 1) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { label: null, title: null });
        }
        return option;
    };
    /**
     * \u8BBE\u7F6E y \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param y
     * @param axes
     * @param option
     * @param facet
     */
    Mirror.prototype.getYAxisOption = function (y, axes, option, facet) {
        // do nothing
        return option;
    };
    Mirror.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet, facetIndex) {
            var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
            var formatter = (0,esm/* get */.U2)(_this.cfg.title, 'formatter');
            if (_this.cfg.transpose) {
                var config = (0,esm/* deepMix */.b$)({
                    position: ['50%', '0%'],
                    content: formatter ? formatter(columnValue) : columnValue,
                }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.title);
                view.annotation().text(config);
            }
            else {
                var config = (0,esm/* deepMix */.b$)({
                    position: ['100%', '50%'],
                    content: formatter ? formatter(rowValue) : rowValue,
                }, getFactTitleConfig(constant_DIRECTION.RIGHT), _this.cfg.title);
                view.annotation().text(config);
            }
        });
    };
    return Mirror;
}(Facet));
/* harmony default export */ var mirror = (Mirror);
//# sourceMappingURL=mirror.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/rect.js





/**
 * @ignore
 * \u77E9\u9635\u5206\u9762
 */
var facet_rect_Rect = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Rect, _super);
    function Rect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    Rect.prototype.beforeEachView = function (view, facet) {
        // do nothing
    };
    Rect.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'rect',
            columnTitle: (0,tslib_es6/* __assign */.pi)({}, _super.prototype.getDefaultTitleCfg.call(this)),
            rowTitle: (0,tslib_es6/* __assign */.pi)({}, _super.prototype.getDefaultTitleCfg.call(this)),
        });
    };
    Rect.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    /**
     * \u751F\u6210\u77E9\u9635\u5206\u9762\u7684\u5206\u9762\u6570\u636E
     * @param data
     */
    Rect.prototype.generateFacets = function (data) {
        var _this = this;
        var _a = (0,tslib_es6/* __read */.CR)(this.cfg.fields, 2), columnField = _a[0], rowField = _a[1];
        var rst = [];
        var columnValuesLength = 1;
        var rowValuesLength = 1;
        var columnValues = [''];
        var rowValues = [''];
        if (columnField) {
            columnValues = this.getFieldValues(data, columnField);
            columnValuesLength = columnValues.length;
        }
        if (rowField) {
            rowValues = this.getFieldValues(data, rowField);
            rowValuesLength = rowValues.length;
        }
        // \u83B7\u53D6\u6BCF\u4E2A\u7EF4\u5EA6\u5BF9\u5E94\u7684\u6570\u636E\u914D\u7F6E\u7247\u6BB5
        columnValues.forEach(function (xVal, xIndex) {
            rowValues.forEach(function (yVal, yIndex) {
                var conditions = [
                    { field: columnField, value: xVal, values: columnValues },
                    { field: rowField, value: yVal, values: rowValues },
                ];
                var facetData = (0,esm/* filter */.hX)(data, _this.getFacetDataFilter(conditions));
                var facet = {
                    type: _this.cfg.type,
                    data: facetData,
                    region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
                    columnValue: xVal,
                    rowValue: yVal,
                    columnField: columnField,
                    rowField: rowField,
                    columnIndex: xIndex,
                    rowIndex: yIndex,
                    columnValuesLength: columnValuesLength,
                    rowValuesLength: rowValuesLength,
                };
                rst.push(facet);
            });
        });
        return rst;
    };
    Rect.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet, facetIndex) {
            var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
            // top
            if (rowIndex === 0) {
                var formatter = (0,esm/* get */.U2)(_this.cfg.columnTitle, 'formatter');
                var config = (0,esm/* deepMix */.b$)({
                    position: ['50%', '0%'],
                    content: formatter ? formatter(columnValue) : columnValue,
                }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.columnTitle);
                view.annotation().text(config);
            }
            // right
            if (columnIndex === columnValuesLength - 1) {
                var formatter = (0,esm/* get */.U2)(_this.cfg.rowTitle, 'formatter');
                var config = (0,esm/* deepMix */.b$)({
                    position: ['100%', '50%'],
                    content: formatter ? formatter(rowValue) : rowValue,
                }, getFactTitleConfig(constant_DIRECTION.RIGHT), _this.cfg.rowTitle);
                view.annotation().text(config);
            }
        });
    };
    /**
     * \u8BBE\u7F6E x \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param x
     * @param axes
     * @param option
     * @param facet
     */
    Rect.prototype.getXAxisOption = function (x, axes, option, facet) {
        // \u975E\u6700\u540E\u4E00\u884C
        if (facet.rowIndex !== facet.rowValuesLength - 1) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
            // \u4E0D\u662F\u4E2D\u95F4\u5217
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null });
        }
        return option;
    };
    /**
     * \u8BBE\u7F6E y \u5750\u6807\u8F74\u7684\u6587\u672C\u3001title \u662F\u5426\u663E\u793A
     * @param y
     * @param axes
     * @param option
     * @param facet
     */
    Rect.prototype.getYAxisOption = function (y, axes, option, facet) {
        if (facet.columnIndex !== 0) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null });
        }
        return option;
    };
    return Rect;
}(Facet));
/* harmony default export */ var facet_rect = (facet_rect_Rect);
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/facet/tree.js

/**
 * Create By Bruce Too
 * On 2020-02-10
 */




/**
 * @ignore
 * Tree Facet
 */
var Tree = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Tree, _super);
    function Tree() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.afterChartRender = function () {
            if (_this.facets && _this.cfg.line) {
                _this.container.clear();
                _this.drawLines(_this.facets);
            }
        };
        return _this;
    }
    Tree.prototype.afterEachView = function (view, facet) {
        this.processAxis(view, facet);
    };
    Tree.prototype.beforeEachView = function (view, facet) { };
    Tree.prototype.init = function () {
        _super.prototype.init.call(this);
        this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
    };
    Tree.prototype.getDefaultCfg = function () {
        return (0,esm/* deepMix */.b$)({}, _super.prototype.getDefaultCfg.call(this), {
            type: 'tree',
            line: {
                style: {
                    lineWidth: 1,
                    stroke: '#ddd',
                },
                smooth: false,
            },
            showTitle: true,
            title: _super.prototype.getDefaultTitleCfg.call(this),
        });
    };
    Tree.prototype.generateFacets = function (data) {
        var fields = this.cfg.fields;
        if (!fields.length) {
            throw new Error('Please specify for the fields for rootFacet!');
        }
        var rst = [];
        var rootFacet = {
            type: this.cfg.type,
            data: data,
            region: null,
            rowValuesLength: this.getRows(),
            columnValuesLength: 1,
            rowIndex: 0,
            columnIndex: 0,
            rowField: '',
            columnField: '',
            rowValue: '',
            columnValue: '',
        };
        rst.push(rootFacet);
        rootFacet.children = this.getChildFacets(data, 1, rst);
        this.setRegion(rst);
        return rst;
    };
    Tree.prototype.setRegion = function (facets) {
        var _this = this;
        this.forceColIndex(facets);
        facets.forEach(function (facet) {
            // @ts-ignore \u5141\u8BB8\u8C03\u6574
            facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
        });
    };
    Tree.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
        var xWidth = 1 / cols; // x\u8F74\u65B9\u5411\u7684\u6BCF\u4E2A\u5206\u9762\u7684\u504F\u79FB
        var yWidth = 1 / rows; // y\u8F74\u65B9\u5411\u7684\u6BCF\u4E2A\u5206\u9762\u7684\u504F\u79FB
        var start = {
            x: xWidth * xIndex,
            y: yWidth * yIndex,
        };
        var end = {
            x: start.x + xWidth,
            y: start.y + (yWidth * 2) / 3, // \u9884\u75591/3\u7684\u7A7A\u9699\uFF0C\u65B9\u4FBF\u6DFB\u52A0\u8FDE\u63A5\u7EBF
        };
        return {
            start: start,
            end: end,
        };
    };
    Tree.prototype.forceColIndex = function (facets) {
        var e_1, _a;
        var _this = this;
        var leafs = [];
        var index = 0;
        facets.forEach(function (facet) {
            if (_this.isLeaf(facet)) {
                leafs.push(facet);
                // @ts-ignore \u5141\u8BB8\u8C03\u6574
                facet.columnIndex = index;
                index++;
            }
        });
        leafs.forEach(function (facet) {
            // @ts-ignore
            facet.columnValuesLength = leafs.length;
        });
        var maxLevel = this.cfg.fields.length;
        for (var i = maxLevel - 1; i >= 0; i--) {
            var levelFacets = this.getFacetsByLevel(facets, i);
            try {
                // var yIndex = maxLevel - i;
                for (var levelFacets_1 = (e_1 = void 0, (0,tslib_es6/* __values */.XA)(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
                    var facet = levelFacets_1_1.value;
                    if (!this.isLeaf(facet)) {
                        facet.originColIndex = facet.columnIndex;
                        // @ts-ignore
                        facet.columnIndex = this.getRegionIndex(facet.children);
                        // @ts-ignore
                        facet.columnValuesLength = leafs.length;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (levelFacets_1_1 && !levelFacets_1_1.done && (_a = levelFacets_1.return)) _a.call(levelFacets_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    // get facet use level
    Tree.prototype.getFacetsByLevel = function (facets, level) {
        var rst = [];
        facets.forEach(function (facet) {
            if (facet.rowIndex === level) {
                rst.push(facet);
            }
        });
        return rst;
    };
    // if the facet has children , make it's column index in the middle of it's children
    Tree.prototype.getRegionIndex = function (children) {
        var first = children[0];
        var last = children[children.length - 1];
        return (last.columnIndex - first.columnIndex) / 2 + first.columnIndex;
    };
    // is  a leaf without children
    Tree.prototype.isLeaf = function (facet) {
        return !facet.children || !facet.children.length;
    };
    Tree.prototype.getRows = function () {
        return this.cfg.fields.length + 1;
    };
    // get child
    Tree.prototype.getChildFacets = function (data, level, arr) {
        var _this = this;
        // [ 'grade', 'class' ]
        var fields = this.cfg.fields;
        var length = fields.length;
        if (length < level) {
            return;
        }
        var rst = [];
        // get fist level except root node
        var field = fields[level - 1];
        // get field value
        var values = this.getFieldValues(data, field);
        values.forEach(function (value, index) {
            var conditions = [{ field: field, value: value, values: values }];
            var subData = data.filter(_this.getFacetDataFilter(conditions));
            if (subData.length) {
                var facet = {
                    type: _this.cfg.type,
                    data: subData,
                    region: null,
                    columnValue: value,
                    rowValue: '',
                    columnField: field,
                    rowField: '',
                    columnIndex: index,
                    rowValuesLength: _this.getRows(),
                    columnValuesLength: 1,
                    rowIndex: level,
                    children: _this.getChildFacets(subData, level + 1, arr),
                };
                rst.push(facet);
                arr.push(facet);
            }
        });
        return rst;
    };
    Tree.prototype.render = function () {
        _super.prototype.render.call(this);
        if (this.cfg.showTitle) {
            this.renderTitle();
        }
    };
    Tree.prototype.renderTitle = function () {
        var _this = this;
        (0,esm/* each */.S6)(this.facets, function (facet) {
            var columnValue = facet.columnValue, view = facet.view;
            var formatter = (0,esm/* get */.U2)(_this.cfg.title, 'formatter');
            var config = (0,esm/* deepMix */.b$)({
                position: ['50%', '0%'],
                content: formatter ? formatter(columnValue) : columnValue,
            }, getFactTitleConfig(constant_DIRECTION.TOP), _this.cfg.title);
            view.annotation().text(config);
        });
    };
    Tree.prototype.drawLines = function (facets) {
        var _this = this;
        facets.forEach(function (facet) {
            if (!_this.isLeaf(facet)) {
                var children = facet.children;
                _this.addFacetLines(facet, children);
            }
        });
    };
    // add lines with it's children
    Tree.prototype.addFacetLines = function (facet, children) {
        var _this = this;
        var view = facet.view;
        var region = view.coordinateBBox;
        // top, right, bottom, left
        var start = {
            x: region.x + region.width / 2,
            y: region.y + region.height,
        };
        children.forEach(function (subFacet) {
            var subRegion = subFacet.view.coordinateBBox;
            var end = {
                x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
                y: subRegion.tr.y,
            };
            var middle1 = {
                x: start.x,
                y: start.y + (end.y - start.y) / 2,
            };
            var middle2 = {
                x: end.x,
                y: middle1.y,
            };
            _this.drawLine([start, middle1, middle2, end]);
        });
    };
    Tree.prototype.getPath = function (points) {
        var path = [];
        var smooth = this.cfg.line.smooth;
        if (smooth) {
            path.push(['M', points[0].x, points[0].y]);
            path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
        }
        else {
            points.forEach(function (point, index) {
                if (index === 0) {
                    path.push(['M', point.x, point.y]);
                }
                else {
                    path.push(['L', point.x, point.y]);
                }
            });
        }
        return path;
    };
    // draw line width points
    Tree.prototype.drawLine = function (points) {
        var path = this.getPath(points);
        var line = this.cfg.line.style;
        this.container.addShape('path', {
            attrs: (0,esm/* assign */.f0)({
                // @ts-ignore
                path: path,
            }, line),
        });
    };
    Tree.prototype.getXAxisOption = function (x, axes, option, facet) {
        if (facet.rowIndex !== facet.rowValuesLength - 1) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        return option;
    };
    Tree.prototype.getYAxisOption = function (y, axes, option, facet) {
        if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, option), { title: null, label: null });
        }
        return option;
    };
    return Tree;
}(Facet));
/* harmony default export */ var tree = (Tree);
//# sourceMappingURL=tree.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/stat.js


/**
 * \u83B7\u5F97\u4E2D\u4F4D\u6570
 * @param array
 */
function getMedian(array) {
    var arr = (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(array), false);
    // \u5148\u6392\u5E8F
    arr.sort(function (a, b) {
        return a - b;
    });
    var len = arr.length;
    // median
    // 0
    if (len === 0) {
        return 0;
    }
    // \u5947\u6570
    if (len % 2 === 1) {
        return arr[(len - 1) / 2];
    }
    // \u5076\u6570
    return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}
/**
 * \u83B7\u5F97\u5E73\u5747\u503C
 * @param array
 */
function getMean(array) {
    var sum = (0,esm/* reduce */.u4)(array, function (r, num) {
        return (r += isNaN(num) || !(0,esm/* isNumber */.hj)(num) ? 0 : num);
    }, 0);
    return array.length === 0 ? 0 : sum / array.length;
}
//# sourceMappingURL=stat.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/annotation.js

/**
 * parse the value position
 * @param val
 * @param scale
 */
function getNormalizedValue(val, scale) {
    if (!scale) {
        return null;
    }
    var scaled;
    switch (val) {
        case 'start':
            return 0;
        case 'center':
            return 0.5;
        case 'end':
            return 1;
        case 'median': {
            scaled = scale.isCategory ? getMedian(scale.values.map(function (_, idx) { return idx; })) : getMedian(scale.values);
            break;
        }
        case 'mean': {
            scaled = scale.isCategory ? (scale.values.length - 1) / 2 : getMean(scale.values);
            break;
        }
        case 'min':
            scaled = scale.isCategory ? 0 : scale[val];
            break;
        case 'max':
            scaled = scale.isCategory ? scale.values.length - 1 : scale[val];
            break;
        default:
            scaled = val;
            break;
    }
    return scale.scale(scaled);
}
//# sourceMappingURL=annotation.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/annotation.js









/** \u9700\u8981\u5728\u56FE\u5F62\u7ED8\u5236\u5B8C\u6210\u540E\u624D\u6E32\u67D3\u7684\u8F85\u52A9\u7EC4\u4EF6\u7C7B\u578B\u5217\u8868 */
var ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];
/**
 * Annotation controller, \u4E3B\u8981\u4F5C\u7528:
 * 1. \u521B\u5EFA Annotation: line\u3001text\u3001arc ...
 * 2. \u751F\u547D\u5468\u671F: init\u3001layout\u3001render\u3001clear\u3001destroy
 */
var Annotation = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Annotation, _super);
    function Annotation(view) {
        var _this = _super.call(this, view) || this;
        /* \u7EC4\u4EF6\u66F4\u65B0\u7684 cache\uFF0C\u7EC4\u4EF6\u914D\u7F6E object : \u7EC4\u4EF6 */
        _this.cache = new Map();
        _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
        _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
        _this.option = [];
        return _this;
    }
    Object.defineProperty(Annotation.prototype, "name", {
        get: function () {
            return 'annotation';
        },
        enumerable: false,
        configurable: true
    });
    Annotation.prototype.init = function () { };
    /**
     * \u56E0\u4E3A annotation \u9700\u8981\u4F9D\u8D56\u5750\u6807\u7CFB\u4FE1\u606F\uFF0C\u6240\u4EE5 render \u9636\u6BB5\u4E3A\u7A7A\u65B9\u6CD5\uFF0C\u5B9E\u9645\u7684\u521B\u5EFA\u903B\u8F91\u90FD\u5728 layout \u4E2D
     */
    Annotation.prototype.layout = function () {
        this.update();
    };
    // \u56E0\u4E3A Annotation \u4E0D\u53C2\u4E0E\u5E03\u5C40\uFF0C\u4F46\u662F\u6E32\u67D3\u7684\u4F4D\u7F6E\u4F9D\u8D56\u4E8E\u5750\u6807\u7CFB\uFF0C\u6240\u4EE5\u53EF\u4EE5\u5C06\u7ED8\u5236\u9636\u6BB5\u5EF6\u8FDF\u5230 layout() \u8FDB\u884C
    Annotation.prototype.render = function () { };
    /**
     * \u66F4\u65B0
     */
    Annotation.prototype.update = function () {
        var _this = this;
        // 1. \u5148\u5904\u7406\u9700\u8981\u5728\u56FE\u5F62\u6E32\u67D3\u4E4B\u540E\u7684\u8F85\u52A9\u7EC4\u4EF6 \u9700\u8981\u5728 Geometry \u5B8C\u6210\u4E4B\u540E\uFF0C\u62FF\u5230\u56FE\u5F62\u4FE1\u606F
        this.onAfterRender(function () {
            var updated = new Map();
            // \u5148\u770B\u662F\u5426\u6709 regionFilter/shape \u8981\u66F4\u65B0
            (0,esm/* each */.S6)(_this.option, function (option) {
                if ((0,esm/* includes */.q9)(ANNOTATIONS_AFTER_RENDER, option.type)) {
                    var co = _this.updateOrCreate(option);
                    // \u5B58\u50A8\u5DF2\u7ECF\u5904\u7406\u8FC7\u7684
                    if (co) {
                        updated.set(_this.getCacheKey(option), co);
                    }
                }
            });
            // \u5904\u7406\u5B8C\u6210\u4E4B\u540E\uFF0C\u66F4\u65B0 cache
            // \u5904\u7406\u5B8C\u6210\u4E4B\u540E\uFF0C\u9500\u6BC1\u5220\u9664\u7684
            _this.cache = _this.syncCache(updated);
        });
        // 2. \u5904\u7406\u975E regionFilter
        var updateCache = new Map();
        (0,esm/* each */.S6)(this.option, function (option) {
            if (!(0,esm/* includes */.q9)(ANNOTATIONS_AFTER_RENDER, option.type)) {
                var co = _this.updateOrCreate(option);
                // \u5B58\u50A8\u5DF2\u7ECF\u5904\u7406\u8FC7\u7684
                if (co) {
                    updateCache.set(_this.getCacheKey(option), co);
                }
            }
        });
        this.cache = this.syncCache(updateCache);
    };
    /**
     * \u6E05\u7A7A
     * @param includeOption \u662F\u5426\u6E05\u7A7A option \u914D\u7F6E\u9879
     */
    Annotation.prototype.clear = function (includeOption) {
        if (includeOption === void 0) { includeOption = false; }
        _super.prototype.clear.call(this);
        this.clearComponents();
        this.foregroundContainer.clear();
        this.backgroundContainer.clear();
        // clear all option
        if (includeOption) {
            this.option = [];
        }
    };
    Annotation.prototype.destroy = function () {
        this.clear(true);
        this.foregroundContainer.remove(true);
        this.backgroundContainer.remove(true);
    };
    /**
     * \u590D\u5199\u57FA\u7C7B\u7684\u65B9\u6CD5
     */
    Annotation.prototype.getComponents = function () {
        var co = [];
        this.cache.forEach(function (value) {
            co.push(value);
        });
        return co;
    };
    /**
     * \u6E05\u9664\u5F53\u524D\u7684\u7EC4\u4EF6
     */
    Annotation.prototype.clearComponents = function () {
        this.getComponents().forEach(function (co) {
            co.component.destroy();
        });
        this.cache.clear();
    };
    /**
     * region filter \u6BD4\u8F83\u7279\u6B8A\u7684\u6E32\u67D3\u65F6\u673A
     * @param doWhat
     */
    Annotation.prototype.onAfterRender = function (doWhat) {
        var done = false;
        if (this.view.getOptions().animate) {
            this.view.geometries.forEach(function (g) {
                // \u5982\u679C geometry \u5F00\u542F\uFF0C\u5219\u76D1\u542C
                if (g.animateOption) {
                    g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function () {
                        doWhat();
                    });
                    done = true;
                }
            });
        }
        if (!done) {
            this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function () {
                doWhat();
            });
        }
    };
    Annotation.prototype.createAnnotation = function (option) {
        var type = option.type;
        var Ctor = annotation_namespaceObject[(0,esm/* upperFirst */.jC)(type)];
        if (Ctor) {
            var theme = this.getAnnotationTheme(type);
            var cfg = this.getAnnotationCfg(type, option, theme);
            // \u4E0D\u521B\u5EFA
            if (!cfg) {
                return null;
            }
            var annotation = new Ctor(cfg);
            return {
                component: annotation,
                layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
                direction: constant_DIRECTION.NONE,
                type: COMPONENT_TYPE.ANNOTATION,
                extra: option,
            };
        }
    };
    // APIs for creating annotation component
    Annotation.prototype.annotation = function (option) {
        this.option.push(option);
    };
    /**
     * \u521B\u5EFA Arc
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.arc = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'arc' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA image
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.image = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'image' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA Line
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.line = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'line' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA Region
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.region = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'region' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA Text
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.text = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'text' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA DataMarker
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.dataMarker = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'dataMarker' }, option));
        return this;
    };
    /**
     * \u521B\u5EFA DataRegion
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.dataRegion = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'dataRegion' }, option));
    };
    /**
     * \u521B\u5EFA RegionFilter
     * @param option
     * @returns AnnotationController
     */
    Annotation.prototype.regionFilter = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'regionFilter' }, option));
    };
    /**
     * \u521B\u5EFA ShapeAnnotation
     * @param option
     */
    Annotation.prototype.shape = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'shape' }, option));
    };
    /**
     * \u521B\u5EFA HtmlAnnotation
     * @param option
     */
    Annotation.prototype.html = function (option) {
        this.annotation((0,tslib_es6/* __assign */.pi)({ type: 'html' }, option));
    };
    // end API
    /**
     * parse the point position to [x, y]
     * @param p Position
     * @returns { x, y }
     */
    Annotation.prototype.parsePosition = function (p) {
        var e_1, _a;
        var xScale = this.view.getXScale();
        // \u8F6C\u6210 object
        var yScales = this.view.getScalesByDim('y');
        var position = (0,esm/* isFunction */.mf)(p) ? p.call(null, xScale, yScales) : p;
        var x = 0;
        var y = 0;
        // \u5165\u53C2\u662F [24, 24] \u8FD9\u7C7B\u65F6
        if ((0,esm/* isArray */.kJ)(position)) {
            var _b = (0,tslib_es6/* __read */.CR)(position, 2), xPos = _b[0], yPos = _b[1];
            // \u5982\u679C\u6570\u636E\u683C\u5F0F\u662F ['50%', '50%'] \u7684\u683C\u5F0F
            // fix: \u539F\u59CB\u6570\u636E\u4E2D\u53EF\u80FD\u4F1A\u5305\u542B 'xxx5%xxx' \u8FD9\u6837\u7684\u6570\u636E\uFF0C\u9700\u8981\u5224\u65AD\u4E0B https://github.com/antvis/f2/issues/590
            // @ts-ignore
            if ((0,esm/* isString */.HD)(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {
                return this.parsePercentPosition(position);
            }
            x = getNormalizedValue(xPos, xScale);
            y = getNormalizedValue(yPos, Object.values(yScales)[0]);
        }
        else if (!(0,esm/* isNil */.UM)(position)) {
            try {
                // \u5165\u53C2\u662F object \u7ED3\u6784\uFF0C\u6570\u636E\u70B9
                for (var _c = (0,tslib_es6/* __values */.XA)((0,esm/* keys */.XP)(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    var value = position[key];
                    if (key === xScale.field) {
                        x = getNormalizedValue(value, xScale);
                    }
                    if (yScales[key]) {
                        y = getNormalizedValue(value, yScales[key]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (isNaN(x) || isNaN(y)) {
            return null;
        }
        return this.view.getCoordinate().convert({ x: x, y: y });
    };
    /**
     * parse all the points between start and end
     * @param start
     * @param end
     * @return Point[]
     */
    Annotation.prototype.getRegionPoints = function (start, end) {
        var _this = this;
        var xScale = this.view.getXScale();
        var yScales = this.view.getScalesByDim('y');
        var yScale = Object.values(yScales)[0];
        var xField = xScale.field;
        var viewData = this.view.getData();
        var startXValue = (0,esm/* isArray */.kJ)(start) ? start[0] : start[xField];
        var endXValue = (0,esm/* isArray */.kJ)(end) ? end[0] : end[xField];
        var arr = [];
        var startIndex;
        (0,esm/* each */.S6)(viewData, function (item, idx) {
            if (item[xField] === startXValue) {
                startIndex = idx;
            }
            if (idx >= startIndex) {
                var point = _this.parsePosition([item[xField], item[yScale.field]]);
                if (point) {
                    arr.push(point);
                }
            }
            if (item[xField] === endXValue) {
                return false;
            }
        });
        return arr;
    };
    /**
     * parse percent position
     * @param position
     */
    Annotation.prototype.parsePercentPosition = function (position) {
        var xPercent = parseFloat(position[0]) / 100;
        var yPercent = parseFloat(position[1]) / 100;
        var coordinate = this.view.getCoordinate();
        var start = coordinate.start, end = coordinate.end;
        var topLeft = {
            x: Math.min(start.x, end.x),
            y: Math.min(start.y, end.y),
        };
        var x = coordinate.getWidth() * xPercent + topLeft.x;
        var y = coordinate.getHeight() * yPercent + topLeft.y;
        return { x: x, y: y };
    };
    /**
     * get coordinate bbox
     */
    Annotation.prototype.getCoordinateBBox = function () {
        var coordinate = this.view.getCoordinate();
        var start = coordinate.start, end = coordinate.end;
        var width = coordinate.getWidth();
        var height = coordinate.getHeight();
        var topLeft = {
            x: Math.min(start.x, end.x),
            y: Math.min(start.y, end.y),
        };
        return {
            x: topLeft.x,
            y: topLeft.y,
            minX: topLeft.x,
            minY: topLeft.y,
            maxX: topLeft.x + width,
            maxY: topLeft.y + height,
            width: width,
            height: height,
        };
    };
    /**
     * get annotation component config by different type
     * @param type
     * @param option \u7528\u6237\u7684\u914D\u7F6E
     * @param theme
     */
    Annotation.prototype.getAnnotationCfg = function (type, option, theme) {
        var _this = this;
        var coordinate = this.view.getCoordinate();
        var canvas = this.view.getCanvas();
        var o = {};
        if ((0,esm/* isNil */.UM)(option)) {
            return null;
        }
        var start = option.start, end = option.end, position = option.position;
        var sp = this.parsePosition(start);
        var ep = this.parsePosition(end);
        var textPoint = this.parsePosition(position);
        if (['arc', 'image', 'line', 'region', 'regionFilter'].includes(type) && (!sp || !ep)) {
            return null;
        }
        else if (['text', 'dataMarker', 'html'].includes(type) && !textPoint) {
            return null;
        }
        if (type === 'arc') {
            var _a = option, start_1 = _a.start, end_1 = _a.end, rest = (0,tslib_es6/* __rest */._T)(_a, ["start", "end"]);
            var startAngle = getAngleByPoint(coordinate, sp);
            var endAngle = getAngleByPoint(coordinate, ep);
            if (startAngle > endAngle) {
                endAngle = Math.PI * 2 + endAngle;
            }
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { center: coordinate.getCenter(), radius: getDistanceToCenter(coordinate, sp), startAngle: startAngle, endAngle: endAngle });
        }
        else if (type === 'image') {
            var _b = option, start_2 = _b.start, end_2 = _b.end, rest = (0,tslib_es6/* __rest */._T)(_b, ["start", "end"]);
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { start: sp, end: ep, src: option.src });
        }
        else if (type === 'line') {
            var _c = option, start_3 = _c.start, end_3 = _c.end, rest = (0,tslib_es6/* __rest */._T)(_c, ["start", "end"]);
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { start: sp, end: ep, text: (0,esm/* get */.U2)(option, 'text', null) });
        }
        else if (type === 'region') {
            var _d = option, start_4 = _d.start, end_4 = _d.end, rest = (0,tslib_es6/* __rest */._T)(_d, ["start", "end"]);
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { start: sp, end: ep });
        }
        else if (type === 'text') {
            var filteredData = this.view.getData();
            var _e = option, position_1 = _e.position, content = _e.content, rest = (0,tslib_es6/* __rest */._T)(_e, ["position", "content"]);
            var textContent = content;
            if ((0,esm/* isFunction */.mf)(content)) {
                textContent = content(filteredData);
            }
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, textPoint), rest), { content: textContent });
        }
        else if (type === 'dataMarker') {
            var _f = option, position_2 = _f.position, point = _f.point, line = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction = _f.direction, rest = (0,tslib_es6/* __rest */._T)(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), textPoint), { coordinateBBox: this.getCoordinateBBox(), point: point, line: line, text: text, autoAdjust: autoAdjust, direction: direction });
        }
        else if (type === 'dataRegion') {
            var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest = (0,tslib_es6/* __rest */._T)(_g, ["start", "end", "region", "text", "lineLength"]);
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { points: this.getRegionPoints(start_5, end_5), region: region, text: text, lineLength: lineLength });
        }
        else if (type === 'regionFilter') {
            var _h = option, start_6 = _h.start, end_6 = _h.end, apply_1 = _h.apply, color = _h.color, rest = (0,tslib_es6/* __rest */._T)(_h, ["start", "end", "apply", "color"]);
            var geometries = this.view.geometries;
            var shapes_1 = [];
            var addShapes_1 = function (item) {
                if (!item) {
                    return;
                }
                if (item.isGroup()) {
                    item.getChildren().forEach(function (child) { return addShapes_1(child); });
                }
                else {
                    shapes_1.push(item);
                }
            };
            (0,esm/* each */.S6)(geometries, function (geom) {
                if (apply_1) {
                    if ((0,esm/* contains */.FX)(apply_1, geom.type)) {
                        (0,esm/* each */.S6)(geom.elements, function (elem) {
                            addShapes_1(elem.shape);
                        });
                    }
                }
                else {
                    (0,esm/* each */.S6)(geom.elements, function (elem) {
                        addShapes_1(elem.shape);
                    });
                }
            });
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, rest), { color: color, shapes: shapes_1, start: sp, end: ep });
        }
        else if (type === 'shape') {
            var _j = option, render_1 = _j.render, restOptions = (0,tslib_es6/* __rest */._T)(_j, ["render"]);
            var wrappedRender = function (container) {
                if ((0,esm/* isFunction */.mf)(option.render)) {
                    return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
                }
            };
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, restOptions), { render: wrappedRender });
        }
        else if (type === 'html') {
            var _k = option, html_1 = _k.html, position_3 = _k.position, restOptions = (0,tslib_es6/* __rest */._T)(_k, ["html", "position"]);
            var wrappedHtml = function (container) {
                if ((0,esm/* isFunction */.mf)(html_1)) {
                    return html_1(container, _this.view);
                }
                return html_1;
            };
            o = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, restOptions), textPoint), { 
                // html \u7EC4\u4EF6\u9700\u8981\u6307\u5B9A parent
                parent: canvas.get('el').parentNode, html: wrappedHtml });
        }
        // \u5408\u5E76\u4E3B\u9898\uFF0C\u7528\u6237\u914D\u7F6E\u4F18\u5148\u7EA7\u9AD8\u4E8E\u9ED8\u8BA4\u4E3B\u9898
        var cfg = (0,esm/* deepMix */.b$)({}, theme, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
        if (type !== 'html') {
            // html \u7C7B\u578B\u4E0D\u4F7F\u7528 G container
            cfg.container = this.getComponentContainer(cfg);
        }
        cfg.animate = this.view.getOptions().animate && cfg.animate && (0,esm/* get */.U2)(option, 'animate', cfg.animate); // \u5982\u679C view \u5173\u95ED\u52A8\u753B\uFF0C\u5219\u4E0D\u6267\u884C
        cfg.animateOption = (0,esm/* deepMix */.b$)({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
        return cfg;
    };
    /**
     * is annotation render on top
     * @param option
     * @return whethe on top
     */
    Annotation.prototype.isTop = function (option) {
        return (0,esm/* get */.U2)(option, 'top', true);
    };
    /**
     * get the container by option.top
     * default is on top
     * @param option
     * @returns the container
     */
    Annotation.prototype.getComponentContainer = function (option) {
        return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
    };
    Annotation.prototype.getAnnotationTheme = function (type) {
        return (0,esm/* get */.U2)(this.view.getTheme(), ['components', 'annotation', type], {});
    };
    /**
     * \u521B\u5EFA\u6216\u8005\u66F4\u65B0 annotation
     * @param option
     */
    Annotation.prototype.updateOrCreate = function (option) {
        // \u62FF\u5230\u7F13\u5B58\u7684\u5185\u5BB9
        var co = this.cache.get(this.getCacheKey(option));
        // \u5B58\u5728\u5219\u66F4\u65B0\uFF0C\u4E0D\u5B58\u5728\u5728\u521B\u5EFA
        if (co) {
            var type = option.type;
            var theme = this.getAnnotationTheme(type);
            var cfg = this.getAnnotationCfg(type, option, theme);
            // \u5FFD\u7565\u6389\u4E00\u4E9B\u914D\u7F6E
            if (cfg) {
                omit(cfg, ['container']);
            }
            co.component.update((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, (cfg || {})), { visible: !!cfg }));
            // \u5BF9\u4E8E regionFilter/shape\uFF0C\u56E0\u4E3A\u751F\u547D\u5468\u671F\u7684\u539F\u56E0\uFF0C\u9700\u8981\u989D\u5916 render
            if ((0,esm/* includes */.q9)(ANNOTATIONS_AFTER_RENDER, option.type)) {
                co.component.render();
            }
        }
        else {
            // \u4E0D\u5B58\u5728\uFF0C\u521B\u5EFA
            co = this.createAnnotation(option);
            if (co) {
                co.component.init();
                // Note\uFF1AregionFilter/shape \u7279\u6B8A\u5904\u7406\uFF0CregionFilter/shape \u9700\u8981\u53D6\u5230 Geometry \u4E2D\u7684 Shape\uFF0C\u9700\u8981\u5728 view render \u4E4B\u540E\u5904\u7406
                // \u5176\u4ED6\u7EC4\u4EF6\u4F7F\u7528\u5916\u5C42\u7684\u7EDF\u4E00 render \u903B\u8F91
                if ((0,esm/* includes */.q9)(ANNOTATIONS_AFTER_RENDER, option.type)) {
                    co.component.render();
                }
            }
        }
        return co;
    };
    /**
     * \u66F4\u65B0\u7F13\u5B58\uFF0C\u4EE5\u53CA\u9500\u6BC1\u7EC4\u4EF6
     * @param updated \u66F4\u65B0\u6216\u8005\u521B\u5EFA\u7684\u7EC4\u4EF6
     */
    Annotation.prototype.syncCache = function (updated) {
        var _this = this;
        var newCache = new Map(this.cache); // clone \u4E00\u4EFD
        // \u5C06 update \u66F4\u65B0\u5230 cache
        updated.forEach(function (co, key) {
            newCache.set(key, co);
        });
        // \u53E6\u5916\u548C options \u8FDB\u884C\u5BF9\u6BD4\uFF0C\u5220\u9664
        newCache.forEach(function (co, key) {
            // option \u4E2D\u5DF2\u7ECF\u627E\u4E0D\u5230\uFF0C\u90A3\u4E48\u5C31\u662F\u5220\u9664\u7684
            if (!(0,esm/* find */.sE)(_this.option, function (option) {
                return key === _this.getCacheKey(option);
            })) {
                co.component.destroy();
                newCache.delete(key);
            }
        });
        return newCache;
    };
    /**
     * \u83B7\u5F97\u7F13\u5B58\u7EC4\u4EF6\u7684 key
     * @param option
     */
    Annotation.prototype.getCacheKey = function (option) {
        // \u5982\u679C\u5B58\u5728 id\uFF0C\u5219\u4F7F\u7528 id string\uFF0C\u5426\u5219\u76F4\u63A5\u4F7F\u7528 option \u5F15\u7528\u4F5C\u4E3A key
        return option;
        // \u540E\u7EED\u6269\u5C55 id \u7528
        // const id = get(option, 'id');
        // return id ? id : option;
    };
    return Annotation;
}(Controller));
/* harmony default export */ var annotation = (Annotation);
//# sourceMappingURL=annotation.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/grid.js

/**
 * @ignore
 * get the grid theme by type, will mix the common cfg of axis
 * @param theme
 * @param direction
 * @returns theme object
 */
function getGridThemeCfg(theme, direction) {
    var axisTheme = (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(theme, ['components', 'axis', 'common']), (0,esm/* get */.U2)(theme, ['components', 'axis', direction]));
    return (0,esm/* get */.U2)(axisTheme, ['grid'], {});
}
/**
 * @ignore
 * get axis grid items
 * @param coordinate
 * @param scale
 * @param dim
 * @return items
 */
function getLineGridItems(coordinate, scale, dim, alignTick) {
    var items = [];
    var ticks = scale.getTicks();
    if (coordinate.isPolar) {
        // \u8865\u5168 ticks
        ticks.push({
            value: 1,
            text: '',
            tickValue: '',
        });
    }
    ticks.reduce(function (preTick, currentTick, currentIndex) {
        var currentValue = currentTick.value;
        if (alignTick) {
            items.push({
                points: [
                    coordinate.convert(dim === 'y' ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
                    coordinate.convert(dim === 'y' ? { x: 1, y: currentValue } : { x: currentValue, y: 1 }),
                ],
            });
        }
        else {
            if (currentIndex) {
                var preValue = preTick.value;
                var middleValue = (preValue + currentValue) / 2;
                items.push({
                    points: [
                        coordinate.convert(dim === 'y' ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
                        coordinate.convert(dim === 'y' ? { x: 1, y: middleValue } : { x: middleValue, y: 1 }),
                    ],
                });
            }
        }
        return currentTick;
    }, ticks[0]);
    return items;
}
/**
 * @ignore
 * get
 * @param coordinate
 * @param xScale
 * @param yScale
 * @param dim
 * @returns items
 */
function getCircleGridItems(coordinate, xScale, yScale, alignTick, dim) {
    var count = xScale.values.length;
    var items = [];
    var ticks = yScale.getTicks();
    ticks.reduce(function (preTick, currentTick) {
        var preValue = preTick ? preTick.value : currentTick.value; // \u53EA\u6709\u4E00\u9879\u6570\u636E\u65F6\u53D6\u5F53\u524D\u503C
        var currentValue = currentTick.value;
        var middleValue = (preValue + currentValue) / 2;
        if (dim === 'x') {
            // \u5982\u679C\u662F x \u8F74\u4F5C\u4E3A\u534A\u5F84\u8F74\uFF0C\u90A3\u4E48\u53EA\u9700\u8981\u53D6\u5706\u5F27\u6536\u5C3E\u4E24\u4E2A\u5373\u53EF
            items.push({
                points: [
                    coordinate.convert({
                        x: alignTick ? currentValue : middleValue,
                        y: 0,
                    }),
                    coordinate.convert({
                        x: alignTick ? currentValue : middleValue,
                        y: 1,
                    }),
                ],
            });
        }
        else {
            items.push({
                points: (0,esm/* map */.UI)(Array(count + 1), function (__, idx) {
                    return coordinate.convert({
                        x: idx / count,
                        y: alignTick ? currentValue : middleValue,
                    });
                }),
            });
        }
        return currentTick;
    }, ticks[0]);
    return items;
}
/**
 * @ignore
 * show grid or not
 * @param axisTheme
 * @param axisOption
 */
function showGrid(axisTheme, axisOption) {
    var userGrid = (0,esm/* get */.U2)(axisOption, 'grid');
    if (userGrid === null) {
        return false;
    }
    var themeGrid = (0,esm/* get */.U2)(axisTheme, 'grid');
    return !(userGrid === undefined && themeGrid === null);
}
//# sourceMappingURL=grid.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/axis.js










// update \u7EC4\u4EF6\u7684\u65F6\u5019\uFF0C\u5FFD\u7565\u7684\u6570\u636E\u66F4\u65B0
var OMIT_CFG = ['container'];
// \u5750\u6807\u8F74\u9ED8\u8BA4\u52A8\u753B\u914D\u7F6E
var AXIS_DEFAULT_ANIMATE_CFG = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, DEFAULT_ANIMATE_CFG), { appear: null });
/**
 * @ignore
 * G2 Axis controller, will:
 *  - create component
 *    - axis
 *    - grid
 *  - life circle
 */
var Axis = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Axis, _super);
    function Axis(view) {
        var _this = _super.call(this, view) || this;
        /** \u4F7F\u7528 object \u5B58\u50A8\u7EC4\u4EF6 */
        _this.cache = new Map();
        // \u5148\u521B\u5EFA gridContainer\uFF0C\u5C06 grid \u653E\u5230 axis \u5E95\u5C42
        _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
        _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
        _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
        _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
        return _this;
    }
    Object.defineProperty(Axis.prototype, "name", {
        get: function () {
            return 'axis';
        },
        enumerable: false,
        configurable: true
    });
    Axis.prototype.init = function () { };
    Axis.prototype.render = function () {
        this.update();
    };
    /**
     * \u66F4\u65B0\u7EC4\u4EF6\u5E03\u5C40\uFF0C\u4F4D\u7F6E\u5927\u5C0F
     */
    Axis.prototype.layout = function () {
        var _this = this;
        var coordinate = this.view.getCoordinate();
        (0,esm/* each */.S6)(this.getComponents(), function (co) {
            var component = co.component, direction = co.direction, type = co.type, extra = co.extra;
            var dim = extra.dim, scale = extra.scale, alignTick = extra.alignTick;
            var updated;
            if (type === COMPONENT_TYPE.AXIS) {
                if (coordinate.isPolar) {
                    if (dim === 'x') {
                        updated = coordinate.isTransposed
                            ? getAxisRegion(coordinate, direction)
                            : getCircleAxisCenterRadius(coordinate);
                    }
                    else if (dim === 'y') {
                        updated = coordinate.isTransposed
                            ? getCircleAxisCenterRadius(coordinate)
                            : getAxisRegion(coordinate, direction);
                    }
                }
                else {
                    updated = getAxisRegion(coordinate, direction);
                }
            }
            else if (type === COMPONENT_TYPE.GRID) {
                if (coordinate.isPolar) {
                    var items = void 0;
                    if (coordinate.isTransposed) {
                        items =
                            dim === 'x'
                                ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale, alignTick, dim)
                                : getLineGridItems(coordinate, scale, dim, alignTick);
                    }
                    else {
                        items =
                            dim === 'x'
                                ? getLineGridItems(coordinate, scale, dim, alignTick)
                                : getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick, dim);
                    }
                    updated = {
                        items: items,
                        // coordinate \u66F4\u65B0\u4E4B\u540E\uFF0Ccenter \u4E5F\u53D8\u5316\u4E86
                        center: _this.view.getCoordinate().getCenter(),
                    };
                }
                else {
                    updated = { items: getLineGridItems(coordinate, scale, dim, alignTick) };
                }
            }
            component.update(updated);
        });
    };
    /**
     * \u66F4\u65B0 axis \u7EC4\u4EF6
     */
    Axis.prototype.update = function () {
        this.option = this.view.getOptions().axes;
        var updatedCache = new Map();
        this.updateXAxes(updatedCache);
        this.updateYAxes(updatedCache);
        // \u5904\u7406\u5B8C\u6210\u4E4B\u540E\uFF0C\u9500\u6BC1\u5220\u9664\u7684
        // \u4E0D\u5728\u5904\u7406\u4E2D\u7684
        var newCache = new Map();
        this.cache.forEach(function (co, key) {
            if (updatedCache.has(key)) {
                newCache.set(key, co);
            }
            else {
                // \u4E0D\u5B58\u5728\uFF0C\u5219\u662F\u6240\u6709\u9700\u8981\u88AB\u9500\u6BC1\u7684\u7EC4\u4EF6
                co.component.destroy();
            }
        });
        // \u66F4\u65B0\u7F13\u5B58
        this.cache = newCache;
    };
    Axis.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.cache.clear();
        this.gridContainer.clear();
        this.gridForeContainer.clear();
        this.axisContainer.clear();
        this.axisForeContainer.clear();
    };
    Axis.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.gridContainer.remove(true);
        this.gridForeContainer.remove(true);
        this.axisContainer.remove(true);
        this.axisForeContainer.remove(true);
    };
    /**
     * @override
     */
    Axis.prototype.getComponents = function () {
        var co = [];
        this.cache.forEach(function (value) {
            co.push(value);
        });
        return co;
    };
    /**
     * \u66F4\u65B0 x axis
     * @param updatedCache
     */
    Axis.prototype.updateXAxes = function (updatedCache) {
        // x axis
        var scale = this.view.getXScale();
        if (!scale || scale.isIdentity) {
            return;
        }
        var xAxisOption = getAxisOption(this.option, scale.field);
        if (xAxisOption === false) {
            return;
        }
        var direction = getAxisDirection(xAxisOption, constant_DIRECTION.BOTTOM);
        var layer = LAYER.BG;
        var dim = 'x';
        var coordinate = this.view.getCoordinate();
        var axisId = this.getId('axis', scale.field);
        var gridId = this.getId('grid', scale.field);
        if (coordinate.isRect) {
            // 1. do axis update
            var axis = this.cache.get(axisId);
            // \u5B58\u5728\u5219\u66F4\u65B0
            if (axis) {
                var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);
                omit(cfg, OMIT_CFG);
                axis.component.update(cfg);
                updatedCache.set(axisId, axis);
            }
            else {
                // \u4E0D\u5B58\u5728\uFF0C\u5219\u521B\u5EFA
                axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);
                this.cache.set(axisId, axis);
                updatedCache.set(axisId, axis);
            }
            // 2. do grid update
            var grid = this.cache.get(gridId);
            // \u5B58\u5728\u5219\u66F4\u65B0
            if (grid) {
                var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);
                omit(cfg, OMIT_CFG);
                grid.component.update(cfg);
                updatedCache.set(gridId, grid);
            }
            else {
                // \u4E0D\u5B58\u5728\u5219\u521B\u5EFA
                grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);
                if (grid) {
                    this.cache.set(gridId, grid);
                    updatedCache.set(gridId, grid);
                }
            }
        }
        else if (coordinate.isPolar) {
            // 1. do axis update
            var axis = this.cache.get(axisId);
            // \u5B58\u5728\u5219\u66F4\u65B0
            if (axis) {
                var cfg = coordinate.isTransposed
                    ? this.getLineAxisCfg(scale, xAxisOption, constant_DIRECTION.RADIUS)
                    : this.getCircleAxisCfg(scale, xAxisOption, direction);
                omit(cfg, OMIT_CFG);
                axis.component.update(cfg);
                updatedCache.set(axisId, axis);
            }
            else {
                // \u4E0D\u5B58\u5728\uFF0C\u5219\u521B\u5EFA
                if (coordinate.isTransposed) {
                    if ((0,esm/* isUndefined */.o8)(xAxisOption)) {
                        // \u9ED8\u8BA4\u4E0D\u6E32\u67D3\u8F6C\u7F6E\u6781\u5750\u6807\u4E0B\u7684\u5750\u6807\u8F74
                        return;
                    }
                    else {
                        // \u5982\u679C\u7528\u6237\u6253\u5F00\u4E86\u9690\u85CF\u7684\u5750\u6807\u8F74 chart.axis(true)/chart.axis('x', true)
                        // \u90A3\u4E48\u5BF9\u4E8E\u8F6C\u7F6E\u4E86\u7684\u6781\u5750\u6807\uFF0C\u534A\u5F84\u8F74\u663E\u793A\u7684\u662F x \u8F74\u5BF9\u5E94\u7684\u6570\u636E
                        axis = this.createLineAxis(scale, xAxisOption, layer, constant_DIRECTION.RADIUS, dim);
                    }
                }
                else {
                    axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);
                }
                this.cache.set(axisId, axis);
                updatedCache.set(axisId, axis);
            }
            // 2. do grid update
            var grid = this.cache.get(gridId);
            // \u5B58\u5728\u5219\u66F4\u65B0
            if (grid) {
                var cfg = coordinate.isTransposed
                    ? this.getCircleGridCfg(scale, xAxisOption, constant_DIRECTION.RADIUS, dim)
                    : this.getLineGridCfg(scale, xAxisOption, constant_DIRECTION.CIRCLE, dim);
                omit(cfg, OMIT_CFG);
                grid.component.update(cfg);
                updatedCache.set(gridId, grid);
            }
            else {
                // \u4E0D\u5B58\u5728\u5219\u521B\u5EFA
                if (coordinate.isTransposed) {
                    if ((0,esm/* isUndefined */.o8)(xAxisOption)) {
                        return;
                    }
                    else {
                        grid = this.createCircleGrid(scale, xAxisOption, layer, constant_DIRECTION.RADIUS, dim);
                    }
                }
                else {
                    // grid\uFF0C\u6781\u5750\u6807\u4E0B\u7684 x \u8F74\u7F51\u683C\u7EBF\u6CBF\u7740\u534A\u5F84\u65B9\u5411\u7ED8\u5236
                    grid = this.createLineGrid(scale, xAxisOption, layer, constant_DIRECTION.CIRCLE, dim);
                }
                if (grid) {
                    this.cache.set(gridId, grid);
                    updatedCache.set(gridId, grid);
                }
            }
        }
        else {
            // helix and other, do not draw axis
        }
    };
    Axis.prototype.updateYAxes = function (updatedCache) {
        var _this = this;
        // y axes
        var yScales = this.view.getYScales();
        (0,esm/* each */.S6)(yScales, function (scale, idx) {
            // @ts-ignore
            if (!scale || scale.isIdentity) {
                return;
            }
            var field = scale.field;
            var yAxisOption = getAxisOption(_this.option, field);
            if (yAxisOption !== false) {
                var layer = LAYER.BG;
                var dim = 'y';
                var axisId = _this.getId('axis', field);
                var gridId = _this.getId('grid', field);
                var coordinate = _this.view.getCoordinate();
                if (coordinate.isRect) {
                    var direction = getAxisDirection(yAxisOption, idx === 0 ? constant_DIRECTION.LEFT : constant_DIRECTION.RIGHT);
                    // 1. do axis update
                    var axis = _this.cache.get(axisId);
                    // \u5B58\u5728\u5219\u66F4\u65B0
                    if (axis) {
                        var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);
                        omit(cfg, OMIT_CFG);
                        axis.component.update(cfg);
                        updatedCache.set(axisId, axis);
                    }
                    else {
                        // \u4E0D\u5B58\u5728\uFF0C\u5219\u521B\u5EFA
                        axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);
                        _this.cache.set(axisId, axis);
                        updatedCache.set(axisId, axis);
                    }
                    // 2. do grid update
                    var grid = _this.cache.get(gridId);
                    // \u5B58\u5728\u5219\u66F4\u65B0
                    if (grid) {
                        var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);
                        omit(cfg, OMIT_CFG);
                        grid.component.update(cfg);
                        updatedCache.set(gridId, grid);
                    }
                    else {
                        // \u4E0D\u5B58\u5728\u5219\u521B\u5EFA
                        grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);
                        if (grid) {
                            _this.cache.set(gridId, grid);
                            updatedCache.set(gridId, grid);
                        }
                    }
                }
                else if (coordinate.isPolar) {
                    // 1. do axis update
                    var axis = _this.cache.get(axisId);
                    // \u5B58\u5728\u5219\u66F4\u65B0
                    if (axis) {
                        var cfg = coordinate.isTransposed
                            ? _this.getCircleAxisCfg(scale, yAxisOption, constant_DIRECTION.CIRCLE)
                            : _this.getLineAxisCfg(scale, yAxisOption, constant_DIRECTION.RADIUS);
                        // @ts-ignore
                        omit(cfg, OMIT_CFG);
                        axis.component.update(cfg);
                        updatedCache.set(axisId, axis);
                    }
                    else {
                        // \u4E0D\u5B58\u5728\uFF0C\u5219\u521B\u5EFA
                        if (coordinate.isTransposed) {
                            if ((0,esm/* isUndefined */.o8)(yAxisOption)) {
                                return;
                            }
                            else {
                                axis = _this.createCircleAxis(scale, yAxisOption, layer, constant_DIRECTION.CIRCLE, dim);
                            }
                        }
                        else {
                            axis = _this.createLineAxis(scale, yAxisOption, layer, constant_DIRECTION.RADIUS, dim);
                        }
                        _this.cache.set(axisId, axis);
                        updatedCache.set(axisId, axis);
                    }
                    // 2. do grid update
                    var grid = _this.cache.get(gridId);
                    // \u5B58\u5728\u5219\u66F4\u65B0
                    if (grid) {
                        var cfg = coordinate.isTransposed
                            ? _this.getLineGridCfg(scale, yAxisOption, constant_DIRECTION.CIRCLE, dim)
                            : _this.getCircleGridCfg(scale, yAxisOption, constant_DIRECTION.RADIUS, dim);
                        omit(cfg, OMIT_CFG);
                        grid.component.update(cfg);
                        updatedCache.set(gridId, grid);
                    }
                    else {
                        // \u4E0D\u5B58\u5728\u5219\u521B\u5EFA
                        if (coordinate.isTransposed) {
                            if ((0,esm/* isUndefined */.o8)(yAxisOption)) {
                                return;
                            }
                            else {
                                grid = _this.createLineGrid(scale, yAxisOption, layer, constant_DIRECTION.CIRCLE, dim);
                            }
                        }
                        else {
                            grid = _this.createCircleGrid(scale, yAxisOption, layer, constant_DIRECTION.RADIUS, dim);
                        }
                        if (grid) {
                            _this.cache.set(gridId, grid);
                            updatedCache.set(gridId, grid);
                        }
                    }
                }
                else {
                    // helix and other, do not draw axis
                }
            }
        });
    };
    /**
     * \u521B\u5EFA line axis
     * @param scale
     * @param option
     * @param layer
     * @param direction
     * @param dim
     */
    Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {
        // axis
        var axis = {
            component: new LineAxis(this.getLineAxisCfg(scale, option, direction)),
            layer: layer,
            direction: direction === constant_DIRECTION.RADIUS ? constant_DIRECTION.NONE : direction,
            type: COMPONENT_TYPE.AXIS,
            extra: { dim: dim, scale: scale },
        };
        axis.component.set('field', scale.field);
        axis.component.init();
        return axis;
    };
    Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {
        var cfg = this.getLineGridCfg(scale, option, direction, dim);
        if (cfg) {
            var grid = {
                component: new LineGrid(cfg),
                layer: layer,
                direction: constant_DIRECTION.NONE,
                type: COMPONENT_TYPE.GRID,
                extra: {
                    dim: dim,
                    scale: scale,
                    alignTick: (0,esm/* get */.U2)(cfg, 'alignTick', true),
                },
            };
            grid.component.init();
            return grid;
        }
    };
    Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {
        var axis = {
            component: new CircleAxis(this.getCircleAxisCfg(scale, option, direction)),
            layer: layer,
            direction: direction,
            type: COMPONENT_TYPE.AXIS,
            extra: { dim: dim, scale: scale },
        };
        axis.component.set('field', scale.field);
        axis.component.init();
        return axis;
    };
    Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {
        var cfg = this.getCircleGridCfg(scale, option, direction, dim);
        if (cfg) {
            var grid = {
                component: new CircleGrid(cfg),
                layer: layer,
                direction: constant_DIRECTION.NONE,
                type: COMPONENT_TYPE.GRID,
                extra: {
                    dim: dim,
                    scale: scale,
                    alignTick: (0,esm/* get */.U2)(cfg, 'alignTick', true),
                },
            };
            grid.component.init();
            return grid;
        }
    };
    /**
     * generate line axis cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return line axis cfg
     */
    Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {
        var container = (0,esm/* get */.U2)(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;
        var coordinate = this.view.getCoordinate();
        var region = getAxisRegion(coordinate, direction);
        var titleText = getAxisTitleText(scale, axisOption);
        var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction);
        // the cfg order should be ensure
        var optionWithTitle = (0,esm/* get */.U2)(axisOption, ['title'])
            ? (0,esm/* deepMix */.b$)({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) }, axisOption)
            : axisOption;
        var cfg = (0,esm/* deepMix */.b$)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ container: container }, region), { ticks: scale.getTicks().map(function (tick) { return ({ id: "".concat(tick.tickValue), name: tick.text, value: tick.value }); }), verticalFactor: coordinate.isPolar
                ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1
                : getAxisFactorByRegion(region, coordinate.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
        var _a = this.getAnimateCfg(cfg), animate = _a.animate, animateOption = _a.animateOption;
        cfg.animateOption = animateOption;
        cfg.animate = animate;
        // \u8BA1\u7B97 verticalLimitLength
        var isAxisVertical = isVertical(region);
        // TODO: 1 / 3 \u7B49\u9ED8\u8BA4\u503C\u9700\u8981\u6709\u4E00\u4E2A\u5168\u5C40\u7684\u914D\u7F6E\u7684\u5730\u65B9
        var verticalLimitLength = (0,esm/* get */.U2)(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);
        if (verticalLimitLength <= 1) {
            // \u914D\u7F6E\u7684\u76F8\u5BF9\u503C\uFF0C\u76F8\u5BF9\u4E8E\u753B\u5E03
            var canvasWidth = this.view.getCanvas().get('width');
            var canvasHeight = this.view.getCanvas().get('height');
            cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
        }
        return cfg;
    };
    /**
     * generate line grid cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @param dim
     * @return line grid cfg
     */
    Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {
        if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
            return undefined;
        }
        var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction);
        // the cfg order should be ensure
        // grid \u52A8\u753B\u4EE5 axis \u4E3A\u51C6
        var gridCfg = (0,esm/* deepMix */.b$)({
            container: (0,esm/* get */.U2)(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,
        }, gridThemeCfg, (0,esm/* get */.U2)(axisOption, 'grid'), this.getAnimateCfg(axisOption));
        gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale, dim, (0,esm/* get */.U2)(gridCfg, 'alignTick', true));
        return gridCfg;
    };
    /**
     * generate circle axis cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return circle axis cfg
     */
    Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {
        var container = (0,esm/* get */.U2)(axisOption, ['top']) ? this.axisForeContainer : this.axisContainer;
        var coordinate = this.view.getCoordinate();
        var ticks = scale.getTicks().map(function (tick) { return ({ id: "".concat(tick.tickValue), name: tick.text, value: tick.value }); });
        if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
            // x \u8F74\u5BF9\u5E94\u7684\u503C\u5982\u679C\u662F\u975E cat \u7C7B\u578B\uFF0C\u5728\u6574\u5706\u7684\u60C5\u51B5\u4E0B\u5750\u6807\u8F74\u7B2C\u4E00\u4E2A\u548C\u6700\u540E\u4E00\u4E2A\u6587\u672C\u4F1A\u91CD\u53E0\uFF0C\u9ED8\u8BA4\u53EA\u5C55\u793A\u7B2C\u4E00\u4E2A\u6587\u672C
            if (ticks.length)
                ticks[ticks.length - 1].name = '';
        }
        var titleText = getAxisTitleText(scale, axisOption);
        var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), constant_DIRECTION.CIRCLE);
        // the cfg order should be ensure
        var optionWithTitle = (0,esm/* get */.U2)(axisOption, ['title'])
            ? (0,esm/* deepMix */.b$)({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction, axisOption.title) }, axisOption)
            : axisOption;
        var cfg = (0,esm/* deepMix */.b$)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ container: container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks: ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
        var _a = this.getAnimateCfg(cfg), animate = _a.animate, animateOption = _a.animateOption;
        cfg.animate = animate;
        cfg.animateOption = animateOption;
        return cfg;
    };
    /**
     * generate circle grid cfg
     * @param scale
     * @param axisOption
     * @param direction
     * @return circle grid cfg
     */
    Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {
        if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
            return undefined;
        }
        // the cfg order should be ensure
        // grid \u52A8\u753B\u4EE5 axis \u4E3A\u51C6
        var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), constant_DIRECTION.RADIUS);
        var gridCfg = (0,esm/* deepMix */.b$)({
            container: (0,esm/* get */.U2)(axisOption, ['top']) ? this.gridForeContainer : this.gridContainer,
            center: this.view.getCoordinate().getCenter(),
        }, gridThemeCfg, (0,esm/* get */.U2)(axisOption, 'grid'), this.getAnimateCfg(axisOption));
        var alignTick = (0,esm/* get */.U2)(gridCfg, 'alignTick', true);
        var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();
        gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim);
        // the cfg order should be ensure
        // grid \u52A8\u753B\u4EE5 axis \u4E3A\u51C6
        return gridCfg;
    };
    Axis.prototype.getId = function (name, key) {
        var coordinate = this.view.getCoordinate();
        // \u5750\u6807\u7CFB\u7C7B\u578B\u4E5F\u4F5C\u4E3A\u7EC4\u4EF6\u7684 key
        return "".concat(name, "-").concat(key, "-").concat(coordinate.type);
    };
    Axis.prototype.getAnimateCfg = function (cfg) {
        return {
            animate: this.view.getOptions().animate && (0,esm/* get */.U2)(cfg, 'animate'),
            animateOption: cfg && cfg.animateOption ? (0,esm/* deepMix */.b$)({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG,
        };
    };
    return Axis;
}(Controller));
/* harmony default export */ var axis = (Axis);
//# sourceMappingURL=axis.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/util/direction.js

/**
 * @ignore
 * \u65B9\u4F4D\u5E38\u91CF\u8F6C\u5B9E\u9645\u7684 bbox \u4F4D\u7F6E\u5927\u5C0F
 * @param parentBBox
 * @param bbox
 * @param direction
 */
function directionToPosition(parentBBox, bbox, direction) {
    if (direction === constant_DIRECTION.TOP) {
        return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
    }
    if (direction === constant_DIRECTION.BOTTOM) {
        return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
    }
    if (direction === constant_DIRECTION.LEFT) {
        return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction === constant_DIRECTION.RIGHT) {
        return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction === constant_DIRECTION.TOP_LEFT || direction === constant_DIRECTION.LEFT_TOP) {
        return [parentBBox.tl.x, parentBBox.tl.y];
    }
    if (direction === constant_DIRECTION.TOP_RIGHT || direction === constant_DIRECTION.RIGHT_TOP) {
        return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
    }
    if (direction === constant_DIRECTION.BOTTOM_LEFT || direction === constant_DIRECTION.LEFT_BOTTOM) {
        return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
    }
    if (direction === constant_DIRECTION.BOTTOM_RIGHT || direction === constant_DIRECTION.RIGHT_BOTTOM) {
        return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
    }
    return [0, 0];
}
/**
 * get direction after coordinate transpose
 * @param direction
 * @param coordinate
 * @returns direction after transpose or not
 */
function getTransposedDirection(direction, coordinate) {
    if (coordinate.isTransposed) {
        switch (direction) {
            case DIRECTION.BOTTOM:
                return DIRECTION.LEFT;
            case DIRECTION.LEFT:
                return DIRECTION.BOTTOM;
            case DIRECTION.RIGHT:
                return DIRECTION.TOP;
            case DIRECTION.TOP:
                return DIRECTION.RIGHT;
        }
    }
    return direction;
}
function reflectX(direct) {
    if (direct === DIRECTION.LEFT) {
        return DIRECTION.RIGHT;
    }
    if (direct === DIRECTION.RIGHT) {
        return DIRECTION.LEFT;
    }
    return direct;
}
function reflectY(direct) {
    if (direct === DIRECTION.TOP) {
        return DIRECTION.BOTTOM;
    }
    if (direct === DIRECTION.BOTTOM) {
        return DIRECTION.TOP;
    }
    return direct;
}
/**
 * get direction after coordinate.scale
 * @param direction
 * @param coordinate
 */
function getScaleDirection(direction, coordinate) {
    var x = coordinate.matrix[0];
    var y = coordinate.matrix[4];
    var d = direction;
    if (x < 0) {
        d = reflectX(d);
    }
    if (y < 0) {
        d = reflectY(d);
    }
    return d;
}
/**
 *
 * @param direction
 * @param coordinate
 */
function getReflectDirection(direction, coordinate) {
    var d = direction;
    if (coordinate.isReflect('x')) {
        d = reflectX(d);
    }
    if (coordinate.isReflect('y')) {
        d = reflectY(d);
    }
    return d;
}
/**
 * @ignore
 * get direction after coordinate translate
 * @param direction
 * @param coordinate
 */
function getTranslateDirection(direction, coordinate) {
    var d = direction;
    d = getTransposedDirection(d, coordinate);
    d = getScaleDirection(d, coordinate);
    d = getReflectDirection(d, coordinate);
    return d;
}
//# sourceMappingURL=direction.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/legend.js











/**
 * \u4ECE\u914D\u7F6E\u4E2D\u83B7\u53D6\u5355\u4E2A\u5B57\u6BB5\u7684 legend \u914D\u7F6E
 * @param legends
 * @param field
 * @returns the option of one legend field
 */
function getLegendOption(legends, field) {
    if ((0,esm/* isBoolean */.jn)(legends)) {
        return legends === false ? false : {};
    }
    return (0,esm/* get */.U2)(legends, [field], legends);
}
function getDirection(legendOption) {
    return (0,esm/* get */.U2)(legendOption, 'position', constant_DIRECTION.BOTTOM);
}
/**
 * @ignore
 * legend Controller
 */
var Legend = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Legend, _super);
    function Legend(view) {
        var _this = _super.call(this, view) || this;
        _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
        return _this;
    }
    Object.defineProperty(Legend.prototype, "name", {
        get: function () {
            return 'legend';
        },
        enumerable: false,
        configurable: true
    });
    Legend.prototype.init = function () { };
    /**
     * render the legend component by legend options
     */
    Legend.prototype.render = function () {
        // \u548C update \u903B\u8F91\u4FDD\u6301\u4E00\u81F4
        this.update();
    };
    /**
     * layout legend
     * \u8BA1\u7B97\u51FA legend \u7684 direction \u4F4D\u7F6E x, y
     */
    Legend.prototype.layout = function () {
        var _this = this;
        this.layoutBBox = this.view.viewBBox;
        (0,esm/* each */.S6)(this.components, function (co) {
            var component = co.component, direction = co.direction;
            var layout = getLegendLayout(direction);
            var maxWidthRatio = component.get('maxWidthRatio');
            var maxHeightRatio = component.get('maxHeightRatio');
            var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
            var maxWidth = component.get('maxWidth');
            var maxHeight = component.get('maxHeight');
            // \u5148\u66F4\u65B0 maxSize\uFF0C\u66F4\u65B0 layoutBBox\uFF0C\u4EE5\u4FBF\u8BA1\u7B97\u6B63\u786E\u7684 x y
            component.update({
                maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
                maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0),
            });
            var padding = component.get('padding');
            var bboxObject = component.getLayoutBBox(); // \u8FD9\u91CC\u53EA\u9700\u8981\u4ED6\u7684 width\u3001height \u4FE1\u606F\u505A\u4F4D\u7F6E\u8C03\u6574
            var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);
            var _a = (0,tslib_es6/* __read */.CR)(directionToPosition(_this.view.viewBBox, bbox, direction), 2), x1 = _a[0], y1 = _a[1];
            var _b = (0,tslib_es6/* __read */.CR)(directionToPosition(_this.layoutBBox, bbox, direction), 2), x2 = _b[0], y2 = _b[1];
            var x = 0;
            var y = 0;
            // \u56E0\u4E3A legend x y \u8981\u548C coordinateBBox \u5BF9\u9F50\uFF0C\u6240\u4EE5\u8981\u505A\u4E00\u4E2A\u7B80\u5355\u7684\u5224\u65AD
            if (direction.startsWith('top') || direction.startsWith('bottom')) {
                x = x1;
                y = y2;
            }
            else {
                x = x2;
                y = y1;
            }
            // \u66F4\u65B0\u4F4D\u7F6E
            component.setLocation({ x: x + padding[3], y: y + padding[0] });
            _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);
        });
    };
    /**
     * legend \u7684\u66F4\u65B0\u903B\u8F91
     */
    Legend.prototype.update = function () {
        var _this = this;
        this.option = this.view.getOptions().legends;
        // \u5DF2\u7ECF\u5904\u7406\u8FC7\u7684 legend
        var updated = {};
        var eachLegend = function (geometry, attr, scale) {
            var id = _this.getId(scale.field);
            var existCo = _this.getComponentById(id);
            // \u5B58\u5728\u5219 update
            if (existCo) {
                var cfg = void 0;
                var legendOption = getLegendOption(_this.option, scale.field);
                // if the legend option is not false, means legend should be created.
                if (legendOption !== false) {
                    if ((0,esm/* get */.U2)(legendOption, 'custom')) {
                        cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);
                    }
                    else {
                        if (scale.isLinear) {
                            // linear field, create continuous legend
                            cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);
                        }
                        else if (scale.isCategory) {
                            // category field, create category legend
                            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);
                        }
                    }
                }
                // \u5982\u679C cfg \u4E3A\u7A7A\uFF0C\u5219\u4E0D\u5728 updated \u6807\u8BB0\uFF0C\u90A3\u4E48\u4F1A\u5728\u540E\u9762\u903B\u8F91\u4E2D\u5220\u9664
                if (cfg) {
                    // omit \u6389\u4E00\u4E9B\u5C5E\u6027\uFF0C\u6BD4\u5982 container \u7B49
                    omit(cfg, ['container']);
                    existCo.direction = getDirection(legendOption);
                    existCo.component.update(cfg);
                    // \u6807\u8BB0\u4E3A\u65B0\u7684
                    updated[id] = true;
                }
            }
            else {
                // \u4E0D\u5B58\u5728\u5219 create
                var legend = _this.createFieldLegend(geometry, attr, scale);
                if (legend) {
                    legend.component.init();
                    _this.components.push(legend);
                    // \u6807\u8BB0\u4E3A\u65B0\u7684
                    updated[id] = true;
                }
            }
        };
        // \u5168\u5C40\u81EA\u5B9A\u4E49\u56FE\u4F8B
        if ((0,esm/* get */.U2)(this.option, 'custom')) {
            var id = 'global-custom';
            var existCo = this.getComponentById(id);
            if (existCo) {
                var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);
                omit(customCfg, ['container']);
                existCo.component.update(customCfg);
                updated[id] = true;
            }
            else {
                var component = this.createCustomLegend(undefined, undefined, undefined, this.option);
                if (component) {
                    component.init();
                    var layer = LAYER.FORE;
                    var direction = getDirection(this.option);
                    this.components.push({
                        id: id,
                        component: component,
                        layer: layer,
                        direction: direction,
                        type: COMPONENT_TYPE.LEGEND,
                        extra: undefined,
                    });
                    // \u6807\u8BB0\u4E3A\u66F4\u65B0
                    updated[id] = true;
                }
            }
        }
        else {
            // \u904D\u5386\u5904\u7406\u6BCF\u4E00\u4E2A\u521B\u5EFA\u903B\u8F91
            this.loopLegends(eachLegend);
        }
        // \u5904\u7406\u5B8C\u6210\u4E4B\u540E\uFF0C\u9500\u6BC1\u5220\u9664\u7684
        // \u4E0D\u5728\u5904\u7406\u4E2D\u7684
        var components = [];
        (0,esm/* each */.S6)(this.getComponents(), function (co) {
            if (updated[co.id]) {
                components.push(co);
            }
            else {
                co.component.destroy();
            }
        });
        // \u66F4\u65B0\u5F53\u524D\u5DF2\u6709\u7684 components
        this.components = components;
    };
    Legend.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.container.clear();
    };
    Legend.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.container.remove(true);
    };
    /**
     * \u9012\u5F52\u83B7\u53D6\u6240\u6709\u7684 Geometry
     */
    Legend.prototype.getGeometries = function (view) {
        var _this = this;
        var geometries = view.geometries;
        (0,esm/* each */.S6)(view.views, function (v) {
            geometries = geometries.concat(_this.getGeometries(v));
        });
        return geometries;
    };
    /**
     * \u904D\u5386 Geometry\uFF0C\u5904\u7406 legend \u903B\u8F91
     * @param doEach \u6BCF\u4E2A loop \u4E2D\u7684\u5904\u7406\u65B9\u6CD5
     */
    Legend.prototype.loopLegends = function (doEach) {
        var isRootView = this.view.getRootView() === this.view;
        // \u975E\u6839 view\uFF0C\u4E0D\u5904\u7406 legend
        if (!isRootView) {
            return;
        }
        // \u9012\u5F52 view \u4E2D\u6240\u6709\u7684 Geometry\uFF0C\u8FDB\u884C\u521B\u5EFA legend
        var geometries = this.getGeometries(this.view);
        var looped = {}; // \u9632\u6B62\u4E00\u4E2A\u5B57\u6BB5\u521B\u5EFA\u4E24\u4E2A legend
        (0,esm/* each */.S6)(geometries, function (geometry) {
            var attributes = geometry.getGroupAttributes();
            (0,esm/* each */.S6)(attributes, function (attr) {
                var scale = attr.getScale(attr.type);
                // \u5982\u679C\u5728\u89C6\u89C9\u901A\u9053\u4E0A\u6620\u5C04\u5E38\u91CF\u503C\uFF0C\u5982 size(2) shape('circle') \u4E0D\u521B\u5EFA legend
                if (!scale || scale.type === 'identity' || looped[scale.field]) {
                    return;
                }
                doEach(geometry, attr, scale);
                looped[scale.field] = true;
            });
        });
    };
    /**
     * \u521B\u5EFA\u4E00\u4E2A legend
     * @param geometry
     * @param attr
     * @param scale
     */
    Legend.prototype.createFieldLegend = function (geometry, attr, scale) {
        var component;
        var legendOption = getLegendOption(this.option, scale.field);
        var layer = LAYER.FORE;
        var direction = getDirection(legendOption);
        // if the legend option is not false, means legend should be created.
        if (legendOption !== false) {
            if ((0,esm/* get */.U2)(legendOption, 'custom')) {
                component = this.createCustomLegend(geometry, attr, scale, legendOption);
            }
            else {
                if (scale.isLinear) {
                    // linear field, create continuous legend
                    component = this.createContinuousLegend(geometry, attr, scale, legendOption);
                }
                else if (scale.isCategory) {
                    // category field, create category legend
                    component = this.createCategoryLegend(geometry, attr, scale, legendOption);
                }
            }
        }
        if (component) {
            component.set('field', scale.field);
            return {
                id: this.getId(scale.field),
                component: component,
                layer: layer,
                direction: direction,
                type: COMPONENT_TYPE.LEGEND,
                extra: { scale: scale },
            };
        }
    };
    /**
     * \u81EA\u5B9A\u4E49\u56FE\u4F8B\u4F7F\u7528 category \u56FE\u4F8B\u53BB\u6E32\u67D3
     * @param geometry
     * @param attr
     * @param scale
     * @param legendOption
     */
    Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {
        // \u76F4\u63A5\u4F7F\u7528 \u5206\u7C7B\u56FE\u4F8B\u6E32\u67D3
        var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);
        return new CategoryLegend(cfg);
    };
    /**
     * \u521B\u5EFA\u8FDE\u7EED\u56FE\u4F8B
     * @param geometry
     * @param attr
     * @param scale
     * @param legendOption
     */
    Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {
        var cfg = this.getContinuousCfg(geometry, attr, scale, omit(legendOption, ['value']));
        return new ContinuousLegend(cfg);
    };
    /**
     * \u521B\u5EFA\u5206\u7C7B\u56FE\u4F8B
     * @param geometry
     * @param attr
     * @param scale
     * @param legendOption
     */
    Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {
        var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);
        return new CategoryLegend(cfg);
    };
    /**
     * \u83B7\u5F97\u8FDE\u7EED\u56FE\u4F8B\u7684\u914D\u7F6E
     * @param geometry
     * @param attr
     * @param scale
     * @param legendOption
     */
    Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {
        var ticks = scale.getTicks();
        var containMin = (0,esm/* find */.sE)(ticks, function (tick) { return tick.value === 0; });
        var containMax = (0,esm/* find */.sE)(ticks, function (tick) { return tick.value === 1; });
        var items = ticks.map(function (tick) {
            var value = tick.value, tickValue = tick.tickValue;
            var attrValue = attr.mapping(scale.invert(value)).join('');
            return {
                value: tickValue,
                attrValue: attrValue,
                color: attrValue,
                scaleValue: value,
            };
        });
        if (!containMin) {
            items.push({
                value: scale.min,
                attrValue: attr.mapping(scale.invert(0)).join(''),
                color: attr.mapping(scale.invert(0)).join(''),
                scaleValue: 0,
            });
        }
        if (!containMax) {
            items.push({
                value: scale.max,
                attrValue: attr.mapping(scale.invert(1)).join(''),
                color: attr.mapping(scale.invert(1)).join(''),
                scaleValue: 1,
            });
        }
        // \u6392\u5E8F
        items.sort(function (a, b) { return a.value - b.value; });
        // \u8DDF attr \u76F8\u5173\u7684\u914D\u7F6E
        // size color \u533A\u522B\u7684\u914D\u7F6E
        var attrLegendCfg = {
            min: (0,esm/* head */.YM)(items).value,
            max: (0,esm/* last */.Z$)(items).value,
            colors: [],
            rail: {
                type: attr.type,
            },
            track: {},
        };
        if (attr.type === 'size') {
            attrLegendCfg.track = {
                style: {
                    // size \u7684\u9009\u4E2D\u524D\u666F\u8272\uFF0C\u5BF9\u4E8E color\uFF0C\u5219\u76F4\u63A5\u4F7F\u7528 color \u6807\u8BC6
                    // @ts-ignore
                    fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined,
                },
            };
        }
        if (attr.type === 'color') {
            attrLegendCfg.colors = items.map(function (item) { return item.attrValue; });
        }
        var container = this.container;
        // if position is not set, use top as default
        var direction = getDirection(legendOption);
        var layout = getLegendLayout(direction);
        var title = (0,esm/* get */.U2)(legendOption, 'title');
        if (title) {
            title = (0,esm/* deepMix */.b$)({
                text: getName(scale),
            }, title);
        }
        // \u57FA\u7840\u914D\u7F6E\uFF0C\u4ECE\u5F53\u524D\u6570\u636E\u4E2D\u8BFB\u5230\u7684\u914D\u7F6E
        attrLegendCfg.container = container;
        attrLegendCfg.layout = layout;
        attrLegendCfg.title = title;
        attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
        // @ts-ignore
        return this.mergeLegendCfg(attrLegendCfg, legendOption, 'continuous');
    };
    /**
     * \u83B7\u53D6\u5206\u7C7B\u56FE\u4F8B\u7684\u914D\u7F6E\u9879
     * @param geometry
     * @param attr
     * @param scale
     * @param custom
     * @param legendOption
     */
    Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {
        var container = this.container;
        // if position is not set, use top as default
        var direction = (0,esm/* get */.U2)(legendOption, 'position', constant_DIRECTION.BOTTOM);
        var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction);
        // the default marker style
        var themeMarker = (0,esm/* get */.U2)(legendTheme, ['marker']);
        var userMarker = (0,esm/* get */.U2)(legendOption, 'marker');
        var layout = getLegendLayout(direction);
        var themePageNavigator = (0,esm/* get */.U2)(legendTheme, ['pageNavigator']);
        var userPageNavigator = (0,esm/* get */.U2)(legendOption, 'pageNavigator');
        var items = custom
            ? getCustomLegendItems(themeMarker, userMarker, legendOption.items)
            : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);
        var title = (0,esm/* get */.U2)(legendOption, 'title');
        if (title) {
            title = (0,esm/* deepMix */.b$)({
                text: scale ? getName(scale) : '',
            }, title);
        }
        var maxWidthRatio = (0,esm/* get */.U2)(legendOption, 'maxWidthRatio');
        var maxHeightRatio = (0,esm/* get */.U2)(legendOption, 'maxHeightRatio');
        var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
        baseCfg.container = container;
        baseCfg.layout = layout;
        baseCfg.items = items;
        baseCfg.title = title;
        baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
        baseCfg.pageNavigator = (0,esm/* deepMix */.b$)({}, themePageNavigator, userPageNavigator);
        var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);
        if (categoryCfg.reversed) {
            // \u56FE\u4F8B\u9879\u9700\u8981\u9006\u5E8F
            categoryCfg.items.reverse();
        }
        var maxItemWidth = (0,esm/* get */.U2)(categoryCfg, 'maxItemWidth');
        if (maxItemWidth && maxItemWidth <= 1) {
            // \u8F6C\u6362\u6210\u50CF\u7D20\u503C
            categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
        }
        return categoryCfg;
    };
    /**
     * get legend config, use option > suggestion > theme
     * @param baseCfg
     * @param legendOption
     * @param direction
     */
    Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {
        var position = direction.split('-')[0];
        var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
        return (0,esm/* deepMix */.b$)({}, themeObject, baseCfg, legendOption);
    };
    /**
     * \u751F\u6210 id
     * @param key
     */
    Legend.prototype.getId = function (key) {
        return "".concat(this.name, "-").concat(key);
    };
    /**
     * \u6839\u636E id \u6765\u83B7\u53D6\u7EC4\u4EF6
     * @param id
     */
    Legend.prototype.getComponentById = function (id) {
        return (0,esm/* find */.sE)(this.components, function (co) { return co.id === id; });
    };
    Legend.prototype.getCategoryLegendSizeCfg = function (layout, maxWidthRatio, maxHeightRatio) {
        if (maxWidthRatio === void 0) { maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE; }
        if (maxHeightRatio === void 0) { maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE; }
        var _a = this.view.viewBBox, vw = _a.width, vh = _a.height;
        // \u76EE\u524D legend \u7684\u5E03\u5C40\u662F\u4EE5 viewBBox \u4E3A\u53C2\u7167
        // const { width: cw, height: ch } = this.view.coordinateBBox;
        return layout === 'vertical'
            ? {
                maxWidth: vw * maxWidthRatio,
                maxHeight: vh,
            }
            : {
                maxWidth: vw,
                maxHeight: vh * maxHeightRatio,
            };
    };
    return Legend;
}(Controller));
/* harmony default export */ var legend = (Legend);
//# sourceMappingURL=legend.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/slider.js








/**
 * @ignore
 * slider Controller
 */
var Slider = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Slider, _super);
    function Slider(view) {
        var _this = _super.call(this, view) || this;
        _this.onChangeFn = esm/* noop */.ZT;
        /**
         * \u6E05\u9664\u6D4B\u91CF
         */
        _this.resetMeasure = function () {
            _this.clear();
        };
        /**
         * \u6ED1\u5757\u6ED1\u52A8\u7684\u65F6\u5019\u51FA\u53D1
         * @param v
         */
        _this.onValueChange = function (v) {
            var _a = (0,tslib_es6/* __read */.CR)(v, 2), min = _a[0], max = _a[1];
            _this.start = min;
            _this.end = max;
            _this.changeViewData(min, max);
        };
        _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
        _this.onChangeFn = (0,esm/* throttle */.P2)(_this.onValueChange, 20, {
            leading: true,
        });
        _this.width = 0;
        _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
        _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
        return _this;
    }
    Object.defineProperty(Slider.prototype, "name", {
        get: function () {
            return 'slider';
        },
        enumerable: false,
        configurable: true
    });
    Slider.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
        this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    /**
     * \u521D\u59CB\u5316
     */
    Slider.prototype.init = function () { };
    /**
     * \u6E32\u67D3
     */
    Slider.prototype.render = function () {
        this.option = this.view.getOptions().slider;
        var _a = this.getSliderCfg(), start = _a.start, end = _a.end;
        if ((0,esm/* isNil */.UM)(this.start)) {
            this.start = start;
            this.end = end;
        }
        var viewData = this.view.getOptions().data;
        if (this.option && !(0,esm/* isEmpty */.xb)(viewData)) {
            if (this.slider) {
                // exist, update
                this.slider = this.updateSlider();
            }
            else {
                // not exist, create
                this.slider = this.createSlider();
                // \u76D1\u542C\u4E8B\u4EF6\uFF0C\u7ED1\u5B9A\u4EA4\u4E92
                this.slider.component.on('sliderchange', this.onChangeFn);
            }
        }
        else {
            if (this.slider) {
                // exist, destroy
                this.slider.component.destroy();
                this.slider = undefined;
            }
            else {
                // do nothing
            }
        }
    };
    /**
     * \u5E03\u5C40
     */
    Slider.prototype.layout = function () {
        var _this = this;
        if (this.option && !this.width) {
            this.measureSlider();
            setTimeout(function () {
                // \u521D\u59CB\u72B6\u6001\u4E0B\u7684 view \u6570\u636E\u8FC7\u6EE4
                if (!_this.view.destroyed) {
                    _this.changeViewData(_this.start, _this.end);
                }
            }, 0);
        }
        if (this.slider) {
            var width = this.view.coordinateBBox.width;
            // \u83B7\u53D6\u7EC4\u4EF6\u7684 layout bbox
            var padding = this.slider.component.get('padding');
            var _a = (0,tslib_es6/* __read */.CR)(padding, 4), paddingTop = _a[0], paddingRight = _a[1], paddingBottom = _a[2], paddingLeft = _a[3];
            var bboxObject = this.slider.component.getLayoutBBox();
            var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
            var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText;
            var _c = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.viewBBox, bbox, constant_DIRECTION.BOTTOM), 2), x1 = _c[0], y1 = _c[1];
            var _d = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.coordinateBBox, bbox, constant_DIRECTION.BOTTOM), 2), x2 = _d[0], y2 = _d[1];
            // \u9ED8\u8BA4\u653E\u5728 bottom
            this.slider.component.update((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText: minText, maxText: maxText }));
            this.view.viewBBox = this.view.viewBBox.cut(bbox, constant_DIRECTION.BOTTOM);
        }
    };
    /**
     * \u66F4\u65B0
     */
    Slider.prototype.update = function () {
        // \u903B\u8F91\u548C render \u4FDD\u6301\u4E00\u81F4
        this.render();
    };
    /**
     * \u521B\u5EFA slider \u7EC4\u4EF6
     */
    Slider.prototype.createSlider = function () {
        var cfg = this.getSliderCfg();
        // \u6DFB\u52A0 slider \u7EC4\u4EF6
        var component = new slider_Slider((0,tslib_es6/* __assign */.pi)({ container: this.container }, cfg));
        component.init();
        return {
            component: component,
            layer: LAYER.FORE,
            direction: constant_DIRECTION.BOTTOM,
            type: COMPONENT_TYPE.SLIDER,
        };
    };
    /**
     * \u66F4\u65B0\u914D\u7F6E
     */
    Slider.prototype.updateSlider = function () {
        var cfg = this.getSliderCfg();
        if (this.width) {
            var _a = this.getMinMaxText(this.start, this.end), minText = _a.minText, maxText = _a.maxText;
            cfg = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { width: this.width, start: this.start, end: this.end, minText: minText, maxText: maxText });
        }
        this.slider.component.update(cfg);
        return this.slider;
    };
    /**
     * \u8FDB\u884C\u6D4B\u91CF\u64CD\u4F5C
     */
    Slider.prototype.measureSlider = function () {
        var width = this.getSliderCfg().width;
        this.width = width;
    };
    /**
     * \u751F\u6210 slider \u914D\u7F6E
     */
    Slider.prototype.getSliderCfg = function () {
        var cfg = {
            height: 16,
            start: 0,
            end: 1,
            minText: '',
            maxText: '',
            x: 0,
            y: 0,
            width: this.view.coordinateBBox.width,
        };
        if ((0,esm/* isObject */.Kn)(this.option)) {
            // \u7528\u6237\u914D\u7F6E\u7684\u6570\u636E\uFF0C\u4F18\u5148\u7EA7\u66F4\u9AD8
            var trendCfg = (0,tslib_es6/* __assign */.pi)({ data: this.getData() }, (0,esm/* get */.U2)(this.option, 'trendCfg', {}));
            // \u56E0\u4E3A\u6709\u6837\u5F0F\uFF0C\u6240\u4EE5\u6DF1\u5C42\u8986\u76D6
            cfg = (0,esm/* deepMix */.b$)({}, cfg, this.getThemeOptions(), this.option);
            // trendCfg \u56E0\u4E3A\u6709\u6570\u636E\u6570\u7EC4\uFF0C\u6240\u4EE5\u4F7F\u7528\u6D45\u66FF\u6362
            cfg = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { trendCfg: trendCfg });
        }
        cfg.start = (0,esm/* clamp */.uZ)(Math.min((0,esm/* isNil */.UM)(cfg.start) ? 0 : cfg.start, (0,esm/* isNil */.UM)(cfg.end) ? 1 : cfg.end), 0, 1);
        cfg.end = (0,esm/* clamp */.uZ)(Math.max((0,esm/* isNil */.UM)(cfg.start) ? 0 : cfg.start, (0,esm/* isNil */.UM)(cfg.end) ? 1 : cfg.end), 0, 1);
        return cfg;
    };
    /**
     * \u4ECE view \u4E2D\u83B7\u53D6\u6570\u636E\uFF0C\u7F29\u7565\u8F74\u4F7F\u7528\u5168\u91CF\u7684\u6570\u636E
     */
    Slider.prototype.getData = function () {
        var data = this.view.getOptions().data;
        var _a = (0,tslib_es6/* __read */.CR)(this.view.getYScales(), 1), yScale = _a[0];
        var groupScales = this.view.getGroupScales();
        if (groupScales.length) {
            var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
            return data.reduce(function (pre, cur) {
                if (cur[field_1] === ticks_1[0]) {
                    pre.push(cur[yScale.field]);
                }
                return pre;
            }, []);
        }
        return data.map(function (datum) { return datum[yScale.field] || 0; });
    };
    /**
     * \u83B7\u53D6 slider \u7684\u4E3B\u9898\u914D\u7F6E
     */
    Slider.prototype.getThemeOptions = function () {
        var theme = this.view.getTheme();
        return (0,esm/* get */.U2)(theme, ['components', 'slider', 'common'], {});
    };
    /**
     * \u6839\u636E start/end \u548C\u5F53\u524D\u6570\u636E\u8BA1\u7B97\u51FA\u5F53\u524D\u7684 minText/maxText
     * @param min
     * @param max
     */
    Slider.prototype.getMinMaxText = function (min, max) {
        var data = this.view.getOptions().data;
        var xScale = this.view.getXScale();
        var isHorizontal = true;
        var values = (0,esm/* valuesOfKey */.I)(data, xScale.field);
        // \u5982\u679C\u662F xScale \u6570\u503C\u7C7B\u578B\uFF0C\u5219\u8FDB\u884C\u6392\u5E8F
        if (xScale.isLinear) {
            values = values.sort();
        }
        var xValues = isHorizontal ? values : values.reverse();
        var dataSize = (0,esm/* size */.dp)(data);
        if (!xScale || !dataSize) {
            return {}; // fix: \u9700\u8981\u517C\u5BB9\uFF0C\u5426\u5219\u8C03\u7528\u65B9\u76F4\u63A5\u53D6\u503C\u4F1A\u62A5\u9519
        }
        var xTickCount = (0,esm/* size */.dp)(xValues);
        var minIndex = Math.round(min * (xTickCount - 1));
        var maxIndex = Math.round(max * (xTickCount - 1));
        var minText = (0,esm/* get */.U2)(xValues, [minIndex]);
        var maxText = (0,esm/* get */.U2)(xValues, [maxIndex]);
        var formatter = this.getSliderCfg().formatter;
        if (formatter) {
            minText = formatter(minText, data[minIndex], minIndex);
            maxText = formatter(maxText, data[maxIndex], maxIndex);
        }
        return {
            minText: minText,
            maxText: maxText,
        };
    };
    /**
     * \u66F4\u65B0 view \u8FC7\u6EE4\u6570\u636E
     * @param min
     * @param max
     */
    Slider.prototype.changeViewData = function (min, max) {
        var data = this.view.getOptions().data;
        var xScale = this.view.getXScale();
        var dataSize = (0,esm/* size */.dp)(data);
        if (!xScale || !dataSize) {
            return;
        }
        var isHorizontal = true;
        var values = (0,esm/* valuesOfKey */.I)(data, xScale.field);
        // \u5982\u679C\u662F xScale \u6570\u503C\u7C7B\u578B\uFF0C\u5219\u8FDB\u884C\u6392\u5E8F
        var xScaleValues = this.view.getXScale().isLinear ? values.sort(function (a, b) { return Number(a) - Number(b); }) : values;
        var xValues = isHorizontal ? xScaleValues : xScaleValues.reverse();
        var xTickCount = (0,esm/* size */.dp)(xValues);
        var minIndex = Math.round(min * (xTickCount - 1));
        var maxIndex = Math.round(max * (xTickCount - 1));
        // \u589E\u52A0 x \u8F74\u7684\u8FC7\u6EE4\u5668
        this.view.filter(xScale.field, function (value, datum) {
            var idx = xValues.indexOf(value);
            return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;
        });
        this.view.render(true);
    };
    /**
     * \u8986\u5199\u7236\u7C7B\u65B9\u6CD5
     */
    Slider.prototype.getComponents = function () {
        return this.slider ? [this.slider] : [];
    };
    /**
     * \u8986\u76D6\u7236\u7C7B
     */
    Slider.prototype.clear = function () {
        if (this.slider) {
            this.slider.component.destroy();
            this.slider = undefined;
        }
        this.width = 0;
        this.start = undefined;
        this.end = undefined;
    };
    return Slider;
}(Controller));
/* harmony default export */ var controller_slider = (Slider);
//# sourceMappingURL=slider.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/chart/controller/scrollbar.js








var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Scrollbar, _super);
    function Scrollbar(view) {
        var _this = _super.call(this, view) || this;
        _this.onChangeFn = esm/* noop */.ZT;
        _this.resetMeasure = function () {
            _this.clear();
        };
        _this.onValueChange = function (_a) {
            var ratio = _a.ratio;
            var animate = _this.getValidScrollbarCfg().animate;
            _this.ratio = (0,esm/* clamp */.uZ)(ratio, 0, 1);
            var originalAnimate = _this.view.getOptions().animate;
            if (!animate) {
                _this.view.animate(false);
            }
            _this.changeViewData(_this.getScrollRange(), true);
            _this.view.animate(originalAnimate);
        };
        _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
        _this.onChangeFn = (0,esm/* throttle */.P2)(_this.onValueChange, 20, {
            leading: true,
        });
        _this.trackLen = 0;
        _this.thumbLen = 0;
        _this.ratio = 0;
        _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
        _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
        return _this;
    }
    Object.defineProperty(Scrollbar.prototype, "name", {
        get: function () {
            return 'scrollbar';
        },
        enumerable: false,
        configurable: true
    });
    Scrollbar.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
        this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Scrollbar.prototype.init = function () { };
    /**
     * \u6E32\u67D3
     */
    Scrollbar.prototype.render = function () {
        this.option = this.view.getOptions().scrollbar;
        if (this.option) {
            if (this.scrollbar) {
                // exist, update
                this.scrollbar = this.updateScrollbar();
            }
            else {
                // not exist, create
                this.scrollbar = this.createScrollbar();
                this.scrollbar.component.on('scrollchange', this.onChangeFn);
            }
        }
        else {
            if (this.scrollbar) {
                // exist, destroy
                this.scrollbar.component.destroy();
                this.scrollbar = undefined;
            }
        }
    };
    /**
     * \u5E03\u5C40
     */
    Scrollbar.prototype.layout = function () {
        var _this = this;
        if (this.option && !this.trackLen) {
            this.measureScrollbar();
            setTimeout(function () {
                if (!_this.view.destroyed) {
                    _this.changeViewData(_this.getScrollRange(), true);
                }
            });
        }
        if (this.scrollbar) {
            var width = this.view.coordinateBBox.width;
            var padding = this.scrollbar.component.get('padding');
            var bboxObject = this.scrollbar.component.getLayoutBBox();
            var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
            var cfg = this.getScrollbarComponentCfg();
            var x = void 0;
            var y = void 0;
            if (cfg.isHorizontal) {
                var _a = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.viewBBox, bbox, constant_DIRECTION.BOTTOM), 2), x1 = _a[0], y1 = _a[1];
                var _b = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.coordinateBBox, bbox, constant_DIRECTION.BOTTOM), 2), x2 = _b[0], y2 = _b[1];
                x = x2;
                y = y1;
            }
            else {
                var _c = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.viewBBox, bbox, constant_DIRECTION.RIGHT), 2), x1 = _c[0], y1 = _c[1];
                var _d = (0,tslib_es6/* __read */.CR)(directionToPosition(this.view.viewBBox, bbox, constant_DIRECTION.RIGHT), 2), x2 = _d[0], y2 = _d[1];
                x = x2;
                y = y1;
            }
            x += padding[3];
            y += padding[0];
            // \u9ED8\u8BA4\u653E\u5728 bottom
            if (this.trackLen) {
                this.scrollbar.component.update((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { x: x, y: y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
            }
            else {
                this.scrollbar.component.update((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), { x: x, y: y }));
            }
            this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? constant_DIRECTION.BOTTOM : constant_DIRECTION.RIGHT);
        }
    };
    /**
     * \u66F4\u65B0
     */
    Scrollbar.prototype.update = function () {
        // \u903B\u8F91\u548C render \u4FDD\u6301\u4E00\u81F4
        this.render();
    };
    Scrollbar.prototype.getComponents = function () {
        return this.scrollbar ? [this.scrollbar] : [];
    };
    Scrollbar.prototype.clear = function () {
        if (this.scrollbar) {
            this.scrollbar.component.destroy();
            this.scrollbar = undefined;
        }
        this.trackLen = 0;
        this.thumbLen = 0;
        this.ratio = 0;
        this.cnt = 0;
        this.step = 0;
        this.data = undefined;
        this.xScaleCfg = undefined;
        this.yScalesCfg = [];
    };
    /** \u8BBE\u7F6E\u6EDA\u52A8\u6761\u4F4D\u7F6E  */
    Scrollbar.prototype.setValue = function (ratio) {
        this.onValueChange({ ratio: ratio });
    };
    /** \u83B7\u5F97\u6EDA\u52A8\u6761\u4F4D\u7F6E  */
    Scrollbar.prototype.getValue = function () {
        return this.ratio;
    };
    /**
     * \u83B7\u53D6 scrollbar \u7684\u4E3B\u9898\u914D\u7F6E
     */
    Scrollbar.prototype.getThemeOptions = function () {
        var theme = this.view.getTheme();
        return (0,esm/* get */.U2)(theme, ['components', 'scrollbar', 'common'], {});
    };
    /**
     * \u83B7\u53D6 scrollbar \u7EC4\u4EF6\u7684\u4E3B\u9898\u6837\u5F0F
     */
    Scrollbar.prototype.getScrollbarTheme = function (style) {
        var theme = (0,esm/* get */.U2)(this.view.getTheme(), ['components', 'scrollbar']);
        var _a = style || {}, thumbHighlightColor = _a.thumbHighlightColor, restStyles = (0,tslib_es6/* __rest */._T)(_a, ["thumbHighlightColor"]);
        return {
            default: (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(theme, ['default', 'style'], {}), restStyles),
            hover: (0,esm/* deepMix */.b$)({}, (0,esm/* get */.U2)(theme, ['hover', 'style'], {}), { thumbColor: thumbHighlightColor }),
        };
    };
    Scrollbar.prototype.measureScrollbar = function () {
        var xScale = this.view.getXScale();
        var yScales = this.view.getYScales().slice();
        this.data = this.getScrollbarData();
        this.step = this.getStep();
        this.cnt = this.getCnt();
        var _a = this.getScrollbarComponentCfg(), trackLen = _a.trackLen, thumbLen = _a.thumbLen;
        this.trackLen = trackLen;
        this.thumbLen = thumbLen;
        this.xScaleCfg = {
            field: xScale.field,
            values: xScale.values || [],
        };
        this.yScalesCfg = yScales;
    };
    Scrollbar.prototype.getScrollRange = function () {
        var startIdx = Math.floor((this.cnt - this.step) * (0,esm/* clamp */.uZ)(this.ratio, 0, 1));
        var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
        return [startIdx, endIdx];
    };
    Scrollbar.prototype.changeViewData = function (_a, render) {
        var _this = this;
        var _b = (0,tslib_es6/* __read */.CR)(_a, 2), startIdx = _b[0], endIdx = _b[1];
        var type = this.getValidScrollbarCfg().type;
        var isHorizontal = type !== 'vertical';
        var values = (0,esm/* valuesOfKey */.I)(this.data, this.xScaleCfg.field);
        // \u5982\u679C\u662F xScale \u6570\u503C\u7C7B\u578B\uFF0C\u5219\u8FDB\u884C\u6392\u5E8F
        var xScaleValues = this.view.getXScale().isLinear ? values.sort(function (a, b) { return Number(a) - Number(b); }) : values;
        var xValues = isHorizontal ? xScaleValues : xScaleValues.reverse();
        this.yScalesCfg.forEach(function (cfg) {
            _this.view.scale(cfg.field, {
                formatter: cfg.formatter,
                type: cfg.type,
                min: cfg.min,
                max: cfg.max,
                tickMethod: cfg.tickMethod
            });
        });
        this.view.filter(this.xScaleCfg.field, function (val) {
            var idx = xValues.indexOf(val);
            return idx > -1 ? isBetween(idx, startIdx, endIdx) : true;
        });
        this.view.render(true);
    };
    Scrollbar.prototype.createScrollbar = function () {
        var type = this.getValidScrollbarCfg().type;
        var isHorizontal = type !== 'vertical';
        var component = new scrollbar_Scrollbar((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
        component.init();
        return {
            component: component,
            layer: LAYER.FORE,
            direction: isHorizontal ? constant_DIRECTION.BOTTOM : constant_DIRECTION.RIGHT,
            type: COMPONENT_TYPE.SCROLLBAR,
        };
    };
    Scrollbar.prototype.updateScrollbar = function () {
        var config = this.getScrollbarComponentCfg();
        var realConfig = this.trackLen
            ? (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : (0,tslib_es6/* __assign */.pi)({}, config);
        this.scrollbar.component.update(realConfig);
        return this.scrollbar;
    };
    Scrollbar.prototype.getStep = function () {
        if (this.step) {
            return this.step;
        }
        var coordinateBBox = this.view.coordinateBBox;
        var _a = this.getValidScrollbarCfg(), type = _a.type, categorySize = _a.categorySize;
        var isHorizontal = type !== 'vertical';
        return Math.floor((isHorizontal ? coordinateBBox.width : coordinateBBox.height) / categorySize);
    };
    Scrollbar.prototype.getCnt = function () {
        if (this.cnt) {
            return this.cnt;
        }
        var xScale = this.view.getXScale();
        var data = this.getScrollbarData();
        var values = (0,esm/* valuesOfKey */.I)(data, xScale.field);
        return (0,esm/* size */.dp)(values);
    };
    Scrollbar.prototype.getScrollbarComponentCfg = function () {
        var _a = this.view, coordinateBBox = _a.coordinateBBox, viewBBox = _a.viewBBox;
        var _b = this.getValidScrollbarCfg(), type = _b.type, padding = _b.padding, width = _b.width, height = _b.height, style = _b.style;
        var isHorizontal = type !== 'vertical';
        var _c = (0,tslib_es6/* __read */.CR)(padding, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
        var position = isHorizontal
            ? {
                x: coordinateBBox.minX + paddingLeft,
                y: viewBBox.maxY - height - paddingBottom,
            }
            : {
                x: viewBBox.maxX - width - paddingRight,
                y: coordinateBBox.minY + paddingTop,
            };
        var step = this.getStep();
        var cnt = this.getCnt();
        var trackLen = isHorizontal
            ? coordinateBBox.width - paddingLeft - paddingRight
            : coordinateBBox.height - paddingTop - paddingBottom;
        var thumbLen = Math.max(trackLen * (0,esm/* clamp */.uZ)(step / cnt, 0, 1), MIN_THUMB_LENGTH);
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal ? height : width, isHorizontal: isHorizontal, trackLen: trackLen, thumbLen: thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
    };
    /**
     * \u586B\u5145\u4E00\u4E9B\u9ED8\u8BA4\u7684\u914D\u7F6E\u9879\u76EE
     */
    Scrollbar.prototype.getValidScrollbarCfg = function () {
        var cfg = {
            type: 'horizontal',
            categorySize: DEFAULT_CATEGORY_SIZE,
            width: DEFAULT_SIZE,
            height: DEFAULT_SIZE,
            padding: [0, 0, 0, 0],
            animate: true,
            style: {},
        };
        if ((0,esm/* isObject */.Kn)(this.option)) {
            cfg = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, cfg), this.option);
        }
        if (!(0,esm/* isObject */.Kn)(this.option) || !this.option.padding) {
            cfg.padding =
                cfg.type === 'horizontal' ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
        }
        return cfg;
    };
    /**
     * \u83B7\u53D6\u6570\u636E
     */
    Scrollbar.prototype.getScrollbarData = function () {
        var coordinate = this.view.getCoordinate();
        var cfg = this.getValidScrollbarCfg();
        var data = this.view.getOptions().data || [];
        // \u7EB5\u5411\u505A\u4E86 y \u8F74\u955C\u50CF\u4E4B\u540E\uFF0C\u6570\u636E\u4E5F\u9700\u8981\u955C\u50CF\u53CD\u8F6C
        if (coordinate.isReflect('y') && cfg.type === 'vertical') {
            data = (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(data), false).reverse();
        }
        return data;
    };
    return Scrollbar;
}(Controller));
/* harmony default export */ var scrollbar = (Scrollbar);
//# sourceMappingURL=scrollbar.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/active-region.js





var DEFAULT_REGION_PATH_STYLE = {
    fill: '#CCD6EC',
    opacity: 0.3,
};
function getItemsOfView(view, point, tooltipCfg) {
    var e_1, _a, e_2, _b, e_3, _c;
    var items = findItemsFromViewRecurisive(view, point, tooltipCfg);
    if (items.length) {
        // \u4E09\u5C42
        items = (0,esm/* flatten */.xH)(items);
        try {
            for (var items_1 = (0,tslib_es6/* __values */.XA)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var itemArr = items_1_1.value;
                try {
                    for (var itemArr_1 = (e_2 = void 0, (0,tslib_es6/* __values */.XA)(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
                        var item = itemArr_1_1.value;
                        var _d = item.mappingData, x = _d.x, y = _d.y;
                        item.x = (0,esm/* isArray */.kJ)(x) ? x[x.length - 1] : x;
                        item.y = (0,esm/* isArray */.kJ)(y) ? y[y.length - 1] : y;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return)) _b.call(itemArr_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var shared = tooltipCfg.shared;
        // shared: false \u4EE3\u8868\u53EA\u663E\u793A\u5F53\u524D\u62FE\u53D6\u5230\u7684 shape \u7684\u6570\u636E\uFF0C\u4F46\u662F\u4E00\u4E2A view \u4F1A\u6709\u591A\u4E2A Geometry\uFF0C\u6240\u4EE5\u6709\u53EF\u80FD\u4F1A\u62FE\u53D6\u5230\u591A\u4E2A shape
        if (shared === false && items.length > 1) {
            var snapItem = items[0];
            var min = Math.abs(point.y - snapItem[0].y);
            try {
                for (var items_2 = (0,tslib_es6/* __values */.XA)(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                    var aItem = items_2_1.value;
                    var yDistance = Math.abs(point.y - aItem[0].y);
                    if (yDistance <= min) {
                        snapItem = aItem;
                        min = yDistance;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
            items = [snapItem];
        }
        return (0,esm/* uniq */.jj)((0,esm/* flatten */.xH)(items));
    }
    return [];
}
/**
 * \u80CC\u666F\u6846\u7684 Action. \u53EA\u4F5C\u7528\u4E8E interval \u548C schema geometry
 * @ignore
 */
var ActiveRegion = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ActiveRegion, _super);
    function ActiveRegion() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u663E\u793A
     * @param {ShapeAttrs} style region-path \u7684\u6837\u5F0F
     * @param {number} appendRatio \u9002\u7528\u4E8E\u7B1B\u5361\u5C14\u5750\u6807\u7CFB. \u5BF9\u4E8E x \u8F74\u975E linear \u7C7B\u578B: \u9ED8\u8BA4\uFF1A0.25, x \u8F74 linear \u7C7B\u578B: \u9ED8\u8BA4 0
     * @param {number} appendWidth  \u9002\u7528\u4E8E\u7B1B\u5361\u5C14\u5750\u6807\u7CFB. \u50CF\u7D20\u7EA7\u522B\uFF0C\u4F18\u5148\u7EA7 > appendRatio
     */
    ActiveRegion.prototype.show = function (args) {
        var view = this.context.view;
        var ev = this.context.event;
        var tooltipCfg = view.getController('tooltip').getTooltipCfg();
        var tooltipItems = getItemsOfView(view, {
            x: ev.x,
            y: ev.y,
        }, tooltipCfg);
        if ((0,esm/* isEqual */.Xy)(tooltipItems, this.items)) {
            // \u5982\u679C\u62FE\u53D6\u6570\u636E\u540C\u4E0A\u6B21\u76F8\u540C\uFF0C\u5219\u4E0D\u91CD\u590D\u7ED8\u5236
            return;
        }
        this.items = tooltipItems;
        if (tooltipItems.length) {
            var xField_1 = view.getXScale().field;
            var xValue_1 = tooltipItems[0].data[xField_1];
            // \u6839\u636E x \u5BF9\u5E94\u7684\u503C\u67E5\u627E elements
            var elements_1 = [];
            var geometries = view.geometries;
            (0,esm/* each */.S6)(geometries, function (geometry) {
                if (geometry.type === 'interval' || geometry.type === 'schema') {
                    var result = geometry.getElementsBy(function (ele) {
                        var eleData = ele.getData();
                        return eleData[xField_1] === xValue_1;
                    });
                    elements_1 = elements_1.concat(result);
                }
            });
            // \u6839\u636E bbox \u8BA1\u7B97\u80CC\u666F\u6846\u7684\u9762\u79EF\u533A\u57DF
            if (elements_1.length) {
                var coordinate_1 = view.getCoordinate();
                var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
                var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
                var groupBBox_1 = firstBBox_1;
                (0,esm/* each */.S6)(elements_1, function (ele) {
                    var bbox = ele.shape.getCanvasBBox();
                    if (coordinate_1.isTransposed) {
                        if (bbox.minY < firstBBox_1.minY) {
                            firstBBox_1 = bbox;
                        }
                        if (bbox.maxY > lastBBox_1.maxY) {
                            lastBBox_1 = bbox;
                        }
                    }
                    else {
                        if (bbox.minX < firstBBox_1.minX) {
                            firstBBox_1 = bbox;
                        }
                        if (bbox.maxX > lastBBox_1.maxX) {
                            lastBBox_1 = bbox;
                        }
                    }
                    groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
                    groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
                    groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
                    groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
                });
                var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
                var path = void 0;
                if (coordinate_1.isRect) {
                    var xScale = view.getXScale();
                    var _a = args || {}, appendRatio = _a.appendRatio, appendWidth = _a.appendWidth;
                    if ((0,esm/* isNil */.UM)(appendWidth)) {
                        appendRatio = (0,esm/* isNil */.UM)(appendRatio) ? (xScale.isLinear ? 0 : 0.25) : appendRatio; // \u5982\u679C x \u8F74\u662F\u6570\u503C\u7C7B\u578B\uFF0C\u5982\u76F4\u65B9\u56FE\uFF0C\u9ED8\u8BA4\u4E0D\u9700\u8981\u52A0\u989D\u5916\u7684\u5BBD\u5EA6
                        appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
                    }
                    var minX = void 0;
                    var minY = void 0;
                    var width = void 0;
                    var height = void 0;
                    if (coordinate_1.isTransposed) {
                        minX = coordinateBBox.minX;
                        minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
                        width = coordinateBBox.width;
                        height = groupBBox_1.height + appendWidth * 2;
                    }
                    else {
                        minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
                        // \u76F4\u89D2\u5750\u6807\u7CFB \u975E\u8F6C\u7F6E\uFF1A\u6700\u5C0F\u503C\u76F4\u63A5\u53D6 \u5750\u6807\u7CFB minY
                        minY = coordinateBBox.minY;
                        width = groupBBox_1.width + appendWidth * 2;
                        height = coordinateBBox.height;
                    }
                    path = [
                        ['M', minX, minY],
                        ['L', minX + width, minY],
                        ['L', minX + width, minY + height],
                        ['L', minX, minY + height],
                        ['Z'],
                    ];
                }
                else {
                    var firstElement = (0,esm/* head */.YM)(elements_1);
                    var lastElement = (0,esm/* last */.Z$)(elements_1);
                    var startAngle = getAngle(firstElement.getModel(), coordinate_1).startAngle;
                    var endAngle = getAngle(lastElement.getModel(), coordinate_1).endAngle;
                    var center = coordinate_1.getCenter();
                    var radius = coordinate_1.getRadius();
                    var innterRadius = coordinate_1.innerRadius * radius;
                    path = getSectorPath(center.x, center.y, radius, startAngle, endAngle, innterRadius);
                }
                if (this.regionPath) {
                    this.regionPath.attr('path', path);
                    this.regionPath.show();
                }
                else {
                    var style = (0,esm/* get */.U2)(args, 'style', DEFAULT_REGION_PATH_STYLE);
                    this.regionPath = backgroundGroup.addShape({
                        type: 'path',
                        name: 'active-region',
                        capture: false,
                        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, style), { path: path }),
                    });
                }
            }
        }
    };
    /**
     * \u9690\u85CF
     */
    ActiveRegion.prototype.hide = function () {
        if (this.regionPath) {
            this.regionPath.hide();
        }
        // this.regionPath = null;
        this.items = null;
    };
    /**
     * \u9500\u6BC1
     */
    ActiveRegion.prototype.destroy = function () {
        this.hide();
        if (this.regionPath) {
            this.regionPath.remove(true);
        }
        _super.prototype.destroy.call(this);
    };
    return ActiveRegion;
}(action_base));
/* harmony default export */ var active_region = (ActiveRegion);
//# sourceMappingURL=active-region.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js



/**
 * Tooltip \u5C55\u793A\u9690\u85CF\u7684 Action
 * @ignore
 */
var TooltipAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TooltipAction, _super);
    function TooltipAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeStamp = 0;
        return _this;
    }
    /**
     * \u663E\u793A Tooltip
     * @returns
     */
    TooltipAction.prototype.show = function () {
        var context = this.context;
        var ev = context.event;
        var view = context.view;
        var isTooltipLocked = view.isTooltipLocked();
        if (isTooltipLocked) {
            // \u9501\u5B9A\u65F6\u4E0D\u79FB\u52A8 tooltip
            return;
        }
        var lastTimeStamp = this.timeStamp;
        var timeStamp = +new Date();
        // \u5728 showDelay \u6BEB\u79D2\uFF08\u9ED8\u8BA4 16ms\uFF09\u5185\u5230 tooltip \u4E0A\u53EF\u4EE5\u5B9E\u73B0 enterable\uFF08\u8C03\u53C2\u5DE5\u7A0B\u5E08\uFF09
        var showDelay = (0,esm/* get */.U2)(context.view.getOptions(), 'tooltip.showDelay', 16);
        if (timeStamp - lastTimeStamp > showDelay) {
            var preLoc = this.location;
            var curLoc = { x: ev.x, y: ev.y };
            if (!preLoc || !(0,esm/* isEqual */.Xy)(preLoc, curLoc)) {
                this.showTooltip(view, curLoc);
            }
            this.timeStamp = timeStamp;
            this.location = curLoc;
        }
    };
    /**
     * \u9690\u85CF Tooltip\u3002
     * @returns
     */
    TooltipAction.prototype.hide = function () {
        var view = this.context.view;
        var tooltip = view.getController('tooltip');
        var _a = this.context.event, clientX = _a.clientX, clientY = _a.clientY;
        // \u5982\u679C\u5DF2\u7ECF enterable + \u5DF2\u7ECF\u5728 tooltip \u4E0A\uFF0C\u90A3\u4E48\u4E0D\u9690\u85CF
        if (tooltip.isCursorEntered({ x: clientX, y: clientY })) {
            return;
        }
        // \u9501\u5B9A tooltip \u65F6\u4E0D\u9690\u85CF
        if (view.isTooltipLocked()) {
            return;
        }
        this.hideTooltip(view);
        this.location = null;
    };
    TooltipAction.prototype.showTooltip = function (view, point) {
        // \u76F8\u540C\u4F4D\u7F6E\u4E0D\u91CD\u590D\u5C55\u793A
        view.showTooltip(point);
    };
    TooltipAction.prototype.hideTooltip = function (view) {
        view.hideTooltip();
    };
    return TooltipAction;
}(action_base));
/* harmony default export */ var geometry = (TooltipAction);
//# sourceMappingURL=geometry.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js




/**
 * \u5B58\u5728\u591A\u4E2A view \u65F6\uFF0C\u63A7\u5236\u5176\u4ED6 view \u4E0A\u7684 tooltip \u663E\u793A
 * @ignore
 */
var SiblingTooltip = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SiblingTooltip, _super);
    function SiblingTooltip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u6240\u6709\u540C\u4E00\u5C42\u7EA7\u7684 tooltip \u663E\u793A
     * @param view
     * @param point
     */
    SiblingTooltip.prototype.showTooltip = function (view, point) {
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            var siblingPoint = getSiblingPoint(view, sibling, point);
            sibling.showTooltip(siblingPoint);
        });
    };
    /**
     * \u9690\u85CF\u540C\u4E00\u5C42\u7EA7\u7684 tooltip
     * @param view
     */
    SiblingTooltip.prototype.hideTooltip = function (view) {
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            sibling.hideTooltip();
        });
    };
    return SiblingTooltip;
}(geometry));
/* harmony default export */ var sibling = (SiblingTooltip);
//# sourceMappingURL=sibling.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js





/**
 * \u7528\u4E8E\u7EC4\u4EF6\u6587\u672C\u7701\u7565\u540E\u9700\u8981\u5C55\u793A\u5B8C\u6574\u4FE1\u606F\u7684 Tooltip Action
 * @ignore
 */
var EllipsisText = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(EllipsisText, _super);
    function EllipsisText() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeStamp = 0;
        return _this;
    }
    EllipsisText.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.tooltip && this.tooltip.destroy();
    };
    /**
     * \u663E\u793A Tooltip
     * @returns
     */
    EllipsisText.prototype.show = function () {
        var context = this.context;
        var ev = context.event;
        var lastTimeStamp = this.timeStamp;
        var timeStamp = +new Date();
        if (timeStamp - lastTimeStamp > 16) {
            var preLoc = this.location;
            var curLoc = { x: ev.x, y: ev.y };
            if (!preLoc || !(0,esm/* isEqual */.Xy)(preLoc, curLoc)) {
                this.showTooltip(curLoc);
            }
            this.timeStamp = timeStamp;
            this.location = curLoc;
        }
    };
    /**
     * \u9690\u85CF Tooltip\u3002
     * @returns
     */
    EllipsisText.prototype.hide = function () {
        this.hideTooltip();
        this.location = null;
    };
    EllipsisText.prototype.showTooltip = function (curLoc) {
        var context = this.context;
        var ev = context.event;
        var target = ev.target;
        if (target && target.get('tip')) {
            if (!this.tooltip) {
                this.renderTooltip(); // \u5EF6\u8FDF\u751F\u6210
            }
            var tipContent = target.get('tip');
            // \u5C55\u793A tooltip
            this.tooltip.update((0,tslib_es6/* __assign */.pi)({ title: tipContent }, curLoc));
            this.tooltip.show();
        }
    };
    EllipsisText.prototype.hideTooltip = function () {
        this.tooltip && this.tooltip.hide();
    };
    EllipsisText.prototype.renderTooltip = function () {
        var _a;
        var view = this.context.view;
        var canvas = view.canvas;
        var region = {
            start: { x: 0, y: 0 },
            end: { x: canvas.get('width'), y: canvas.get('height') },
        };
        var theme = view.getTheme();
        var tooltipStyles = (0,esm/* get */.U2)(theme, ['components', 'tooltip', 'domStyles'], {}); // \u83B7\u53D6 tooltip \u6837\u5F0F
        var tooltip = new HtmlTooltip({
            parent: canvas.get('el').parentNode,
            region: region,
            visible: false,
            crosshairs: null,
            domStyles: (0,tslib_es6/* __assign */.pi)({}, (0,esm/* deepMix */.b$)({}, tooltipStyles, (_a = {},
                // \u8D85\u957F\u7684\u65F6\u5019\uFF0Ctooltip tip \u6700\u5927\u5BBD\u5EA6\u4E3A 50%\uFF0C\u7136\u540E\u53EF\u4EE5\u6362\u884C
                _a[css_const_CONTAINER_CLASS] = { 'max-width': '50%' },
                _a[TITLE_CLASS] = { 'word-break': 'break-all' },
                _a))),
        });
        tooltip.init();
        tooltip.setCapture(false); // \u4E0D\u5141\u8BB8\u6355\u83B7\u4E8B\u4EF6
        this.tooltip = tooltip;
    };
    return EllipsisText;
}(action_base));
/* harmony default export */ var ellipsis_text = (EllipsisText);
//# sourceMappingURL=ellipsis-text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/state-base.js




/**
 * \u72B6\u6001\u91CF Action \u7684\u57FA\u7C7B
 * @abstract
 * @class
 * @ignore
 */
var StateBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(StateBase, _super);
    function StateBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * \u72B6\u6001\u540D\u79F0
         */
        _this.stateName = '';
        return _this;
    }
    /**
     * \u662F\u5426\u5177\u6709\u67D0\u4E2A\u72B6\u6001
     * @param element \u56FE\u8868 Element \u5143\u7D20
     */
    StateBase.prototype.hasState = function (element) {
        return element.hasState(this.stateName);
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001\u6FC0\u6D3B
     * @param enable \u72B6\u6001\u503C
     */
    StateBase.prototype.setElementState = function (element, enable) {
        // \u9632\u6B62\u95EA\u70C1
        element.setState(this.stateName, enable);
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001
     */
    StateBase.prototype.setState = function () {
        this.setStateEnable(true);
    };
    /**
     * \u6E05\u9664\u6240\u6709 Element \u7684\u72B6\u6001
     */
    StateBase.prototype.clear = function () {
        var view = this.context.view;
        this.clearViewState(view);
    };
    StateBase.prototype.clearViewState = function (view) {
        var _this = this;
        var elements = getElementsByState(view, this.stateName);
        (0,esm/* each */.S6)(elements, function (el) {
            _this.setElementState(el, false);
        });
    };
    return StateBase;
}(action_base));
/* harmony default export */ var state_base = (StateBase);
//# sourceMappingURL=state-base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/state.js




function getItem(shape) {
    return (0,esm/* get */.U2)(shape.get('delegateObject'), 'item');
}
/**
 * \u72B6\u6001\u91CF Action \u7684\u57FA\u7C7B\uFF0C\u5141\u8BB8\u591A\u4E2A Element \u540C\u65F6\u62E5\u6709\u67D0\u4E2A\u72B6\u6001
 * @class
 * @ignore
 */
var ElementState = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementState, _super);
    function ElementState() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.ignoreListItemStates = ['unchecked'];
        return _this;
    }
    // \u662F\u5426\u5FFD\u7565\u89E6\u53D1\u7684\u5217\u8868\u9879
    ElementState.prototype.isItemIgnore = function (item, list) {
        var states = this.ignoreListItemStates;
        var filtered = states.filter(function (state) {
            return list.hasState(item, state);
        });
        return !!filtered.length;
    };
    // \u8BBE\u7F6E\u7531\u7EC4\u4EF6\u9009\u9879\u5BFC\u81F4\u7684\u72B6\u6001\u53D8\u5316
    ElementState.prototype.setStateByComponent = function (component, item, enable) {
        var view = this.context.view;
        var field = component.get('field');
        var elements = getElements(view);
        this.setElementsStateByItem(elements, field, item, enable);
    };
    // \u5904\u7406\u89E6\u53D1\u6E90\u7531 element \u5BFC\u81F4\u7684\u72B6\u6001\u53D8\u5316
    ElementState.prototype.setStateByElement = function (element, enable) {
        this.setElementState(element, enable);
    };
    /** \u7EC4\u4EF6\u7684\u9009\u9879\u662F\u5426\u540C element \u5339\u914D */
    ElementState.prototype.isMathItem = function (element, field, item) {
        var view = this.context.view;
        var scale = getScaleByField(view, field);
        var value = getElementValue(element, field);
        return !(0,esm/* isNil */.UM)(value) && item.name === scale.getText(value);
    };
    ElementState.prototype.setElementsStateByItem = function (elements, field, item, enable) {
        var _this = this;
        (0,esm/* each */.S6)(elements, function (el) {
            if (_this.isMathItem(el, field, item)) {
                el.setState(_this.stateName, enable);
            }
        });
    };
    /** \u8BBE\u7F6E\u72B6\u6001\u662F\u5426\u6FC0\u6D3B */
    ElementState.prototype.setStateEnable = function (enable) {
        var element = getCurrentElement(this.context);
        if (element) {
            // \u89E6\u53D1\u6E90\u7531\u4E8E element \u5BFC\u81F4
            if (isElementChange(this.context)) {
                this.setStateByElement(element, enable);
            }
        }
        else {
            // \u89E6\u53D1\u6E90\u7531\u7EC4\u4EF6\u5BFC\u81F4
            var delegateObject = getDelegationObject(this.context);
            // \u5982\u679C\u89E6\u53D1\u6E90\u65F6\u5217\u8868\uFF0C\u56FE\u4F8B\u3001\u5750\u6807\u8F74
            if (isList(delegateObject)) {
                var item = delegateObject.item, component = delegateObject.component;
                if (item && component && !this.isItemIgnore(item, component)) {
                    var event_1 = this.context.event.gEvent;
                    // \u9632\u6B62\u95EA\u70C1
                    if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
                        return;
                    }
                    this.setStateByComponent(component, item, enable);
                }
            }
        }
    };
    /**
     * \u5207\u6362\u72B6\u6001
     */
    ElementState.prototype.toggle = function () {
        var element = getCurrentElement(this.context);
        if (element) {
            var hasState = element.hasState(this.stateName);
            this.setElementState(element, !hasState);
        }
    };
    /**
     * \u53D6\u6D88\u5F53\u524D\u65F6\u95F4\u5F71\u54CD\u7684\u72B6\u6001
     */
    ElementState.prototype.reset = function () {
        this.setStateEnable(false);
    };
    return ElementState;
}(state_base));
/* harmony default export */ var state = (ElementState);
//# sourceMappingURL=state.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/active.js


/**
 * \u5143\u7D20 active \u7684 Action\uFF0C\u5141\u8BB8\u591A\u4E2A\u5143\u7D20\u540C\u65F6 active
 * @class
 * @ignore
 */
var ElementActive = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementActive, _super);
    function ElementActive() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    /**
     * Active Element
     */
    ElementActive.prototype.active = function () {
        this.setState();
    };
    return ElementActive;
}(state));
/* harmony default export */ var active = (ElementActive);
//# sourceMappingURL=active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js




/**
 * Link Elements by color
 *
 * public \u65B9\u6CD5\u662F\u5BF9\u5916\u53EF\u7528\u7684\u53CD\u9988\u4EA4\u4E92\u3002\u4F7F\u7528\u65B9\u5F0F\uFF0C\u5982\uFF1Aelement-link-by-color:link, element-link-by-color:unlink, element-link-by-color:clear
 */
var LinkByColor = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(LinkByColor, _super);
    function LinkByColor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.cache = {};
        return _this;
    }
    // \u83B7\u53D6\u989C\u8272\u5BF9\u5E94\u7684 scale
    LinkByColor.prototype.getColorScale = function (view, element) {
        var colorAttr = element.geometry.getAttribute('color');
        if (!colorAttr) {
            return null;
        }
        var scale = view.getScaleByField(colorAttr.getFields()[0]);
        return scale;
    };
    // \u83B7\u53D6\u8FDE\u63A5\u7684 path
    LinkByColor.prototype.getLinkPath = function (element, nextElement) {
        var view = this.context.view;
        var isTransposed = view.getCoordinate().isTransposed;
        var bbox = element.shape.getCanvasBBox();
        var nextBBox = nextElement.shape.getCanvasBBox();
        var path = isTransposed
            ? [
                ['M', bbox.minX, bbox.minY],
                ['L', nextBBox.minX, nextBBox.maxY],
                ['L', nextBBox.maxX, nextBBox.maxY],
                ['L', bbox.maxX, bbox.minY],
                ['Z'],
            ]
            : [
                ['M', bbox.maxX, bbox.minY],
                ['L', nextBBox.minX, nextBBox.minY],
                ['L', nextBBox.minX, nextBBox.maxY],
                ['L', bbox.maxX, bbox.maxY],
                ['Z'],
            ];
        return path;
    };
    // \u6DFB\u52A0\u8FDE\u63A5\u7684\u56FE\u5F62
    LinkByColor.prototype.addLinkShape = function (group, element, nextElement, activeStyle) {
        var style = {
            opacity: 0.4,
            fill: element.shape.attr('fill'),
        };
        group.addShape({
            type: 'path',
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, (0,esm/* deepMix */.b$)({}, style, (0,esm/* isFunction */.mf)(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) }),
        });
    };
    // \u4F7F\u7528\u56FE\u5F62\u8FDE\u63A5
    LinkByColor.prototype.linkByElement = function (element, activeStyle) {
        var _this = this;
        var view = this.context.view;
        var scale = this.getColorScale(view, element);
        if (!scale) {
            return;
        }
        var value = getElementValue(element, scale.field);
        if (!this.cache[value]) {
            var elements_1 = getElementsByField(view, scale.field, value);
            var linkGroup = this.linkGroup;
            var group_1 = linkGroup.addGroup();
            this.cache[value] = group_1; // \u7F13\u5B58
            var count_1 = elements_1.length;
            (0,esm/* each */.S6)(elements_1, function (el, index) {
                if (index < count_1 - 1) {
                    var nextEl = elements_1[index + 1];
                    _this.addLinkShape(group_1, el, nextEl, activeStyle);
                }
            });
        }
    };
    // \u79FB\u9664\u8FDE\u63A5
    LinkByColor.prototype.removeLink = function (element) {
        var scale = this.getColorScale(this.context.view, element);
        if (!scale) {
            return;
        }
        var value = getElementValue(element, scale.field);
        if (this.cache[value]) {
            this.cache[value].remove();
            this.cache[value] = null;
        }
    };
    /**
     * \u8FDE\u63A5 elements
     *
     * @usage
     * registerInteraction('xxx', {
     *   start: [
     *    {
     *      trigger: 'interval:mouseenter',
     *      action: 'element-link-by-color:link',
     *      arg: {
     *        // style: { fill: 'red' }
     *        style: (style, element) => ({ fill: 'red' })
     *     },
     *   },
     *  ],
     * });
     */
    LinkByColor.prototype.link = function (args) {
        var context = this.context;
        if (!this.linkGroup) {
            // \u4E0D\u5141\u8BB8\u88AB\u62FE\u53D6
            this.linkGroup = context.view.foregroundGroup.addGroup({
                id: 'link-by-color-group',
                capture: false,
            });
        }
        var element = getCurrentElement(context);
        if (element) {
            this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
        }
    };
    /**
     * \u53D6\u6D88\u8FDE\u63A5 elements
     */
    LinkByColor.prototype.unlink = function () {
        var element = getCurrentElement(this.context);
        if (element) {
            this.removeLink(element);
        }
    };
    /**
     * \u6E05\u9664\u6240\u6709\u8FDE\u63A5
     */
    LinkByColor.prototype.clear = function () {
        if (this.linkGroup) {
            this.linkGroup.clear();
        }
        this.cache = {};
    };
    /**
     * \u9500\u6BC1
     */
    LinkByColor.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.linkGroup) {
            this.linkGroup.remove();
        }
    };
    return LinkByColor;
}(action_base));
/* harmony default export */ var link_by_color = (LinkByColor);
//# sourceMappingURL=link-by-color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/range-state.js




/**
 * @ignore
 * \u533A\u57DF\u8BBE\u7F6E\u72B6\u6001\u7684\u57FA\u7840 Action
 */
var ElementRangeState = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementRangeState, _super);
    function ElementRangeState() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.startPoint = null;
        _this.endPoint = null;
        _this.isStarted = false;
        /**
         * \u662F\u5426\u4F5C\u7528\u4E8E\u5F53\u524D view \u7684 siblings\uFF0C\u9ED8\u8BA4\u662F false \u4EC5\u4F5C\u7528\u4E8E\u81EA\u5DF1
         */
        _this.effectSiblings = false;
        /**
         * \u662F\u5426\u53D7 element \u7684\u6570\u636E\u5F71\u54CD\uFF0C\u8FD8\u662F\u53D7\u5305\u56F4\u76D2\u7684\u5F71\u54CD
         */
        _this.effectByRecord = false;
        return _this;
    }
    // \u83B7\u53D6\u5F53\u524D\u7684\u4F4D\u7F6E
    ElementRangeState.prototype.getCurrentPoint = function () {
        var event = this.context.event;
        return {
            x: event.x,
            y: event.y,
        };
    };
    /**
     * \u5F00\u59CB\uFF0C\u8BB0\u5F55\u5F00\u59CB\u9009\u4E2D\u7684\u4F4D\u7F6E
     */
    ElementRangeState.prototype.start = function () {
        this.clear(); // \u5F00\u59CB\u7684\u65F6\u5019\u6E05\u7406\u4E4B\u524D\u7684\u72B6\u6001
        this.startPoint = this.getCurrentPoint();
        this.isStarted = true;
    };
    ElementRangeState.prototype.getIntersectElements = function () {
        var elements = null;
        if (isMask(this.context)) {
            elements = getMaskedElements(this.context, 10);
        }
        else {
            var startPoint = this.startPoint;
            var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
            // \u5982\u679C\u6CA1\u6709\u5F00\u59CB\uFF0C\u5219\u4E0D\u5141\u8BB8\u8303\u56F4\u8BBE\u7F6E\u72B6\u6001\uFF0C\u4FDD\u62A4\u6027\u8D28
            if (!startPoint || !endPoint) {
                return;
            }
            // \u8BA1\u7B97\u6846\u9009\u533A\u57DF
            var box = {
                minX: Math.min(startPoint.x, endPoint.x),
                minY: Math.min(startPoint.y, endPoint.y),
                maxX: Math.max(startPoint.x, endPoint.x),
                maxY: Math.max(startPoint.y, endPoint.y),
            };
            // this.clear(); // \u4E0D\u5168\u90E8\u6E05\u7406\uFF0C\u4F1A\u5BFC\u81F4\u95EA\u70C1
            var view = this.context.view;
            elements = getIntersectElements(view, box);
        }
        return elements;
    };
    /**
     * \u9009\u4E2D
     */
    ElementRangeState.prototype.setStateEnable = function (enable) {
        if (this.effectSiblings && !this.effectByRecord) {
            this.setSiblingsState(enable);
        }
        else {
            var allElements = getElements(this.context.view);
            var elements = this.getIntersectElements();
            if (elements && elements.length) {
                if (this.effectByRecord) {
                    this.setSiblingsStateByRecord(elements, enable);
                }
                else {
                    this.setElementsState(elements, enable, allElements);
                }
            }
            else {
                this.clear();
            }
        }
    };
    // \u6839\u636E\u9009\u4E2D\u7684 element \u7684\u6570\u636E\u8FDB\u884C\u8BBE\u7F6E\u72B6\u6001
    ElementRangeState.prototype.setSiblingsStateByRecord = function (elements, enable) {
        var _this = this;
        var view = this.context.view;
        var siblings = getSilbings(view);
        var records = elements.map(function (el) {
            return el.getModel().data;
        });
        var xFiled = view.getXScale().field;
        var yField = view.getYScales()[0].field;
        (0,esm/* each */.S6)(siblings, function (sibling) {
            var allElements = getElements(sibling);
            var effectElements = allElements.filter(function (el) {
                var record = el.getModel().data;
                return isInRecords(records, record, xFiled, yField);
            });
            _this.setElementsState(effectElements, enable, allElements);
        });
    };
    // \u8BBE\u7F6E\u5144\u5F1F view \u7684\u72B6\u6001
    ElementRangeState.prototype.setSiblingsState = function (enable) {
        var _this = this;
        var view = this.context.view;
        var siblings = getSilbings(view);
        if (isMask(this.context)) {
            // \u53D7 mask \u5F71\u54CD
            (0,esm/* each */.S6)(siblings, function (sibling) {
                var allElements = getElements(sibling);
                var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
                if (effectElements && effectElements.length) {
                    _this.setElementsState(effectElements, enable, allElements);
                }
                else {
                    _this.clearViewState(sibling);
                }
            });
        }
    };
    ElementRangeState.prototype.setElementsState = function (elements, enable, allElements) {
        var _this = this;
        (0,esm/* each */.S6)(allElements, function (el) {
            if (!elements.includes(el)) {
                _this.setElementState(el, false);
            }
            else {
                _this.setElementState(el, enable);
            }
        });
    };
    /**
     * \u7ED3\u675F
     */
    ElementRangeState.prototype.end = function () {
        this.isStarted = false;
        this.endPoint = this.getCurrentPoint();
    };
    // \u590D\u5199 clear
    ElementRangeState.prototype.clear = function () {
        var _this = this;
        var view = this.context.view;
        // \u5224\u65AD\u662F\u5426\u5F71\u54CD siblings
        if (this.effectSiblings) {
            var siblings = getSilbings(view);
            (0,esm/* each */.S6)(siblings, function (sibling) {
                _this.clearViewState(sibling);
            });
        }
        else {
            this.clearViewState(view);
        }
    };
    return ElementRangeState;
}(state_base));
/* harmony default export */ var range_state = (ElementRangeState);
//# sourceMappingURL=range-state.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/range-active.js


/**
 * @ignore
 * \u56FE\u8868\u5143\u7D20\u533A\u57DF Active \u7684 Action
 */
var ElementRangeActive = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementRangeActive, _super);
    function ElementRangeActive() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    /**
     * \u56FE\u8868\u5143\u7D20 Active
     */
    ElementRangeActive.prototype.active = function () {
        this.setState();
    };
    return ElementRangeActive;
}(range_state));
/* harmony default export */ var range_active = (ElementRangeActive);
//# sourceMappingURL=range-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/single-state.js



/**
 * \u5355\u72B6\u6001\u91CF\u7684 Action \u57FA\u7C7B
 * @class
 * @ignore
 */
var ElementSingleState = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementSingleState, _super);
    function ElementSingleState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementSingleState.prototype.setStateEnable = function (enable) {
        var element = getCurrentElement(this.context);
        if (element) {
            // \u5728\u540C\u4E00\u4E2A element \u5185\u90E8\u79FB\u52A8\uFF0C\u5FFD\u89C6 label \u548C shape \u4E4B\u95F4
            if (!isElementChange(this.context)) {
                return;
            }
            // \u4EC5\u652F\u6301\u5355\u4E2A\u72B6\u6001\u91CF\u7684\u5143\u7D20\uFF0C\u53EA\u80FD\u7531 element \u89E6\u53D1
            if (enable) {
                this.clear();
                this.setElementState(element, true);
            }
            else if (this.hasState(element)) {
                this.setElementState(element, false);
            }
        }
    };
    /**
     * \u5207\u6362\u9009\u4E2D\uFF0C\u53EA\u5141\u8BB8\u9009\u4E2D\u4E00\u4E2A
     */
    ElementSingleState.prototype.toggle = function () {
        var element = getCurrentElement(this.context);
        if (element) {
            var hasState = this.hasState(element); // \u63D0\u524D\u83B7\u53D6\u72B6\u6001
            if (!hasState) {
                this.clear();
            }
            this.setElementState(element, !hasState);
        }
    };
    /**
     * \u53D6\u6D88\u5F53\u524D\u65F6\u95F4\u5F71\u54CD\u7684\u72B6\u6001
     */
    ElementSingleState.prototype.reset = function () {
        this.setStateEnable(false);
    };
    return ElementSingleState;
}(state_base));
/* harmony default export */ var single_state = (ElementSingleState);
//# sourceMappingURL=single-state.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/single-active.js


/**
 * @ignore
 * \u4EC5\u5141\u8BB8\u5355\u4E2A Element Active \u7684 Action
 */
var ElementSingleActive = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementSingleActive, _super);
    function ElementSingleActive() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    /**
     * \u5F53\u524D\u4E8B\u4EF6\u76F8\u5173\u7684 Element Active
     */
    ElementSingleActive.prototype.active = function () {
        this.setState();
    };
    return ElementSingleActive;
}(single_state));
/* harmony default export */ var single_active = (ElementSingleActive);
//# sourceMappingURL=single-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js


var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
/**
 * @ignore
 * \u6E05\u7406 highlight \u6548\u679C
 * @param view View \u6216\u8005 Chart
 */
function clearHighlight(view) {
    var elements = getElements(view);
    (0,esm/* each */.S6)(elements, function (el) {
        if (el.hasState(STATUS_ACTIVE)) {
            el.setState(STATUS_ACTIVE, false);
        }
        if (el.hasState(STATUS_UNACTIVE)) {
            el.setState(STATUS_UNACTIVE, false);
        }
    });
}
/**
 * @ignore
 * \u8BBE\u7F6E\u591A\u4E2A\u5143\u7D20\u7684 highlight
 * @param elements \u5143\u7D20\u96C6\u5408
 * @param callback \u8BBE\u7F6E\u56DE\u8C03\u51FD\u6570
 * @param enable \u8BBE\u7F6E\u6216\u8005\u53D6\u6D88
 */
function setHighlightBy(elements, callback, enable) {
    (0,esm/* each */.S6)(elements, function (el) {
        // \u9700\u8981\u5904\u7406 active \u548C unactive \u7684\u4E92\u65A5
        if (callback(el)) {
            if (el.hasState(STATUS_UNACTIVE)) {
                el.setState(STATUS_UNACTIVE, false);
            }
            el.setState(STATUS_ACTIVE, enable);
        }
        else {
            if (el.hasState(STATUS_ACTIVE)) {
                el.setState(STATUS_ACTIVE, false);
            }
            el.setState(STATUS_UNACTIVE, enable);
        }
    });
}
//# sourceMappingURL=highlight-util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/highlight.js






var highlight_STATUS_UNACTIVE = ELEMENT_STATE.INACTIVE;
var highlight_STATUS_ACTIVE = ELEMENT_STATE.ACTIVE;
/**
 * @ignore
 * highlight\uFF0C\u6307\u5B9A\u56FE\u5F62\u9AD8\u4EAE\uFF0C\u5176\u4ED6\u56FE\u5F62\u53D8\u6697
 */
var ElementHighlight = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementHighlight, _super);
    function ElementHighlight() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = highlight_STATUS_ACTIVE;
        return _this;
    }
    // \u591A\u4E2A\u5143\u7D20\u8BBE\u7F6E\u3001\u53D6\u6D88 highlight
    ElementHighlight.prototype.setElementsStateByItem = function (elements, field, item, enable) {
        var _this = this;
        var callback = function (el) { return _this.isMathItem(el, field, item); };
        this.setHighlightBy(elements, callback, enable);
    };
    // \u8BBE\u7F6E\u5143\u7D20\u7684 highlight
    ElementHighlight.prototype.setElementHighlight = function (el, callback) {
        if (callback(el)) {
            if (el.hasState(highlight_STATUS_UNACTIVE)) {
                el.setState(highlight_STATUS_UNACTIVE, false);
            }
            el.setState(highlight_STATUS_ACTIVE, true);
        }
        else if (!el.hasState(highlight_STATUS_ACTIVE)) {
            el.setState(highlight_STATUS_UNACTIVE, true);
        }
    };
    ElementHighlight.prototype.setHighlightBy = function (elements, callback, enable) {
        var _this = this;
        if (enable) {
            // \u5982\u679C\u662F\u8BBE\u7F6E highlight \uFF0C\u5219\u5C06\u5339\u914D\u7684 element \u8BBE\u7F6E\u6210 active\uFF0C
            // \u5176\u4ED6\u5982\u679C\u4E0D\u662F active\uFF0C\u5219\u8BBE\u7F6E\u6210 unactive
            (0,esm/* each */.S6)(elements, function (el) {
                _this.setElementHighlight(el, callback);
            });
        }
        else {
            // \u5982\u679C\u53D6\u6D88 highlight\uFF0C\u5219\u8981\u68C0\u6D4B\u662F\u5426\u5168\u90E8\u53D6\u6D88 highlight
            var activeElements = getElementsByState(this.context.view, highlight_STATUS_ACTIVE);
            var allCancel_1 = true;
            // \u68C0\u6D4B\u6240\u6709 activeElements \u90FD\u8981\u53D6\u6D88 highlight
            (0,esm/* each */.S6)(activeElements, function (el) {
                if (!callback(el)) {
                    allCancel_1 = false;
                    return false;
                }
            });
            if (allCancel_1) {
                // \u90FD\u8981\u53D6\u6D88\uFF0C\u5219\u53D6\u6D88\u6240\u6709\u7684 active\uFF0Cunactive \u72B6\u6001
                this.clear();
            }
            else {
                // \u5982\u679C\u4E0D\u662F\u90FD\u8981\u53D6\u6D88 highlight, \u5219\u8BBE\u7F6E\u5339\u914D\u7684 element \u7684\u72B6\u6001\u4E3A unactive
                // \u5176\u4ED6 element \u72B6\u6001\u4E0D\u53D8
                (0,esm/* each */.S6)(elements, function (el) {
                    if (callback(el)) {
                        if (el.hasState(highlight_STATUS_ACTIVE)) {
                            el.setState(highlight_STATUS_ACTIVE, false);
                        }
                        el.setState(highlight_STATUS_UNACTIVE, true);
                    }
                });
            }
        }
    };
    // \u5355\u4E2A\u5143\u7D20\u8BBE\u7F6E\u548C\u53D6\u6D88 highlight
    ElementHighlight.prototype.setElementState = function (element, enable) {
        var view = this.context.view;
        var elements = getElements(view);
        this.setHighlightBy(elements, function (el) { return element === el; }, enable);
    };
    ElementHighlight.prototype.highlight = function () {
        this.setState();
    };
    // \u6E05\u7406\u6389\u6240\u6709\u7684 active\uFF0C unactive \u72B6\u6001
    ElementHighlight.prototype.clear = function () {
        var view = this.context.view;
        clearHighlight(view);
    };
    return ElementHighlight;
}(state));
/* harmony default export */ var highlight = (ElementHighlight);
//# sourceMappingURL=highlight.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js



/**
 * Highlight color
 * @ignore
 */
var HighlightColor = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(HighlightColor, _super);
    function HighlightColor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightColor.prototype.setStateByElement = function (element, enable) {
        var view = this.context.view;
        var colorAttr = element.geometry.getAttribute('color');
        if (!colorAttr) {
            return;
        }
        var scale = view.getScaleByField(colorAttr.getFields()[0]);
        var value = getElementValue(element, scale.field);
        var elements = getElements(view);
        var highlightElements = elements.filter(function (el) {
            return getElementValue(el, scale.field) === value;
        });
        this.setHighlightBy(elements, function (el) { return highlightElements.includes(el); }, enable);
    };
    return HighlightColor;
}(highlight));
/* harmony default export */ var highlight_by_color = (HighlightColor);
//# sourceMappingURL=highlight-by-color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js



/**
 * Highlight x
 * @ignore
 */
var HighlightX = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(HighlightX, _super);
    function HighlightX() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // \u4E0D\u5141\u8BB8\u591A\u9009
    HighlightX.prototype.setElementHighlight = function (el, callback) {
        if (callback(el)) {
            if (el.hasState(highlight_STATUS_UNACTIVE)) {
                el.setState(highlight_STATUS_UNACTIVE, false);
            }
            el.setState(highlight_STATUS_ACTIVE, true);
        }
        else {
            el.setState(highlight_STATUS_UNACTIVE, true);
            if (el.hasState(highlight_STATUS_ACTIVE)) {
                el.setState(highlight_STATUS_ACTIVE, false);
            }
        }
    };
    HighlightX.prototype.setStateByElement = function (element, enable) {
        var view = this.context.view;
        var scale = view.getXScale();
        var value = getElementValue(element, scale.field);
        var elements = getElements(view);
        var highlightElements = elements.filter(function (el) {
            return getElementValue(el, scale.field) === value;
        });
        this.setHighlightBy(elements, function (el) { return highlightElements.includes(el); }, enable);
    };
    /**
     * \u5207\u6362\u72B6\u6001
     */
    HighlightX.prototype.toggle = function () {
        var element = getCurrentElement(this.context);
        if (element) {
            var hasState = element.hasState(this.stateName);
            this.setStateByElement(element, !hasState);
        }
    };
    return HighlightX;
}(highlight));
/* harmony default export */ var highlight_by_x = (HighlightX);
//# sourceMappingURL=highlight-by-x.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js




var range_highlight_EVENTS;
(function (EVENTS) {
    EVENTS["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
    EVENTS["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
    EVENTS["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
    EVENTS["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(range_highlight_EVENTS || (range_highlight_EVENTS = {}));

/**
 * @ignore
 * \u533A\u57DF highlight \u7684 Action
 */
var ElementRangeHighlight = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementRangeHighlight, _super);
    function ElementRangeHighlight() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    // \u6E05\u7406\u6389\u6240\u6709\u7684 active\uFF0C unactive \u72B6\u6001
    ElementRangeHighlight.prototype.clearViewState = function (view) {
        clearHighlight(view);
    };
    /**
     * \u8BBE\u7F6E highlight
     */
    ElementRangeHighlight.prototype.highlight = function () {
        var _a = this.context, view = _a.view, event = _a.event;
        var elements = this.getIntersectElements();
        var payload = { view: view, event: event, highlightElements: elements };
        view.emit(range_highlight_EVENTS.BEFORE_HIGHLIGHT, chart_event.fromData(view, range_highlight_EVENTS.BEFORE_HIGHLIGHT, payload));
        this.setState();
        view.emit(range_highlight_EVENTS.AFTER_HIGHLIGHT, chart_event.fromData(view, range_highlight_EVENTS.AFTER_HIGHLIGHT, payload));
    };
    /**
     * @overrider \u6DFB\u52A0\u4E8B\u4EF6
     */
    ElementRangeHighlight.prototype.clear = function () {
        var view = this.context.view;
        view.emit(range_highlight_EVENTS.BEFORE_CLEAR, chart_event.fromData(view, range_highlight_EVENTS.BEFORE_CLEAR, {}));
        _super.prototype.clear.call(this);
        view.emit(range_highlight_EVENTS.AFTER_CLEAR, chart_event.fromData(view, range_highlight_EVENTS.AFTER_CLEAR, {}));
    };
    ElementRangeHighlight.prototype.setElementsState = function (elements, enable, allElements) {
        setHighlightBy(allElements, function (el) { return elements.indexOf(el) >= 0; }, enable);
    };
    return ElementRangeHighlight;
}(range_state));
/* harmony default export */ var range_highlight = (ElementRangeHighlight);
//# sourceMappingURL=range-highlight.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js




/**
 * @ignore
 * \u5355\u4E2A Element Highlight \u7684 Action
 */
var ElementSingleHighlight = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementSingleHighlight, _super);
    function ElementSingleHighlight() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    /**
     * Element Highlight
     */
    ElementSingleHighlight.prototype.highlight = function () {
        this.setState();
    };
    ElementSingleHighlight.prototype.setElementState = function (element, enable) {
        var view = this.context.view;
        var elements = getElements(view);
        setHighlightBy(elements, function (el) { return element === el; }, enable);
    };
    // \u6E05\u7406\u6389\u6240\u6709\u7684 active\uFF0C unactive \u72B6\u6001
    ElementSingleHighlight.prototype.clear = function () {
        var view = this.context.view;
        clearHighlight(view);
    };
    return ElementSingleHighlight;
}(single_state));
/* harmony default export */ var single_highlight = (ElementSingleHighlight);
//# sourceMappingURL=single-highlight.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/range-selected.js


/**
 * @ignore
 * \u533A\u57DF\u9009\u4E2D\u7684 Action
 */
var ElementRangeSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementRangeSelected, _super);
    function ElementRangeSelected() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'selected';
        return _this;
    }
    /**
     * \u9009\u4E2D
     */
    ElementRangeSelected.prototype.selected = function () {
        this.setState();
    };
    return ElementRangeSelected;
}(range_state));
/* harmony default export */ var range_selected = (ElementRangeSelected);
//# sourceMappingURL=range-selected.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/selected.js


/**
 * @ignore
 * \u5141\u8BB8\u591A\u9009\u7684 Action
 * @class
 */
var ElementMultipleSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementMultipleSelected, _super);
    function ElementMultipleSelected() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'selected';
        return _this;
    }
    /**
     * \u9009\u4E2D\u8282\u70B9\uFF0C\u5141\u8BB8\u591A\u9009
     */
    ElementMultipleSelected.prototype.selected = function () {
        this.setState();
    };
    return ElementMultipleSelected;
}(state));
/* harmony default export */ var selected = (ElementMultipleSelected);
//# sourceMappingURL=selected.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/single-selected.js


/**
 * @ignore
 * \u5355\u9009\u7684 Action
 */
var ElementSingleSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementSingleSelected, _super);
    function ElementSingleSelected() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'selected';
        return _this;
    }
    /**
     * \u9009\u4E2D
     */
    ElementSingleSelected.prototype.selected = function () {
        this.setState();
    };
    return ElementSingleSelected;
}(single_state));
/* harmony default export */ var single_selected = (ElementSingleSelected);
//# sourceMappingURL=single-selected.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-state.js





/**
 * \u5217\u8868\u9879\u72B6\u6001 Action \u7684\u57FA\u7840\u7C7B
 * @class
 * @ignore
 */
var ListState = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListState, _super);
    function ListState() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = '';
        _this.ignoreItemStates = [];
        return _this;
    }
    /** \u83B7\u53D6\u89E6\u53D1\u7684\u5217\u8868\u7EC4\u4EF6 */
    ListState.prototype.getTriggerListInfo = function () {
        var delegateObject = getDelegationObject(this.context);
        var info = null;
        if (isList(delegateObject)) {
            info = {
                item: delegateObject.item,
                list: delegateObject.component,
            };
        }
        return info;
    };
    // \u83B7\u53D6\u6240\u6709\u5141\u8BB8\u6267\u884C Action \u7684\u7EC4\u4EF6
    ListState.prototype.getAllowComponents = function () {
        var _this = this;
        var view = this.context.view;
        var components = getComponents(view);
        var rst = [];
        (0,esm/* each */.S6)(components, function (component) {
            if (component.isList() && _this.allowSetStateByElement(component)) {
                rst.push(component);
            }
        });
        return rst;
    };
    /** \u662F\u5426\u5B58\u5728\u6307\u5B9A\u7684\u72B6\u6001 */
    ListState.prototype.hasState = function (list, item) {
        return list.hasState(item, this.stateName);
    };
    /** \u6E05\u7406\u7EC4\u4EF6\u7684\u72B6\u6001 */
    ListState.prototype.clearAllComponentsState = function () {
        var _this = this;
        var components = this.getAllowComponents();
        (0,esm/* each */.S6)(components, function (component) {
            component.clearItemsState(_this.stateName);
        });
    };
    // \u4E0D\u662F\u6240\u6709\u7684 component \u90FD\u80FD\u8FDB\u884C active\uFF0C\u76EE\u524D\u4EC5\u652F\u6301\u5206\u7C7B scale \u5BF9\u5E94\u7684\u7EC4\u4EF6
    ListState.prototype.allowSetStateByElement = function (component) {
        var field = component.get('field');
        if (!field) {
            return false;
        }
        if (this.cfg && this.cfg.componentNames) {
            var name_1 = component.get('name');
            // \u5982\u679C\u914D\u7F6E\u4E86\u9650\u5236\u7684 component name\uFF0C\u5219\u8981\u8FDB\u884C\u68C0\u6D4B
            if (this.cfg.componentNames.indexOf(name_1) === -1) {
                return false;
            }
        }
        var view = this.context.view;
        var scale = getScaleByField(view, field);
        return scale && scale.isCategory;
    };
    // \u68C0\u6D4B\u662F\u5426\u5141\u8BB8\u89E6\u53D1\u5BF9\u5E94\u7684\u72B6\u6001\u6539\u53D8\u4E8B\u4EF6
    ListState.prototype.allowSetStateByItem = function (item, list) {
        var ignoreStates = this.ignoreItemStates;
        if (ignoreStates.length) {
            var filterStates = ignoreStates.filter(function (state) {
                return list.hasState(item, state);
            });
            return filterStates.length === 0;
        }
        return true; // \u6CA1\u6709\u5B9A\u4E49\u5FFD\u7565\u7684\u72B6\u6001\u65F6\uFF0C\u5141\u8BB8
    };
    // \u8BBE\u7F6E\u7EC4\u4EF6\u7684 item active
    ListState.prototype.setStateByElement = function (component, element, enable) {
        var field = component.get('field');
        var view = this.context.view;
        var scale = getScaleByField(view, field);
        var value = getElementValue(element, field);
        var text = scale.getText(value);
        this.setItemsState(component, text, enable);
    };
    // \u8BBE\u7F6E\u72B6\u6001
    ListState.prototype.setStateEnable = function (enable) {
        var _this = this;
        var element = getCurrentElement(this.context);
        if (element) {
            // trigger by element
            var components = this.getAllowComponents();
            (0,esm/* each */.S6)(components, function (component) {
                _this.setStateByElement(component, element, enable);
            });
        }
        else {
            // \u88AB\u7EC4\u4EF6\u89E6\u53D1
            var delegateObject = getDelegationObject(this.context);
            if (isList(delegateObject)) {
                var item = delegateObject.item, component = delegateObject.component;
                if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
                    this.setItemState(component, item, enable);
                }
            }
        }
    };
    // \u591A\u4E2A item \u8BBE\u7F6E\u72B6\u6001
    ListState.prototype.setItemsState = function (list, name, enable) {
        var _this = this;
        var items = list.getItems();
        (0,esm/* each */.S6)(items, function (item) {
            if (item.name === name) {
                _this.setItemState(list, item, enable);
            }
        });
    };
    // \u5355\u4E2A item \u8BBE\u7F6E\u72B6\u6001
    ListState.prototype.setItemState = function (list, item, enable) {
        list.setItemState(item, this.stateName, enable);
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001
     */
    ListState.prototype.setState = function () {
        this.setStateEnable(true);
    };
    /**
     * \u53D6\u6D88\u72B6\u6001
     */
    ListState.prototype.reset = function () {
        this.setStateEnable(false);
    };
    /**
     * \u5207\u6362\u72B6\u6001
     */
    ListState.prototype.toggle = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo && triggerInfo.item) {
            var list = triggerInfo.list, item = triggerInfo.item;
            var enable = this.hasState(list, item);
            this.setItemState(list, item, !enable);
        }
    };
    /**
     * \u53D6\u6D88\u72B6\u6001
     */
    ListState.prototype.clear = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo) {
            triggerInfo.list.clearItemsState(this.stateName);
        }
        else {
            this.clearAllComponentsState();
        }
    };
    return ListState;
}(action_base));
/* harmony default export */ var list_state = (ListState);
//# sourceMappingURL=list-state.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-active.js


/**
 * \u5217\u8868\u9879\uFF08\u56FE\u4F8B\u9879\u3001\u5750\u6807\u8F74\u6587\u672C\uFF09\u6FC0\u6D3B\u7684 Action
 * @class
 * @ignore
 */
var ListActive = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListActive, _super);
    function ListActive() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'active';
        return _this;
    }
    /**
     * \u6FC0\u6D3B\u9009\u9879
     */
    ListActive.prototype.active = function () {
        this.setState();
    };
    return ListActive;
}(list_state));
/* harmony default export */ var list_active = (ListActive);
//# sourceMappingURL=list-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js

var list_highlight_util_STATUS_UNACTIVE = 'inactive';
var list_highlight_util_STATUS_ACTIVE = 'active';
/**
 * \u6E05\u7406\u56FE\u4F8B\u7684 Highlight \u6548\u679C
 * @param list \u5217\u8868\u7EC4\u4EF6\uFF0C\u56FE\u4F8B\u6216\u8005\u5750\u6807\u8F74
 * @ignore
 */
function clearList(list) {
    var items = list.getItems();
    (0,esm/* each */.S6)(items, function (item) {
        if (list.hasState(item, list_highlight_util_STATUS_ACTIVE)) {
            list.setItemState(item, list_highlight_util_STATUS_ACTIVE, false);
        }
        if (list.hasState(item, list_highlight_util_STATUS_UNACTIVE)) {
            list.setItemState(item, list_highlight_util_STATUS_UNACTIVE, false);
        }
    });
}
//# sourceMappingURL=list-highlight-util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js




var list_highlight_STATUS_UNACTIVE = 'inactive';
var list_highlight_STATUS_ACTIVE = 'active';
/**
 * highlight Action \u7684\u6548\u679C\u662F active \u548C inactive \u4E24\u4E2A\u72B6\u6001\u7684\u7EC4\u5408
 * @class
 * @ignore
 */
var ListHighlight = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListHighlight, _super);
    function ListHighlight() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = list_highlight_STATUS_ACTIVE;
        _this.ignoreItemStates = ['unchecked']; // \u5F53\u5B58\u5728 unchecked \u72B6\u6001\u65F6\u4E0D\u89E6\u53D1
        return _this;
    }
    // \u5982\u679C item.name \u5339\u914D\uFF0C\u5219\u8BBE\u7F6E highlight \u4EE5\u53CA\u53D6\u6D88
    ListHighlight.prototype.setItemsState = function (list, name, enable) {
        this.setHighlightBy(list, function (item) { return item.name === name; }, enable);
    };
    // \u5355\u4E2A item \u8BBE\u7F6E\u72B6\u6001
    ListHighlight.prototype.setItemState = function (list, item, enable) {
        var items = list.getItems();
        this.setHighlightBy(list, function (el) { return el === item; }, enable);
    };
    // \u6839\u636E\u6761\u4EF6\u8BBE\u7F6E highlight
    ListHighlight.prototype.setHighlightBy = function (list, callback, enable) {
        var items = list.getItems();
        if (enable) {
            // \u8BBE\u7F6E highlight \u65F6\uFF0C\u4FDD\u7559\u4E4B\u524D\u5DF2\u7ECF Highlight \u7684\u9879
            (0,esm/* each */.S6)(items, function (item) {
                if (callback(item)) {
                    if (list.hasState(item, list_highlight_STATUS_UNACTIVE)) {
                        list.setItemState(item, list_highlight_STATUS_UNACTIVE, false);
                    }
                    list.setItemState(item, list_highlight_STATUS_ACTIVE, true);
                }
                else if (!list.hasState(item, list_highlight_STATUS_ACTIVE)) {
                    list.setItemState(item, list_highlight_STATUS_UNACTIVE, true);
                }
            });
        }
        else {
            var activeItems = list.getItemsByState(list_highlight_STATUS_ACTIVE);
            var allCancel_1 = true;
            // \u68C0\u6D4B activeItems \u662F\u5426\u8981\u5168\u90E8\u53D6\u6D88
            (0,esm/* each */.S6)(activeItems, function (item) {
                if (!callback(item)) {
                    allCancel_1 = false;
                    return false;
                }
            });
            if (allCancel_1) {
                this.clear();
            }
            else {
                // \u5982\u679C\u4E0D\u662F\u90FD\u8981\u53D6\u6D88 highlight, \u5219\u8BBE\u7F6E\u5339\u914D\u7684 element \u7684\u72B6\u6001\u4E3A unactive
                // \u5176\u4ED6 element \u72B6\u6001\u4E0D\u53D8
                (0,esm/* each */.S6)(items, function (item) {
                    if (callback(item)) {
                        if (list.hasState(item, list_highlight_STATUS_ACTIVE)) {
                            list.setItemState(item, list_highlight_STATUS_ACTIVE, false);
                        }
                        list.setItemState(item, list_highlight_STATUS_UNACTIVE, true);
                    }
                });
            }
        }
    };
    /**
     * highlight \u56FE\u4F8B\u9879\uFF08\u5750\u6807\u8F74\u6587\u672C\uFF09
     */
    ListHighlight.prototype.highlight = function () {
        this.setState();
    };
    // \u9700\u8981\u5168\u90E8\u6E05\u7406 active \u548C unactive
    ListHighlight.prototype.clear = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo) {
            clearList(triggerInfo.list);
        }
        else {
            // \u5982\u679C\u4E0D\u662F component \u7684\u4E8B\u4EF6\u89E6\u53D1\uFF0C\u5219\u6240\u6709\u6EE1\u8DB3\u89E6\u53D1\u6761\u4EF6\u7684\u7EC4\u4EF6\u90FD\u6E05\u9664\u8BE5\u72B6\u6001
            var components = this.getAllowComponents();
            (0,esm/* each */.S6)(components, function (component) {
                component.clearItemsState(list_highlight_STATUS_ACTIVE);
                component.clearItemsState(list_highlight_STATUS_UNACTIVE);
            });
        }
    };
    return ListHighlight;
}(list_state));
/* harmony default export */ var list_highlight = (ListHighlight);
//# sourceMappingURL=list-highlight.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-selected.js


/**
 * \u56FE\u4F8B\u9879\u548C\u5750\u6807\u8F74\u6587\u672C\u9009\u4E2D\u7684 Action
 * @ignore
 */
var ListSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListSelected, _super);
    function ListSelected() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'selected';
        return _this;
    }
    ListSelected.prototype.selected = function () {
        this.setState();
    };
    return ListSelected;
}(list_state));
/* harmony default export */ var list_selected = (ListSelected);
//# sourceMappingURL=list-selected.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js


/**
 * \u56FE\u4F8B\u9879\u53D6\u6D88\u52FE\u9009\u7684 Action
 * @ignore
 */
var ListUnchecked = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListUnchecked, _super);
    function ListUnchecked() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = 'unchecked';
        return _this;
    }
    /**
     * \u53D6\u6D88\u52FE\u9009
     */
    ListUnchecked.prototype.unchecked = function () {
        this.setState();
    };
    return ListUnchecked;
}(list_state));
/* harmony default export */ var list_unchecked = (ListUnchecked);
//# sourceMappingURL=list-unchecked.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-checked.js



var STATUS_UNCHECKED = 'unchecked';
var STATUS_CHECKED = 'checked';
/**
 * checked Action
 * \u63D0\u4F9B\u4E09\u4E2A\u5BF9\u5916\u65B9\u6CD5
 * 1. toggle \u5207\u6362\u72B6\u6001
 * 2. checked \u9009\u4E2D
 * 3. reset \u6E05\u9664\u91CD\u7F6E
 */
var ListChecked = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListChecked, _super);
    function ListChecked() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stateName = STATUS_CHECKED;
        return _this;
    }
    // \u5355\u4E2A item \u8BBE\u7F6E\u72B6\u6001
    ListChecked.prototype.setItemState = function (list, item, enable) {
        this.setCheckedBy(list, function (el) { return el === item; }, enable);
    };
    // \u6839\u636E\u6761\u4EF6\u8BBE\u7F6E checked
    ListChecked.prototype.setCheckedBy = function (list, callback, enable) {
        var items = list.getItems();
        if (enable) {
            // \u8BBE\u7F6E checked \u65F6\uFF0C\u4FDD\u7559\u4E4B\u524D\u5DF2\u7ECF checked \u7684\u9879
            (0,esm/* each */.S6)(items, function (item) {
                if (callback(item)) {
                    if (list.hasState(item, STATUS_UNCHECKED)) {
                        list.setItemState(item, STATUS_UNCHECKED, false);
                    }
                    list.setItemState(item, STATUS_CHECKED, true);
                }
                else if (!list.hasState(item, STATUS_CHECKED)) {
                    list.setItemState(item, STATUS_UNCHECKED, true);
                }
            });
        }
    };
    /**
     * \u5207\u6362\u72B6\u6001.
     * 1. \u5F53\u5168\u90E8\u9009\u4E2D\u7684\u65F6\u5019 \u6216\u8005 \u5F53\u524D item \u672A\u9009\u4E2D\u65F6\uFF0C\u8FDB\u884C\u6FC0\u6D3B\u64CD\u4F5C
     * 2. \u5426\u5219\uFF0C\u91CD\u7F6E
     * @override
     */
    ListChecked.prototype.toggle = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo && triggerInfo.item) {
            var list_1 = triggerInfo.list, item = triggerInfo.item;
            // \u4E0D\u77E5\u9053 \u{1F937}\u200D\u2640\uFE0F \u53EA\u8BA4 unchecked status
            var allChecked = !(0,esm/* some */.G)(list_1.getItems(), function (t) { return list_1.hasState(t, STATUS_UNCHECKED); });
            //
            if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
                this.setItemState(list_1, item, true);
            }
            else {
                this.reset();
            }
        }
    };
    /**
     * checked \u56FE\u4F8B\u9879
     */
    ListChecked.prototype.checked = function () {
        this.setState();
    };
    /**
     * \u91CD\u7F6E\uFF0C\u9700\u8981\u5168\u90E8\u6E05\u7406 checked \u548C unchecked
     */
    ListChecked.prototype.reset = function () {
        var components = this.getAllowComponents();
        (0,esm/* each */.S6)(components, function (component) {
            component.clearItemsState(STATUS_CHECKED);
            component.clearItemsState(STATUS_UNCHECKED);
        });
    };
    return ListChecked;
}(list_state));
/* harmony default export */ var list_checked = (ListChecked);
//# sourceMappingURL=list-checked.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-focus.js


var list_focus_STATUS_UNCHECKED = 'unchecked';
var ListFocus = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListFocus, _super);
    function ListFocus() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListFocus.prototype.toggle = function () {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
            var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
            var items = list_1.getItems();
            var checkedItems = items.filter(function (t) { return !list_1.hasState(t, list_focus_STATUS_UNCHECKED); });
            var uncheckedItems = items.filter(function (t) { return list_1.hasState(t, list_focus_STATUS_UNCHECKED); });
            var checkedItem = checkedItems[0];
            /**
             * 1. \u521D\u59CB\u5316\uFF0C\u5168\u90E8 checked\u3002\u6B64\u65F6\uFF0C\u70B9\u51FB radio, clickItem \u8FDB\u5165\u805A\u7126
             * 2. \u5F53\u524D\u53EA\u9009\u4E2D\u4E00\u4E2A
             *    2.1 \u4E14\u9009\u4E2D item \u7B49\u4E8E clickItem\uFF0C\u9000\u51FA\u805A\u7126\uFF0C\u5168\u90E8\u91CD\u65B0\u9009\u4E2D
             *    2.2 \u66FF\u6362\u805A\u7126\u7684 item
             * 3. \u5176\u5B83\uFF0C\u540C 2.2
             */
            if (items.length === checkedItems.length) {
                try {
                    for (var items_1 = (0,tslib_es6/* __values */.XA)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        list_1.setItemState(item, list_focus_STATUS_UNCHECKED, item.id !== clickedItem.id);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else if (items.length - uncheckedItems.length === 1) {
                if (checkedItem.id === clickedItem.id) {
                    try {
                        for (var items_2 = (0,tslib_es6/* __values */.XA)(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                            var item = items_2_1.value;
                            list_1.setItemState(item, list_focus_STATUS_UNCHECKED, false);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (items_2_1 && !items_2_1.done && (_b = items_2.return)) _b.call(items_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                else {
                    try {
                        for (var items_3 = (0,tslib_es6/* __values */.XA)(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                            var item = items_3_1.value;
                            list_1.setItemState(item, list_focus_STATUS_UNCHECKED, item.id !== clickedItem.id);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (items_3_1 && !items_3_1.done && (_c = items_3.return)) _c.call(items_3);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            else {
                try {
                    for (var items_4 = (0,tslib_es6/* __values */.XA)(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
                        var item = items_4_1.value;
                        list_1.setItemState(item, list_focus_STATUS_UNCHECKED, item.id !== clickedItem.id);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (items_4_1 && !items_4_1.done && (_d = items_4.return)) _d.call(items_4);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
    };
    return ListFocus;
}(list_state));
/* harmony default export */ var list_focus = (ListFocus);
//# sourceMappingURL=list-focus.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/list-radio.js





var STATUS_SHOW = 'showRadio';
var TIP_ID = 'legend-radio-tip';
var ListRadio = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ListRadio, _super);
    function ListRadio() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeStamp = 0;
        return _this;
    }
    ListRadio.prototype.show = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
            var list = triggerInfo.list, item = triggerInfo.item;
            list.setItemState(item, STATUS_SHOW, true);
        }
    };
    ListRadio.prototype.hide = function () {
        var triggerInfo = this.getTriggerListInfo();
        if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
            var list = triggerInfo.list, item = triggerInfo.item;
            list.setItemState(item, STATUS_SHOW, false);
        }
    };
    ListRadio.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.tooltip && this.tooltip.destroy();
    };
    /**
     * \u663E\u793A Tooltip (\u5C55\u793A\u5728\u4E0A\u65B9)
     * @returns
     */
    ListRadio.prototype.showTip = function () {
        var context = this.context;
        var ev = context.event;
        var lastTimeStamp = this.timeStamp;
        var timeStamp = +new Date();
        var target = this.context.event.target;
        if (timeStamp - lastTimeStamp > 16 && target.get('name') === 'legend-item-radio') {
            var preLoc = this.location;
            var curLoc = { x: ev.x, y: ev.y };
            this.timeStamp = timeStamp;
            this.location = curLoc;
            if (!preLoc || !(0,esm/* isEqual */.Xy)(preLoc, curLoc)) {
                this.showTooltip(curLoc);
            }
        }
    };
    /**
     * \u9690\u85CF Tooltip\u3002
     * @returns
     */
    ListRadio.prototype.hideTip = function () {
        this.hideTooltip();
        this.location = null;
    };
    ListRadio.prototype.showTooltip = function (curLoc) {
        var context = this.context;
        var ev = context.event;
        var target = ev.target;
        if (target && target.get('tip')) {
            if (!this.tooltip) {
                this.renderTooltip(); // \u5EF6\u8FDF\u751F\u6210
            }
            // \u5C55\u793A tooltip
            var _a = context.view.getCanvas().get('el').getBoundingClientRect(), offsetX = _a.x, offsetY = _a.y;
            this.tooltip.update((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ title: target.get('tip') }, curLoc), { x: curLoc.x + offsetX, y: curLoc.y + offsetY }));
            this.tooltip.show();
        }
    };
    ListRadio.prototype.hideTooltip = function () {
        this.tooltip && this.tooltip.hide();
    };
    ListRadio.prototype.renderTooltip = function () {
        var _a;
        var tooltipStyles = (_a = {},
            _a[css_const_CONTAINER_CLASS] = {
                padding: '6px 8px',
                transform: 'translate(-50%, -80%)',
                background: 'rgba(0,0,0,0.75)',
                color: '#fff',
                'border-radius': '2px',
                // \u907F\u514D\u906E\u6321\uFF0C\u5982\u679C\u8FD8\u4E0D\u591F\u7684\u8BDD\uFF0C\u518D\u8003\u8651\u5F00\u653E\u7528\u6237\u914D\u7F6E
                'z-index': 100,
            },
            _a[TITLE_CLASS] = {
                'font-size': '12px',
                'line-height': '14px',
                'margin-bottom': 0,
                'word-break': 'break-all',
            },
            _a);
        if (document.getElementById(TIP_ID)) {
            document.body.removeChild(document.getElementById(TIP_ID));
        }
        var tooltip = new HtmlTooltip({
            parent: document.body,
            // tooltip \u9650\u5236\u7684\u533A\u57DF
            region: null,
            visible: false,
            crosshairs: null,
            domStyles: tooltipStyles,
            containerId: TIP_ID,
        });
        tooltip.init();
        tooltip.setCapture(false); // \u4E0D\u5141\u8BB8\u6355\u83B7\u4E8B\u4EF6
        this.tooltip = tooltip;
    };
    return ListRadio;
}(list_state));
/* harmony default export */ var list_radio = (ListRadio);
//# sourceMappingURL=list-radio.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/base.js



/**
 * @ignore
 * \u8F85\u52A9\u6846 Action \u7684\u57FA\u7C7B
 */
var MaskBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(MaskBase, _super);
    function MaskBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // mask \u56FE\u5F62
        _this.maskShape = null;
        // \u7EC4\u6210 mask \u7684\u5404\u4E2A\u70B9
        _this.points = [];
        // \u5F00\u59CB mask \u7684\u6807\u8BB0
        _this.starting = false;
        // \u5F00\u59CB\u79FB\u52A8\u7684\u6807\u8BB0
        _this.moving = false;
        _this.preMovePoint = null;
        _this.shapeType = 'path';
        return _this;
    }
    // \u83B7\u53D6\u5F53\u524D\u7684\u4F4D\u7F6E
    MaskBase.prototype.getCurrentPoint = function () {
        var event = this.context.event;
        return {
            x: event.x,
            y: event.y,
        };
    };
    // \u89E6\u53D1 mask \u7684\u4E8B\u4EF6
    MaskBase.prototype.emitEvent = function (type) {
        var eventName = "mask:".concat(type);
        var view = this.context.view;
        var event = this.context.event;
        view.emit(eventName, {
            target: this.maskShape,
            shape: this.maskShape,
            points: this.points,
            x: event.x,
            y: event.y,
        });
    };
    // \u521B\u5EFA mask
    MaskBase.prototype.createMask = function () {
        var view = this.context.view;
        var maskAttrs = this.getMaskAttrs();
        var maskShape = view.foregroundGroup.addShape({
            type: this.shapeType,
            name: 'mask',
            draggable: true,
            attrs: (0,tslib_es6/* __assign */.pi)({ fill: '#C5D4EB', opacity: 0.3 }, maskAttrs),
        });
        return maskShape;
    };
    // \u751F\u6210 mask \u7684\u8DEF\u5F84
    MaskBase.prototype.getMaskPath = function () {
        return [];
    };
    /**
     * \u663E\u793A
     */
    MaskBase.prototype.show = function () {
        if (this.maskShape) {
            this.maskShape.show();
            this.emitEvent('show');
        }
    };
    /**
     * \u5F00\u59CB
     */
    MaskBase.prototype.start = function (arg) {
        this.starting = true;
        // \u5F00\u59CB\u65F6\uFF0C\u4FDD\u8BC1\u79FB\u52A8\u7ED3\u675F
        this.moving = false;
        this.points = [this.getCurrentPoint()];
        if (!this.maskShape) {
            this.maskShape = this.createMask();
            // \u5F00\u59CB\u65F6\u8BBE\u7F6E capture: false\uFF0C\u53EF\u4EE5\u907F\u514D\u521B\u5EFA\u3001resize \u65F6\u89E6\u53D1\u4E8B\u4EF6
            this.maskShape.set('capture', false);
        }
        this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
        this.emitEvent('start');
    };
    /**
     * \u5F00\u59CB\u79FB\u52A8
     */
    MaskBase.prototype.moveStart = function () {
        this.moving = true;
        this.preMovePoint = this.getCurrentPoint();
    };
    /**
     * \u79FB\u52A8 mask
     */
    MaskBase.prototype.move = function () {
        if (!this.moving || !this.maskShape) {
            return;
        }
        var currentPoint = this.getCurrentPoint();
        var preMovePoint = this.preMovePoint;
        var dx = currentPoint.x - preMovePoint.x;
        var dy = currentPoint.y - preMovePoint.y;
        var points = this.points;
        (0,esm/* each */.S6)(points, function (point) {
            point.x += dx;
            point.y += dy;
        });
        this.updateMask();
        this.emitEvent('change');
        this.preMovePoint = currentPoint;
    };
    MaskBase.prototype.updateMask = function (maskStyle) {
        var attrs = (0,esm/* deepMix */.b$)({}, this.getMaskAttrs(), maskStyle);
        this.maskShape.attr(attrs);
    };
    /**
     * \u7ED3\u675F\u79FB\u52A8
     */
    MaskBase.prototype.moveEnd = function () {
        this.moving = false;
        this.preMovePoint = null;
    };
    /**
     * \u7ED3\u675F
     */
    MaskBase.prototype.end = function () {
        this.starting = false;
        this.emitEvent('end');
        if (this.maskShape) {
            this.maskShape.set('capture', true);
        }
    };
    /**
     * \u9690\u85CF
     */
    MaskBase.prototype.hide = function () {
        if (this.maskShape) {
            this.maskShape.hide();
            this.emitEvent('hide');
        }
    };
    /**
     * \u5927\u5C0F\u53D8\u5316
     */
    MaskBase.prototype.resize = function () {
        // \u53EA\u6709\u8FDB\u884C\u4E2D\uFF0C\u624D\u4F1A\u5141\u8BB8\u5927\u5C0F\u53D8\u5316
        if (this.starting && this.maskShape) {
            this.points.push(this.getCurrentPoint());
            this.updateMask();
            this.emitEvent('change');
        }
    };
    /**
     * \u9500\u6BC1
     */
    MaskBase.prototype.destroy = function () {
        this.points = [];
        if (this.maskShape) {
            this.maskShape.remove();
        }
        this.maskShape = null;
        this.preMovePoint = null;
        _super.prototype.destroy.call(this);
    };
    return MaskBase;
}(action_base));
/* harmony default export */ var mask_base = (MaskBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/circle.js




function getMaskAttrs(points) {
    var currentPoint = (0,esm/* last */.Z$)(points);
    var r = 0;
    var x = 0;
    var y = 0;
    if (points.length) {
        var first = points[0];
        r = action_util_distance(first, currentPoint) / 2;
        x = (currentPoint.x + first.x) / 2;
        y = (currentPoint.y + first.y) / 2;
    }
    return {
        x: x,
        y: y,
        r: r,
    };
}
/**
 * @ignore
 * \u5706\u5F62\u8F85\u52A9\u6846 Action
 */
var CircleMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CircleMask, _super);
    function CircleMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.shapeType = 'circle';
        return _this;
    }
    CircleMask.prototype.getMaskAttrs = function () {
        return getMaskAttrs(this.points);
    };
    return CircleMask;
}(mask_base));
/* harmony default export */ var mask_circle = (CircleMask);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/rect.js



function getRegion(points) {
    return {
        start: (0,esm/* head */.YM)(points),
        end: (0,esm/* last */.Z$)(points),
    };
}
/**
 * \u6DFB\u52A0\u56FE\u5F62
 * @param points
 * @returns
 */
function rect_getMaskAttrs(start, end) {
    var x = Math.min(start.x, end.x);
    var y = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
        x: x,
        y: y,
        width: width,
        height: height,
    };
}
/**
 * @ignore
 * \u77E9\u5F62\u7684\u8F85\u52A9\u6846 Action
 */
var RectMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RectMask, _super);
    function RectMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.shapeType = 'rect';
        return _this;
    }
    RectMask.prototype.getRegion = function () {
        return getRegion(this.points);
    };
    RectMask.prototype.getMaskAttrs = function () {
        var _a = this.getRegion(), start = _a.start, end = _a.end;
        return rect_getMaskAttrs(start, end);
    };
    return RectMask;
}(mask_base));
/* harmony default export */ var mask_rect = (RectMask);
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js



function clampPoint(point) {
    point.x = (0,esm/* clamp */.uZ)(point.x, 0, 1);
    point.y = (0,esm/* clamp */.uZ)(point.y, 0, 1);
}
function dim_rect_getRegion(points, dim, inPlot, coord) {
    var start = null;
    var end = null;
    var normalStart = coord.invert((0,esm/* head */.YM)(points));
    var normalEnd = coord.invert((0,esm/* last */.Z$)(points));
    if (inPlot) {
        // \u7EA6\u675F\u5230 0 - 1 \u8303\u56F4\u5185
        clampPoint(normalStart);
        clampPoint(normalEnd);
    }
    if (dim === 'x') {
        // x \u8F74\u65B9\u5411\u6269\u5C55, y \u8F74\u65B9\u5411\u5360\u6EE1\u5168\u90E8
        start = coord.convert({
            x: normalStart.x,
            y: 0,
        });
        end = coord.convert({
            x: normalEnd.x,
            y: 1,
        });
    }
    else {
        // y \u8F74\u65B9\u5411\u6269\u5C55, x \u8F74\u65B9\u5411\u5360\u6EE1\u5168\u90E8
        start = coord.convert({
            x: 0,
            y: normalStart.y,
        });
        end = coord.convert({
            x: 1,
            y: normalEnd.y,
        });
    }
    return {
        start: start,
        end: end,
    };
}
/**
 * @ignore
 */
var DimRect = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DimRect, _super);
    function DimRect() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dim = 'x';
        _this.inPlot = true;
        return _this;
    }
    DimRect.prototype.getRegion = function () {
        var coord = this.context.view.getCoordinate();
        return dim_rect_getRegion(this.points, this.dim, this.inPlot, coord);
    };
    return DimRect;
}(mask_rect));
/* harmony default export */ var dim_rect = (DimRect);
//# sourceMappingURL=dim-rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/path.js



/**
 * \u751F\u6210 mask \u7684\u8DEF\u5F84
 * @param points
 * @returns
 */
function path_getMaskPath(points) {
    var path = [];
    if (points.length) {
        (0,esm/* each */.S6)(points, function (point, index) {
            if (index === 0) {
                path.push(['M', point.x, point.y]);
            }
            else {
                path.push(['L', point.x, point.y]);
            }
        });
        path.push(['L', points[0].x, points[0].y]);
    }
    return path;
}
function path_getMaskAttrs(points) {
    return {
        path: path_getMaskPath(points),
    };
}
/**
 * @ignore
 * \u591A\u4E2A\u70B9\u6784\u6210\u7684 Path \u8F85\u52A9\u6846 Action
 */
var PathMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PathMask, _super);
    function PathMask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PathMask.prototype.getMaskPath = function () {
        return path_getMaskPath(this.points);
    };
    PathMask.prototype.getMaskAttrs = function () {
        return path_getMaskAttrs(this.points);
    };
    /**
     * \u6DFB\u52A0\u4E00\u4E2A\u70B9
     */
    PathMask.prototype.addPoint = function () {
        this.resize();
    };
    return PathMask;
}(mask_base));
/* harmony default export */ var mask_path = (PathMask);
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js



/**
 * \u751F\u6210 mask \u7684\u8DEF\u5F84
 * @param points
 * @returns
 */
function smooth_path_getMaskPath(points) {
    return getSpline(points, true);
}
function smooth_path_getMaskAttrs(points) {
    return {
        path: smooth_path_getMaskPath(points),
    };
}
/**
 * Smooth path mask
 * @ignore
 */
var SmoothPathMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SmoothPathMask, _super);
    function SmoothPathMask() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SmoothPathMask.prototype.getMaskPath = function () {
        return smooth_path_getMaskPath(this.points);
    };
    SmoothPathMask.prototype.getMaskAttrs = function () {
        return smooth_path_getMaskAttrs(this.points);
    };
    return SmoothPathMask;
}(mask_path));
/* harmony default export */ var smooth_path = (SmoothPathMask);
//# sourceMappingURL=smooth-path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/base.js



/**
 * @ignore
 * \u8F85\u52A9\u6846 Action \u7684\u57FA\u7C7B
 */
var MultipleMaskBase = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(MultipleMaskBase, _super);
    function MultipleMaskBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // mask \u56FE\u5F62
        _this.maskShapes = [];
        // \u5F00\u59CB mask \u7684\u6807\u8BB0
        _this.starting = false;
        // \u5F00\u59CB\u79FB\u52A8\u7684\u6807\u8BB0
        _this.moving = false;
        // \u8BB0\u5F55 mask \u8282\u70B9
        _this.recordPoints = null;
        _this.preMovePoint = null;
        _this.shapeType = 'path';
        _this.maskType = 'multi-mask';
        return _this;
    }
    /**
     * \u83B7\u53D6\u5F53\u524D\u7684\u4F4D\u7F6E
     */
    MultipleMaskBase.prototype.getCurrentPoint = function () {
        var event = this.context.event;
        return {
            x: event.x,
            y: event.y,
        };
    };
    /**
     * \u89E6\u53D1 mask \u7684\u4E8B\u4EF6
     * @param type
     */
    MultipleMaskBase.prototype.emitEvent = function (type) {
        var eventName = "".concat(this.maskType, ":").concat(type);
        var view = this.context.view;
        var event = this.context.event;
        var target = {
            type: this.shapeType,
            name: this.maskType,
            get: function (key) { return (target.hasOwnProperty(key) ? target[key] : undefined); },
        };
        view.emit(eventName, {
            target: target,
            maskShapes: this.maskShapes,
            multiPoints: this.recordPoints,
            x: event.x,
            y: event.y,
        });
    };
    /**
     * \u521B\u5EFA mask
     * @param index
     */
    MultipleMaskBase.prototype.createMask = function (index) {
        var view = this.context.view;
        var points = this.recordPoints[index];
        var maskAttrs = this.getMaskAttrs(points);
        var maskShape = view.foregroundGroup.addShape({
            type: this.shapeType,
            name: 'mask',
            draggable: true,
            attrs: (0,tslib_es6/* __assign */.pi)({ fill: '#C5D4EB', opacity: 0.3 }, maskAttrs),
        });
        this.maskShapes.push(maskShape);
    };
    /**
     * \u751F\u6210 mask \u7684\u8DEF\u5F84
     */
    MultipleMaskBase.prototype.getMaskPath = function (points) {
        return [];
    };
    /**
     * \u663E\u793A
     */
    MultipleMaskBase.prototype.show = function () {
        if (this.maskShapes.length > 0) {
            this.maskShapes.forEach(function (maskShape) { return maskShape.show(); });
            this.emitEvent('show');
        }
    };
    /**
     * \u5F00\u59CB
     */
    MultipleMaskBase.prototype.start = function (arg) {
        this.recordPointStart();
        this.starting = true;
        // \u5F00\u59CB\u65F6\uFF0C\u4FDD\u8BC1\u79FB\u52A8\u7ED3\u675F
        this.moving = false;
        // \u5F00\u59CB\u7B2C index \u4E2A mask
        var index = this.recordPoints.length - 1;
        this.createMask(index);
        // \u5F00\u59CB\u65F6\u8BBE\u7F6E capture: false\uFF0C\u53EF\u4EE5\u907F\u514D\u521B\u5EFA\u3001resize \u65F6\u89E6\u53D1\u4E8B\u4EF6
        this.updateShapesCapture(false);
        this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
        this.emitEvent('start');
    };
    /**
     * \u5F00\u59CB\u79FB\u52A8
     */
    MultipleMaskBase.prototype.moveStart = function () {
        this.moving = true;
        this.preMovePoint = this.getCurrentPoint();
        this.updateShapesCapture(false);
    };
    /**
     * \u79FB\u52A8 mask
     */
    MultipleMaskBase.prototype.move = function () {
        if (!this.moving || this.maskShapes.length === 0) {
            return;
        }
        var currentPoint = this.getCurrentPoint();
        var preMovePoint = this.preMovePoint;
        var dx = currentPoint.x - preMovePoint.x;
        var dy = currentPoint.y - preMovePoint.y;
        // \u53EA\u79FB\u52A8\u5F53\u524D event (x, y) \u6240\u5728\u7684\u67D0\u4E2A mask
        var index = this.getCurMaskShapeIndex();
        if (index > -1) {
            this.recordPoints[index].forEach(function (point) {
                point.x += dx;
                point.y += dy;
            });
            this.updateMask();
            this.emitEvent('change');
            this.preMovePoint = currentPoint;
        }
    };
    /**
     * \u66F4\u65B0
     * @param maskStyle
     */
    MultipleMaskBase.prototype.updateMask = function (maskStyle) {
        var _this = this;
        this.recordPoints.forEach(function (points, index) {
            var attrs = (0,esm/* deepMix */.b$)({}, _this.getMaskAttrs(points), maskStyle);
            _this.maskShapes[index].attr(attrs);
        });
    };
    /**
     * \u5927\u5C0F\u53D8\u5316
     */
    MultipleMaskBase.prototype.resize = function () {
        if (this.starting && this.maskShapes.length > 0) {
            this.recordPointContinue();
            this.updateMask();
            this.emitEvent('change');
        }
    };
    /**
     * \u7ED3\u675F\u79FB\u52A8
     */
    MultipleMaskBase.prototype.moveEnd = function () {
        this.moving = false;
        this.preMovePoint = null;
        this.updateShapesCapture(true);
    };
    /**
     * \u7ED3\u675F
     */
    MultipleMaskBase.prototype.end = function () {
        this.starting = false;
        this.emitEvent('end');
        this.updateShapesCapture(true);
    };
    /**
     * \u9690\u85CF
     */
    MultipleMaskBase.prototype.hide = function () {
        if (this.maskShapes.length > 0) {
            this.maskShapes.forEach(function (maskShape) { return maskShape.hide(); });
            this.emitEvent('hide');
        }
    };
    /**
     * \u6E05\u9664\u67D0\u4E2A mask
     */
    MultipleMaskBase.prototype.remove = function () {
        var index = this.getCurMaskShapeIndex();
        if (index > -1) {
            // event (x, y) \u5728\u7684\u67D0\u4E2A mask \u533A\u57DF\u5185\u65F6\uFF0C\u6E05\u9664\u8BE5 mask
            this.recordPoints.splice(index, 1);
            this.maskShapes[index].remove();
            this.maskShapes.splice(index, 1);
            this.preMovePoint = null;
            this.updateShapesCapture(true);
            this.emitEvent('change');
        }
    };
    /**
     * \u6E05\u9664\u5168\u90E8 mask
     */
    MultipleMaskBase.prototype.clearAll = function () {
        this.recordPointClear();
        this.maskShapes.forEach(function (maskShape) { return maskShape.remove(); });
        this.maskShapes = [];
        this.preMovePoint = null;
    };
    /**
     * \u6E05\u9664
     */
    MultipleMaskBase.prototype.clear = function () {
        var index = this.getCurMaskShapeIndex();
        if (index === -1) {
            this.recordPointClear();
            this.maskShapes.forEach(function (maskShape) { return maskShape.remove(); });
            this.maskShapes = [];
            this.emitEvent('clearAll');
        }
        else {
            this.recordPoints.splice(index, 1);
            this.maskShapes[index].remove();
            this.maskShapes.splice(index, 1);
            this.preMovePoint = null;
            this.emitEvent('clearSingle');
        }
        this.preMovePoint = null;
    };
    /**
     * \u9500\u6BC1
     */
    MultipleMaskBase.prototype.destroy = function () {
        this.clear();
        _super.prototype.destroy.call(this);
    };
    /**
     * \u83B7\u53D6 mask \u8282\u70B9\u8BB0\u5F55
     */
    MultipleMaskBase.prototype.getRecordPoints = function () {
        var _a;
        return (0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(((_a = this.recordPoints) !== null && _a !== void 0 ? _a : [])), false);
    };
    /**
     * \u521B\u5EFA mask \u8282\u70B9\u8BB0\u5F55
     */
    MultipleMaskBase.prototype.recordPointStart = function () {
        var recordPoints = this.getRecordPoints();
        var currentPoint = this.getCurrentPoint();
        this.recordPoints = (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(recordPoints), false), [[currentPoint]], false);
    };
    /**
     * \u6301\u7EED\u8BB0\u5F55 mask \u8282\u70B9
     */
    MultipleMaskBase.prototype.recordPointContinue = function () {
        var recordPoints = this.getRecordPoints();
        var currentPoint = this.getCurrentPoint();
        var lastPoints = recordPoints.splice(-1, 1)[0] || [];
        lastPoints.push(currentPoint);
        this.recordPoints = (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,tslib_es6/* __read */.CR)(recordPoints), false), [lastPoints], false);
    };
    /**
     * \u6E05\u9664 mask \u8282\u70B9 \u8BB0\u5F55
     */
    MultipleMaskBase.prototype.recordPointClear = function () {
        this.recordPoints = [];
    };
    /**
     * \u8BBE\u7F6E capture
     * false: \u907F\u514D\u521B\u5EFA\u3001resize \u65F6\u89E6\u53D1\u4E8B\u4EF6
     * true: \u6B63\u5E38\u89E6\u53D1\u5176\u5B83\u4E8B\u4EF6
     * @param isCapture
     */
    MultipleMaskBase.prototype.updateShapesCapture = function (isCapture) {
        this.maskShapes.forEach(function (maskShape) { return maskShape.set('capture', isCapture); });
    };
    /**
     *
     * @returns \u83B7\u53D6\u5F53\u524D event (x, y) \u6240\u5728 maskShape \u7684 index
     */
    MultipleMaskBase.prototype.getCurMaskShapeIndex = function () {
        var currentPoint = this.getCurrentPoint();
        return this.maskShapes.findIndex(function (maskShape) {
            var _a = maskShape.attrs, width = _a.width, height = _a.height, r = _a.r;
            var isEmpty = width === 0 || height === 0 || r === 0;
            return !isEmpty && maskShape.isHit(currentPoint.x, currentPoint.y);
        });
    };
    return MultipleMaskBase;
}(action_base));
/* harmony default export */ var multiple_base = (MultipleMaskBase);
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/rect.js



/**
 * @ignore
 * \u77E9\u5F62\u7684\u8F85\u52A9\u6846 Action
 */
var RectMultiMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RectMultiMask, _super);
    function RectMultiMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.shapeType = 'rect';
        return _this;
    }
    RectMultiMask.prototype.getRegion = function (points) {
        return getRegion(points);
    };
    RectMultiMask.prototype.getMaskAttrs = function (points) {
        var _a = this.getRegion(points), start = _a.start, end = _a.end;
        return rect_getMaskAttrs(start, end);
    };
    return RectMultiMask;
}(multiple_base));
/* harmony default export */ var multiple_rect = (RectMultiMask);
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/dim-rect.js



/**
 * @ignore
 */
var DimRectMultiMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DimRectMultiMask, _super);
    function DimRectMultiMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dim = 'x';
        _this.inPlot = true;
        return _this;
    }
    DimRectMultiMask.prototype.getRegion = function (points) {
        var coord = this.context.view.getCoordinate();
        return dim_rect_getRegion(points, this.dim, this.inPlot, coord);
    };
    return DimRectMultiMask;
}(multiple_rect));
/* harmony default export */ var multiple_dim_rect = (DimRectMultiMask);
//# sourceMappingURL=dim-rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/circle.js



/**
 * @ignore
 * \u5706\u5F62\u8F85\u52A9\u6846 Action
 */
var CircleMultiMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CircleMultiMask, _super);
    function CircleMultiMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.shapeType = 'circle';
        _this.getMaskAttrs = getMaskAttrs;
        return _this;
    }
    return CircleMultiMask;
}(multiple_base));
/* harmony default export */ var multiple_circle = (CircleMultiMask);
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/path.js



/**
 * @ignore
 * \u591A\u4E2A\u70B9\u6784\u6210\u7684 Path \u8F85\u52A9\u6846 Action
 */
var PathMultiMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PathMultiMask, _super);
    function PathMultiMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getMaskPath = path_getMaskPath;
        _this.getMaskAttrs = path_getMaskAttrs;
        return _this;
    }
    PathMultiMask.prototype.addPoint = function () {
        this.resize();
    };
    return PathMultiMask;
}(multiple_base));
/* harmony default export */ var multiple_path = (PathMultiMask);
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/mask/multiple/smooth-path.js



/**
 * Smooth path mask
 * @ignore
 */
var SmoothPathMultiMask = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SmoothPathMultiMask, _super);
    function SmoothPathMultiMask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getMaskPath = smooth_path_getMaskPath;
        _this.getMaskAttrs = smooth_path_getMaskAttrs;
        return _this;
    }
    return SmoothPathMultiMask;
}(multiple_path));
/* harmony default export */ var multiple_smooth_path = (SmoothPathMultiMask);
//# sourceMappingURL=smooth-path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/cursor.js

/**
 * @fileoverview \u8BBE\u7F6E\u753B\u5E03\u7684\u7BAD\u5934\uFF0C\u53C2\u770B\uFF1Ahttps://www.w3school.com.cn/jsref/prop_style_cursor.asp
 * @author dxq613
 */

/**
 * \u9F20\u6807\u5F62\u72B6\u7684 Action
 * @ignore
 */
var CursorAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CursorAction, _super);
    function CursorAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CursorAction.prototype.setCursor = function (cursor) {
        var view = this.context.view;
        view.getCanvas().setCursor(cursor);
    };
    /**
     * \u9ED8\u8BA4\u5149\u6807\uFF08\u901A\u5E38\u662F\u4E00\u4E2A\u7BAD\u5934\uFF09
     */
    CursorAction.prototype.default = function () {
        this.setCursor('default');
    };
    /** \u5149\u6807\u5448\u73B0\u4E3A\u6307\u793A\u94FE\u63A5\u7684\u6307\u9488\uFF08\u4E00\u53EA\u624B\uFF09 */
    CursorAction.prototype.pointer = function () {
        this.setCursor('pointer');
    };
    /** \u6B64\u5149\u6807\u6307\u793A\u67D0\u5BF9\u8C61\u53EF\u88AB\u79FB\u52A8\u3002 */
    CursorAction.prototype.move = function () {
        this.setCursor('move');
    };
    /** \u5149\u6807\u5448\u73B0\u4E3A\u5341\u5B57\u7EBF\u3002 */
    CursorAction.prototype.crosshair = function () {
        this.setCursor('crosshair');
    };
    /** \u6B64\u5149\u6807\u6307\u793A\u7A0B\u5E8F\u6B63\u5FD9\uFF08\u901A\u5E38\u662F\u4E00\u53EA\u8868\u6216\u6C99\u6F0F\uFF09\u3002 */
    CursorAction.prototype.wait = function () {
        this.setCursor('wait');
    };
    /** \u6B64\u5149\u6807\u6307\u793A\u53EF\u7528\u7684\u5E2E\u52A9\uFF08\u901A\u5E38\u662F\u4E00\u4E2A\u95EE\u53F7\u6216\u4E00\u4E2A\u6C14\u7403\uFF09\u3002 */
    CursorAction.prototype.help = function () {
        this.setCursor('help');
    };
    /** \u6B64\u5149\u6807\u6307\u793A\u6587\u672C\u3002 */
    CursorAction.prototype.text = function () {
        this.setCursor('text');
    };
    /**
     * \u6B64\u5149\u6807\u6307\u793A\u77E9\u5F62\u6846\u7684\u8FB9\u7F18\u53EF\u88AB\u5411\u53F3\uFF08\u4E1C\uFF09\u79FB\u52A8\u3002
     */
    CursorAction.prototype.eResize = function () {
        this.setCursor('e-resize');
    };
    /**
     * \u6B64\u5149\u6807\u6307\u793A\u77E9\u5F62\u6846\u7684\u8FB9\u7F18\u53EF\u88AB\u5411\u5DE6\uFF08\u897F\uFF09\u79FB\u52A8\u3002
     */
    CursorAction.prototype.wResize = function () {
        this.setCursor('w-resize');
    };
    /**
     * \u6B64\u5149\u6807\u6307\u793A\u77E9\u5F62\u6846\u7684\u8FB9\u7F18\u53EF\u88AB\u5411\u4E0A\uFF08\u5317\uFF09\u79FB\u52A8\u3002
     */
    CursorAction.prototype.nResize = function () {
        this.setCursor('n-resize');
    };
    /**
     * \u6B64\u5149\u6807\u6307\u793A\u77E9\u5F62\u6846\u7684\u8FB9\u7F18\u53EF\u88AB\u5411\u4E0B\uFF08\u5357\uFF09\u79FB\u52A8\u3002
     */
    CursorAction.prototype.sResize = function () {
        this.setCursor('s-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u79FB\u52A8\u7684\u65B9\u5411 \u53F3\u4E0A\u65B9\uFF08\u4E1C\u5317\uFF09
     */
    CursorAction.prototype.neResize = function () {
        this.setCursor('ne-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u79FB\u52A8\u7684\u65B9\u5411 \u5DE6\u4E0A\u65B9\uFF08\u897F\u5317\uFF09
     */
    CursorAction.prototype.nwResize = function () {
        this.setCursor('nw-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u79FB\u52A8\u7684\u65B9\u5411\u53F3\u4E0B\u65B9\uFF08\u4E1C\u5357\uFF09
     */
    CursorAction.prototype.seResize = function () {
        this.setCursor('se-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u79FB\u52A8\u7684\u65B9\u5411\u5DE6\u4E0B\u65B9\uFF08\u897F\u5357\uFF09
     */
    CursorAction.prototype.swResize = function () {
        this.setCursor('sw-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u4EE5\u5728\u4E0A\u4E0B\u65B9\u5411\u79FB\u52A8
     */
    CursorAction.prototype.nsResize = function () {
        this.setCursor('ns-resize');
    };
    /**
     * \u5149\u6807\u6307\u793A\u53EF\u4EE5\u5728\u5DE6\u53F3\u65B9\u5411\u79FB\u52A8
     */
    CursorAction.prototype.ewResize = function () {
        this.setCursor('ew-resize');
    };
    /**
     * \u5149\u6807\u663E\u793A\u53EF\u4EE5\u88AB\u653E\u5927
     */
    CursorAction.prototype.zoomIn = function () {
        this.setCursor('zoom-in');
    };
    /**
     * \u5149\u6807\u663E\u793A\u53EF\u4EE5\u7F29\u5C0F\u5C3A\u5BF8
     */
    CursorAction.prototype.zoomOut = function () {
        this.setCursor('zoom-out');
    };
    return CursorAction;
}(action_base));
/* harmony default export */ var cursor = (CursorAction);
//# sourceMappingURL=cursor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/data/filter.js




/**
 * \u6570\u636E\u8FC7\u6EE4\u3002
 * @ignore
 */
var DataFilter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DataFilter, _super);
    function DataFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFilter.prototype.filterView = function (view, field, filter) {
        var _this = this;
        // \u53EA\u6709\u5B58\u5728\u8FD9\u4E2A scale \u65F6\u624D\u751F\u6548
        if (view.getScaleByField(field)) {
            view.filter(field, filter);
        }
        if (view.views && view.views.length) {
            (0,esm/* each */.S6)(view.views, function (subView) {
                _this.filterView(subView, field, filter);
            });
        }
    };
    /**
     * \u8FC7\u6EE4\u6570\u636E
     */
    DataFilter.prototype.filter = function () {
        var delegateObject = getDelegationObject(this.context);
        if (delegateObject) {
            var view = this.context.view;
            var component = delegateObject.component;
            var field = component.get('field');
            // \u5217\u8868\u7C7B\u7684\u7EC4\u4EF6\u80FD\u591F\u89E6\u53D1
            if (isList(delegateObject)) {
                if (field) {
                    var unCheckedItems = component.getItemsByState('unchecked');
                    var scale_1 = getScaleByField(view, field);
                    var names_1 = unCheckedItems.map(function (item) { return item.name; });
                    if (names_1.length) {
                        this.filterView(view, field, function (value) {
                            var text = scale_1.getText(value);
                            return !names_1.includes(text);
                        });
                    }
                    else {
                        this.filterView(view, field, null);
                    }
                    view.render(true);
                }
            }
            else if (isSlider(delegateObject)) {
                var range = component.getValue();
                var _a = (0,tslib_es6/* __read */.CR)(range, 2), min_1 = _a[0], max_1 = _a[1];
                this.filterView(view, field, function (value) {
                    return value >= min_1 && value <= max_1;
                });
                view.render(true);
            }
        }
    };
    return DataFilter;
}(action_base));
/* harmony default export */ var filter = (DataFilter);
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/data/range-filter.js




// \u83B7\u53D6\u5BF9\u5E94\u7684 scale
function getFilter(scale, dim, point1, point2) {
    var min = Math.min(point1[dim], point2[dim]);
    var max = Math.max(point1[dim], point2[dim]);
    var _a = (0,tslib_es6/* __read */.CR)(scale.range, 2), rangeMin = _a[0], rangeMax = _a[1];
    // \u7EA6\u675F\u503C\u5728 scale \u7684 range \u4E4B\u95F4
    if (min < rangeMin) {
        min = rangeMin;
    }
    if (max > rangeMax) {
        max = rangeMax;
    }
    // \u8303\u56F4\u5927\u4E8E\u6574\u4E2A view \u7684\u8303\u56F4\uFF0C\u5219\u8FD4\u56DE null
    if (min === rangeMax && max === rangeMax) {
        return null;
    }
    var minValue = scale.invert(min);
    var maxValue = scale.invert(max);
    if (scale.isCategory) {
        var minIndex = scale.values.indexOf(minValue);
        var maxIndex = scale.values.indexOf(maxValue);
        var arr_1 = scale.values.slice(minIndex, maxIndex + 1);
        return function (value) {
            return arr_1.includes(value);
        };
    }
    else {
        return function (value) {
            return value >= minValue && value <= maxValue;
        };
    }
}
/** range-filter \u53EA\u7528\u4E8E\uFF1Abrush-filter, brush-x-filter, brush-y-filter */
var range_filter_EVENTS;
(function (EVENTS) {
    EVENTS["FILTER"] = "brush-filter-processing";
    EVENTS["RESET"] = "brush-filter-reset";
    EVENTS["BEFORE_FILTER"] = "brush-filter:beforefilter";
    EVENTS["AFTER_FILTER"] = "brush-filter:afterfilter";
    EVENTS["BEFORE_RESET"] = "brush-filter:beforereset";
    EVENTS["AFTER_RESET"] = "brush-filter:afterreset";
})(range_filter_EVENTS || (range_filter_EVENTS = {}));

/**
 * \u8303\u56F4\u8FC7\u6EE4\u7684 Action
 * @ignore
 */
var RangeFilter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RangeFilter, _super);
    function RangeFilter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * \u8303\u56F4\u8FC7\u6EE4\u751F\u6548\u7684\u5B57\u6BB5/\u7EF4\u5EA6\uFF0C\u53EF\u4EE5\u662F x, y
         */
        _this.dims = ['x', 'y'];
        /** \u8D77\u59CB\u70B9 */
        _this.startPoint = null;
        _this.isStarted = false;
        return _this;
    }
    // x,y \u662F\u5426\u751F\u6548
    RangeFilter.prototype.hasDim = function (dim) {
        return this.dims.includes(dim);
    };
    /**
     * \u5F00\u59CB\u8303\u56F4\u8FC7\u6EE4\uFF0C\u8BB0\u5F55\u8303\u56F4\u8FC7\u6EE4\u7684\u8D77\u70B9
     */
    RangeFilter.prototype.start = function () {
        var context = this.context;
        this.isStarted = true;
        this.startPoint = context.getCurrentPoint();
    };
    /**
     * \u8FC7\u6EE4\uFF0C\u4EE5\u5F00\u59CB\u7684\u70B9\u548C\u5F53\u524D\u70B9\u5BF9\u6570\u636E\u8FDB\u884C\u8FC7\u6EE4
     */
    RangeFilter.prototype.filter = function () {
        var startPoint;
        var currentPoint;
        if (isMask(this.context)) {
            var maskShape = this.context.event.target;
            var bbox = maskShape.getCanvasBBox();
            startPoint = { x: bbox.x, y: bbox.y };
            currentPoint = { x: bbox.maxX, y: bbox.maxY };
        }
        else {
            if (!this.isStarted) {
                // \u5982\u679C\u6CA1\u6709\u5F00\u59CB\uFF0C\u5219\u4E0D\u6267\u884C\u8FC7\u6EE4
                return;
            }
            startPoint = this.startPoint;
            currentPoint = this.context.getCurrentPoint();
        }
        if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
            // \u8DDD\u79BB\u8FC7\u5C0F\u4E5F\u4E0D\u751F\u6548
            return;
        }
        var _a = this.context, view = _a.view, event = _a.event;
        var payload = { view: view, event: event, dims: this.dims };
        view.emit(range_filter_EVENTS.BEFORE_FILTER, chart_event.fromData(view, range_filter_EVENTS.BEFORE_FILTER, payload));
        var coord = view.getCoordinate();
        var normalCurrent = coord.invert(currentPoint);
        var normalStart = coord.invert(startPoint);
        // \u8BBE\u7F6E x \u65B9\u5411\u7684 filter
        if (this.hasDim('x')) {
            var xScale = view.getXScale();
            var filter = getFilter(xScale, 'x', normalCurrent, normalStart);
            this.filterView(view, xScale.field, filter);
        }
        // \u8BBE\u7F6E y \u65B9\u5411\u7684 filter
        if (this.hasDim('y')) {
            var yScale = view.getYScales()[0];
            var filter = getFilter(yScale, 'y', normalCurrent, normalStart);
            this.filterView(view, yScale.field, filter);
        }
        this.reRender(view, { source: range_filter_EVENTS.FILTER });
        view.emit(range_filter_EVENTS.AFTER_FILTER, chart_event.fromData(view, range_filter_EVENTS.AFTER_FILTER, payload));
    };
    /**
     * \u7ED3\u675F
     */
    RangeFilter.prototype.end = function () {
        this.isStarted = false;
    };
    /**
     * \u53D6\u6D88\u540C\u5F53\u524D Action \u76F8\u5173\u7684\u8FC7\u6EE4\uFF0C\u6307\u5B9A\u7684 x,y
     */
    RangeFilter.prototype.reset = function () {
        var view = this.context.view;
        view.emit(range_filter_EVENTS.BEFORE_RESET, chart_event.fromData(view, range_filter_EVENTS.BEFORE_RESET, {}));
        this.isStarted = false;
        if (this.hasDim('x')) {
            var xScale = view.getXScale();
            this.filterView(view, xScale.field, null); // \u53D6\u6D88\u8FC7\u6EE4
        }
        if (this.hasDim('y')) {
            // y \u8F74\u8FC7\u6EE4\u4EC5\u53D6\u7B2C\u4E00\u4E2A yScale
            var yScale = view.getYScales()[0];
            this.filterView(view, yScale.field, null); // \u53D6\u6D88\u8FC7\u6EE4
        }
        this.reRender(view, { source: range_filter_EVENTS.RESET });
        view.emit(range_filter_EVENTS.AFTER_RESET, chart_event.fromData(view, range_filter_EVENTS.AFTER_RESET, {}));
    };
    /**
     * \u5BF9 view \u8FDB\u884C\u8FC7\u6EE4
     */
    RangeFilter.prototype.filterView = function (view, field, filter) {
        view.filter(field, filter);
    };
    /**
     * \u91CD\u65B0\u6E32\u67D3
     * @param view
     */
    RangeFilter.prototype.reRender = function (view, payload) {
        view.render(true, payload);
    };
    return RangeFilter;
}(action_base));
/* harmony default export */ var range_filter = (RangeFilter);
//# sourceMappingURL=range-filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js




/**
 * \u6570\u636E\u8303\u56F4\u8FC7\u6EE4\uFF0C\u4F46\u4E0D\u5728\u5F53\u524D\u7684 view \u4E0A\u751F\u6548\uFF0C\u800C\u5728\u5F53\u524D\u7684 view \u540C\u4E00\u5C42\u7EA7\u7684\u5176\u4ED6 views \u4E0A\u751F\u6548\uFF0C\u7528\u4E8E\u5B9E\u73B0\u8054\u52A8\u8FC7\u6EE4\u3002
 * @ignore
 */
var SiblingFilter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SiblingFilter, _super);
    function SiblingFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u5BF9 view \u8FDB\u884C\u8FC7\u6EE4
     * @param view
     * @param field
     * @param filter
     */
    SiblingFilter.prototype.filterView = function (view, field, filter) {
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            sibling.filter(field, filter);
        });
    };
    /**
     * \u91CD\u65B0\u6E32\u67D3
     * @param view
     */
    SiblingFilter.prototype.reRender = function (view) {
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            sibling.render(true);
        });
    };
    return SiblingFilter;
}(range_filter));
/* harmony default export */ var sibling_filter = (SiblingFilter);
//# sourceMappingURL=sibling-filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/filter.js




/**
 * \u5143\u7D20\u8FC7\u6EE4\u7684 Action\uFF0C\u63A7\u5236\u5143\u7D20\u7684\u663E\u793A\u9690\u85CF
 * @ignore
 */
var ElementFilter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ElementFilter, _super);
    function ElementFilter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u8FC7\u6EE4
     */
    ElementFilter.prototype.filter = function () {
        var delegateObject = getDelegationObject(this.context);
        var view = this.context.view;
        var elements = getElements(view);
        if (isMask(this.context)) {
            var maskElements_1 = getMaskedElements(this.context, 10);
            if (maskElements_1) {
                (0,esm/* each */.S6)(elements, function (el) {
                    if (maskElements_1.includes(el)) {
                        el.show();
                    }
                    else {
                        el.hide();
                    }
                });
            }
        }
        else if (delegateObject) {
            var component = delegateObject.component;
            var field_1 = component.get('field');
            // \u5217\u8868\u7C7B\u7684\u7EC4\u4EF6\u80FD\u591F\u89E6\u53D1
            if (isList(delegateObject)) {
                if (field_1) {
                    var unCheckedItems = component.getItemsByState('unchecked');
                    var scale_1 = getScaleByField(view, field_1);
                    var names_1 = unCheckedItems.map(function (item) { return item.name; });
                    // \u76F4\u63A5\u63A7\u5236\u663E\u793A\u3001\u9690\u85CF
                    (0,esm/* each */.S6)(elements, function (el) {
                        var value = getElementValue(el, field_1);
                        var text = scale_1.getText(value);
                        if (names_1.indexOf(text) >= 0) {
                            el.hide();
                        }
                        else {
                            el.show();
                        }
                    });
                }
            }
            else if (isSlider(delegateObject)) {
                var range = component.getValue();
                var _a = (0,tslib_es6/* __read */.CR)(range, 2), min_1 = _a[0], max_1 = _a[1];
                (0,esm/* each */.S6)(elements, function (el) {
                    var value = getElementValue(el, field_1);
                    if (value >= min_1 && value <= max_1) {
                        el.show();
                    }
                    else {
                        el.hide();
                    }
                });
            }
        }
    };
    /**
     * \u6E05\u9664\u8FC7\u6EE4
     */
    ElementFilter.prototype.clear = function () {
        var elements = getElements(this.context.view);
        (0,esm/* each */.S6)(elements, function (el) {
            el.show();
        });
    };
    /**
     * \u6062\u590D\u53D1\u751F\u7684\u8FC7\u6EE4\uFF0C\u4FDD\u6301\u540C data-filter \u547D\u540D\u7684\u4E00\u81F4
     */
    ElementFilter.prototype.reset = function () {
        this.clear();
    };
    return ElementFilter;
}(action_base));
/* harmony default export */ var element_filter = (ElementFilter);
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js




/**
 * Sibling filter
 * @ignore
 */
var sibling_filter_SiblingFilter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SiblingFilter, _super);
    function SiblingFilter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.byRecord = false;
        return _this;
    }
    /**
     * \u8FC7\u6EE4\u9690\u85CF\u56FE\u5F62
     */
    SiblingFilter.prototype.filter = function () {
        // \u4EC5\u8003\u8651 mask \u5BFC\u81F4\u7684\u8FC7\u6EE4
        if (isMask(this.context)) {
            if (this.byRecord) {
                this.filterByRecord();
            }
            else {
                this.filterByBBox();
            }
        }
    };
    // \u6839\u636E\u6846\u9009\u7684\u8BB0\u5F55\u6765\u505A\u8FC7\u6EE4
    SiblingFilter.prototype.filterByRecord = function () {
        var view = this.context.view;
        var maskElements = getMaskedElements(this.context, 10);
        if (!maskElements) {
            return;
        }
        var xFiled = view.getXScale().field;
        var yField = view.getYScales()[0].field;
        var records = maskElements.map(function (el) {
            return el.getModel().data;
        });
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            var elements = getElements(sibling);
            (0,esm/* each */.S6)(elements, function (el) {
                var record = el.getModel().data;
                // records.includes(record) \u4E0D\u751F\u6548\uFF0C\u5E94\u8BE5\u662F\u6570\u636E\u7684\u5F15\u7528\u88AB\u6539\u4E86
                if (isInRecords(records, record, xFiled, yField)) {
                    el.show();
                }
                else {
                    el.hide();
                }
            });
        });
    };
    // \u6839\u636E\u88AB\u6846\u9009\u7684\u5305\u56F4\u76D2\u505A\u8FC7\u6EE4
    SiblingFilter.prototype.filterByBBox = function () {
        var _this = this;
        var view = this.context.view;
        var siblings = getSilbings(view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
            var elements = getElements(sibling);
            if (maskElements) {
                // mask \u8FC7\u5C0F\u65F6\u8FD4\u56DE\u4E3A null\uFF0C\u4E0D\u80FD\u662F\u7A7A\u6570\u7EC4\uFF0C\u5426\u5219\u540C\u672A\u6846\u9009\u5230\u6DF7\u6DC6
                (0,esm/* each */.S6)(elements, function (el) {
                    if (maskElements.includes(el)) {
                        el.show();
                    }
                    else {
                        el.hide();
                    }
                });
            }
        });
    };
    /**
     * \u6E05\u7406\u6240\u6709\u9690\u85CF\u7684\u56FE\u5F62
     */
    SiblingFilter.prototype.reset = function () {
        var siblings = getSilbings(this.context.view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            var elements = getElements(sibling);
            (0,esm/* each */.S6)(elements, function (el) {
                el.show();
            });
        });
    };
    return SiblingFilter;
}(action_base));
/* harmony default export */ var element_sibling_filter = (sibling_filter_SiblingFilter);
//# sourceMappingURL=sibling-filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/button.js





var PADDING_RIGHT = 10;
var PADDING_TOP = 5;
/**
 * Button action
 * @ignore
 */
var ButtonAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ButtonAction, _super);
    function ButtonAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buttonGroup = null;
        _this.buttonCfg = {
            name: 'button',
            text: 'button',
            textStyle: {
                x: 0,
                y: 0,
                fontSize: 12,
                fill: '#333333',
                cursor: 'pointer',
            },
            padding: [8, 10],
            style: {
                fill: '#f7f7f7',
                stroke: '#cccccc',
                cursor: 'pointer',
            },
            activeStyle: {
                fill: '#e6e6e6',
            },
        };
        return _this;
    }
    // mix \u9ED8\u8BA4\u7684\u914D\u7F6E\u548C\u7528\u6237\u914D\u7F6E
    ButtonAction.prototype.getButtonCfg = function () {
        return (0,esm/* deepMix */.b$)(this.buttonCfg, this.cfg);
    };
    // \u7ED8\u5236 Button \u548C \u6587\u672C
    ButtonAction.prototype.drawButton = function () {
        var config = this.getButtonCfg();
        var group = this.context.view.foregroundGroup.addGroup({
            name: config.name,
        });
        // \u6DFB\u52A0\u6587\u672C
        var textShape = group.addShape({
            type: 'text',
            name: 'button-text',
            attrs: (0,tslib_es6/* __assign */.pi)({ text: config.text }, config.textStyle),
        });
        var textBBox = textShape.getBBox();
        var padding = parsePadding(config.padding);
        // \u6DFB\u52A0\u80CC\u666F\u6309\u94AE
        var buttonShape = group.addShape({
            type: 'rect',
            name: 'button-rect',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2] }, config.style),
        });
        buttonShape.toBack(); // \u5728\u540E\u9762
        // active \u6548\u679C\u5185\u7F6E
        group.on('mouseenter', function () {
            buttonShape.attr(config.activeStyle);
        });
        group.on('mouseleave', function () {
            buttonShape.attr(config.style);
        });
        this.buttonGroup = group;
    };
    // \u91CD\u7F6E\u4F4D\u7F6E
    ButtonAction.prototype.resetPosition = function () {
        var view = this.context.view;
        var coord = view.getCoordinate();
        var point = coord.convert({ x: 1, y: 1 }); // \u540E\u9762\u76F4\u63A5\u6539\u6210\u5DE6\u4E0A\u89D2
        var buttonGroup = this.buttonGroup;
        var bbox = buttonGroup.getBBox();
        var matrix = ext/* transform */.vs(null, [
            ['t', point.x - bbox.width - PADDING_RIGHT, point.y + bbox.height + PADDING_TOP],
        ]);
        buttonGroup.setMatrix(matrix);
    };
    /**
     * \u663E\u793A
     */
    ButtonAction.prototype.show = function () {
        if (!this.buttonGroup) {
            this.drawButton();
        }
        this.resetPosition();
        this.buttonGroup.show();
    };
    /**
     * \u9690\u85CF
     */
    ButtonAction.prototype.hide = function () {
        if (this.buttonGroup) {
            this.buttonGroup.hide();
        }
    };
    /**
     * \u9500\u6BC1
     */
    ButtonAction.prototype.destroy = function () {
        var buttonGroup = this.buttonGroup;
        if (buttonGroup) {
            buttonGroup.remove();
        }
        _super.prototype.destroy.call(this);
    };
    return ButtonAction;
}(action_base));
/* harmony default export */ var view_button = (ButtonAction);
//# sourceMappingURL=button.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/drag.js



var DISTANCE = 4; // \u79FB\u52A8\u7684\u6700\u5C0F\u8DDD\u79BB
/**
 * @ignore
 * View \u652F\u6301 Drag \u7684 Action
 */
var Drag = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Drag, _super);
    function Drag() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // Action \u5F00\u59CB\uFF0C\u4E0D\u7B49\u540C\u4E8E \u62D6\u62FD\u5F00\u59CB\uFF0C\u9700\u8981\u5224\u5B9A\u79FB\u52A8\u7684\u8303\u56F4
        _this.starting = false;
        // \u62D6\u62FD\u5F00\u59CB
        _this.dragStart = false;
        return _this;
    }
    /**
     * \u5F00\u59CB
     */
    Drag.prototype.start = function () {
        this.starting = true;
        this.startPoint = this.context.getCurrentPoint();
    };
    /**
     * \u62D6\u62FD
     */
    Drag.prototype.drag = function () {
        if (!this.startPoint) {
            return;
        }
        var current = this.context.getCurrentPoint();
        var view = this.context.view;
        var event = this.context.event;
        if (!this.dragStart) {
            if (action_util_distance(current, this.startPoint) > DISTANCE) {
                view.emit('dragstart', {
                    target: event.target,
                    x: event.x,
                    y: event.y,
                });
                this.dragStart = true;
            }
        }
        else {
            view.emit('drag', {
                target: event.target,
                x: event.x,
                y: event.y,
            });
        }
    };
    /**
     * \u7ED3\u675F
     */
    Drag.prototype.end = function () {
        if (this.dragStart) {
            var view = this.context.view;
            var event_1 = this.context.event;
            view.emit('dragend', {
                target: event_1.target,
                x: event_1.x,
                y: event_1.y,
            });
        }
        this.starting = false;
        this.dragStart = false;
    };
    return Drag;
}(action_base));
/* harmony default export */ var drag = (Drag);
//# sourceMappingURL=drag.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/move.js




var MIN_DISTANCE = 5;
/**
 * @ignore
 * View \u79FB\u52A8\u7684 Action
 */
var Move = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Move, _super);
    function Move() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.starting = false;
        _this.isMoving = false;
        // private cacheRange = null;
        _this.startPoint = null;
        _this.startMatrix = null;
        return _this;
    }
    /**
     * \u5F00\u59CB\u79FB\u52A8
     */
    Move.prototype.start = function () {
        this.starting = true;
        this.startPoint = this.context.getCurrentPoint();
        // \u7F13\u5B58\u5F00\u59CB\u65F6\u7684\u77E9\u9635\uFF0C\u9632\u6B62\u53CD\u590D\u62D6\u62FD
        this.startMatrix = this.context.view.middleGroup.getMatrix();
    };
    /**
     * \u79FB\u52A8
     */
    Move.prototype.move = function () {
        if (!this.starting) {
            return;
        }
        var startPoint = this.startPoint;
        var currentPoint = this.context.getCurrentPoint();
        var d = action_util_distance(startPoint, currentPoint);
        if (d > MIN_DISTANCE && !this.isMoving) {
            this.isMoving = true;
        }
        if (this.isMoving) {
            var view = this.context.view;
            var matrix = ext/* transform */.vs(this.startMatrix, [
                ['t', currentPoint.x - startPoint.x, currentPoint.y - startPoint.y],
            ]);
            view.backgroundGroup.setMatrix(matrix);
            view.foregroundGroup.setMatrix(matrix);
            view.middleGroup.setMatrix(matrix);
        }
    };
    /**
     * \u7ED3\u675F\u79FB\u52A8
     */
    Move.prototype.end = function () {
        if (this.isMoving) {
            this.isMoving = false;
        }
        this.startMatrix = null;
        this.starting = false;
        this.startPoint = null;
    };
    /**
     * \u56DE\u6EDA
     */
    Move.prototype.reset = function () {
        this.starting = false;
        this.startPoint = null;
        this.isMoving = false;
        var view = this.context.view;
        view.backgroundGroup.resetMatrix();
        view.foregroundGroup.resetMatrix();
        view.middleGroup.resetMatrix();
        this.isMoving = false;
    };
    return Move;
}(action_base));
/* harmony default export */ var move = (Move);
//# sourceMappingURL=move.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js


var DIM_X = 'x';
var DIM_Y = 'y';
/**
 * Scale translate
 * @ignore
 */
var ScaleTranslate = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ScaleTranslate, _super);
    function ScaleTranslate() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.dims = [DIM_X, DIM_Y];
        _this.cfgFields = ['dims'];
        _this.cacheScaleDefs = {};
        return _this;
    }
    // \u662F\u5426\u652F\u6301\u5BF9\u5E94\u5B57\u6BB5\u7684\u5E73\u79FB
    ScaleTranslate.prototype.hasDim = function (dim) {
        return this.dims.includes(dim);
    };
    ScaleTranslate.prototype.getScale = function (dim) {
        var view = this.context.view;
        if (dim === 'x') {
            return view.getXScale();
        }
        else {
            return view.getYScales()[0];
        }
    };
    ScaleTranslate.prototype.resetDim = function (dim) {
        var view = this.context.view;
        if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
            var scale = this.getScale(dim);
            view.scale(scale.field, this.cacheScaleDefs[dim]);
            this.cacheScaleDefs[dim] = null;
        }
    };
    /**
     * \u56DE\u6EDA
     */
    ScaleTranslate.prototype.reset = function () {
        this.resetDim(DIM_X);
        this.resetDim(DIM_Y);
        var view = this.context.view;
        view.render(true);
    };
    return ScaleTranslate;
}(action_base));
/* harmony default export */ var scale_transform = (ScaleTranslate);
//# sourceMappingURL=scale-transform.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js



/**
 * \u62D6\u62FD Scale \u7684 Action
 * @ignore
 */
var scale_translate_ScaleTranslate = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ScaleTranslate, _super);
    function ScaleTranslate() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.startPoint = null;
        _this.starting = false;
        _this.startCache = {};
        return _this;
    }
    /**
     * \u5F00\u59CB
     */
    ScaleTranslate.prototype.start = function () {
        var _this = this;
        this.startPoint = this.context.getCurrentPoint();
        this.starting = true;
        var dims = this.dims;
        (0,esm/* each */.S6)(dims, function (dim) {
            var scale = _this.getScale(dim);
            var min = scale.min, max = scale.max, values = scale.values;
            _this.startCache[dim] = { min: min, max: max, values: values };
        });
    };
    // \u5E73\u79FB\u5206\u7C7B\u7684\u5EA6\u91CF
    // private translateCategory(dim, scale, normalPoint) {
    // }
    /**
     * \u7ED3\u675F
     */
    ScaleTranslate.prototype.end = function () {
        this.startPoint = null;
        this.starting = false;
        this.startCache = {};
    };
    /**
     * \u5E73\u79FB
     */
    ScaleTranslate.prototype.translate = function () {
        var _this = this;
        if (!this.starting) {
            return;
        }
        var startPoint = this.startPoint;
        var coord = this.context.view.getCoordinate();
        var currentPoint = this.context.getCurrentPoint();
        var normalStart = coord.invert(startPoint);
        var noramlCurrent = coord.invert(currentPoint);
        var dx = noramlCurrent.x - normalStart.x;
        var dy = noramlCurrent.y - normalStart.y;
        var view = this.context.view;
        var dims = this.dims;
        (0,esm/* each */.S6)(dims, function (dim) {
            _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
        });
        view.render(true);
    };
    // \u5E73\u79FB\u5EA6\u91CF
    ScaleTranslate.prototype.translateDim = function (dim, normalPoint) {
        if (this.hasDim(dim)) {
            var scale = this.getScale(dim);
            if (scale.isLinear) {
                this.translateLinear(dim, scale, normalPoint);
            }
            //  else { // \u6682\u65F6\u4EC5\u5904\u7406\u8FDE\u7EED\u5B57\u6BB5
            // this.translateCategory(dim, scale, normalPoint);
            // }
        }
    };
    // linear \u5EA6\u91CF\u5E73\u79FB
    ScaleTranslate.prototype.translateLinear = function (dim, scale, normalPoint) {
        var view = this.context.view;
        var _a = this.startCache[dim], min = _a.min, max = _a.max;
        var range = max - min;
        var d = normalPoint[dim] * range;
        // \u53EA\u6709\u7B2C\u4E00\u6B21\u7F13\u5B58\uFF0C\u5426\u5219\u65E0\u6CD5\u56DE\u6EDA
        if (!this.cacheScaleDefs[dim]) {
            this.cacheScaleDefs[dim] = {
                // @ts-ignore
                nice: scale.nice,
                min: min,
                max: max,
            };
        }
        view.scale(scale.field, {
            // @ts-ignore
            nice: false,
            min: min + d,
            max: max + d,
        });
    };
    // \u5E73\u79FB\u5206\u7C7B\u7684\u5EA6\u91CF
    // private translateCategory(dim, scale, normalPoint) {
    // }
    /**
     * \u56DE\u6EDA
     */
    ScaleTranslate.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.startPoint = null;
        this.starting = false;
    };
    return ScaleTranslate;
}(scale_transform));
/* harmony default export */ var scale_translate = (scale_translate_ScaleTranslate);
//# sourceMappingURL=scale-translate.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js



/**
 * \u7F29\u653E Scale \u7684 Action
 * @ignore
 */
var scale_zoom_ScaleTranslate = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ScaleTranslate, _super);
    function ScaleTranslate() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.zoomRatio = 0.05;
        return _this;
        // \u5E73\u79FB\u5206\u7C7B\u7684\u5EA6\u91CF
        // private translateCategory(dim, scale, normalPoint) {
        // }
    }
    /**
     * \u7F29\u5C0F
     */
    ScaleTranslate.prototype.zoomIn = function () {
        this.zoom(this.zoomRatio);
    };
    ScaleTranslate.prototype.zoom = function (scale) {
        var _this = this;
        var dims = this.dims;
        (0,esm/* each */.S6)(dims, function (dim) {
            _this.zoomDim(dim, scale);
        });
        this.context.view.render(true);
    };
    /**
     * \u653E\u5927
     */
    ScaleTranslate.prototype.zoomOut = function () {
        this.zoom(-1 * this.zoomRatio);
    };
    // \u7F29\u653E\u5EA6\u91CF
    ScaleTranslate.prototype.zoomDim = function (dim, dRatio) {
        if (this.hasDim(dim)) {
            var scale = this.getScale(dim);
            if (scale.isLinear) {
                this.zoomLinear(dim, scale, dRatio);
            }
            //  else { // \u6682\u65F6\u4EC5\u5904\u7406\u8FDE\u7EED\u5B57\u6BB5
            // this.zoomCategory(dim, scale, normalPoint);
            // }
        }
    };
    // linear \u5EA6\u91CF\u5E73\u79FB
    ScaleTranslate.prototype.zoomLinear = function (dim, scale, dRatio) {
        var view = this.context.view;
        // \u53EA\u6709\u7B2C\u4E00\u6B21\u7F13\u5B58\uFF0C\u5426\u5219\u65E0\u6CD5\u56DE\u6EDA
        if (!this.cacheScaleDefs[dim]) {
            this.cacheScaleDefs[dim] = {
                // @ts-ignore
                nice: scale.nice,
                min: scale.min,
                max: scale.max,
            };
        }
        // \u4F7F\u7528\u4F7F\u7528\u539F\u59CB\u5EA6\u91CF\u4F5C\u4E3A\u7F29\u653E\u6807\u51C6
        var scaleDef = this.cacheScaleDefs[dim];
        var range = scaleDef.max - scaleDef.min;
        var min = scale.min, max = scale.max;
        var d = dRatio * range;
        var toMin = min - d;
        var toMax = max + d;
        var curRange = toMax - toMin;
        var scaled = curRange / range;
        if (toMax > toMin && scaled < 100 && scaled > 0.01) {
            view.scale(scale.field, {
                // @ts-ignore
                nice: false,
                min: min - d,
                max: max + d,
            });
        }
    };
    return ScaleTranslate;
}(scale_transform));
/* harmony default export */ var scale_zoom = (scale_zoom_ScaleTranslate);
//# sourceMappingURL=scale-zoom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js



function isWheelDown(event) {
    var wheelEvent = event.gEvent.originalEvent;
    return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(MousewheelScroll, _super);
    function MousewheelScroll() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MousewheelScroll.prototype.scroll = function (arg) {
        var _a = this.context, view = _a.view, event = _a.event;
        if (!view.getOptions().scrollbar) {
            return;
        }
        var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
        var scrollbarController = view.getController('scrollbar');
        var xScale = view.getXScale();
        var data = view.getOptions().data;
        var dataSize = (0,esm/* size */.dp)((0,esm/* valuesOfKey */.I)(data, xScale.field));
        var step = (0,esm/* size */.dp)(xScale.values);
        var currentRatio = scrollbarController.getValue();
        var currentStart = Math.floor((dataSize - step) * currentRatio);
        var nextStart = currentStart + (isWheelDown(event) ? wheelDelta : -wheelDelta);
        var correction = wheelDelta / (dataSize - step) / 10000;
        var nextRatio = (0,esm/* clamp */.uZ)(nextStart / (dataSize - step) + correction, 0, 1);
        scrollbarController.setValue(nextRatio);
    };
    return MousewheelScroll;
}(action_base));
/* harmony default export */ var mousewheel_scroll = (MousewheelScroll);
//# sourceMappingURL=mousewheel-scroll.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/interaction/action/component/axis/axis-description.js






var AXIS_DESCRIPTION_TOOLTIP = 'aixs-description-tooltip';
var AxisDescription = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(AxisDescription, _super);
    function AxisDescription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisDescription.prototype.show = function () {
        var context = this.context;
        var axis = getDelegationObject(context).axis;
        var _a = axis.cfg.title, description = _a.description, text = _a.text, descriptionTooltipStyle = _a.descriptionTooltipStyle;
        var _b = context.event, x = _b.x, y = _b.y;
        if (!this.tooltip) {
            this.renderTooltip();
        }
        this.tooltip.update({
            title: text || '',
            customContent: function () {
                return "\\n          <div class=\\"".concat(css_const_CONTAINER_CLASS, "\\" style={").concat(descriptionTooltipStyle, "}>\\n            <div class=\\"").concat(TITLE_CLASS, "\\">\\n              \\u5B57\\u6BB5\\u8BF4\\u660E\\uFF1A").concat(description, "\\n            </div>\\n          </div>\\n        ");
            },
            x: x,
            y: y,
        });
        this.tooltip.show();
    };
    AxisDescription.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.tooltip && this.tooltip.destroy();
    };
    AxisDescription.prototype.hide = function () {
        this.tooltip && this.tooltip.hide();
    };
    AxisDescription.prototype.renderTooltip = function () {
        var _a;
        var view = this.context.view;
        var canvas = view.canvas;
        var region = {
            start: { x: 0, y: 0 },
            end: { x: canvas.get('width'), y: canvas.get('height') },
        };
        var tooltip = new HtmlTooltip({
            parent: canvas.get('el').parentNode,
            region: region,
            visible: false,
            containerId: AXIS_DESCRIPTION_TOOLTIP,
            domStyles: (0,tslib_es6/* __assign */.pi)({}, (0,esm/* deepMix */.b$)({}, (_a = {},
                // \u8D85\u957F\u7684\u65F6\u5019\uFF0Ctooltip tip \u6700\u5927\u5BBD\u5EA6\u4E3A 50%\uFF0C\u7136\u540E\u53EF\u4EE5\u6362\u884C
                _a[css_const_CONTAINER_CLASS] = {
                    'max-width': '50%',
                    padding: '10px',
                    'line-height': '15px',
                    'font-size': '12px',
                    color: 'rgba(0, 0, 0, .65)',
                },
                _a[TITLE_CLASS] = {
                    'word-break': 'break-all',
                    'margin-bottom': '3px',
                },
                _a))),
        });
        tooltip.init();
        tooltip.setCapture(false);
        this.tooltip = tooltip;
    };
    return AxisDescription;
}(action_base));
/* harmony default export */ var axis_description = (AxisDescription);
//# sourceMappingURL=axis-description.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2/esm/index.js
// \u6CE8\u518C\u9ED1\u6697\u4E3B\u9898



registerTheme('dark', createThemeByStyleSheet(antvDark));
// \u6CE8\u518C G \u6E32\u67D3\u5F15\u64CE



registerEngine('canvas', g_canvas_esm_namespaceObject);
registerEngine('svg', g_svg_esm_namespaceObject);
// \u6CE8\u518C G2 \u5185\u7F6E\u7684 geometry











registerGeometry('Polygon', geometry_polygon);
registerGeometry('Interval', geometry_interval);
registerGeometry('Schema', geometry_schema);
registerGeometry('Path', geometry_path);
registerGeometry('Point', geometry_point);
registerGeometry('Line', geometry_line);
registerGeometry('Area', geometry_area);
registerGeometry('Edge', geometry_edge);
registerGeometry('Heatmap', heatmap);
registerGeometry('Violin', geometry_violin);
// \u5F15\u5165\u6240\u6709\u5185\u7F6E\u7684 shapes




















// \u6CE8\u518C Geometry \u5185\u7F6E\u7684 label





registerGeometryLabel('base', label_base);
registerGeometryLabel('interval', label_interval);
registerGeometryLabel('pie', pie);
registerGeometryLabel('polar', label_polar);
// \u6CE8\u518C Geometry label \u5185\u7F6E\u7684\u5E03\u5C40\u51FD\u6570














registerGeometryLabelLayout('overlap', overlap);
registerGeometryLabelLayout('distribute', distribute);
registerGeometryLabelLayout('fixed-overlap', fixedOverlap);
registerGeometryLabelLayout('hide-overlap', hideOverlap);
registerGeometryLabelLayout('limit-in-shape', limitInShape);
registerGeometryLabelLayout('limit-in-canvas', limitInCanvas);
registerGeometryLabelLayout('limit-in-plot', limitInPlot);
registerGeometryLabelLayout('pie-outer', pieOuterLabelLayout);
registerGeometryLabelLayout('adjust-color', adjustColor);
registerGeometryLabelLayout('interval-adjust-position', intervalAdjustPosition);
registerGeometryLabelLayout('interval-hide-overlap', intervalHideOverlap);
registerGeometryLabelLayout('point-adjust-position', pointAdjustPosition);
registerGeometryLabelLayout('pie-spider', pieSpiderLabelLayout);
registerGeometryLabelLayout('path-adjust-position', pathAdjustPosition);
// \u6CE8\u518C\u9700\u8981\u7684\u52A8\u753B\u6267\u884C\u51FD\u6570









registerAnimation('fade-in', fadeIn);
registerAnimation('fade-out', fadeOut);
registerAnimation('grow-in-x', growInX);
registerAnimation('grow-in-xy', growInXY);
registerAnimation('grow-in-y', growInY);
registerAnimation('scale-in-x', scaleInX);
registerAnimation('scale-in-y', scaleInY);
registerAnimation('wave-in', waveIn);
registerAnimation('zoom-in', zoomIn);
registerAnimation('zoom-out', zoomOut);
registerAnimation('position-update', positionUpdate);
registerAnimation('sector-path-update', sectorPathUpdate);
registerAnimation('path-in', pathIn);
// \u6CE8\u518C\u5185\u7F6E\u7684 Facet







registerFacet('rect', facet_rect);
registerFacet('mirror', mirror);
registerFacet('list', list);
registerFacet('matrix', matrix);
registerFacet('circle', facet_circle);
registerFacet('tree', tree);
// \u6CE8\u518C\u5185\u7F6E\u7684 Component







// register build-in components
registerComponentController('axis', axis);
registerComponentController('legend', legend);
registerComponentController('tooltip', tooltip);
registerComponentController('annotation', annotation);
registerComponentController('slider', controller_slider);
registerComponentController('scrollbar', scrollbar);
// \u6CE8\u518C Interaction Action















































registerAction('tooltip', geometry);
registerAction('sibling-tooltip', sibling);
registerAction('ellipsis-text', ellipsis_text);
registerAction('element-active', active);
registerAction('element-single-active', single_active);
registerAction('element-range-active', range_active);
registerAction('element-highlight', highlight);
registerAction('element-highlight-by-x', highlight_by_x);
registerAction('element-highlight-by-color', highlight_by_color);
registerAction('element-single-highlight', single_highlight);
registerAction('element-range-highlight', range_highlight);
registerAction('element-sibling-highlight', range_highlight, {
    effectSiblings: true,
    effectByRecord: true,
});
registerAction('element-selected', selected);
registerAction('element-single-selected', single_selected);
registerAction('element-range-selected', range_selected);
registerAction('element-link-by-color', link_by_color);
registerAction('active-region', active_region);
registerAction('list-active', list_active);
registerAction('list-selected', list_selected);
registerAction('list-highlight', list_highlight);
registerAction('list-unchecked', list_unchecked);
registerAction('list-checked', list_checked);
registerAction('list-focus', list_focus);
registerAction('list-radio', list_radio);
registerAction('legend-item-highlight', list_highlight, {
    componentNames: ['legend'],
});
registerAction('axis-label-highlight', list_highlight, {
    componentNames: ['axis'],
});
registerAction('axis-description', axis_description);
registerAction('rect-mask', mask_rect);
registerAction('x-rect-mask', dim_rect, { dim: 'x' });
registerAction('y-rect-mask', dim_rect, { dim: 'y' });
registerAction('circle-mask', mask_circle);
registerAction('path-mask', mask_path);
registerAction('smooth-path-mask', smooth_path);
registerAction('rect-multi-mask', multiple_rect);
registerAction('x-rect-multi-mask', multiple_dim_rect, { dim: 'x' });
registerAction('y-rect-multi-mask', multiple_dim_rect, { dim: 'y' });
registerAction('circle-multi-mask', multiple_circle);
registerAction('path-multi-mask', multiple_path);
registerAction('smooth-path-multi-mask', multiple_smooth_path);
registerAction('cursor', cursor);
registerAction('data-filter', filter);
registerAction('brush', range_filter);
registerAction('brush-x', range_filter, { dims: ['x'] });
registerAction('brush-y', range_filter, { dims: ['y'] });
registerAction('sibling-filter', sibling_filter);
registerAction('sibling-x-filter', sibling_filter, { dims: 'x' });
registerAction('sibling-y-filter', sibling_filter, { dims: 'y' });
registerAction('element-filter', element_filter);
registerAction('element-sibling-filter', element_sibling_filter);
registerAction('element-sibling-filter-record', element_sibling_filter, { byRecord: true });
registerAction('view-drag', drag);
registerAction('view-move', move);
registerAction('scale-translate', scale_translate);
registerAction('scale-zoom', scale_zoom);
registerAction('reset-button', view_button, {
    name: 'reset-button',
    text: 'reset',
});
registerAction('mousewheel-scroll', mousewheel_scroll);
// \u6CE8\u518C\u9ED8\u8BA4\u7684 Interaction \u4EA4\u4E92\u884C\u4E3A


function isPointInView(context) {
    return context.isInPlot();
}
// \u6CE8\u518C tooltip \u7684 interaction
registerInteraction('tooltip', {
    start: [
        { trigger: 'plot:mousemove', action: 'tooltip:show', throttle: { wait: 50, leading: true, trailing: false } },
        { trigger: 'plot:touchmove', action: 'tooltip:show', throttle: { wait: 50, leading: true, trailing: false } },
    ],
    end: [
        { trigger: 'plot:mouseleave', action: 'tooltip:hide' },
        { trigger: 'plot:leave', action: 'tooltip:hide' },
        { trigger: 'plot:touchend', action: 'tooltip:hide' },
    ],
});
registerInteraction('ellipsis-text', {
    start: [
        {
            trigger: 'legend-item-name:mousemove',
            action: 'ellipsis-text:show',
            throttle: { wait: 50, leading: true, trailing: false },
        },
        {
            trigger: 'legend-item-name:touchstart',
            action: 'ellipsis-text:show',
            throttle: { wait: 50, leading: true, trailing: false },
        },
        {
            trigger: 'axis-label:mousemove',
            action: 'ellipsis-text:show',
            throttle: { wait: 50, leading: true, trailing: false },
        },
        {
            trigger: 'axis-label:touchstart',
            action: 'ellipsis-text:show',
            throttle: { wait: 50, leading: true, trailing: false },
        },
    ],
    end: [
        { trigger: 'legend-item-name:mouseleave', action: 'ellipsis-text:hide' },
        { trigger: 'legend-item-name:touchend', action: 'ellipsis-text:hide' },
        { trigger: 'axis-label:mouseleave', action: 'ellipsis-text:hide' },
        { trigger: 'axis-label:mouseout', action: 'ellipsis-text:hide' },
        { trigger: 'axis-label:touchend', action: 'ellipsis-text:hide' },
    ],
});
// \u79FB\u52A8\u5230 element \u4E0A active
registerInteraction('element-active', {
    start: [{ trigger: 'element:mouseenter', action: 'element-active:active' }],
    end: [{ trigger: 'element:mouseleave', action: 'element-active:reset' }],
});
// \u70B9\u51FB\u9009\u4E2D\uFF0C\u5141\u8BB8\u53D6\u6D88
registerInteraction('element-selected', {
    start: [{ trigger: 'element:click', action: 'element-selected:toggle' }],
});
// hover highlight\uFF0C\u5141\u8BB8\u53D6\u6D88
registerInteraction('element-highlight', {
    start: [{ trigger: 'element:mouseenter', action: 'element-highlight:highlight' }],
    end: [{ trigger: 'element:mouseleave', action: 'element-highlight:reset' }],
});
// hover highlight by x\uFF0C\u5141\u8BB8\u53D6\u6D88
registerInteraction('element-highlight-by-x', {
    start: [{ trigger: 'element:mouseenter', action: 'element-highlight-by-x:highlight' }],
    end: [{ trigger: 'element:mouseleave', action: 'element-highlight-by-x:reset' }],
});
// hover highlight by y\uFF0C\u5141\u8BB8\u53D6\u6D88
registerInteraction('element-highlight-by-color', {
    start: [{ trigger: 'element:mouseenter', action: 'element-highlight-by-color:highlight' }],
    end: [{ trigger: 'element:mouseleave', action: 'element-highlight-by-color:reset' }],
});
// legend hover\uFF0Celement active
registerInteraction('legend-active', {
    start: [{ trigger: 'legend-item:mouseenter', action: ['list-active:active', 'element-active:active'] }],
    end: [{ trigger: 'legend-item:mouseleave', action: ['list-active:reset', 'element-active:reset'] }],
});
// legend hover\uFF0Celement active
registerInteraction('legend-highlight', {
    start: [
        { trigger: 'legend-item:mouseenter', action: ['legend-item-highlight:highlight', 'element-highlight:highlight'] },
    ],
    end: [{ trigger: 'legend-item:mouseleave', action: ['legend-item-highlight:reset', 'element-highlight:reset'] }],
});
// legend hover\uFF0Celement active
registerInteraction('axis-label-highlight', {
    start: [
        { trigger: 'axis-label:mouseenter', action: ['axis-label-highlight:highlight', 'element-highlight:highlight'] },
    ],
    end: [{ trigger: 'axis-label:mouseleave', action: ['axis-label-highlight:reset', 'element-highlight:reset'] }],
});
// legend hover\uFF0Celement active
registerInteraction('element-list-highlight', {
    start: [{ trigger: 'element:mouseenter', action: ['list-highlight:highlight', 'element-highlight:highlight'] }],
    end: [{ trigger: 'element:mouseleave', action: ['list-highlight:reset', 'element-highlight:reset'] }],
});
// \u6846\u9009
registerInteraction('element-range-highlight', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'mask:mouseenter', action: 'cursor:move' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
        { trigger: 'mask:mouseleave', action: 'cursor:crosshair' },
    ],
    start: [
        {
            trigger: 'plot:mousedown',
            isEnable: function (context) {
                // \u4E0D\u8981\u70B9\u51FB\u5728 mask \u4E0A\u91CD\u65B0\u5F00\u59CB
                return !context.isInShape('mask');
            },
            action: ['rect-mask:start', 'rect-mask:show'],
        },
        {
            trigger: 'mask:dragstart',
            action: ['rect-mask:moveStart'],
        },
    ],
    processing: [
        {
            trigger: 'plot:mousemove',
            action: ['rect-mask:resize'],
        },
        {
            trigger: 'mask:drag',
            action: ['rect-mask:move'],
        },
        {
            trigger: 'mask:change',
            action: ['element-range-highlight:highlight'],
        },
    ],
    end: [
        { trigger: 'plot:mouseup', action: ['rect-mask:end'] },
        { trigger: 'mask:dragend', action: ['rect-mask:moveEnd'] },
        {
            trigger: 'document:mouseup',
            isEnable: function (context) {
                return !context.isInPlot();
            },
            action: ['element-range-highlight:clear', 'rect-mask:end', 'rect-mask:hide'],
        },
    ],
    rollback: [{ trigger: 'dblclick', action: ['element-range-highlight:clear', 'rect-mask:hide'] }],
});
registerInteraction('brush', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
    ],
    start: [
        {
            trigger: 'mousedown',
            isEnable: isPointInView,
            action: ['brush:start', 'rect-mask:start', 'rect-mask:show'],
        },
    ],
    processing: [
        {
            trigger: 'mousemove',
            isEnable: isPointInView,
            action: ['rect-mask:resize'],
        },
    ],
    end: [
        {
            trigger: 'mouseup',
            isEnable: isPointInView,
            action: ['brush:filter', 'brush:end', 'rect-mask:end', 'rect-mask:hide', 'reset-button:show'],
        },
    ],
    rollback: [{ trigger: 'reset-button:click', action: ['brush:reset', 'reset-button:hide', 'cursor:crosshair'] }],
});
registerInteraction('brush-visible', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
    ],
    start: [
        {
            trigger: 'plot:mousedown',
            action: ['rect-mask:start', 'rect-mask:show'],
        },
    ],
    processing: [
        {
            trigger: 'plot:mousemove',
            action: ['rect-mask:resize'],
        },
        { trigger: 'mask:change', action: ['element-range-highlight:highlight'] },
    ],
    end: [
        {
            trigger: 'plot:mouseup',
            action: ['rect-mask:end', 'rect-mask:hide', 'element-filter:filter', 'element-range-highlight:clear'],
        },
    ],
    rollback: [
        {
            trigger: 'dblclick',
            action: ['element-filter:clear'],
        },
    ],
});
registerInteraction('brush-x', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
    ],
    start: [
        {
            trigger: 'mousedown',
            isEnable: isPointInView,
            action: ['brush-x:start', 'x-rect-mask:start', 'x-rect-mask:show'],
        },
    ],
    processing: [
        {
            trigger: 'mousemove',
            isEnable: isPointInView,
            action: ['x-rect-mask:resize'],
        },
    ],
    end: [
        {
            trigger: 'mouseup',
            isEnable: isPointInView,
            action: ['brush-x:filter', 'brush-x:end', 'x-rect-mask:end', 'x-rect-mask:hide'],
        },
    ],
    rollback: [{ trigger: 'dblclick', action: ['brush-x:reset'] }],
});
registerInteraction('element-path-highlight', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
    ],
    start: [
        { trigger: 'mousedown', isEnable: isPointInView, action: 'path-mask:start' },
        { trigger: 'mousedown', isEnable: isPointInView, action: 'path-mask:show' },
    ],
    processing: [{ trigger: 'mousemove', action: 'path-mask:addPoint' }],
    end: [{ trigger: 'mouseup', action: 'path-mask:end' }],
    rollback: [{ trigger: 'dblclick', action: 'path-mask:hide' }],
});
registerInteraction('brush-x-multi', {
    showEnable: [
        { trigger: 'plot:mouseenter', action: 'cursor:crosshair' },
        { trigger: 'mask:mouseenter', action: 'cursor:move' },
        { trigger: 'plot:mouseleave', action: 'cursor:default' },
        { trigger: 'mask:mouseleave', action: 'cursor:crosshair' },
    ],
    start: [
        {
            trigger: 'mousedown',
            isEnable: isPointInView,
            action: ['x-rect-multi-mask:start', 'x-rect-multi-mask:show'],
        },
        {
            trigger: 'mask:dragstart',
            action: ['x-rect-multi-mask:moveStart'],
        },
    ],
    processing: [
        {
            trigger: 'mousemove',
            isEnable: function (context) { return !isMultipleMask(context); },
            action: ['x-rect-multi-mask:resize'],
        },
        {
            trigger: 'multi-mask:change',
            action: 'element-range-highlight:highlight',
        },
        {
            trigger: 'mask:drag',
            action: ['x-rect-multi-mask:move'],
        },
    ],
    end: [
        {
            trigger: 'mouseup',
            action: ['x-rect-multi-mask:end'],
        },
        { trigger: 'mask:dragend', action: ['x-rect-multi-mask:moveEnd'] },
    ],
    rollback: [
        {
            trigger: 'dblclick',
            action: ['x-rect-multi-mask:clear', 'cursor:crosshair'],
        },
        {
            trigger: 'multi-mask:clearAll',
            action: ['element-range-highlight:clear'],
        },
        {
            trigger: 'multi-mask:clearSingle',
            action: ['element-range-highlight:highlight'],
        },
    ],
});
// \u70B9\u51FB\u9009\u4E2D\uFF0C\u5141\u8BB8\u53D6\u6D88
registerInteraction('element-single-selected', {
    start: [{ trigger: 'element:click', action: 'element-single-selected:toggle' }],
});
// \u7B5B\u9009\u6570\u636E
registerInteraction('legend-filter', {
    showEnable: [
        { trigger: 'legend-item:mouseenter', action: ['cursor:pointer', 'list-radio:show'] },
        { trigger: 'legend-item:mouseleave', action: ['cursor:default', 'list-radio:hide'] },
    ],
    start: [
        {
            trigger: 'legend-item:click',
            isEnable: function (context) {
                return !context.isInShape('legend-item-radio');
            },
            action: ['legend-item-highlight:reset', 'element-highlight:reset', 'list-unchecked:toggle', 'data-filter:filter', 'list-radio:show'],
        },
        //  \u6B63\u53CD\u9009\u6570\u636E: \u53EA\u6709\u5F53 radio === truthy \u7684\u65F6\u5019\u624D\u4F1A\u6709 legend-item-radio \u8FD9\u4E2A\u5143\u7D20
        {
            trigger: 'legend-item-radio:mouseenter',
            action: ['list-radio:showTip'],
        },
        {
            trigger: 'legend-item-radio:mouseleave',
            action: ['list-radio:hideTip'],
        },
        {
            trigger: 'legend-item-radio:click',
            action: ['list-focus:toggle', 'data-filter:filter', 'list-radio:show'],
        },
    ],
});
// \u7B5B\u9009\u6570\u636E
registerInteraction('continuous-filter', {
    start: [{ trigger: 'legend:valuechanged', action: 'data-filter:filter' }],
});
// \u7B5B\u9009\u6570\u636E
registerInteraction('continuous-visible-filter', {
    start: [{ trigger: 'legend:valuechanged', action: 'element-filter:filter' }],
});
// \u7B5B\u9009\u56FE\u5F62
registerInteraction('legend-visible-filter', {
    showEnable: [
        { trigger: 'legend-item:mouseenter', action: 'cursor:pointer' },
        { trigger: 'legend-item:mouseleave', action: 'cursor:default' },
    ],
    start: [{ trigger: 'legend-item:click', action: ['legend-item-highlight:reset', 'element-highlight:reset', 'list-unchecked:toggle', 'element-filter:filter'] }],
});
// \u51FA\u73B0\u80CC\u666F\u6846
registerInteraction('active-region', {
    start: [{ trigger: 'plot:mousemove', action: 'active-region:show' }],
    end: [{ trigger: 'plot:mouseleave', action: 'active-region:hide' }],
});
// \u663E\u793A\u5750\u6807\u8F74\u6807\u9898\u8BE6\u60C5\u4FE1\u606F
registerInteraction('axis-description', {
    start: [{ trigger: 'axis-description:mousemove', action: 'axis-description:show' }],
    end: [{ trigger: 'axis-description:mouseleave', action: 'axis-description:hide' }]
});
function esm_isWheelDown(event) {
    event.gEvent.preventDefault();
    return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction('view-zoom', {
    start: [
        {
            trigger: 'plot:mousewheel',
            isEnable: function (context) {
                return esm_isWheelDown(context.event);
            },
            action: 'scale-zoom:zoomOut',
            throttle: { wait: 100, leading: true, trailing: false },
        },
        {
            trigger: 'plot:mousewheel',
            isEnable: function (context) {
                return !esm_isWheelDown(context.event);
            },
            action: 'scale-zoom:zoomIn',
            throttle: { wait: 100, leading: true, trailing: false },
        },
    ],
});
registerInteraction('sibling-tooltip', {
    start: [{ trigger: 'plot:mousemove', action: 'sibling-tooltip:show' }],
    end: [{ trigger: 'plot:mouseleave', action: 'sibling-tooltip:hide' }],
});
registerInteraction('plot-mousewheel-scroll', {
    start: [{ trigger: 'plot:mousewheel', action: 'mousewheel-scroll:scroll' }],
});
// \u66B4\u9732\u4E00\u4E9B\u5E38\u91CF

/** brush \u8303\u56F4\u7B5B\u9009\u7684\u4E00\u4E9B\u4E8B\u4EF6\u5E38\u91CF */


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/constant.js
/**
 * \u9700\u8981\u4ECE\u8F74\u914D\u7F6E\u4E2D\u63D0\u53D6\u51FA\u6765\u4F5C\u4E3A meta \u7684\u5C5E\u6027 key \u5217\u8868
 */
var AXIS_META_CONFIG_KEYS = [
    'type',
    'alias',
    'tickCount',
    'tickInterval',
    'min',
    'max',
    'nice',
    'minLimit',
    'maxLimit',
    // \u5750\u6807\u8F74\u7684\u8303\u56F4
    'range',
    'tickMethod',
    // type: 'log' \u7684\u5E95
    'base',
    // type: 'exp' \u7684\u6307\u6570
    'exponent',
    // time \u7C7B\u578B\u7684\u683C\u5F0F\u5316
    'mask',
    // \u662F\u5426\u540C\u6B65
    'sync',
];
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/invariant.js
/**
 * Simplified from https://github.com/zertosh/invariant.
 */

var LEVEL;
(function (LEVEL) {
    LEVEL["ERROR"] = "error";
    LEVEL["WARN"] = "warn";
    LEVEL["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = 'AntV/G2Plot';
/**
 * \u83B7\u53D6\u9519\u8BEF\u6D88\u606F
 * @param format
 * @param args
 */
function getMessage(format) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var argIndex = 0;
    return "".concat(BRAND, ": ").concat(format.replace(/%s/g, function () { return "".concat(args[argIndex++]); }));
}
/**
 * invariant error
 * @param condition
 * @param format
 * @param args
 */
function invariant(condition, format) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if (!condition) {
        var error = new Error(getMessage.apply(void 0, __spreadArray([format], args, false)));
        error.name = BRAND;
        // error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
    }
}
/**
 * \u6253\u5370\u8BED\u53E5
 * @param level
 * @param condition
 * @param format
 * @param args
 */
function invariant_log(level, condition, format) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (!condition) {
        console[level](getMessage.apply(void 0, (0,tslib_es6/* __spreadArray */.ev)([format], args, false)));
    }
}
//# sourceMappingURL=invariant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pick.js
/**
 * \u7C7B\u4F3C lodash.pick \u7684\u65B9\u6CD5
 * @param obj
 * @param keys
 */
function pick(obj, keys) {
    var r = {};
    if (obj !== null && typeof obj === 'object') {
        keys.forEach(function (key) {
            var v = obj[key];
            if (v !== undefined) {
                r[key] = v;
            }
        });
    }
    return r;
}
//# sourceMappingURL=pick.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/data.js




/**
 * \u67E5\u770B\u6570\u636E\u662F\u5426\u662F\u5168\u8D1F\u6570\u3001\u6216\u8005\u5168\u6B63\u6570
 * @param data
 * @param field
 */
function adjustYMetaByZero(data, field) {
    if (!data)
        return {};
    // \u8FC7\u6EE4\u51FA\u6570\u5B57\u6570\u636E
    var numberData = data.filter(function (datum) {
        var v = (0,esm/* get */.U2)(datum, [field]);
        return (0,esm/* isNumber */.hj)(v) && !isNaN(v);
    });
    var gtZero = numberData.every(function (datum) { return (0,esm/* get */.U2)(datum, [field]) >= 0; });
    var ltZero = numberData.every(function (datum) { return (0,esm/* get */.U2)(datum, [field]) <= 0; });
    // \u76EE\u524D\u662F\u589E\u91CF\u66F4\u65B0\uFF0C\u5BF9 { min: 0, max: undefined } \u8FDB\u884C update({ max: 0 }) \u4F1A\u5F97\u5230 { min: 0, max: 0 }
    if (gtZero) {
        return { min: 0 };
    }
    if (ltZero) {
        return { max: 0 };
    }
    return {};
}
/**
 * \u8F6C\u6362\u6570\u636E\u683C\u5F0F\u4E3A\u5E26\u6709\u8282\u70B9\u4E0E\u8FB9\u7684\u6570\u636E\u683C\u5F0F
 * @param data
 * @param sourceField
 * @param targetField
 * @param weightField
 * @param rawFields \u5B58\u653E\u4E00\u4E9B\u539F\u6570\u636E
 */
function transformDataToNodeLinkData(data, sourceField, targetField, weightField, rawFields) {
    if (rawFields === void 0) { rawFields = []; }
    if (!Array.isArray(data)) {
        return {
            nodes: [],
            links: [],
        };
    }
    //   const nodes = [];
    var links = [];
    // \u5148\u4F7F\u7528\u5BF9\u8C61\u65B9\u5F0F\u5B58\u50A8
    var nodesMap = {};
    var nodesIndex = -1;
    // \u6570\u7EC4\u53D8\u6362\u6210 chord layout \u7684\u6570\u636E\u7ED3\u6784
    data.forEach(function (datum) {
        var source = datum[sourceField];
        var target = datum[targetField];
        var weight = datum[weightField];
        var rawData = pick(datum, rawFields);
        // source node
        if (!nodesMap[source]) {
            nodesMap[source] = (0,tslib_es6/* __assign */.pi)({ id: ++nodesIndex, name: source }, rawData);
        }
        if (!nodesMap[target]) {
            nodesMap[target] = (0,tslib_es6/* __assign */.pi)({ id: ++nodesIndex, name: target }, rawData);
        }
        // links
        links.push((0,tslib_es6/* __assign */.pi)({ source: nodesMap[source].id, target: nodesMap[target].id, 
            // sourceName: source,
            // targetName: target,
            value: weight }, rawData));
    });
    return {
        // \u9700\u8981\u6309\u7167 id \u7684\u987A\u5E8F
        nodes: Object.values(nodesMap).sort(function (a, b) { return a.id - b.id; }),
        links: links,
    };
}
/**
 * \u5904\u7406\u4E0D\u5408\u6CD5\u7684\u6570\u636E(\u8FC7\u6EE4 \u975E\u6570\u503C\u578B \u548C NaN\uFF0C\u4FDD\u7559 null)
 * @param data
 * @param angleField
 */
function processIllegalData(data, field) {
    var processData = (0,esm/* filter */.hX)(data, function (d) {
        var v = d[field];
        return v === null || (typeof v === 'number' && !isNaN(v));
    });
    // \u6253\u5370\u5F02\u5E38\u6570\u636E\u60C5\u51B5
    invariant_log(LEVEL.WARN, processData.length === data.length, 'illegal data existed in chart data.');
    return processData;
}
//# sourceMappingURL=data.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/deep-assign.js
var MAX_MIX_LEVEL = 5; // \u6700\u5927\u6BD4\u5BF9\u5C42\u7EA7
var deep_assign_toString = {}.toString;
// \u7C7B\u578B\u68C0\u6D4B
var isType = function (value, type) { return deep_assign_toString.call(value) === '[object ' + type + ']'; };
var deep_assign_isArray = function (value) {
    return isType(value, 'Array');
};
var isObjectLike = function (value) {
    /**
     * isObjectLike({}) => true
     * isObjectLike([1, 2, 3]) => true
     * isObjectLike(Function) => false
     */
    return typeof value === 'object' && value !== null;
};
var isPlainObject = function (value) {
    /**
     * isObjectLike(new Foo) => false
     * isObjectLike([1, 2, 3]) => false
     * isObjectLike({ x: 0, y: 0 }) => true
     */
    if (!isObjectLike(value) || !isType(value, 'Object')) {
        return false;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
};
/***
 * @param {any} dist
 * @param {any} src
 * @param {number} level \u5F53\u524D\u5C42\u7EA7
 * @param {number} maxLevel \u6700\u5927\u5C42\u7EA7
 */
var deep = function (dist, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
        if (Object.prototype.hasOwnProperty.call(src, key)) {
            var value = src[key];
            if (!value) {
                // null \u3001 undefined \u7B49\u60C5\u51B5\u76F4\u63A5\u8D4B\u503C
                dist[key] = value;
            }
            else {
                if (isPlainObject(value)) {
                    if (!isPlainObject(dist[key])) {
                        dist[key] = {};
                    }
                    if (level < maxLevel) {
                        deep(dist[key], value, level + 1, maxLevel);
                    }
                    else {
                        // \u5C42\u7EA7\u8FC7\u6DF1\u76F4\u63A5\u8D4B\u503C\uFF0C\u6027\u80FD\u95EE\u9898
                        dist[key] = src[key];
                    }
                }
                else if (deep_assign_isArray(value)) {
                    dist[key] = [];
                    dist[key] = dist[key].concat(value);
                }
                else {
                    dist[key] = value;
                }
            }
        }
    }
};
/**
 * deepAssign \u529F\u80FD\u7C7B\u4F3C deepMix
 * \u4E0D\u540C\u70B9\u5728\u4E8E deepAssign \u4F1A\u5C06 null undefined \u7B49\u7C7B\u578B\u76F4\u63A5\u8986\u76D6\u7ED9 source
 * \u8BE6\u7EC6\u53C2\u8003\uFF1A __tests__/unit/utils/deep-assign-spec.ts
 */
var deepAssign = function (rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
        deep(rst, args[i]);
    }
    return rst;
};
//# sourceMappingURL=deep-assign.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/dom.js
/**
 * get the element's bounding size
 * @param ele dom element
 * @returns the element width and height
 */
function getContainerSize(ele) {
    if (!ele) {
        return { width: 0, height: 0 };
    }
    var style = getComputedStyle(ele);
    return {
        width: (ele.clientWidth || parseInt(style.width, 10)) -
            parseInt(style.paddingLeft, 10) -
            parseInt(style.paddingRight, 10),
        height: (ele.clientHeight || parseInt(style.height, 10)) -
            parseInt(style.paddingTop, 10) -
            parseInt(style.paddingBottom, 10),
    };
}
//# sourceMappingURL=dom.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/flow.js
/**
 * \u7C7B\u4F3C lodash.flow \u7684\u65B9\u6CD5
 * @param flows
 */
function flow() {
    var flows = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        flows[_i] = arguments[_i];
    }
    return function (param) {
        return flows.reduce(function (result, f) {
            return f(result);
        }, param);
    };
}
//# sourceMappingURL=flow.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/geometry.js

/**
 * \u5728 View \u4E2D\u67E5\u627E\u7B2C\u4E00\u4E2A\u6307\u5B9A type \u7C7B\u578B\u7684 geometry
 * @param view
 * @param type
 */
function findGeometry(view, type) {
    return view.geometries.find(function (g) { return g.type === type; });
}
/**
 * \u83B7\u53D6 View \u7684 \u6240\u6709 elements
 */
function getAllElements(view) {
    return (0,esm/* reduce */.u4)(view.geometries, function (r, geometry) {
        return r.concat(geometry.elements);
    }, []);
}
/**
 * \u9012\u5F52\u83B7\u53D6 View \u7684 \u6240\u6709 elements, \u5305\u62EC View \u7684\u5B50 View
 */
function getAllElementsRecursively(view) {
    if ((0,esm/* get */.U2)(view, ['views', 'length'], 0) <= 0) {
        return getAllElements(view);
    }
    return (0,esm/* reduce */.u4)(view.views, function (ele, subView) {
        return ele.concat(getAllElementsRecursively(subView));
    }, getAllElements(view));
}
/**
 * \u9012\u5F52\u83B7\u53D6 View \u7684 \u6240\u6709 geometries, \u5305\u62EC View \u7684\u5B50 View
 */
function getAllGeometriesRecursively(view) {
    if ((0,esm/* get */.U2)(view, ['views', 'length'], 0) <= 0) {
        return view.geometries;
    }
    return (0,esm/* reduce */.u4)(view.views, function (ele, subView) {
        return ele.concat(subView.geometries);
    }, view.geometries);
}
//# sourceMappingURL=geometry.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/label.js


/**
 * \u517C\u5BB9 v1 label formatter
 * @param labelOptions
 */
function transformLabel(labelOptions) {
    if (!(0,esm/* isType */.P9)(labelOptions, 'Object')) {
        return labelOptions;
    }
    var label = (0,tslib_es6/* __assign */.pi)({}, labelOptions);
    if (label.formatter && !label.content) {
        label.content = label.formatter;
    }
    return label;
}
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/context.js
var context_ctx;
/**
 * \u83B7\u53D6 canvas context
 */
function context_getCanvasContext() {
    if (!context_ctx) {
        context_ctx = document.createElement('canvas').getContext('2d');
    }
    return context_ctx;
}
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/measure-text.js



/**
 * \u8BA1\u7B97\u6587\u672C\u5728\u753B\u5E03\u4E2D\u7684\u5BBD\u5EA6
 * @param text \u6587\u672C
 * @param font \u5B57\u4F53
 */
var measure_text_measureTextWidth = (0,esm/* memoize */.HP)(function (text, font) {
    if (font === void 0) { font = {}; }
    var fontSize = font.fontSize, _a = font.fontFamily, fontFamily = _a === void 0 ? 'sans-serif' : _a, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    var ctx = context_getCanvasContext();
    // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/font
    ctx.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(' ');
    var metrics = ctx.measureText((0,esm/* isString */.HD)(text) ? text : '');
    return metrics.width;
}, function (text, font) {
    if (font === void 0) { font = {}; }
    return (0,tslib_es6/* __spreadArray */.ev)([text], (0,esm/* values */.VO)(font), true).join('');
});
//# sourceMappingURL=measure-text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/number.js
/**
 * \u662F\u5426\u771F\u5B9E\u7684\u662F\u6570\u5B57
 * @param v
 */
function isRealNumber(v) {
    return typeof v === 'number' && !isNaN(v);
}
/**
 * @ignore
 * Determines whether between is
 * @param value
 * @param start
 * @param end
 * @returns true if between
 */
function number_isBetween(value, start, end) {
    var min = Math.min(start, end);
    var max = Math.max(start, end);
    return value >= min && value <= max;
}
//# sourceMappingURL=number.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/padding.js

/**
 * \u628A padding \u8F6C\u6362\u6210\u7EDF\u4E00\u7684\u6570\u7EC4\u5199\u6CD5
 * @param padding
 */
function normalPadding(padding) {
    if ((0,esm/* isNumber */.hj)(padding)) {
        return [padding, padding, padding, padding];
    }
    if ((0,esm/* isArray */.kJ)(padding)) {
        var length_1 = padding.length;
        if (length_1 === 1) {
            return [padding[0], padding[0], padding[0], padding[0]];
        }
        if (length_1 === 2) {
            return [padding[0], padding[1], padding[0], padding[1]];
        }
        if (length_1 === 3) {
            return [padding[0], padding[1], padding[2], padding[1]];
        }
        if (length_1 === 4) {
            return padding;
        }
    }
    return [0, 0, 0, 0];
}
/**
 * \u83B7\u53D6\u8C03\u6574\u7684 appendPadding
 */
function getAdjustAppendPadding(padding, position, append) {
    if (position === void 0) { position = 'bottom'; }
    if (append === void 0) { append = 25; }
    var currentAppendPadding = normalPadding(padding);
    var PADDING = [
        position.startsWith('top') ? append : 0,
        position.startsWith('right') ? append : 0,
        position.startsWith('bottom') ? append : 0,
        position.startsWith('left') ? append : 0,
    ];
    return [
        currentAppendPadding[0] + PADDING[0],
        currentAppendPadding[1] + PADDING[1],
        currentAppendPadding[2] + PADDING[2],
        currentAppendPadding[3] + PADDING[3],
    ];
}
/**
 * \u6839\u636E\u56FE\u8868\u7684 padding \u548C appendPadding \u8BA1\u7B97\u51FA\u56FE\u8868\u7684\u6700\u7EC8 padding
 * @param array
 */
function resolveAllPadding(paddings) {
    // \u5148\u628A\u6570\u7EC4\u91CC\u7684 padding \u5168\u90E8\u8F6C\u6362\u6210 normal
    var normalPaddings = paddings.map(function (item) { return normalPadding(item); });
    var finalPadding = [0, 0, 0, 0];
    if (normalPaddings.length > 0) {
        finalPadding = finalPadding.map(function (item, index) {
            // \u6709\u51E0\u4E2A padding \u6570\u7EC4\u5C31\u904D\u5386\u51E0\u6B21\uFF0C\u7D2F\u52A0
            normalPaddings.forEach(function (d, i) {
                item += normalPaddings[i][index];
            });
            return item;
        });
    }
    return finalPadding;
}
//# sourceMappingURL=padding.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/path.js

function points2Path(points, isInCircle) {
    var path = [];
    if (points.length) {
        path.push(['M', points[0].x, points[0].y]);
        for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
            var item = points[i];
            path.push(['L', item.x, item.y]);
        }
        if (isInCircle) {
            path.push(['Z']);
        }
    }
    return path;
}
/**
 * @ignore
 * \u8BA1\u7B97\u5149\u6ED1\u7684\u8D1D\u585E\u5C14\u66F2\u7EBF
 */
var path_smoothBezier = function (points, smooth, isLoop, constraint) {
    var cps = [];
    var prevPoint;
    var nextPoint;
    var hasConstraint = !!constraint;
    var min;
    var max;
    if (hasConstraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            min = vec2/* min */.VV([0, 0], min, point);
            max = vec2/* max */.Fp([0, 0], max, point);
        }
        min = vec2/* min */.VV([0, 0], min, constraint[0]);
        max = vec2/* max */.Fp([0, 0], max, constraint[1]);
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isLoop) {
            prevPoint = points[i ? i - 1 : len - 1];
            nextPoint = points[(i + 1) % len];
        }
        else {
            if (i === 0 || i === len - 1) {
                cps.push(point);
                continue;
            }
            else {
                prevPoint = points[i - 1];
                nextPoint = points[i + 1];
            }
        }
        var v = [0, 0];
        v = vec2/* sub */.lu(v, nextPoint, prevPoint);
        v = vec2/* scale */.bA(v, v, smooth);
        var d0 = vec2/* distance */.TE(point, prevPoint);
        var d1 = vec2/* distance */.TE(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
            d0 /= sum;
            d1 /= sum;
        }
        var v1 = vec2/* scale */.bA([0, 0], v, -d0);
        var v2 = vec2/* scale */.bA([0, 0], v, d1);
        var cp0 = vec2/* add */.IH([0, 0], point, v1);
        var cp1 = vec2/* add */.IH([0, 0], point, v2);
        if (hasConstraint) {
            cp0 = vec2/* max */.Fp([0, 0], cp0, min);
            cp0 = vec2/* min */.VV([0, 0], cp0, max);
            cp1 = vec2/* max */.Fp([0, 0], cp1, min);
            cp1 = vec2/* min */.VV([0, 0], cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
    }
    if (isLoop) {
        cps.push(cps.shift());
    }
    return cps;
};
/**
 * @ignore
 * \u8D1D\u585E\u5C14\u66F2\u7EBF
 */
function path_catmullRom2bezier(crp, z, constraint) {
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
        pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = path_smoothBezier(pointList, 0.4, isLoop, constraint);
    var len = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p;
    for (var i = 0; i < len - 1; i++) {
        cp1 = controlPointList[i * 2];
        cp2 = controlPointList[i * 2 + 1];
        p = pointList[i + 1];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    if (isLoop) {
        cp1 = controlPointList[len];
        cp2 = controlPointList[len + 1];
        p = pointList[0];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    return d1;
}
/**
 * @ignore
 * \u6839\u636E\u5173\u952E\u70B9\u83B7\u53D6\u9650\u5B9A\u4E86\u8303\u56F4\u7684\u5E73\u6ED1\u7EBF
 */
function path_getSplinePath(points, isInCircle, constaint) {
    var data = [];
    var first = points[0];
    var prePoint = null;
    if (points.length <= 2) {
        // \u4E24\u70B9\u4EE5\u5185\u76F4\u63A5\u7ED8\u5236\u6210\u8DEF\u5F84
        return points2Path(points, isInCircle);
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
            data.push(point.x);
            data.push(point.y);
            prePoint = point;
        }
    }
    var constraint = constaint || [
        // \u8303\u56F4
        [0, 0],
        [1, 1],
    ];
    var splinePath = path_catmullRom2bezier(data, isInCircle, constraint);
    splinePath.unshift(['M', first.x, first.y]);
    return splinePath;
}
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/kebab-case.js
/**
 * @desc simple kebabCase like lodash
 *
 * kebabCase('fooBar'); => 'foo-bar'
 */
function kebabCase(word) {
    if (!word) {
        return word;
    }
    var result = word.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
    return result.map(function (s) { return s.toLowerCase(); }).join('-');
}
//# sourceMappingURL=kebab-case.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/statistic.js




/**
 * @desc \u751F\u6210 html-statistic \u7684 style \u5B57\u7B26\u4E32 (\u517C\u5BB9 canvas \u7684 shapeStyle \u5230 css\u6837\u5F0F\u4E0A)
 *
 * @param width
 * @param style
 */
function adapteStyle(style) {
    var styleObject = {
        overflow: 'hidden',
        'white-space': 'nowrap',
        'text-overflow': 'ellipsis',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
    };
    var shapeStyleKeys = [
        'stroke',
        'lineWidth',
        'shadowColor',
        'strokeOpacity',
        'shadowBlur',
        'shadowOffsetX',
        'shadowOffsetY',
        'fill',
    ];
    // \u517C\u5BB9 shapeStyle \u8BBE\u7F6E \xB7 start
    if ((0,esm/* get */.U2)(style, 'fill')) {
        styleObject['color'] = style['fill'];
    }
    var _a = pick(style, shapeStyleKeys), shadowColor = _a.shadowColor, _b = _a.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
    styleObject['text-shadow'] = "".concat([shadowColor, "".concat(shadowOffsetX, "px"), "".concat(shadowOffsetY, "px"), "".concat(shadowBlur, "px")].join(' '));
    var _e = pick(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
    styleObject['-webkit-text-stroke'] = "".concat(["".concat(lineWidth, "px"), stroke].join(' '));
    // \u517C\u5BB9 shapeStyle \u8BBE\u7F6E \xB7 end
    (0,esm/* each */.S6)(style, function (v, k) {
        //  \u517C\u5BB9 shapeStyle \u7684 fontSize \u6CA1\u6709\u5355\u4F4D
        if (['fontSize'].includes(k) && (0,esm/* isNumber */.hj)(v)) {
            styleObject[kebabCase(k)] = "".concat(v, "px");
        }
        else if (k && !shapeStyleKeys.includes(k)) {
            styleObject[kebabCase(k)] = "".concat(v);
        }
    });
    return styleObject;
}
/**
 * @desc \u8BBE\u7F6E html-statistic \u5BB9\u5668\u7684\u9ED8\u8BA4\u6837\u5F0F
 *
 * - \u9ED8\u8BA4\u4E8B\u4EF6\u7A7F\u900F
 */
function setStatisticContainerStyle(container, style) {
    container.style['pointer-events'] = 'none';
    (0,esm/* each */.S6)(style, function (v, k) {
        if (k && v) {
            container.style[k] = v;
        }
    });
}
/**
 * \u6E32\u67D3\u73AF\u56FE html-annotation\uFF08\u9ED8\u8BA4 position \u5C45\u4E2D [50%, 50%]\uFF09
 * @param chart
 * @param options
 * @param meta \u5B57\u6BB5\u5143\u4FE1\u606F
 * @param {optional} datum \u5F53\u524D\u7684\u5143\u6570\u636E
 */
var renderStatistic = function (chart, options, datum) {
    var statistic = options.statistic, plotType = options.plotType;
    var titleOpt = statistic.title, contentOpt = statistic.content;
    [titleOpt, contentOpt].forEach(function (option, idx) {
        if (!option) {
            return;
        }
        var transform = '';
        if (idx === 0) {
            transform = contentOpt ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
        }
        else {
            transform = titleOpt ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
        }
        var style = (0,esm/* isFunction */.mf)(option.style) ? option.style(datum) : option.style;
        chart.annotation().html((0,tslib_es6/* __assign */.pi)({ position: ['50%', '50%'], html: function (container, view) {
                var coordinate = view.getCoordinate();
                var containerW = 0;
                if (plotType === 'pie' || plotType === 'ring-progress') {
                    containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
                }
                else if (plotType === 'liquid') {
                    var liquidShape = (0,esm/* get */.U2)(view.geometries, [0, 'elements', 0, 'shape']);
                    if (liquidShape) {
                        // \u83B7\u53D6\u5230\u6C34\u6CE2\u56FE\u8FB9\u6846\u5927\u5C0F
                        var path = liquidShape.find(function (t) { return t.get('name') === 'wrap'; });
                        var width = path.getCanvasBBox().width;
                        containerW = width;
                    }
                }
                else if (!containerW) {
                    // \u4FDD\u5E95\u65B9\u6848
                    containerW = coordinate.getWidth();
                }
                setStatisticContainerStyle(container, (0,tslib_es6/* __assign */.pi)({ width: "".concat(containerW, "px"), transform: transform }, adapteStyle(style)));
                var filteredData = view.getData();
                if (option.customHtml) {
                    return option.customHtml(container, view, datum, filteredData);
                }
                var text = option.content;
                if (option.formatter) {
                    text = option.formatter(datum, filteredData);
                }
                // todo G2 \u5C42\u4FEE\u590D\u53EF\u4EE5\u8FD4\u56DE\u7A7A\u5B57\u7B26\u4E32 & G2 \u5C42\u4FEE\u590D\u5141\u8BB8\u8FD4\u56DE\u975E\u5B57\u7B26\u4E32\u7684\u5185\u5BB9\uFF0C\u6BD4\u5982\u6570\u503C number
                return text ? ((0,esm/* isString */.HD)(text) ? text : "".concat(text)) : '<div></div>';
            }, 
            // @ts-ignore
            key: "".concat(idx === 0 ? 'top' : 'bottom', "-statistic") }, pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) /** \u900F\u4F20\u914D\u7F6E */));
    });
};
/**
 * \u6E32\u67D3 html-annotation for gauge (\u7B49\u4E0D\u89C4\u5219 plot), \u9ED8\u8BA4 position \u5C45\u4E2D\u5C45\u5E95 [50%, 100%]\uFF09
 * @param chart
 * @param options
 * @param meta \u5B57\u6BB5\u5143\u4FE1\u606F
 * @param {optional} datum \u5F53\u524D\u7684\u5143\u6570\u636E
 */
var renderGaugeStatistic = function (chart, options, datum) {
    var statistic = options.statistic;
    var titleOpt = statistic.title, contentOpt = statistic.content;
    [titleOpt, contentOpt].forEach(function (option) {
        if (!option) {
            return;
        }
        var style = (0,esm/* isFunction */.mf)(option.style) ? option.style(datum) : option.style;
        chart.annotation().html((0,tslib_es6/* __assign */.pi)({ position: ['50%', '100%'], html: function (container, view) {
                var coordinate = view.getCoordinate();
                // \u5F27\u5F62\u7684\u5750\u6807
                var polarCoord = view.views[0].getCoordinate();
                var polarCenter = polarCoord.getCenter();
                var polarRadius = polarCoord.getRadius();
                var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
                var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat((0,esm/* get */.U2)(style, 'fontSize', 0));
                var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
                setStatisticContainerStyle(container, (0,tslib_es6/* __assign */.pi)({ width: "".concat(containerWidth, "px"), transform: "translate(-50%, ".concat(offsetY, "px)") }, adapteStyle(style)));
                var filteredData = view.getData();
                if (option.customHtml) {
                    return option.customHtml(container, view, datum, filteredData);
                }
                var text = option.content;
                if (option.formatter) {
                    text = option.formatter(datum, filteredData);
                }
                // todo G2 \u5C42\u4FEE\u590D\u53EF\u4EE5\u8FD4\u56DE\u7A7A\u5B57\u7B26\u4E32 & G2 \u5C42\u4FEE\u590D\u5141\u8BB8\u8FD4\u56DE\u975E\u5B57\u7B26\u4E32\u7684\u5185\u5BB9\uFF0C\u6BD4\u5982\u6570\u503C number
                return text ? ((0,esm/* isString */.HD)(text) ? text : "".concat(text)) : '<div></div>';
            } }, pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter']) /** \u900F\u4F20\u914D\u7F6E */));
    });
};
//# sourceMappingURL=statistic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/template.js

/**
 * \u7B80\u5355\u7684\u6A21\u677F\u5F15\u64CE\uFF0C\u4F7F\u7528\u65B9\u5F0F\u5982\u4E0B\uFF08\u7A7A\u683C\u81EA\u52A8\u5FFD\u7565\uFF09\uFF1A
 * template('hello, {name}', { name: 'AntV' }); // hello, AntV
 * @param string
 * @param options
 */
function template(source, data) {
    if (!data) {
        return source;
    }
    return (0,esm/* reduce */.u4)(
    // @ts-ignore
    data, function (r, v, k) { return r.replace(new RegExp("{\\\\s*".concat(k, "\\\\s*}"), 'g'), v); }, source);
}
//# sourceMappingURL=template.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/view.js

/**
 * \u5728 Chart \u4E2D\u67E5\u627E\u7279\u5B9A id \u7684\u5B50 View
 * @param chart
 * @param id
 */
function findViewById(chart, id) {
    return chart.views.find(function (view) { return view.id === id; });
}
/**
 * \u83B7\u53D6\u540C view \u540C\u4E00\u7EA7\u7684\u6240\u6709 views
 * @param view \u5F53\u524D view
 * @returns \u540C\u4E00\u7EA7\u7684 views
 * @ignore
 */
function getViews(view) {
    var parent = view.parent;
    return parent ? parent.views : [];
}
/**
 * \u83B7\u53D6\u540C view \u540C\u4E00\u7EA7\u7684 views\uFF0C\u4E0D\u5305\u62EC\u81EA\u8EAB
 * @param view \u5F53\u524D view
 * @returns \u540C\u4E00\u7EA7\u7684 views
 * @ignore
 */
function getSiblingViews(view) {
    return getViews(view).filter(function (sub) { return sub !== view; });
}
/**
 * \u6240\u6709\u7684 Geometries \u90FD\u4F7F\u7528\u540C\u4E00\u52A8\u753B\uFF08\u5404\u4E2A\u56FE\u5F62\u5982\u6709\u533A\u522B\uFF0C\u81EA\u884C\u8986\u76D6\uFF09\u5E76\u6DFB\u52A0\u5904\u7406\u52A8\u753B\u56DE\u8C03
 * @param view View
 * @param animation \u52A8\u753B\u914D\u7F6E
 */
function addViewAnimation(view, animation, geometries) {
    if (geometries === void 0) { geometries = view.geometries; }
    // \u540C\u65F6\u8BBE\u7F6E\u6574\u4E2A view \u52A8\u753B\u9009\u9879
    if (typeof animation === 'boolean') {
        view.animate(animation);
    }
    else {
        view.animate(true);
    }
    // \u6240\u6709\u7684 Geometry \u90FD\u4F7F\u7528\u540C\u4E00\u52A8\u753B\uFF08\u5404\u4E2A\u56FE\u5F62\u5982\u6709\u533A\u522B\uFF0C\u81EA\u884C\u8986\u76D6\uFF09
    (0,esm/* each */.S6)(geometries, function (g) {
        var animationCfg;
        if ((0,esm/* isFunction */.mf)(animation)) {
            animationCfg = animation(g.type || g.shapeType, g) || true;
        }
        else {
            animationCfg = animation;
        }
        g.animate(animationCfg);
    });
}
//# sourceMappingURL=view.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/index.js
















//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pattern/util.js
/**
 * \u83B7\u53D6\u8BBE\u5907\u50CF\u7D20\u6BD4
 */
function util_getPixelRatio() {
    return typeof window === 'object' ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
/**
 * \u521D\u59CB\u5316 cavnas\uFF0C\u8BBE\u7F6E\u5BBD\u9AD8\u7B49
 */
function initCanvas(width, height) {
    if (height === void 0) { height = width; }
    var canvas = document.createElement('canvas');
    var pixelRatio = util_getPixelRatio();
    // \u753B\u5E03\u5C3A\u5BF8
    canvas.width = width * pixelRatio;
    canvas.height = height * pixelRatio;
    // \u663E\u793A\u5C3A\u5BF8
    canvas.style.width = "".concat(width, "px");
    canvas.style.height = "".concat(height, "px");
    var ctx = canvas.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    return canvas;
}
/**
 * \u7ED8\u5236\u80CC\u666F
 *
 * @param context
 * @param cfg
 * @param width
 * @param height
 */
function drawBackground(context, cfg, width, height) {
    if (height === void 0) { height = width; }
    var backgroundColor = cfg.backgroundColor, opacity = cfg.opacity;
    context.globalAlpha = opacity;
    context.fillStyle = backgroundColor;
    context.beginPath();
    context.fillRect(0, 0, width, height);
    context.closePath();
}
/**
 * \u8BA1\u7B97\u8D34\u56FE\u5355\u5143\u5927\u5C0F
 *
 * @param size \u5143\u7D20\u5927\u5C0F
 * @param padding \u5706\u70B9\u95F4\u9694
 * @param isStagger \u662F\u5426\u4EA4\u9519
 * @reutrn \u8FD4\u56DE\u8D34\u56FE\u5355\u5143\u5927\u5C0F
 */
function getUnitPatternSize(size, padding, isStagger) {
    // \u5982\u679C\u4EA4\u9519, unitSize \u653E\u5927\u4E24\u500D
    var unitSize = size + padding;
    return isStagger ? unitSize * 2 : unitSize;
}
/**
 * \u8BA1\u7B97\u6709\u4EA4\u9519\u60C5\u51B5\u7684\u5143\u7D20\u5750\u6807
 *
 * @param unitSize \u8D34\u56FE\u5355\u5143\u5927\u5C0F
 * @param isStagger \u662F\u5426\u4EA4\u9519
 * @reutrn \u5143\u7D20\u4E2D\u5FC3\u5750\u6807 x,y \u6570\u7EC4\u96C6\u5408
 */
function getSymbolsPosition(unitSize, isStagger) {
    // \u5982\u679C\u4EA4\u9519, \u4EA4\u9519\u7ED8\u5236 dot
    var symbolsPos = isStagger
        ? [
            [unitSize * (1 / 4), unitSize * (1 / 4)],
            [unitSize * (3 / 4), unitSize * (3 / 4)],
        ]
        : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
    return symbolsPos;
}
/**
 * \u7ED9\u6574\u4E2A pattern\u8D34\u56FE \u505A\u53D8\u6362, \u76EE\u524D\u652F\u6301\u65CB\u8F6C
 *
 * @param pattern \u6574\u4E2A\u8D34\u56FE
 * @param dpr  \u8BBE\u5907\u50CF\u7D20\u6BD4
 * @param rotation \u65CB\u8F6C\u89D2\u5EA6
 */
function transformMatrix(dpr, rotation) {
    var radian = (rotation * Math.PI) / 180;
    var matrix = {
        a: Math.cos(radian) * (1 / dpr),
        b: Math.sin(radian) * (1 / dpr),
        c: -Math.sin(radian) * (1 / dpr),
        d: Math.cos(radian) * (1 / dpr),
        e: 0,
        f: 0,
    };
    return matrix;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pattern/dot.js


/**
 * dotPattern\u7684\u9ED8\u8BA4\u914D\u7F6E
 */
var defaultDotPatternCfg = {
    size: 6,
    padding: 2,
    backgroundColor: 'transparent',
    opacity: 1,
    rotation: 0,
    fill: '#fff',
    fillOpacity: 0.5,
    stroke: 'transparent',
    lineWidth: 0,
    isStagger: true,
};
/**
 * \u7ED8\u5236\u5706\u70B9
 *
 * @param context
 * @param cfg
 * @param x \u5706\u70B9\u4E2D\u5FC3\u5750\u6807x
 * @param y \u5706\u70B9\u4E2D\u5FC3\u5750\u6807y
 */
function drawDot(context, cfg, x, y) {
    var size = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
    context.beginPath();
    context.globalAlpha = fillOpacity;
    context.fillStyle = fill;
    context.strokeStyle = stroke;
    context.lineWidth = lineWidth;
    context.arc(x, y, size / 2, 0, 2 * Math.PI, false);
    context.fill();
    if (lineWidth) {
        context.stroke();
    }
    context.closePath();
}
/**
 * \u521B\u5EFA dot pattern\uFF0C\u8FD4\u56DE HTMLCanvasElement
 *
 * @param cfg
 * @returns HTMLCanvasElement
 */
function createDotPattern(cfg) {
    var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
    var size = dotCfg.size, padding = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
    // \u8BA1\u7B97 \u753B\u5E03\u5927\u5C0F\uFF0Cdots\u7684\u4F4D\u7F6E
    var unitSize = getUnitPatternSize(size, padding, isStagger);
    var dots = getSymbolsPosition(unitSize, isStagger);
    // \u521D\u59CB\u5316 patternCanvas
    var canvas = initCanvas(unitSize, unitSize);
    var ctx = canvas.getContext('2d');
    // \u7ED8\u5236 background\uFF0Cdots
    drawBackground(ctx, dotCfg, unitSize);
    for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
        var _a = dots_1[_i], x = _a[0], y = _a[1];
        drawDot(ctx, dotCfg, x, y);
    }
    var pattern = ctx.createPattern(canvas, 'repeat');
    if (pattern) {
        var dpr = util_getPixelRatio();
        var matrix = transformMatrix(dpr, rotation);
        pattern.setTransform(matrix);
    }
    return pattern;
}
//# sourceMappingURL=dot.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pattern/line.js


/**
 * linePattern \u7684 \u9ED8\u8BA4\u914D\u7F6E
 */
var defaultLinePatternCfg = {
    rotation: 45,
    spacing: 5,
    opacity: 1,
    backgroundColor: 'transparent',
    strokeOpacity: 0.5,
    stroke: '#fff',
    lineWidth: 2,
};
/**
 * \u7ED8\u5236line
 *
 * @param context canvasContext
 * @param cfg linePattern \u7684\u914D\u7F6E
 * @param d \u7ED8\u5236 path \u6240\u9700\u7684 d
 */
function drawLine(context, cfg, d) {
    var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
    var path = new Path2D(d);
    context.globalAlpha = strokeOpacity;
    context.lineCap = 'square';
    context.strokeStyle = lineWidth ? stroke : 'transparent';
    context.lineWidth = lineWidth;
    context.stroke(path);
}
/**
 * \u521B\u5EFA linePattern
 */
function createLinePattern(cfg) {
    var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
    var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
    // \u8BA1\u7B97 pattern \u753B\u5E03\u7684\u5927\u5C0F\uFF0C path \u6240\u9700\u7684 d
    var width = spacing + lineWidth || 1;
    var height = spacing + lineWidth || 1;
    var d = "\\n            M 0 0 L ".concat(width, " 0\\n            M 0 ").concat(height, " L ").concat(width, " ").concat(height, "\\n            ");
    // \u521D\u59CB\u5316 patternCanvas
    var canvas = initCanvas(width, height);
    var ctx = canvas.getContext('2d');
    // \u7ED8\u5236 background\uFF0Cline
    drawBackground(ctx, lineCfg, width, height);
    drawLine(ctx, lineCfg, d);
    var pattern = ctx.createPattern(canvas, 'repeat');
    if (pattern) {
        var dpr = util_getPixelRatio();
        var matrix = transformMatrix(dpr, rotation);
        pattern.setTransform(matrix);
    }
    // \u8FD4\u56DE Pattern \u5BF9\u8C61
    return pattern;
}
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pattern/square.js


/**
 * squarePattern \u7684 \u9ED8\u8BA4\u914D\u7F6E
 */
var defaultSquarePatternCfg = {
    size: 6,
    padding: 1,
    isStagger: true,
    backgroundColor: 'transparent',
    opacity: 1,
    rotation: 0,
    fill: '#fff',
    fillOpacity: 0.5,
    stroke: 'transparent',
    lineWidth: 0,
};
/**
 * \u7ED8\u5236square
 *
 * @param context canvasContext
 * @param cfg squarePattern \u7684\u914D\u7F6E
 * @param x\u548Cy square\u7684\u4E2D\u5FC3\u4F4D\u7F6E
 */
function drawSquare(context, cfg, x, y) {
    var stroke = cfg.stroke, size = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, fillOpacity = cfg.fillOpacity;
    context.globalAlpha = fillOpacity;
    context.strokeStyle = stroke;
    context.lineWidth = lineWidth;
    context.fillStyle = fill;
    // \u56E0\u4E3A\u6B63\u65B9\u5F62\u7ED8\u5236\u4ECE\u5DE6\u4E0A\u89D2\u5F00\u59CB\uFF0C\u6240\u4EE5x\uFF0Cy\u505A\u4E2A\u504F\u79FB
    context.strokeRect(x - size / 2, y - size / 2, size, size);
    context.fillRect(x - size / 2, y - size / 2, size, size);
}
/**
 * \u521B\u5EFA squarePattern
 */
function createSquarePattern(cfg) {
    var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
    var size = squareCfg.size, padding = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
    // \u8BA1\u7B97 \u753B\u5E03\u5927\u5C0F\uFF0Csquares\u7684\u4F4D\u7F6E
    var unitSize = getUnitPatternSize(size, padding, isStagger);
    var squares = getSymbolsPosition(unitSize, isStagger); // \u8BA1\u7B97\u65B9\u6CD5\u4E0E dots \u4E00\u6837
    // \u521D\u59CB\u5316 patternCanvas
    var canvas = initCanvas(unitSize, unitSize);
    var ctx = canvas.getContext('2d');
    // \u7ED8\u5236 background\uFF0Csquares
    drawBackground(ctx, squareCfg, unitSize);
    for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
        var _a = squares_1[_i], x = _a[0], y = _a[1];
        drawSquare(ctx, squareCfg, x, y);
    }
    var pattern = ctx.createPattern(canvas, 'repeat');
    if (pattern) {
        var dpr = util_getPixelRatio();
        var matrix = transformMatrix(dpr, rotation);
        pattern.setTransform(matrix);
    }
    return pattern;
}
//# sourceMappingURL=square.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/pattern/index.js



/**
 * \u83B7\u53D6\u5185\u7F6E\u7684 CanvasPattern \u65B9\u6CD5
 * @param options
 * @returns
 */
function getCanvasPattern(options) {
    var type = options.type, cfg = options.cfg;
    var pattern;
    switch (type) {
        case 'dot':
            pattern = createDotPattern(cfg);
            break;
        case 'line':
            pattern = createLinePattern(cfg);
            break;
        case 'square':
            pattern = createSquarePattern(cfg);
            break;
        default:
            break;
    }
    return pattern;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/pattern.js





/**
 * Pattern \u901A\u9053\uFF0C\u5904\u7406\u56FE\u6848\u586B\u5145
 * \u{1F680} \u76EE\u524D\u652F\u6301\u56FE\u8868\u7C7B\u578B\uFF1A\u997C\u56FE\u3001\u67F1\u72B6\u56FE\u3001\u6761\u5F62\u56FE\u3001\u7389\u73CF\u56FE\u7B49\uFF08\u4E0D\u652F\u6301\u5728\u591A view \u56FE\u8868\u4E2D\uFF0C\u540E\u7EED\u6309\u9700\u6269\u5C55\uFF09
 *
 * @param key key of style property
 * @returns
 */
function pattern(key) {
    var _this = this;
    return function (params) {
        var _a;
        var options = params.options, chart = params.chart;
        var patternOption = options.pattern;
        // \u6CA1\u6709 pattern \u914D\u7F6E\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE
        if (!patternOption) {
            return params;
        }
        /** ~~~~~~~ \u8FDB\u884C\u8D34\u56FE\u56FE\u6848\u5904\u7406 ~~~~~~~ */
        var style = function (datum) {
            var _a, _b, _c;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var defaultColor = chart.getTheme().defaultColor;
            var color = defaultColor;
            var colorAttribute = (_b = (_a = chart.geometries) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getAttribute('color');
            if (colorAttribute) {
                var colorField = colorAttribute.getFields()[0];
                var seriesValue = (0,esm/* get */.U2)(datum, colorField);
                color = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
            }
            var pattern = patternOption;
            // 1. \u5982\u679C patternOption \u662F\u4E00\u4E2A\u56DE\u8C03\uFF0C\u5219\u83B7\u53D6\u56DE\u8C03\u7ED3\u679C\u3002\`(datum: Datum, color: string) => CanvasPattern\`
            if (typeof patternOption === 'function') {
                pattern = patternOption.call(_this, datum, color);
            }
            // 2. \u5982\u679C pattern \u4E0D\u662F CanvasPattern\uFF0C\u5219\u8FDB\u4E00\u6B65\u5904\u7406\uFF0C\u5426\u5219\u76F4\u63A5\u8D4B\u4E88\u7ED9 fill
            if (pattern instanceof CanvasPattern === false) {
                // \u901A\u8FC7 createPattern(PatternStyle) \u8F6C\u6362\u4E3A CanvasPattern
                pattern = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color } }, pattern));
            }
            var styleOption = options[key];
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, (typeof styleOption === 'function' ? styleOption.call.apply(styleOption, (0,tslib_es6/* __spreadArray */.ev)([_this, datum], args, false)) : styleOption || {})), { fill: pattern || color });
        };
        return deepAssign({}, params, { options: (_a = {}, _a[key] = style, _a) });
    };
}
//# sourceMappingURL=pattern.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/common.js




/**
 * \u901A\u7528 legend \u914D\u7F6E, \u9002\u7528\u4E8E\u5E26 colorField \u6216 seriesField \u7684\u56FE\u8868
 * @param params
 */
function common_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, colorField = options.colorField, seriesField = options.seriesField;
    if (legend === false) {
        chart.legend(false);
    }
    else if (colorField || seriesField) {
        chart.legend(colorField || seriesField, legend);
    }
    return params;
}
/**
 * \u901A\u7528 tooltip \u914D\u7F6E
 * @param params
 */
function common_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip !== undefined) {
        chart.tooltip(tooltip);
    }
    return params;
}
/**
 * Interaction \u914D\u7F6E
 * @param params
 */
function common_interaction(params) {
    var chart = params.chart, options = params.options;
    var interactions = options.interactions;
    (0,esm/* each */.S6)(interactions, function (i) {
        if (i.enable === false) {
            chart.removeInteraction(i.type);
        }
        else {
            chart.interaction(i.type, i.cfg || {});
        }
    });
    return params;
}
/**
 * \u52A8\u753B
 * @param params
 */
function animation(params) {
    var chart = params.chart, options = params.options;
    var animation = options.animation;
    // \u6240\u6709\u7684 Geometry \u90FD\u4F7F\u7528\u540C\u4E00\u52A8\u753B\uFF08\u5404\u4E2A\u56FE\u5F62\u5982\u6709\u533A\u522B\uFF0C\u81EA\u884C\u8986\u76D6\uFF09
    addViewAnimation(chart, animation);
    return params;
}
/**
 * \u8BBE\u7F6E\u5168\u5C40\u4E3B\u9898\u914D\u7F6E
 * @param params
 */
function common_theme(params) {
    var chart = params.chart, options = params.options;
    var theme = options.theme;
    // \u5B58\u5728\u4E3B\u9898\u624D\u8BBE\u7F6E\u4E3B\u9898
    if (theme) {
        chart.theme(theme);
    }
    return params;
}
/**
 * \u72B6\u6001 state \u914D\u7F6E
 * @param params
 */
function common_state(params) {
    var chart = params.chart, options = params.options;
    var state = options.state;
    if (state) {
        (0,esm/* each */.S6)(chart.geometries, function (geometry) {
            geometry.state(state);
        });
    }
    return params;
}
/**
 * \u5904\u7406\u7F29\u7565\u8F74\u7684 adaptor
 * @param params
 */
function common_slider(params) {
    var chart = params.chart, options = params.options;
    var slider = options.slider;
    chart.option('slider', slider);
    return params;
}
/**
 * \u5904\u7406\u7F29\u7565\u8F74\u7684 adaptor
 * @param params
 */
function common_scrollbar(params) {
    var chart = params.chart, options = params.options;
    var scrollbar = options.scrollbar;
    chart.option('scrollbar', scrollbar);
    return params;
}
/**
 * scale \u7684 adaptor
 * @param axes
 */
function common_scale(axes, meta) {
    return function (params) {
        var chart = params.chart, options = params.options;
        // 1. \u8F74\u914D\u7F6E\u4E2D\u7684 scale \u4FE1\u606F
        var scales = {};
        (0,esm/* each */.S6)(axes, function (axis, field) {
            scales[field] = pick(axis, AXIS_META_CONFIG_KEYS);
        });
        // 2. meta \u76F4\u63A5\u662F scale \u7684\u4FE1\u606F
        scales = deepAssign({}, meta, options.meta, scales);
        chart.scale(scales);
        return params;
    };
}
/**
 * annotation \u914D\u7F6E
 * @param params
 */
function common_annotation(annotationOptions) {
    return function (params) {
        var chart = params.chart, options = params.options;
        var annotationController = chart.getController('annotation');
        /** \u81EA\u5B9A\u4E49 annotation */
        (0,esm/* each */.S6)((0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (options.annotations || []), true), (annotationOptions || []), true), function (annotationOption) {
            // @ts-ignore
            annotationController.annotation(annotationOption);
        });
        return params;
    };
}
/**
 * \u81EA\u52A8\u8BBE\u7F6E limitInPlot
 * @param params
 */
function common_limitInPlot(params) {
    var chart = params.chart, options = params.options;
    var yAxis = options.yAxis, limitInPlot = options.limitInPlot;
    var value = limitInPlot;
    // \u7528\u6237\u6CA1\u6709\u8BBE\u7F6E limitInPlot\uFF0C\u5219\u81EA\u52A8\u6839\u636E yAxis \u662F\u5426\u6709 min/max \u6765\u8BBE\u7F6E limitInPlot
    if ((0,esm/* isObject */.Kn)(yAxis) && (0,esm/* isNil */.UM)(limitInPlot)) {
        if (Object.values(pick(yAxis, ['min', 'max', 'minLimit', 'maxLimit'])).some(function (value) { return !(0,esm/* isNil */.UM)(value); })) {
            value = true;
        }
        else {
            value = false;
        }
    }
    chart.limitInPlot = value;
    return params;
}
/**
 * \u5750\u6807\u7CFB\u8F6C\u6362
 */
function transformations(coordinateType) {
    if (coordinateType === void 0) { coordinateType = 'rect'; }
    return function (params) {
        var chart = params.chart, options = params.options;
        var coordinate = options.coordinate;
        var actions = Array.from(coordinate || [])
            .map(function (cfg) {
            if (cfg.type === 'reflectX')
                return ['reflect', 'x'];
            if (cfg.type === 'reflectY')
                return ['reflect', 'y'];
            if (cfg.type === 'transpose')
                return ['transpose'];
            return null;
        })
            .filter(function (d) { return !!d; });
        if (actions.length !== 0) {
            chart.coordinate({ type: coordinateType, actions: actions });
        }
        return params;
    };
}

//# sourceMappingURL=common.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/core/global.js

/**
 * @file \u5168\u5C40\u7684\u4E00\u4E9B\u53D8\u91CF\u5B9A\u4E49\uFF1A\u542B\u56FD\u9645\u5316\u3001\u4E3B\u9898...
 */
var GLOBAL = {
    /** \u5168\u5C40\u8BED\u8A00 */
    locale: 'en-US',
};
/**
 * \u5168\u5C40\u53D8\u91CF\u8BBE\u7F6E
 * @param key
 * @param value
 */
function setGlobal(datum) {
    each(datum, function (v, k) { return (GLOBAL[k] = v); });
}
//# sourceMappingURL=global.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/core/locale.js



var LocaleMap = {};
/**
 * register a locale
 * @param locale
 * @param localeObj
 */
function registerLocale(locale, localeObj) {
    LocaleMap[locale] = localeObj;
}
/**
 * get locale of specific language
 * @param lang
 * @returns
 */
function getLocale(locale) {
    return {
        get: function (key, obj) {
            return template((0,esm/* get */.U2)(LocaleMap[locale], key) || (0,esm/* get */.U2)(LocaleMap[GLOBAL.locale], key) || (0,esm/* get */.U2)(LocaleMap['en-US'], key) || key, obj);
        },
    };
}
//# sourceMappingURL=locale.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/locales/en_US.js
var EN_US_LOCALE = {
    locale: 'en-US',
    // General
    general: {
        increase: 'Increase',
        decrease: 'Decrease',
        root: 'Root',
    },
    // Plot Components
    /** statistic text component */
    statistic: {
        total: 'Total',
    },
    /** conversionTag component */
    conversionTag: {
        label: 'Rate',
    },
    legend: {},
    tooltip: {},
    slider: {},
    scrollbar: {},
    // Plots
    waterfall: {
        total: 'Total',
    },
};
//# sourceMappingURL=en_US.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/locales/zh_CN.js
var ZH_CN_LOCALE = {
    locale: 'zh-CN',
    // \u901A\u7528
    general: {
        increase: '\u589E\u52A0',
        decrease: '\u51CF\u5C11',
        root: '\u521D\u59CB',
    },
    // \u6309\u7167\u56FE\u8868\u7EC4\u4EF6
    /** \u4E2D\u5FC3\u6587\u672C */
    statistic: {
        total: '\u603B\u8BA1',
    },
    /** \u8F6C\u5316\u7387\u7EC4\u4EF6 */
    conversionTag: {
        label: '\u8F6C\u5316\u7387',
    },
    legend: {},
    tooltip: {},
    slider: {},
    scrollbar: {},
    // \u6309\u7167\u56FE\u8868\u7C7B\u578B
    waterfall: {
        total: '\u603B\u8BA1',
    },
};
//# sourceMappingURL=zh_CN.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/tooltip.js

/**
 * \u83B7\u5F97 tooltip \u7684\u6620\u5C04\u4FE1\u606F
 * @param tooltip
 * @param defaultFields
 */
function getTooltipMapping(tooltip, defaultFields) {
    if (tooltip === false) {
        return {
            fields: false, // \u5173\u95ED tooltip
        };
    }
    var fields = (0,esm/* get */.U2)(tooltip, 'fields');
    var formatter = (0,esm/* get */.U2)(tooltip, 'formatter');
    if (formatter && !fields) {
        fields = defaultFields;
    }
    return {
        fields: fields,
        formatter: formatter,
    };
}
//# sourceMappingURL=tooltip.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/base.js



/**
 * \u83B7\u5F97\u6620\u5C04\u7684\u5B57\u6BB5\u5217\u8868
 * @param options
 * @param field
 */
function getMappingField(o, field) {
    var type = o.type, xField = o.xField, yField = o.yField, colorField = o.colorField, shapeField = o.shapeField, sizeField = o.sizeField, styleField = o.styleField;
    var rawFields = o.rawFields;
    var fields = [];
    rawFields = ((0,esm/* isFunction */.mf)(rawFields) ? rawFields(type, field) : rawFields) || [];
    // \u56E0\u4E3A color \u4F1A\u5F71\u54CD\u5230\u6570\u636E\u5206\u7EC4\uFF0C\u4EE5\u53CA\u6700\u540E\u7684\u56FE\u5F62\u6620\u5C04\u3002\u6240\u4EE5\u5BFC\u81F4 bar \u56FE\u4E2D\u7684 widthRatio \u8BBE\u7F6E\u4E0D\u751F\u6548
    // \u6240\u4EE5\u5BF9\u4E8E color \u5B57\u6BB5\uFF0C\u4EC5\u4EC5\u4FDD\u7559 colorField \u597D\u4E86\uFF01 + rawFields
    // shape, size \u540C\u7406
    if (field === 'color') {
        fields = (0,tslib_es6/* __spreadArray */.ev)([colorField || xField], rawFields, true);
    }
    else if (field === 'shape') {
        fields = (0,tslib_es6/* __spreadArray */.ev)([shapeField || xField], rawFields, true);
    }
    else if (field === 'size') {
        fields = (0,tslib_es6/* __spreadArray */.ev)([sizeField || xField], rawFields, true);
    }
    else {
        fields = (0,tslib_es6/* __spreadArray */.ev)([xField, yField, colorField, shapeField, sizeField, styleField], rawFields, true);
        // \u4E00\u5B9A\u80FD\u627E\u5230\u7684\uFF01
        var idx = ['x', 'y', 'color', 'shape', 'size', 'style'].indexOf(field);
        var f = fields[idx];
        // \u5220\u9664\u5F53\u524D\u5B57\u6BB5
        fields.splice(idx, 1);
        // \u63D2\u5165\u5230\u7B2C\u4E00\u4E2A
        fields.unshift(f);
    }
    var mappingFields = (0,esm/* uniq */.jj)(fields.filter(function (f) { return !!f; }));
    /**
     * \u4FEE\u590D line geometry \u65E0\u62C6\u5206\u65F6 color \u56DE\u8C03\u9519\u8BEF
     * eg:
     *   geometry.color(xField, ()=> '#f24')
     */
    var tileMappingField = type === 'line' && [xField, yField].includes(mappingFields.join('*')) ? '' : mappingFields.join('*');
    return {
        mappingFields: mappingFields,
        tileMappingField: tileMappingField,
    };
}
/**
 * \u83B7\u5F97\u6620\u5C04\u51FD\u6570
 * @param mappingFields
 * @param func
 */
function getMappingFunction(mappingFields, func) {
    if (!func)
        return undefined;
    // \u8FD4\u56DE\u51FD\u6570
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {};
        mappingFields.forEach(function (f, idx) {
            params[f] = args[idx];
        });
        // \u5220\u9664 undefined
        delete params['undefined'];
        return func(params);
    };
}
/**
 * \u901A\u7528 geometry \u7684\u914D\u7F6E\u5904\u7406\u7684 adaptor
 * @param params
 */
function base_geometry(params) {
    var chart = params.chart, options = params.options;
    var type = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label = options.label, state = options.state, customInfo = options.customInfo;
    // \u5982\u679C\u6CA1\u6709 mapping \u4FE1\u606F\uFF0C\u90A3\u4E48\u76F4\u63A5\u8FD4\u56DE
    if (!mapping) {
        return params;
    }
    var color = mapping.color, shape = mapping.shape, size = mapping.size, style = mapping.style, tooltip = mapping.tooltip;
    // \u521B\u5EFA geometry
    var geometry = chart[type](args).position("".concat(xField, "*").concat(yField));
    /**
     * color \u7684\u51E0\u79CD\u60C5\u51B5
     * g.color('red');
     * g.color('color', ['red', 'blue']);
     * g.color('x', (x, y) => 'red');
     * g.color('color', (color, x, y) => 'red');
     */
    if ((0,esm/* isString */.HD)(color)) {
        colorField ? geometry.color(colorField, color) : geometry.color(color);
    }
    else if ((0,esm/* isFunction */.mf)(color)) {
        var _a = getMappingField(options, 'color'), mappingFields = _a.mappingFields, tileMappingField = _a.tileMappingField;
        geometry.color(tileMappingField, getMappingFunction(mappingFields, color));
    }
    else {
        colorField && geometry.color(colorField, color);
    }
    /**
     * shape \u7684\u51E0\u79CD\u60C5\u51B5
     * g.shape('rect');
     * g.shape('shape', ['rect', 'circle']);
     * g.shape('x*y', (x, y) => 'rect');
     * g.shape('shape*x*y', (shape, x, y) => 'rect');
     */
    if ((0,esm/* isString */.HD)(shape)) {
        shapeField ? geometry.shape(shapeField, [shape]) : geometry.shape(shape); // [shape] \u9700\u8981\u5728 G2 \u505A\u6389
    }
    else if ((0,esm/* isFunction */.mf)(shape)) {
        var _b = getMappingField(options, 'shape'), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
        geometry.shape(tileMappingField, getMappingFunction(mappingFields, shape));
    }
    else {
        shapeField && geometry.shape(shapeField, shape);
    }
    /**
     * size \u7684\u51E0\u79CD\u60C5\u51B5
     * g.size(10);
     * g.size('size', [10, 20]);
     * g.size('x*y', (x, y) => 10);
     * g.color('size*x*y', (size, x, y) => 1-);
     */
    if ((0,esm/* isNumber */.hj)(size)) {
        sizeField ? geometry.size(sizeField, size) : geometry.size(size);
    }
    else if ((0,esm/* isFunction */.mf)(size)) {
        var _c = getMappingField(options, 'size'), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
        geometry.size(tileMappingField, getMappingFunction(mappingFields, size));
    }
    else {
        sizeField && geometry.size(sizeField, size);
    }
    /**
     * style \u7684\u51E0\u79CD\u60C5\u51B5
     * g.style({ fill: 'red' });
     * g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
     */
    if ((0,esm/* isFunction */.mf)(style)) {
        var _d = getMappingField(options, 'style'), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
        geometry.style(tileMappingField, getMappingFunction(mappingFields, style));
    }
    else if ((0,esm/* isObject */.Kn)(style)) {
        geometry.style(style);
    }
    /**
     * tooltip \u7684 API
     * g.tooltip('x*y*color', (x, y, color) => ({ name, value }));
     * g.tooltip(false);
     */
    if (tooltipFields === false) {
        geometry.tooltip(false);
    }
    else if (!(0,esm/* isEmpty */.xb)(tooltipFields)) {
        geometry.tooltip(tooltipFields.join('*'), getMappingFunction(tooltipFields, tooltip));
    }
    /**
     * label \u7684\u6620\u5C04
     */
    if (label === false) {
        geometry.label(false);
    }
    else if (label) {
        var callback = label.callback, fields = label.fields, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback", "fields"]);
        geometry.label({
            fields: fields || [yField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    /**
     * state \u72B6\u6001\u6837\u5F0F
     */
    if (state) {
        geometry.state(state);
    }
    /**
     * \u81EA\u5B9A\u4E49\u4FE1\u606F
     */
    if (customInfo) {
        geometry.customInfo(customInfo);
    }
    // \u9632\u6B62\u56E0\u4E3A x y \u5B57\u6BB5\u505A\u4E86\u901A\u9053\u6620\u5C04\uFF0C\u5BFC\u81F4\u751F\u6210\u56FE\u4F8B
    [xField, yField]
        .filter(function (f) { return f !== colorField; })
        .forEach(function (f) {
        chart.legend(f, false);
    });
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { 
        // geometry adaptor \u989D\u5916\u9700\u8981\u505A\u7684\u4E8B\u60C5\uFF0C\u5C31\u662F\u5C06\u521B\u5EFA\u597D\u7684 geometry \u8FD4\u56DE\u5230\u4E0B\u4E00\u5C42 adaptor\uFF0C\u9632\u6B62\u901A\u8FC7 type \u67E5\u8BE2\u7684\u65F6\u5019\u5BB9\u6613\u8BEF\u5224
        ext: { geometry: geometry } });
}
//# sourceMappingURL=base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/area.js




/**
 * area geometry \u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function area_area(params) {
    var options = params.options;
    var area = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    // \u5982\u679C\u5B58\u5728\u624D\u5904\u7406
    return area
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'area',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,esm/* deepMix */.b$)({
                    shape: smooth ? 'smooth' : 'area',
                    tooltip: formatter,
                }, area),
                args: { useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=area.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/edge.js




/**
 * edge \u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function edge_edge(params) {
    var options = params.options;
    var edge = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    return edge
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'edge',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, edge),
                args: { useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=edge.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/interval.js






/**
 * \u67F1\u5F62\u56FE\u5176\u4ED6\u7684 adaptor
 * @param params
 */
function otherAdaptor(params) {
    var chart = params.chart, options = params.options, ext = params.ext;
    var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme = options.theme;
    /**
     * adjust
     */
    var adjust = [];
    if (seriesField) {
        // group
        if (isGroup) {
            adjust.push({
                type: 'dodge',
                dodgeBy: groupField || seriesField,
                marginRatio: marginRatio,
            });
        }
        // stack
        if (isStack) {
            adjust.push({
                type: 'stack',
                marginRatio: marginRatio,
            });
        }
    }
    if (adjust.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
        var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
        g.adjust(adjust);
    }
    // widthRatio
    if (!(0,esm/* isNil */.UM)(widthRatio)) {
        chart.theme(deepAssign({}, (0,esm/* isObject */.Kn)(theme) ? theme : getTheme(theme), {
            // columWidthRatio \u914D\u7F6E\u8986\u76D6 theme \u4E2D\u7684\u914D\u7F6E
            columnWidthRatio: widthRatio,
        }));
    }
    return params;
}
function interval_interval(params) {
    var options = params.options;
    var xField = options.xField, yField = options.yField, interval = options.interval, seriesField = options.seriesField, tooltip = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    // \u4FDD\u969C\u4E00\u5B9A\u8981\u5B58\u5728 interval \u6620\u5C04
    var ext = (interval
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'interval',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, interval),
                args: {
                    dodgePadding: dodgePadding,
                    intervalPadding: intervalPadding,
                    minColumnWidth: minColumnWidth,
                    maxColumnWidth: maxColumnWidth,
                    background: columnBackground,
                    useDeferredLabel: useDeferredLabel,
                },
            },
        }))
        : params).ext;
    return otherAdaptor((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { ext: ext }));
}
//# sourceMappingURL=interval.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/line.js




/**
 * line \u8F85\u52A9\u70B9\u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function line_line(params) {
    var options = params.options;
    var line = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    // \u5982\u679C\u5B58\u5728\u624D\u5904\u7406
    return line
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'line',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,esm/* deepMix */.b$)({
                    shape: stepType || (smooth ? 'smooth' : 'line'),
                    tooltip: formatter,
                }, line),
                args: { connectNulls: connectNulls, useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/point.js




/**
 * point \u8F85\u52A9\u70B9\u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function point_point(params) {
    var options = params.options;
    var point = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField, sizeField, shapeField]), fields = _a.fields, formatter = _a.formatter;
    return point
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'point',
                colorField: seriesField,
                shapeField: shapeField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, point),
                args: { useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=point.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/polygon.js




/**
 * polygon \u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function polygon_polygon(params) {
    var options = params.options;
    var polygon = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    return polygon
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'polygon',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, polygon),
                args: { useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/schema.js




/**
 * schema \u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function schema_schema(params) {
    var options = params.options;
    var schema = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip = options.tooltip, useDeferredLabel = options.useDeferredLabel;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField]), fields = _a.fields, formatter = _a.formatter;
    return schema
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'schema',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, schema),
                args: { useDeferredLabel: useDeferredLabel },
            },
        }))
        : params;
}
//# sourceMappingURL=schema.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/violin.js




/**
 * violin \u8F85\u52A9\u70B9\u7684\u914D\u7F6E\u5904\u7406
 * @param params
 */
function violin_violin(params) {
    var options = params.options;
    var violin = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip = options.tooltip;
    var _a = getTooltipMapping(tooltip, [xField, yField, seriesField, sizeField]), fields = _a.fields, formatter = _a.formatter;
    return violin
        ? base_geometry(deepAssign({}, params, {
            options: {
                type: 'violin',
                colorField: seriesField,
                tooltipFields: fields,
                mapping: (0,tslib_es6/* __assign */.pi)({ tooltip: formatter }, violin),
            },
        }))
        : params;
}
//# sourceMappingURL=violin.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/geometries/index.js








//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/size-sensor/lib/index.js
var lib = __webpack_require__(18587);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/core/plot.js






var SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';
/** plot \u56FE\u8868\u5BB9\u5668\u7684\u914D\u7F6E */
var PLOT_CONTAINER_OPTIONS = [
    'padding',
    'appendPadding',
    'renderer',
    'pixelRatio',
    'syncViewPadding',
    'supportCSSTransform',
    'limitInPlot',
];
/**
 * \u6240\u6709 plot \u7684\u57FA\u7C7B
 */
var Plot = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Plot, _super);
    function Plot(container, options) {
        var _this = _super.call(this) || this;
        _this.container = typeof container === 'string' ? document.getElementById(container) : container;
        _this.options = deepAssign({}, _this.getDefaultOptions(), options);
        _this.createG2();
        _this.bindEvents();
        return _this;
    }
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u7684 options \u914D\u7F6E\u9879
     * \u6BCF\u4E2A\u7EC4\u4EF6\u90FD\u53EF\u4EE5\u590D\u5199
     */
    Plot.getDefaultOptions = function () {
        return {
            renderer: 'canvas',
            xAxis: {
                nice: true,
                label: {
                    autoRotate: false,
                    autoHide: { type: 'equidistance', cfg: { minGap: 6 } },
                },
            },
            yAxis: {
                nice: true,
                label: {
                    autoHide: true,
                    autoRotate: false,
                },
            },
            animation: true,
        };
    };
    /**
     * \u521B\u5EFA G2 \u5B9E\u4F8B
     */
    Plot.prototype.createG2 = function () {
        var _a = this.options, width = _a.width, height = _a.height, defaultInteractions = _a.defaultInteractions;
        this.chart = new chart((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ container: this.container, autoFit: false }, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions: defaultInteractions }));
        // \u7ED9\u5BB9\u5668\u589E\u52A0\u6807\u8BC6\uFF0C\u77E5\u9053\u56FE\u8868\u7684\u6765\u6E90\u533A\u522B\u4E8E G2
        this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');
    };
    /**
     * \u8BA1\u7B97\u9ED8\u8BA4\u7684 chart \u5927\u5C0F\u3002\u903B\u8F91\u7B80\u5316\uFF1A\u5982\u679C\u5B58\u5728 width \u6216 height\uFF0C\u5219\u76F4\u63A5\u4F7F\u7528\uFF0C\u5426\u5219\u4F7F\u7528\u5BB9\u5668\u5927\u5C0F
     * @param width
     * @param height
     */
    Plot.prototype.getChartSize = function (width, height) {
        var chartSize = getContainerSize(this.container);
        return { width: width || chartSize.width || 400, height: height || chartSize.height || 400 };
    };
    /**
     * \u7ED1\u5B9A\u4EE3\u7406\u6240\u6709 G2 \u7684\u4E8B\u4EF6
     */
    Plot.prototype.bindEvents = function () {
        var _this = this;
        if (this.chart) {
            this.chart.on('*', function (e) {
                if (e === null || e === void 0 ? void 0 : e.type) {
                    _this.emit(e.type, e);
                }
            });
        }
    };
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u7684 options \u914D\u7F6E\u9879
     * \u6BCF\u4E2A\u7EC4\u4EF6\u90FD\u53EF\u4EE5\u590D\u5199
     */
    Plot.prototype.getDefaultOptions = function () {
        return Plot.getDefaultOptions();
    };
    /**
     * \u7ED8\u5236
     */
    Plot.prototype.render = function () {
        // \u66B4\u529B\u5904\u7406\uFF0C\u5148\u6E05\u7A7A\u518D\u6E32\u67D3\uFF0C\u9700\u8981 G2 \u5C42\u81EA\u884C\u505A\u597D\u66F4\u65B0\u6E32\u67D3
        this.chart.clear();
        // \u56E0\u4E3A\u5B50 view \u4F1A\u7EE7\u627F\u7236 view \u7684 options \u914D\u7F6E\uFF08\u5305\u62EC legend\uFF0C\u6240\u4EE5\u4F1A\u5BFC\u81F4 legend \u91CD\u590D\u521B\u5EFA\uFF09
        // \u6240\u4EE5\u8FD9\u91CC\u7ED9 chart \u5B9E\u4F8B\u7684 options \u914D\u7F6E\u6E05\u7A7A
        // \u6700\u597D\u7684\u89E3\u6CD5\u662F\u5728 G2 view.clear \u65B9\u6CD5\u7684\u65F6\u5019\uFF0C\u91CD\u7F6E options \u914D\u7F6E\u3002\u6216\u8005\u63D0\u4F9B\u65B9\u6CD5\u53BB resetOptions
        // #1684 \u7406\u8BBA\u4E0A\u5728\u591A view \u56FE\u5F62\u4E0A\uFF0C\u53EA\u8981\u5B58\u5728 custom legend\uFF0C\u90FD\u5B58\u5728\u7C7B\u4F3C\u95EE\u9898\uFF08\u5B50\u5F39\u56FE\u3001\u53CC\u8F74\u56FE\uFF09
        // @ts-ignore
        this.chart.options = {
            data: [],
            animate: true,
        };
        this.chart.views = []; // \u5220\u9664\u5DF2\u6709\u7684 views
        // \u6267\u884C adaptor
        this.execAdaptor();
        // \u6E32\u67D3
        this.chart.render();
        // \u7ED1\u5B9A
        this.bindSizeSensor();
    };
    /**
     * \u66F4\u65B0: \u66F4\u65B0\u914D\u7F6E\u4E14\u91CD\u65B0\u6E32\u67D3
     * @param options
     */
    Plot.prototype.update = function (options) {
        this.updateOption(options);
        this.render();
    };
    /**
     * \u66F4\u65B0\u914D\u7F6E
     * @param options
     */
    Plot.prototype.updateOption = function (options) {
        this.options = deepAssign({}, this.options, options);
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001
     * @param type \u72B6\u6001\u7C7B\u578B\uFF0C\u652F\u6301 'active' | 'inactive' | 'selected' \u4E09\u79CD
     * @param conditions \u6761\u4EF6\uFF0C\u652F\u6301\u6570\u7EC4
     * @param status \u662F\u5426\u6FC0\u6D3B\uFF0C\u9ED8\u8BA4 true
     */
    Plot.prototype.setState = function (type, condition, status) {
        if (status === void 0) { status = true; }
        var elements = getAllElementsRecursively(this.chart);
        (0,esm/* each */.S6)(elements, function (ele) {
            if (condition(ele.getData())) {
                ele.setState(type, status);
            }
        });
    };
    /**
     * \u83B7\u53D6\u72B6\u6001
     */
    Plot.prototype.getStates = function () {
        var elements = getAllElementsRecursively(this.chart);
        var stateObjects = [];
        (0,esm/* each */.S6)(elements, function (element) {
            var data = element.getData();
            var states = element.getStates();
            (0,esm/* each */.S6)(states, function (state) {
                stateObjects.push({ data: data, state: state, geometry: element.geometry, element: element });
            });
        });
        return stateObjects;
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @override
     * @param options
     */
    Plot.prototype.changeData = function (data) {
        // @ts-ignore
        this.update({ data: data });
        // TODO: \u4E34\u65F6\u65B9\u6848\uFF0C\u6700\u597D\u4F7F\u7528\u4E0B\u9762\u7684\u65B9\u5F0F\u53BB\u66F4\u65B0\u6570\u636E
        // this.chart.changeData(data);
    };
    /**
     * \u4FEE\u6539\u753B\u5E03\u5927\u5C0F
     * @param width
     * @param height
     */
    Plot.prototype.changeSize = function (width, height) {
        this.chart.changeSize(width, height);
    };
    /**
     * \u589E\u52A0\u56FE\u8868\u6807\u6CE8\u3002\u901A\u8FC7 id \u6807\u8BC6\uFF0C\u5982\u679C\u5339\u914D\u5230\uFF0C\u5C31\u505A\u66F4\u65B0
     */
    Plot.prototype.addAnnotations = function (annotations, view) {
        view = view ? view : this.chart;
        var incoming = (0,tslib_es6/* __spreadArray */.ev)([], annotations, true);
        var controller = view.getController('annotation');
        var current = controller.getComponents().map(function (co) { return co.extra; });
        controller.clear(true);
        var _loop_1 = function (i) {
            var annotation = current[i];
            var findIndex = incoming.findIndex(function (item) { return item.id && item.id === annotation.id; });
            if (findIndex !== -1) {
                annotation = deepAssign({}, annotation, incoming[findIndex]);
                incoming.splice(findIndex, 1);
            }
            controller.annotation(annotation);
        };
        for (var i = 0; i < current.length; i++) {
            _loop_1(i);
        }
        incoming.forEach(function (annotation) { return controller.annotation(annotation); });
        view.render(true);
    };
    /**
     * \u5220\u9664\u56FE\u8868\u6807\u6CE8\u3002\u901A\u8FC7 id \u6807\u8BC6\uFF0C\u5982\u679C\u5339\u914D\u5230\uFF0C\u5C31\u505A\u5220\u9664
     */
    Plot.prototype.removeAnnotations = function (annotations) {
        var controller = this.chart.getController('annotation');
        var current = controller.getComponents().map(function (co) { return co.extra; });
        controller.clear(true);
        var _loop_2 = function (i) {
            var annotation = current[i];
            if (!annotations.find(function (item) { return item.id && item.id === annotation.id; })) {
                controller.annotation(annotation);
            }
        };
        for (var i = 0; i < current.length; i++) {
            _loop_2(i);
        }
        this.chart.render(true);
    };
    /**
     * \u9500\u6BC1
     */
    Plot.prototype.destroy = function () {
        // \u53D6\u6D88 size-sensor \u7684\u7ED1\u5B9A
        this.unbindSizeSensor();
        // G2 \u7684\u9500\u6BC1
        this.chart.destroy();
        // \u6E05\u7A7A\u5DF2\u7ECF\u7ED1\u5B9A\u7684\u4E8B\u4EF6
        this.off();
        this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    /**
     * \u6267\u884C adaptor \u64CD\u4F5C
     */
    Plot.prototype.execAdaptor = function () {
        var adaptor = this.getSchemaAdaptor();
        var _a = this.options, padding = _a.padding, appendPadding = _a.appendPadding;
        // \u66F4\u65B0 padding
        this.chart.padding = padding;
        // \u66F4\u65B0 appendPadding
        this.chart.appendPadding = appendPadding;
        // \u8F6C\u5316\u6210 G2 API
        adaptor({
            chart: this.chart,
            options: this.options,
        });
    };
    /**
     * \u5F53\u56FE\u8868\u5BB9\u5668\u5927\u5C0F\u53D8\u5316\u7684\u65F6\u5019\uFF0C\u6267\u884C\u7684\u51FD\u6570
     */
    Plot.prototype.triggerResize = function () {
        this.chart.forceFit();
    };
    /**
     * \u7ED1\u5B9A dom \u5BB9\u5668\u5927\u5C0F\u53D8\u5316\u7684\u4E8B\u4EF6
     */
    Plot.prototype.bindSizeSensor = function () {
        var _this = this;
        if (this.unbind) {
            return;
        }
        var _a = this.options.autoFit, autoFit = _a === void 0 ? true : _a;
        if (autoFit) {
            this.unbind = (0,lib/* bind */.ak)(this.container, function () {
                // \u83B7\u53D6\u6700\u65B0\u7684\u5BBD\u9AD8\u4FE1\u606F
                var _a = getContainerSize(_this.container), width = _a.width, height = _a.height;
                // \u4E3B\u8981\u662F\u9632\u6B62\u7ED1\u5B9A\u7684\u65F6\u5019\u89E6\u53D1 resize \u56DE\u8C03
                if (width !== _this.chart.width || height !== _this.chart.height) {
                    _this.triggerResize();
                }
            });
        }
    };
    /**
     * \u53D6\u6D88\u7ED1\u5B9A
     */
    Plot.prototype.unbindSizeSensor = function () {
        if (this.unbind) {
            this.unbind();
            this.unbind = undefined;
        }
    };
    return Plot;
}(event_emitter_esm/* default */.Z));

//# sourceMappingURL=plot.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/transform/percent.js



/**
 * \u5BF9\u6570\u636E\u8FDB\u884C\u767E\u5206\u6BD4\u5316
 * @param data
 * @param measure
 * @param groupField
 * @param as
 */
function percent(data, measure, groupField, as) {
    // 1. \u5148\u8BA1\u7B97\u6BCF\u4E00\u4E2A\u5206\u7EC4\u7684 max \u503C
    var sumMap = (0,esm/* reduce */.u4)(data, function (map, datum) {
        var groupValue = datum[groupField];
        var sum = map.has(groupValue) ? map.get(groupValue) : 0;
        var v = datum[measure];
        sum = isRealNumber(v) ? sum + v : sum;
        map.set(groupValue, sum);
        return map;
    }, new Map());
    // 2. \u5FAA\u73AF\u6570\u7EC4\uFF0C\u8BA1\u7B97\u5360\u6BD4
    return (0,esm/* map */.UI)(data, function (datum) {
        var _a;
        var v = datum[measure];
        var groupValue = datum[groupField];
        var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, datum), (_a = {}, _a[as] = percentage, _a));
    });
}
/**
 * \u5BF9\u6570\u636E\u8FDB\u884C\u6DF1\u5C42\u767E\u5206\u6BD4\u5316
 * @param data
 * @param measure  // \u6570\u503C
 * @param fields // \u9700\u8981\u5206\u7EC4\u7684 field\u503C
 * @param as // \u5B58\u50A8percent \u767E\u5206\u6BD4\u7684\u503C
 */
function getDeepPercent(data, measure, fields, percent) {
    var sumMap = (0,esm/* reduce */.u4)(data, function (map, datum) {
        // \u83B7\u53D6\u5206\u7EC4\u5F97\u5230\u7684\u679A\u4E3Ekey\u503C
        var groupValue = (0,esm/* reduce */.u4)(fields, function (value, field) { return "".concat(value).concat(datum[field]); }, '');
        var sum = map.has(groupValue) ? map.get(groupValue) : 0;
        var v = datum[measure];
        sum = isRealNumber(v) ? sum + v : sum;
        map.set(groupValue, sum);
        return map;
    }, new Map());
    // 2. \u5FAA\u73AF\u6570\u7EC4\uFF0C\u8BA1\u7B97\u5360\u6BD4
    return (0,esm/* map */.UI)(data, function (datum) {
        var _a;
        var v = datum[measure];
        // \u83B7\u53D6\u5206\u7EC4\u5F97\u5230\u7684\u679A\u4E3Ekey\u503C
        var groupValue = (0,esm/* reduce */.u4)(fields, function (value, field) { return "".concat(value).concat(datum[field]); }, '');
        var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, datum), (_a = {}, _a[percent] = percentage, _a));
    });
}
/**
 * \u83B7\u53D6\u6570\u636E\uFF0C\u5982\u679C\u662F\u767E\u5206\u6BD4\uFF0C\u8FDB\u884C\u6570\u636E\u8F6C\u6362 (\u9002\u7528\u4E8E\u9762\u79EF\u56FE\u3001\u67F1\u72B6\u56FE\u3001\u6761\u5F62\u56FE)
 * @param isPercent \u662F\u5426\u767E\u5206\u6BD4
 */
function getDataWhetherPercentage(data, yField, groupField, asField, isPercent) {
    return !isPercent ? data : percent(data, yField, groupField, asField);
}
//# sourceMappingURL=percent.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/line/adaptor.js






/**
 * geometry \u914D\u7F6E\u5904\u7406
 * @param params
 */
function adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, color = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
    var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
    var areaState = areaMapping === null || areaMapping === void 0 ? void 0 : areaMapping.state;
    chart.data(data);
    // line geometry \u5904\u7406
    var primary = deepAssign({}, params, {
        options: {
            shapeField: seriesField,
            line: {
                color: color,
                style: lineStyle,
                shape: lineShape,
            },
            // \u989C\u8272\u4FDD\u6301\u4E00\u81F4\uFF0C\u56E0\u4E3A\u5982\u679C\u989C\u8272\u4E0D\u4E00\u81F4\uFF0C\u4F1A\u5BFC\u81F4 tooltip \u4E2D\u5143\u7D20\u91CD\u590D\u3002
            // \u5982\u679C\u5B58\u5728\uFF0C\u624D\u8BBE\u7F6E\uFF0C\u5426\u5219\u4E3A\u7A7A
            point: pointMapping && (0,tslib_es6/* __assign */.pi)({ color: color, shape: 'circle' }, pointMapping),
            // \u9762\u79EF\u914D\u7F6E
            area: areaMapping && (0,tslib_es6/* __assign */.pi)({ color: color }, areaMapping),
            // label \u4E0D\u4F20\u9012\u7ED9\u5404\u4E2A geometry adaptor\uFF0C\u7531 label adaptor \u5904\u7406
            label: undefined,
        },
    });
    var second = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
    var areaParams = deepAssign({}, primary, { options: { tooltip: false, state: areaState } });
    line_line(primary);
    point_point(second);
    area_area(areaParams);
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function meta(params) {
    var _a, _b;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data = options.data;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a), (_b = {},
        _b[xField] = {
            type: 'cat',
        },
        _b[yField] = adjustYMetaByZero(data, yField),
        _b)))(params);
}
/**
 * \u5750\u6807\u7CFB\u914D\u7F6E. \u652F\u6301 reflect \u955C\u50CF\u5904\u7406
 * @param params
 */
function coordinate(params) {
    var chart = params.chart, options = params.options;
    var reflect = options.reflect;
    if (reflect) {
        var p = reflect;
        if (!(0,esm/* isArray */.kJ)(p)) {
            p = [p];
        }
        var actions = p.map(function (d) { return ['reflect', d]; });
        chart.coordinate({ type: 'rect', actions: actions });
    }
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(yField, false);
    }
    else {
        chart.axis(yField, yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, seriesField = options.seriesField;
    if (legend && seriesField) {
        chart.legend(seriesField, legend);
    }
    else if (legend === false) {
        chart.legend(false);
    }
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField;
    var lineGeometry = findGeometry(chart, 'line');
    // label \u4E3A false, \u7A7A \u5219\u4E0D\u663E\u793A label
    if (!label) {
        lineGeometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        lineGeometry.label({
            fields: [yField],
            callback: callback,
            cfg: (0,tslib_es6/* __assign */.pi)({ layout: [
                    { type: 'limit-in-plot' },
                    { type: 'path-adjust-position' },
                    { type: 'point-adjust-position' },
                    { type: 'limit-in-plot', cfg: { action: 'hide' } },
                ] }, transformLabel(cfg)),
        });
    }
    return params;
}
/**
 * \u7EDF\u4E00\u5904\u7406 adjust
 * @param params
 */
function adaptor_adjust(params) {
    var chart = params.chart, options = params.options;
    var isStack = options.isStack;
    if (isStack) {
        (0,esm/* each */.S6)(chart.geometries, function (g) {
            g.adjust('stack');
        });
    }
    return params;
}
/**
 * \u6298\u7EBF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(adaptor_geometry, meta, adaptor_adjust, common_theme, coordinate, adaptor_axis, adaptor_legend, common_tooltip, label, common_slider, common_scrollbar, common_interaction, animation, common_annotation(), common_limitInPlot)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/area/adaptor.js








/**
 * geometry \u5904\u7406
 * @param params
 */
function area_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, areaStyle = options.areaStyle, areaShape = options.areaShape, color = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
    var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
    var chartData = getDataWhetherPercentage(data, yField, xField, yField, isPercent);
    chart.data(chartData);
    // \u767E\u5206\u6BD4\u5806\u79EF\u56FE\uFF0C\u9ED8\u8BA4\u4F1A\u7ED9\u4E00\u4E2A % \u683C\u5F0F\u5316\u903B\u8F91, \u7528\u6237\u53EF\u81EA\u5B9A\u4E49
    var tooltipOptions = isPercent
        ? (0,tslib_es6/* __assign */.pi)({ formatter: function (datum) { return ({
                name: datum[seriesField] || datum[xField],
                value: (Number(datum[yField]) * 100).toFixed(2) + '%',
            }); } }, tooltip) : tooltip;
    var primary = deepAssign({}, params, {
        options: {
            area: {
                color: color,
                style: areaStyle,
                shape: areaShape,
            },
            point: pointMapping && (0,tslib_es6/* __assign */.pi)({ color: color }, pointMapping),
            tooltip: tooltipOptions,
            // label \u4E0D\u4F20\u9012\u7ED9\u5404\u4E2A geometry adaptor\uFF0C\u7531 label adaptor \u5904\u7406
            label: undefined,
            args: {
                startOnZero: startOnZero,
            },
        },
    });
    // \u7EBF\u9ED8\u8BA4 2px (\u6298\u7EBF\u4E0D\u80FD\u590D\u7528\u9762\u79EF\u56FE\u7684 state\uFF0C\u56E0\u4E3A fill \u548C stroke \u4E0D\u5339\u914D)
    var lineParams = {
        chart: chart,
        options: deepAssign({ line: { size: 2 } }, (0,esm/* omit */.CE)(options, ['state']), {
            // \u989C\u8272\u4FDD\u6301\u4E00\u81F4\uFF0C\u56E0\u4E3A\u5982\u679C\u989C\u8272\u4E0D\u4E00\u81F4\uFF0C\u4F1A\u5BFC\u81F4 tooltip \u4E2D\u5143\u7D20\u91CD\u590D\u3002
            // \u5982\u679C\u5B58\u5728\uFF0C\u624D\u8BBE\u7F6E\uFF0C\u5426\u5219\u4E3A\u7A7A
            line: lineMapping && (0,tslib_es6/* __assign */.pi)({ color: color }, lineMapping),
            sizeField: seriesField,
            state: lineMapping === null || lineMapping === void 0 ? void 0 : lineMapping.state,
            tooltip: false,
            // label \u4E0D\u4F20\u9012\u7ED9\u5404\u4E2A geometry adaptor\uFF0C\u7531 label adaptor \u5904\u7406
            label: undefined,
            args: {
                startOnZero: startOnZero,
            },
        }),
    };
    var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
    // area geometry \u5904\u7406
    area_area(primary);
    line_line(lineParams);
    point_point(pointParams);
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField;
    var areaGeometry = findGeometry(chart, 'area');
    // label \u4E3A false, \u7A7A \u5219\u4E0D\u663E\u793A label
    if (!label) {
        areaGeometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        areaGeometry.label({
            fields: [yField],
            callback: callback,
            cfg: (0,tslib_es6/* __assign */.pi)({ layout: [
                    { type: 'limit-in-plot' },
                    { type: 'path-adjust-position' },
                    { type: 'point-adjust-position' },
                    { type: 'limit-in-plot', cfg: { action: 'hide' } },
                ] }, transformLabel(cfg)),
        });
    }
    return params;
}
/**
 * \u5904\u7406 adjust
 * @param params
 */
function area_adaptor_adjust(params) {
    var chart = params.chart, options = params.options;
    var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
    if ((isPercent || isStack) && seriesField) {
        (0,esm/* each */.S6)(chart.geometries, function (g) {
            g.adjust('stack');
        });
    }
    return params;
}
/**
 * \u6298\u7EBF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, pattern('areaStyle'), transformations('rect'), area_adaptor_geometry, meta, area_adaptor_adjust, adaptor_axis, adaptor_legend, common_tooltip, adaptor_label, common_slider, common_annotation(), common_interaction, animation, common_limitInPlot)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/area/constants.js


/**
 * \u9762\u79EF\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
            type: 'x',
        },
    },
    isStack: true,
    // \u9ED8\u8BA4\u5F00\u542F
    line: {},
    legend: {
        position: 'top-left',
        radio: {},
    },
});
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/area/index.js





var area_Area = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Area, _super);
    function Area() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'area';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9762\u79EF\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Area.getDefaultOptions = function () {
        return DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u9762\u79EF\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Area.prototype.getDefaultOptions = function () {
        return Area.getDefaultOptions();
    };
    /**
     * @override
     * @param data
     */
    Area.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this.options, isPercent = _a.isPercent, xField = _a.xField, yField = _a.yField;
        var _b = this, chart = _b.chart, options = _b.options;
        meta({ chart: chart, options: options });
        this.chart.changeData(getDataWhetherPercentage(data, yField, xField, yField, isPercent));
    };
    /**
     * \u83B7\u53D6 \u9762\u79EF\u56FE \u7684\u9002\u914D\u5668
     */
    Area.prototype.getSchemaAdaptor = function () {
        return adaptor_adaptor;
    };
    return Area;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/interactions/actions/reset-button.js




var reset_button_PADDING_RIGHT = 10;
var reset_button_PADDING_TOP = 5;
/**
 * Action \u4E2D\u7684 Button \u6309\u94AE\u914D\u7F6E
 *
 * \u53EF\u80FD\u7684\u4F7F\u7528\u573A\u666F\uFF1Abrush filter
 */
var BUTTON_ACTION_CONFIG = {
    padding: [8, 10],
    text: 'reset',
    textStyle: {
        default: {
            x: 0,
            y: 0,
            fontSize: 12,
            fill: '#333333',
            cursor: 'pointer',
        },
    },
    buttonStyle: {
        default: {
            fill: '#f7f7f7',
            stroke: '#cccccc',
            cursor: 'pointer',
        },
        active: {
            fill: '#e6e6e6',
        },
    },
};
/**
 * @override \u590D\u5199 G2 Button Action, \u540E\u7EED\u76F4\u63A5\u4F7F\u7528 GUI
 */
var reset_button_ButtonAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ButtonAction, _super);
    function ButtonAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.buttonGroup = null;
        _this.buttonCfg = (0,tslib_es6/* __assign */.pi)({ name: 'button' }, BUTTON_ACTION_CONFIG);
        return _this;
    }
    /**
     * \u83B7\u53D6 mix \u9ED8\u8BA4\u7684\u914D\u7F6E\u548C\u7528\u6237\u914D\u7F6E
     */
    ButtonAction.prototype.getButtonCfg = function () {
        var view = this.context.view;
        var buttonCfg = (0,esm/* get */.U2)(view, ['interactions', 'filter-action', 'cfg', 'buttonConfig']);
        return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
    };
    /**
     * \u7ED8\u5236 Button \u548C \u6587\u672C
     */
    ButtonAction.prototype.drawButton = function () {
        var config = this.getButtonCfg();
        var group = this.context.view.foregroundGroup.addGroup({
            name: config.name,
        });
        var textShape = this.drawText(group);
        this.drawBackground(group, textShape.getBBox());
        this.buttonGroup = group;
    };
    /**
     * \u7ED8\u5236\u6587\u672C
     */
    ButtonAction.prototype.drawText = function (group) {
        var _a;
        var config = this.getButtonCfg();
        // \u6DFB\u52A0\u6587\u672C
        return group.addShape({
            type: 'text',
            name: 'button-text',
            attrs: (0,tslib_es6/* __assign */.pi)({ text: config.text }, (_a = config.textStyle) === null || _a === void 0 ? void 0 : _a.default),
        });
    };
    ButtonAction.prototype.drawBackground = function (group, bbox) {
        var _a;
        var config = this.getButtonCfg();
        var padding = normalPadding(config.padding);
        // \u6DFB\u52A0\u80CC\u666F\u6309\u94AE
        var buttonShape = group.addShape({
            type: 'rect',
            name: 'button-rect',
            attrs: (0,tslib_es6/* __assign */.pi)({ x: bbox.x - padding[3], y: bbox.y - padding[0], width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, (_a = config.buttonStyle) === null || _a === void 0 ? void 0 : _a.default),
        });
        buttonShape.toBack(); // \u5728\u540E\u9762
        // active \u6548\u679C\u5185\u7F6E
        group.on('mouseenter', function () {
            var _a;
            buttonShape.attr((_a = config.buttonStyle) === null || _a === void 0 ? void 0 : _a.active);
        });
        group.on('mouseleave', function () {
            var _a;
            buttonShape.attr((_a = config.buttonStyle) === null || _a === void 0 ? void 0 : _a.default);
        });
        return buttonShape;
    };
    // \u91CD\u7F6E\u4F4D\u7F6E
    ButtonAction.prototype.resetPosition = function () {
        var view = this.context.view;
        var coord = view.getCoordinate();
        var point = coord.convert({ x: 1, y: 1 }); // \u540E\u9762\u76F4\u63A5\u6539\u6210\u5DE6\u4E0A\u89D2
        var buttonGroup = this.buttonGroup;
        var bbox = buttonGroup.getBBox();
        var matrix = Util.transform(null, [
            ['t', point.x - bbox.width - reset_button_PADDING_RIGHT, point.y + bbox.height + reset_button_PADDING_TOP],
        ]);
        buttonGroup.setMatrix(matrix);
    };
    /**
     * \u663E\u793A
     */
    ButtonAction.prototype.show = function () {
        if (!this.buttonGroup) {
            this.drawButton();
        }
        this.resetPosition();
        this.buttonGroup.show();
    };
    /**
     * \u9690\u85CF
     */
    ButtonAction.prototype.hide = function () {
        if (this.buttonGroup) {
            this.buttonGroup.hide();
        }
    };
    /**
     * \u9500\u6BC1
     */
    ButtonAction.prototype.destroy = function () {
        var buttonGroup = this.buttonGroup;
        if (buttonGroup) {
            buttonGroup.remove();
        }
        _super.prototype.destroy.call(this);
    };
    return ButtonAction;
}(action_base));

//# sourceMappingURL=reset-button.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/interactions/brush.js


registerAction('brush-reset-button', reset_button_ButtonAction, {
    name: 'brush-reset-button',
});
registerInteraction('filter-action', {});
/**
 * G2 \u5DF2\u7ECF\u5185\u7F6E\u4E86 brush\u3001brush-x\u3001brush-y \u7B49\u4EA4\u4E92\uFF0C\u5176\u5B83\uFF1A
 *
 * 1. element-range-highlight \u662F\u5426\u53EF\u7528\u91CD\u547D\u540D\u4E3A brush-highlight\uFF1F(mask \u53EF\u4EE5\u79FB\u52A8)
 * 2. brush-visible \u4E0E brush \u7684\u533A\u522B\u662F\uFF1F
 */
function brush_isPointInView(context) {
    return context.isInPlot();
}
/**
 * \u83B7\u53D6 \u4EA4\u4E92 start \u9636\u6BB5\u7684\u76F8\u5173\u914D\u7F6E
 */
function getInteractionCfg(interactionType, brushType, options) {
    var _a = options || {}, mask = _a.mask, isStartEnable = _a.isStartEnable;
    var maskType = brushType || 'rect';
    switch (interactionType) {
        case 'brush':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                ],
                start: [
                    {
                        trigger: 'mousedown',
                        isEnable: isStartEnable || brush_isPointInView,
                        action: ['brush:start', "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C\u4E8C\u4E2Aaction\u7684\u53C2\u6570
                        arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                ],
                processing: [
                    {
                        trigger: 'mousemove',
                        isEnable: brush_isPointInView,
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                ],
                end: [
                    {
                        trigger: 'mouseup',
                        isEnable: brush_isPointInView,
                        action: [
                            'brush:filter',
                            'brush:end',
                            "".concat(maskType, "-mask:end"),
                            "".concat(maskType, "-mask:hide"),
                            'brush-reset-button:show',
                        ],
                    },
                ],
                rollback: [
                    {
                        trigger: 'brush-reset-button:click',
                        action: ['brush:reset', 'brush-reset-button:hide', 'cursor:crosshair'],
                    },
                ],
            };
        case 'brush-highlight':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mousemove', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    {
                        trigger: 'plot:mousemove',
                        action: 'cursor:default',
                        isEnable: function (context) { return (isStartEnable ? !isStartEnable(context) : false); },
                    },
                    { trigger: 'mask:mouseenter', action: 'cursor:move', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                    { trigger: 'mask:mouseleave', action: 'cursor:crosshair' },
                ],
                start: [
                    {
                        trigger: 'plot:mousedown',
                        isEnable: isStartEnable ||
                            (function (context) {
                                // \u4E0D\u8981\u70B9\u51FB\u5728 mask \u4E0A\u91CD\u65B0\u5F00\u59CB
                                return !context.isInShape('mask');
                            }),
                        action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C 1 \u4E2Aaction\u7684\u53C2\u6570
                        arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                    {
                        trigger: 'mask:dragstart',
                        action: ["".concat(maskType, "-mask:moveStart")],
                    },
                ],
                processing: [
                    {
                        trigger: 'plot:mousemove',
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                    {
                        trigger: 'mask:drag',
                        action: ["".concat(maskType, "-mask:move")],
                    },
                    {
                        trigger: 'mask:change',
                        action: ['element-range-highlight:highlight'],
                    },
                ],
                end: [
                    { trigger: 'plot:mouseup', action: ["".concat(maskType, "-mask:end")] },
                    { trigger: 'mask:dragend', action: ["".concat(maskType, "-mask:moveEnd")] },
                    {
                        trigger: 'document:mouseup',
                        isEnable: function (context) {
                            return !context.isInPlot();
                        },
                        action: ['element-range-highlight:clear', "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")],
                    },
                ],
                rollback: [{ trigger: 'dblclick', action: ['element-range-highlight:clear', "".concat(maskType, "-mask:hide")] }],
            };
        case 'brush-x':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                ],
                start: [
                    {
                        trigger: 'mousedown',
                        isEnable: isStartEnable || brush_isPointInView,
                        action: ['brush-x:start', "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C\u4E8C\u4E2Aaction\u7684\u53C2\u6570
                        arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                ],
                processing: [
                    {
                        trigger: 'mousemove',
                        isEnable: brush_isPointInView,
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                ],
                end: [
                    {
                        trigger: 'mouseup',
                        isEnable: brush_isPointInView,
                        action: ['brush-x:filter', 'brush-x:end', "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")],
                    },
                ],
                rollback: [{ trigger: 'dblclick', action: ['brush-x:reset'] }],
            };
        case 'brush-x-highlight':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'mask:mouseenter', action: 'cursor:move', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                    { trigger: 'mask:mouseleave', action: 'cursor:crosshair' },
                ],
                start: [
                    {
                        trigger: 'plot:mousedown',
                        isEnable: isStartEnable ||
                            (function (context) {
                                // \u4E0D\u8981\u70B9\u51FB\u5728 mask \u4E0A\u91CD\u65B0\u5F00\u59CB
                                return !context.isInShape('mask');
                            }),
                        action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C 1 \u4E2Aaction\u7684\u53C2\u6570
                        arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                    {
                        trigger: 'mask:dragstart',
                        action: ["".concat(maskType, "-mask:moveStart")],
                    },
                ],
                processing: [
                    {
                        trigger: 'plot:mousemove',
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                    {
                        trigger: 'mask:drag',
                        action: ["".concat(maskType, "-mask:move")],
                    },
                    {
                        trigger: 'mask:change',
                        action: ['element-range-highlight:highlight'],
                    },
                ],
                end: [
                    { trigger: 'plot:mouseup', action: ["".concat(maskType, "-mask:end")] },
                    { trigger: 'mask:dragend', action: ["".concat(maskType, "-mask:moveEnd")] },
                    {
                        trigger: 'document:mouseup',
                        isEnable: function (context) {
                            return !context.isInPlot();
                        },
                        action: ['element-range-highlight:clear', "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")],
                    },
                ],
                rollback: [{ trigger: 'dblclick', action: ['element-range-highlight:clear', "".concat(maskType, "-mask:hide")] }],
            };
        case 'brush-y':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                ],
                start: [
                    {
                        trigger: 'mousedown',
                        isEnable: isStartEnable || brush_isPointInView,
                        action: ['brush-y:start', "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C\u4E8C\u4E2Aaction\u7684\u53C2\u6570
                        arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                ],
                processing: [
                    {
                        trigger: 'mousemove',
                        isEnable: brush_isPointInView,
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                ],
                end: [
                    {
                        trigger: 'mouseup',
                        isEnable: brush_isPointInView,
                        action: ['brush-y:filter', 'brush-y:end', "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")],
                    },
                ],
                rollback: [{ trigger: 'dblclick', action: ['brush-y:reset'] }],
            };
        case 'brush-y-highlight':
            return {
                showEnable: [
                    { trigger: 'plot:mouseenter', action: 'cursor:crosshair', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'mask:mouseenter', action: 'cursor:move', isEnable: isStartEnable || (function () { return true; }) },
                    { trigger: 'plot:mouseleave', action: 'cursor:default' },
                    { trigger: 'mask:mouseleave', action: 'cursor:crosshair' },
                ],
                start: [
                    {
                        trigger: 'plot:mousedown',
                        isEnable: isStartEnable ||
                            (function (context) {
                                // \u4E0D\u8981\u70B9\u51FB\u5728 mask \u4E0A\u91CD\u65B0\u5F00\u59CB
                                return !context.isInShape('mask');
                            }),
                        action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
                        // \u5BF9\u5E94\u7B2C 1 \u4E2Aaction\u7684\u53C2\u6570
                        arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }],
                    },
                    {
                        trigger: 'mask:dragstart',
                        action: ["".concat(maskType, "-mask:moveStart")],
                    },
                ],
                processing: [
                    {
                        trigger: 'plot:mousemove',
                        action: ["".concat(maskType, "-mask:resize")],
                    },
                    {
                        trigger: 'mask:drag',
                        action: ["".concat(maskType, "-mask:move")],
                    },
                    {
                        trigger: 'mask:change',
                        action: ['element-range-highlight:highlight'],
                    },
                ],
                end: [
                    { trigger: 'plot:mouseup', action: ["".concat(maskType, "-mask:end")] },
                    { trigger: 'mask:dragend', action: ["".concat(maskType, "-mask:moveEnd")] },
                    {
                        trigger: 'document:mouseup',
                        isEnable: function (context) {
                            return !context.isInPlot();
                        },
                        action: ['element-range-highlight:clear', "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")],
                    },
                ],
                rollback: [{ trigger: 'dblclick', action: ['element-range-highlight:clear', "".concat(maskType, "-mask:hide")] }],
            };
        default:
            return {};
    }
}
// \u76F4\u63A5\u62F7\u8D1D\u8FC7\u6765\u7684
registerInteraction('brush', getInteractionCfg('brush'));
// \u590D\u5199 element-range-highlight interaction
registerInteraction('brush-highlight', getInteractionCfg('brush-highlight'));
// \u590D\u5199
registerInteraction('brush-x', getInteractionCfg('brush-x', 'x-rect'));
// \u590D\u5199
registerInteraction('brush-y', getInteractionCfg('brush-y', 'y-rect'));
// \u65B0\u589E, x \u6846\u9009\u9AD8\u4EAE
registerInteraction('brush-x-highlight', getInteractionCfg('brush-x-highlight', 'x-rect'));
// \u65B0\u589E, y \u6846\u9009\u9AD8\u4EAE
registerInteraction('brush-y-highlight', getInteractionCfg('brush-y-highlight', 'y-rect'));
//# sourceMappingURL=brush.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/brush.js

/** \u5148\u5F15\u5165brush \u4EA4\u4E92 */



var BRUSH_TYPES = ['brush', 'brush-x', 'brush-y', 'brush-highlight', 'brush-x-highlight', 'brush-y-highlight'];
/**
 * brush \u4EA4\u4E92
 */
function brushInteraction(params) {
    var options = params.options;
    var brush = options.brush;
    // \u5148\u8FC7\u6EE4\u6389 brush \u7B49\u4EA4\u4E92
    var interactions = (0,esm/* filter */.hX)(options.interactions || [], function (i) { return BRUSH_TYPES.indexOf(i.type) === -1; });
    // \u8BBE\u7F6E brush \u4EA4\u4E92
    if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
        BRUSH_TYPES.forEach(function (type) {
            var enable = false;
            switch (brush.type) {
                case 'x-rect':
                    enable = type === (brush.action === 'highlight' ? 'brush-x-highlight' : 'brush-x');
                    break;
                case 'y-rect':
                    enable = type === (brush.action === 'highlight' ? 'brush-y-highlight' : 'brush-y');
                    break;
                default:
                    enable = type === (brush.action === 'highlight' ? 'brush-highlight' : 'brush');
                    break;
            }
            var obj = { type: type, enable: enable };
            if (brush) {
                obj.cfg = getInteractionCfg(type, brush.type, brush);
            }
            interactions.push(obj);
        });
        // \u585E\u5165 button \u914D\u7F6E (G2Plot \u7684\u5C01\u88C5)
        if ((brush === null || brush === void 0 ? void 0 : brush.action) !== 'highlight') {
            interactions.push({
                type: 'filter-action',
                cfg: {
                    buttonConfig: brush.button,
                },
            });
        }
    }
    return deepAssign({}, params, { options: { interactions: interactions } });
}
//# sourceMappingURL=brush.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/connected-area.js

var INTERACTION_MAP = {
    hover: '__interval-connected-area-hover__',
    click: '__interval-connected-area-click__',
};
var getStartStages = function (trigger, style) {
    if (trigger === 'hover') {
        return [
            {
                trigger: "interval:mouseenter",
                action: ['element-highlight-by-color:highlight', 'element-link-by-color:link'],
                arg: [null, { style: style }],
            },
        ];
    }
    return [
        {
            trigger: "interval:click",
            action: [
                'element-highlight-by-color:clear',
                'element-highlight-by-color:highlight',
                'element-link-by-color:clear',
                'element-link-by-color:unlink',
                'element-link-by-color:link',
            ],
            arg: [null, null, null, null, { style: style }],
        },
    ];
};
/** hover \u89E6\u53D1\u7684\u8FDE\u901A\u533A\u57DF\u4EA4\u4E92 */
registerInteraction(INTERACTION_MAP.hover, {
    start: getStartStages(INTERACTION_MAP.hover),
    end: [
        {
            trigger: 'interval:mouseleave',
            action: ['element-highlight-by-color:reset', 'element-link-by-color:unlink'],
        },
    ],
});
/** click \u89E6\u53D1\u7684\u8054\u901A\u533A\u57DF\u4EA4\u4E92 */
registerInteraction(INTERACTION_MAP.click, {
    start: getStartStages(INTERACTION_MAP.click),
    end: [
        {
            trigger: 'document:mousedown',
            action: ['element-highlight-by-color:clear', 'element-link-by-color:clear'],
        },
    ],
});
/**
 * \u8FD4\u56DE\u652F\u6301\u8054\u901A\u533A\u57DF\u7EC4\u4EF6\u4EA4\u4E92\u7684 adaptor\uFF0C\u9002\u7528\u4E8E\u5806\u53E0\u67F1\u5F62\u56FE/\u5806\u53E0\u6761\u5F62\u56FE
 * @param disable
 */
function connectedArea(disable) {
    if (disable === void 0) { disable = false; }
    return function (params) {
        var chart = params.chart, options = params.options;
        var connectedArea = options.connectedArea;
        var clear = function () {
            chart.removeInteraction(INTERACTION_MAP.hover);
            chart.removeInteraction(INTERACTION_MAP.click);
        };
        if (!disable && connectedArea) {
            var trigger = connectedArea.trigger || 'hover';
            clear();
            chart.interaction(INTERACTION_MAP[trigger], {
                start: getStartStages(trigger, connectedArea.style),
            });
        }
        else {
            clear();
        }
        return params;
    };
}
//# sourceMappingURL=connected-area.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/conversion.js

/**
 * \u8F6C\u5316\u7387\u7684\u8BA1\u7B97\u65B9\u5F0F
 * @param prev
 * @param next
 */
function conversionTagFormatter(prev, next) {
    if (!(0,esm/* isNumber */.hj)(prev) || !(0,esm/* isNumber */.hj)(next)) {
        return '-';
    }
    // 0 / 0 \u6CA1\u6709\u610F\u4E49
    if (prev === 0 && next === 0) {
        return '-';
    }
    if (prev === next) {
        return '100%';
    }
    if (prev === 0) {
        return '\u221E';
    }
    return "".concat(((100 * next) / prev).toFixed(2), "%");
}
//# sourceMappingURL=conversion.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/adaptor/conversion-tag.js





function getConversionTagOptionsWithDefaults(options, horizontal) {
    return deepAssign({
        size: horizontal ? 32 : 80,
        spacing: horizontal ? 8 : 12,
        offset: horizontal ? 32 : 0,
        arrow: options.arrow !== false && {
            headSize: 12,
            style: {
                fill: 'rgba(0, 0, 0, 0.05)',
            },
        },
        text: options.text !== false && {
            style: {
                fontSize: 12,
                fill: 'rgba(0, 0, 0, 0.85)',
                textAlign: 'center',
                textBaseline: 'middle',
            },
            formatter: conversionTagFormatter,
        },
    }, options);
}
function parsePoints(coordinate, element) {
    // @ts-ignore
    return (0,esm/* map */.UI)(element.getModel().points, function (point) { return coordinate.convertPoint(point); });
}
function renderArrowTag(config, elemPrev, elemNext) {
    var view = config.view, geometry = config.geometry, group = config.group, options = config.options, horizontal = config.horizontal;
    var offset = options.offset, size = options.size, arrow = options.arrow;
    var coordinate = view.getCoordinate();
    var pointPrev = parsePoints(coordinate, elemPrev)[3];
    var pointNext = parsePoints(coordinate, elemNext)[0];
    var totalHeight = pointNext.y - pointPrev.y;
    var totalWidth = pointNext.x - pointPrev.x;
    if (typeof arrow === 'boolean') {
        return;
    }
    var headSize = arrow.headSize;
    var spacing = options.spacing;
    var points;
    if (horizontal) {
        if ((totalWidth - headSize) / 2 < spacing) {
            // \u5F53\u67F1\u95F4\u8DDD\u4E0D\u8DB3\u5BB9\u7EB3\u7BAD\u5934\u5C16\u4E0E\u95F4\u9694\u65F6\uFF0C\u753B\u4E09\u89D2\u5E76\u6324\u5360\u95F4\u9694
            spacing = Math.max(1, (totalWidth - headSize) / 2);
            points = [
                [pointPrev.x + spacing, pointPrev.y - offset],
                [pointPrev.x + spacing, pointPrev.y - offset - size],
                [pointNext.x - spacing, pointNext.y - offset - size / 2],
            ];
        }
        else {
            // \u5F53\u67F1\u95F4\u8DDD\u8DB3\u591F\u65F6\uFF0C\u753B\u5B8C\u6574\u56FE\u5F62\u5E76\u7559\u51FA\u95F4\u9694\u3002
            points = [
                [pointPrev.x + spacing, pointPrev.y - offset],
                [pointPrev.x + spacing, pointPrev.y - offset - size],
                [pointNext.x - spacing - headSize, pointNext.y - offset - size],
                [pointNext.x - spacing, pointNext.y - offset - size / 2],
                [pointNext.x - spacing - headSize, pointNext.y - offset],
            ];
        }
    }
    else {
        if ((totalHeight - headSize) / 2 < spacing) {
            // \u5F53\u67F1\u95F4\u8DDD\u4E0D\u8DB3\u5BB9\u7EB3\u7BAD\u5934\u5C16\u4E0E\u95F4\u9694\u65F6\uFF0C\u753B\u4E09\u89D2\u5E76\u6324\u5360\u95F4\u9694
            spacing = Math.max(1, (totalHeight - headSize) / 2);
            points = [
                [pointPrev.x + offset, pointPrev.y + spacing],
                [pointPrev.x + offset + size, pointPrev.y + spacing],
                [pointNext.x + offset + size / 2, pointNext.y - spacing],
            ];
        }
        else {
            // \u5F53\u67F1\u95F4\u8DDD\u8DB3\u591F\u65F6\uFF0C\u753B\u5B8C\u6574\u56FE\u5F62\u5E76\u7559\u51FA\u95F4\u9694\u3002
            points = [
                [pointPrev.x + offset, pointPrev.y + spacing],
                [pointPrev.x + offset + size, pointPrev.y + spacing],
                [pointNext.x + offset + size, pointNext.y - spacing - headSize],
                [pointNext.x + offset + size / 2, pointNext.y - spacing],
                [pointNext.x + offset, pointNext.y - spacing - headSize],
            ];
        }
    }
    group.addShape('polygon', {
        id: "".concat(view.id, "-conversion-tag-arrow-").concat(geometry.getElementId(elemPrev.getModel().mappingData)),
        name: 'conversion-tag-arrow',
        origin: {
            element: elemPrev,
            nextElement: elemNext,
        },
        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, (arrow.style || {})), { points: points }),
    });
}
function renderTextTag(config, elemPrev, elemNext) {
    var _a, _b, _c;
    var view = config.view, geometry = config.geometry, group = config.group, options = config.options, field = config.field, horizontal = config.horizontal;
    var offset = options.offset, size = options.size;
    if (typeof options.text === 'boolean') {
        return;
    }
    var coordinate = view.getCoordinate();
    var text = ((_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field], elemNext.getData()[field]));
    var pointPrev = parsePoints(coordinate, elemPrev)[horizontal ? 3 : 0];
    var pointNext = parsePoints(coordinate, elemNext)[horizontal ? 0 : 3];
    var textShape = group.addShape('text', {
        id: "".concat(view.id, "-conversion-tag-text-").concat(geometry.getElementId(elemPrev.getModel().mappingData)),
        name: 'conversion-tag-text',
        origin: {
            element: elemPrev,
            nextElement: elemNext,
        },
        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, (((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {})), { text: text, x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size / 2, y: horizontal ? pointPrev.y - offset - size / 2 : (pointPrev.y + pointNext.y) / 2 }),
    });
    if (horizontal) {
        var totalWidth = pointNext.x - pointPrev.x;
        var textWidth = textShape.getBBox().width;
        if (textWidth > totalWidth) {
            var cWidth = textWidth / text.length;
            var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
            var textAdjusted = "".concat(text.slice(0, cEnd), "...");
            textShape.attr('text', textAdjusted);
        }
    }
}
function conversion_tag_renderTag(options, elemPrev, elemNext) {
    renderArrowTag(options, elemPrev, elemNext);
    renderTextTag(options, elemPrev, elemNext);
}
/**
 * \u8FD4\u56DE\u652F\u6301\u8F6C\u5316\u7387\u7EC4\u4EF6\u7684 adaptor\uFF0C\u9002\u7528\u4E8E\u67F1\u5F62\u56FE/\u6761\u5F62\u56FE
 * @param field \u7528\u6237\u8F6C\u5316\u7387\u8BA1\u7B97\u7684\u5B57\u6BB5
 * @param horizontal \u662F\u5426\u6C34\u5E73\u65B9\u5411\u7684\u8F6C\u5316\u7387
 * @param disabled \u662F\u5426\u7981\u7528
 */
function conversionTag(field, horizontal, disabled) {
    if (horizontal === void 0) { horizontal = true; }
    if (disabled === void 0) { disabled = false; }
    return function (params) {
        var options = params.options, chart = params.chart;
        var conversionTag = options.conversionTag, theme = options.theme;
        if (conversionTag && !disabled) {
            // \u6709\u8F6C\u5316\u7387\u7EC4\u4EF6\u65F6\uFF0C\u67F1\u5B50\u5BBD\u5EA6\u5360\u6BD4\u81EA\u52A8\u4E3A 1/3
            chart.theme(deepAssign({}, (0,esm/* isObject */.Kn)(theme) ? theme : getTheme(theme), {
                columnWidthRatio: 1 / 3,
            }));
            // \u4F7F\u7528  shape annotation \u7ED8\u5236\u8F6C\u5316\u7387\u7EC4\u4EF6
            chart.annotation().shape({
                render: function (container, view) {
                    var group = container.addGroup({
                        id: "".concat(chart.id, "-conversion-tag-group"),
                        name: 'conversion-tag-group',
                    });
                    var interval = (0,esm/* find */.sE)(chart.geometries, function (geom) { return geom.type === 'interval'; });
                    var config = {
                        view: view,
                        geometry: interval,
                        group: group,
                        field: field,
                        horizontal: horizontal,
                        options: getConversionTagOptionsWithDefaults(conversionTag, horizontal),
                    };
                    var elements = interval.elements;
                    (0,esm/* each */.S6)(elements, function (elem, idx) {
                        if (idx > 0) {
                            conversion_tag_renderTag(config, elements[idx - 1], elem);
                        }
                    });
                },
            });
        }
        return params;
    };
}
//# sourceMappingURL=conversion-tag.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/column/adaptor.js










/**
 * defaultOptions
 * @param params
 */
function defaultOptions(params) {
    var options = params.options;
    // \u9ED8\u8BA4 legend \u4F4D\u7F6E
    var legend = options.legend;
    var seriesField = options.seriesField, isStack = options.isStack;
    if (seriesField) {
        if (legend !== false) {
            legend = (0,tslib_es6/* __assign */.pi)({ position: isStack ? 'right-top' : 'top-left' }, legend);
        }
    }
    else {
        legend = false;
    }
    // @ts-ignore \u76F4\u63A5\u6539\u503C
    params.options.legend = legend;
    return params;
}
/**
 * \u5B57\u6BB5
 * @param params
 */
function column_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, columnStyle = options.columnStyle, color = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip = options.tooltip, shape = options.shape;
    var percentData = isPercent && isGroup && isStack
        ? getDeepPercent(data, yField, [xField, groupField], yField)
        : getDataWhetherPercentage(data, yField, xField, yField, isPercent);
    var chartData = [];
    // \u5B58\u5728\u5806\u53E0,\u5E76\u4E14\u5B58\u5728\u5806\u53E0seriesField\u5206\u7C7B\uFF0C\u5E76\u4E14\u4E0D\u5B58\u5728\u5206\u7EC4\u7684\u65F6\u5019 \u8FDB\u884C\u5806\u53E0
    if (isStack && seriesField && !isGroup) {
        percentData.forEach(function (item) {
            var stackedItem = chartData.find(function (v) { return v[xField] === item[xField] && v[seriesField] === item[seriesField]; });
            if (stackedItem) {
                stackedItem[yField] += item[yField] || 0;
            }
            else {
                chartData.push((0,tslib_es6/* __assign */.pi)({}, item));
            }
        });
    }
    else {
        chartData = percentData;
    }
    chart.data(chartData);
    // \u767E\u5206\u6BD4\u5806\u79EF\u56FE\uFF0C\u9ED8\u8BA4\u4F1A\u7ED9\u4E00\u4E2A % \u683C\u5F0F\u5316\u903B\u8F91, \u7528\u6237\u53EF\u81EA\u5B9A\u4E49
    var tooltipOptions = isPercent
        ? (0,tslib_es6/* __assign */.pi)({ formatter: function (datum) {
                var _a;
                return ({
                    name: isGroup && isStack ? "".concat(datum[seriesField], " - ").concat(datum[groupField]) : (_a = datum[seriesField]) !== null && _a !== void 0 ? _a : datum[xField],
                    value: (Number(datum[yField]) * 100).toFixed(2) + '%',
                });
            } }, tooltip) : tooltip;
    var p = deepAssign({}, params, {
        options: {
            data: chartData,
            widthRatio: columnWidthRatio,
            tooltip: tooltipOptions,
            interval: {
                shape: shape,
                style: columnStyle,
                color: color,
            },
        },
    });
    interval_interval(p);
    return p;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function adaptor_meta(params) {
    var _a, _b;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data = options.data, isPercent = options.isPercent;
    var percentYMeta = isPercent ? { max: 1, min: 0, minLimit: 0, maxLimit: 1 } : {};
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a), (_b = {},
        _b[xField] = {
            type: 'cat',
        },
        _b[yField] = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, adjustYMetaByZero(data, yField)), percentYMeta),
        _b)))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function column_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(yField, false);
    }
    else {
        chart.axis(yField, yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function column_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, seriesField = options.seriesField;
    if (legend && seriesField) {
        chart.legend(seriesField, legend);
    }
    else if (legend === false) {
        chart.legend(false);
    }
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function column_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField, isRange = options.isRange;
    var geometry = findGeometry(chart, 'interval');
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: [yField],
            callback: callback,
            cfg: (0,tslib_es6/* __assign */.pi)({ 
                // \u914D\u7F6E\u9ED8\u8BA4\u7684 label layout\uFF1A \u5982\u679C\u7528\u6237\u6CA1\u6709\u6307\u5B9A layout \u548C position\uFF0C \u5219\u81EA\u52A8\u914D\u7F6E layout
                layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position)
                    ? undefined
                    : [
                        { type: 'interval-adjust-position' },
                        { type: 'interval-hide-overlap' },
                        { type: 'adjust-color' },
                        { type: 'limit-in-plot', cfg: { action: 'hide' } },
                    ] }, transformLabel(isRange
                ? (0,tslib_es6/* __assign */.pi)({ content: function (item) {
                        var _a;
                        return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
                    } }, cfg) : cfg)),
        });
    }
    return params;
}
/**
 * \u67F1\u5F62\u56FE tooltip \u914D\u7F6E (\u5BF9\u5806\u53E0\u3001\u5206\u7EC4\u505A\u7279\u6B8A\u5904\u7406)
 * @param params
 */
function columnTooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
    if (tooltip === false) {
        chart.tooltip(false);
    }
    else {
        var tooltipOptions = tooltip;
        // fix: https://github.com/antvis/G2Plot/issues/2572
        if (isGroup && isStack) {
            var customItems_1 = tooltipOptions.customItems;
            var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) ||
                (function (datum) { return ({ name: "".concat(datum[seriesField], " - ").concat(datum[groupField]), value: datum[yField] }); });
            tooltipOptions = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, tooltipOptions), { customItems: function (originalItems) {
                    var items = [];
                    (0,esm/* each */.S6)(originalItems, function (item) {
                        // Find datas in same cluster
                        var datas = (0,esm/* filter */.hX)(data, function (d) { return (0,esm/* isMatch */.BD)(d, pick(item.data, [xField, seriesField])); });
                        datas.forEach(function (datum) {
                            items.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { value: datum[yField], data: datum, mappingData: { _origin: datum } }), tooltipFormatter_1(datum)));
                        });
                    });
                    // fix https://github.com/antvis/G2Plot/issues/3367
                    return customItems_1 ? customItems_1(items) : items;
                } });
        }
        chart.tooltip(tooltipOptions);
    }
    return params;
}
/**
 * \u67F1\u5F62\u56FE\u9002\u914D\u5668
 * @param params
 */
function column_adaptor_adaptor(params, isBar) {
    if (isBar === void 0) { isBar = false; }
    var options = params.options;
    var seriesField = options.seriesField;
    return flow(defaultOptions, // \u5904\u7406\u9ED8\u8BA4\u914D\u7F6E
    common_theme, // theme \u9700\u8981\u5728 geometry \u4E4B\u524D
    pattern('columnStyle'), common_state, transformations('rect'), column_adaptor_geometry, adaptor_meta, column_adaptor_axis, column_adaptor_legend, columnTooltip, common_slider, common_scrollbar, column_adaptor_label, brushInteraction, common_interaction, animation, common_annotation(), conversionTag(options.yField, !isBar, !!seriesField), // \u6709\u62C6\u5206\u7684\u65F6\u5019\u7981\u7528\u8F6C\u5316\u7387
    connectedArea(!options.isStack), common_limitInPlot)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bar/adaptor.js





/**
 * \u5904\u7406\u9ED8\u8BA4\u914D\u7F6E\u9879
 * 1. switch xField\u3001 yField
 * 2. switch xAxis\u3001 yAxis and adjust axis.position configuration
 */
function adaptor_defaultOptions(params) {
    var options = params.options;
    var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
    var position = {
        left: 'bottom',
        right: 'top',
        top: 'left',
        bottom: 'right',
    };
    var verticalAxis = yAxis !== false
        ? (0,tslib_es6/* __assign */.pi)({ position: position[(yAxis === null || yAxis === void 0 ? void 0 : yAxis.position) || 'left'] }, yAxis) : false;
    var horizontalAxis = xAxis !== false
        ? (0,tslib_es6/* __assign */.pi)({ position: position[(xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) || 'bottom'] }, xAxis) : false;
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { xField: yField, yField: xField, 
            // \u6761\u5F62\u56FE xAxis\uFF0CyAxis \u4E0D\u53EF\u4EE5\u505A deepAssign
            xAxis: verticalAxis, yAxis: horizontalAxis }) });
}
/**
 * label \u9002\u914D\u5668
 * @param params
 */
function bar_adaptor_label(params) {
    var options = params.options;
    var label = options.label;
    // label of bar charts default position is left, if plot has label
    if (label && !label.position) {
        label.position = 'left';
        // \u914D\u7F6E\u9ED8\u8BA4\u7684 label layout\uFF1A \u5982\u679C\u7528\u6237\u6CA1\u6709\u6307\u5B9A layout \u548C position\uFF0C \u5219\u81EA\u52A8\u914D\u7F6E layout
        if (!label.layout) {
            label.layout = [
                { type: 'interval-adjust-position' },
                { type: 'interval-hide-overlap' },
                { type: 'adjust-color' },
                { type: 'limit-in-plot', cfg: { action: 'hide' } },
            ];
        }
    }
    return deepAssign({}, params, { options: { label: label } });
}
/**
 * legend \u9002\u914D\u5668
 * @param params
 */
function bar_adaptor_legend(params) {
    var options = params.options;
    // \u9ED8\u8BA4 legend \u4F4D\u7F6E
    var seriesField = options.seriesField, isStack = options.isStack;
    var legend = options.legend;
    if (seriesField) {
        if (legend !== false) {
            legend = (0,tslib_es6/* __assign */.pi)({ position: isStack ? 'top-left' : 'right-top' }, (legend || {}));
        }
    }
    else {
        legend = false;
    }
    return deepAssign({}, params, { options: { legend: legend } });
}
/**
 * coordinate \u9002\u914D\u5668
 * @param params
 */
function adaptor_coordinate(params) {
    // transpose column to bar \u5BF9\u89D2\u53D8\u6362 & y \u65B9\u5411\u955C\u50CF\u53D8\u6362
    var options = params.options;
    var coordinateOptions = [{ type: 'transpose' }, { type: 'reflectY' }].concat(options.coordinate || []);
    return deepAssign({}, params, { options: { coordinate: coordinateOptions } });
}
/**
 * \u67F1\u5F62\u56FE\u9002\u914D\u5668
 * @param params
 */
function bar_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth, barBackground = options.barBackground;
    return column_adaptor_adaptor({
        chart: chart,
        options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { 
            // rename attrs as column
            columnStyle: barStyle, columnWidthRatio: barWidthRatio, minColumnWidth: minBarWidth, maxColumnWidth: maxBarWidth, columnBackground: barBackground }),
    }, true);
}
/**
 * @param chart
 * @param options
 */
function bar_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(adaptor_defaultOptions, bar_adaptor_label, bar_adaptor_legend, common_tooltip, adaptor_coordinate, bar_adaptor_geometry)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bar/constants.js


/**
 * \u6761\u5F62\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var constants_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    barWidthRatio: 0.6,
    marginRatio: 1 / 32,
    tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20,
    },
    legend: {
        radio: {},
    },
    interactions: [{ type: 'active-region' }],
});
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bar/index.js





/**
 * \u6761\u5F62\u56FE
 */
var Bar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Bar, _super);
    function Bar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'bar';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u6761\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Bar.getDefaultOptions = function () {
        return constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     */
    Bar.prototype.changeData = function (data) {
        var _a, _b;
        this.updateOption({ data: data });
        var _c = this, chart = _c.chart, options = _c.options;
        var isPercent = options.isPercent;
        var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
        _a = [yField, xField], xField = _a[0], yField = _a[1];
        _b = [yAxis, xAxis], xAxis = _b[0], yAxis = _b[1];
        var switchedFieldOptions = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { xField: xField, yField: yField, yAxis: yAxis, xAxis: xAxis });
        adaptor_meta({ chart: chart, options: switchedFieldOptions });
        chart.changeData(getDataWhetherPercentage(data, xField, yField, xField, isPercent));
    };
    /**
     * \u83B7\u53D6 \u6761\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Bar.prototype.getDefaultOptions = function () {
        return Bar.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u6761\u5F62\u56FE \u7684\u9002\u914D\u5668
     */
    Bar.prototype.getSchemaAdaptor = function () {
        return bar_adaptor_adaptor;
    };
    return Bar;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/column/constants.js


/**
 * \u67F1\u5F62\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var column_constants_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    columnWidthRatio: 0.6,
    marginRatio: 1 / 32,
    tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20,
    },
    legend: {
        radio: {},
    },
    interactions: [{ type: 'active-region' }],
});
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/column/index.js





/**
 * \u67F1\u5F62\u56FE
 */
var Column = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Column, _super);
    function Column() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'column';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u67F1\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Column.getDefaultOptions = function () {
        return column_constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     */
    Column.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this.options, yField = _a.yField, xField = _a.xField, isPercent = _a.isPercent;
        var _b = this, chart = _b.chart, options = _b.options;
        adaptor_meta({ chart: chart, options: options });
        this.chart.changeData(getDataWhetherPercentage(data, yField, xField, yField, isPercent));
    };
    /**
     * \u83B7\u53D6 \u67F1\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Column.prototype.getDefaultOptions = function () {
        return Column.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u67F1\u5F62\u56FE \u7684\u9002\u914D\u5668
     */
    Column.prototype.getSchemaAdaptor = function () {
        return column_adaptor_adaptor;
    };
    return Column;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/constant.js
var constant_a;
// \u6F0F\u6597\u5360\u6BD4: data[n][yField] / data[0][yField]
var FUNNEL_PERCENT = '$$percentage$$';
// \u6F0F\u6597\u6620\u5C04\u503C
var FUNNEL_MAPPING_VALUE = '$$mappingValue$$';
// \u6F0F\u6597\u8F6C\u5316\u7387: data[n][yField] / data[n-1][yField];
var FUNNEL_CONVERSATION = '$$conversion$$';
// \u6F0F\u6597\u5355\u9879\u5360\u603B\u4F53\u548C\u7684\u767E\u5206\u6BD4\uFF0C\u7528\u4E8E\u52A8\u6001\u6F0F\u6597\u56FE\u8BA1\u7B97\u9AD8\u5EA6\uFF1A
// data[n][yField] / sum(data[0-n][yField])
var FUNNEL_TOTAL_PERCENT = '$$totalPercentage$$';
// \u6F0F\u6597\u591A\u8FB9\u578B x \u5750\u6807
var PLOYGON_X = '$$x$$';
var PLOYGON_Y = '$$y$$';
/**
 * \u6F0F\u6597\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var constant_DEFAULT_OPTIONS = {
    appendPadding: [0, 80],
    minSize: 0,
    maxSize: 1,
    meta: (constant_a = {},
        constant_a[FUNNEL_MAPPING_VALUE] = {
            min: 0,
            max: 1,
            nice: false,
        },
        constant_a),
    label: {
        style: {
            fill: '#fff',
            fontSize: 12,
        },
    },
    tooltip: {
        showTitle: false,
        showMarkers: false,
        shared: false,
    },
    conversionTag: {
        offsetX: 10,
        offsetY: 0,
        style: {
            fontSize: 12,
            fill: 'rgba(0,0,0,0.45)',
        },
    },
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/geometries/common.js



var CONVERSION_TAG_NAME = 'CONVERSION_TAG_NAME';
/**
 * \u6F0F\u6597\u56FE transform
 * @param geometry
 */
function transformData(data, originData, options) {
    var formatData = [];
    var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
    var maxYFieldValue = (0,esm/* get */.U2)((0,esm/* maxBy */.UT)(originData, yField), [yField]);
    var max = (0,esm/* isNumber */.hj)(maxSize) ? maxSize : 1;
    var min = (0,esm/* isNumber */.hj)(minSize) ? minSize : 0;
    // format \u6570\u636E
    formatData = (0,esm/* map */.UI)(data, function (row, index) {
        var percent = (row[yField] || 0) / maxYFieldValue;
        row[FUNNEL_PERCENT] = percent;
        row[FUNNEL_MAPPING_VALUE] = (max - min) * percent + min;
        // \u8F6C\u5316\u7387\u6570\u636E\u5B58\u50A8\u524D\u540E\u6570\u636E
        row[FUNNEL_CONVERSATION] = [(0,esm/* get */.U2)(data, [index - 1, yField]), row[yField]];
        return row;
    });
    return formatData;
}
/**
 * \u6F0F\u6597\u56FE\u901A\u7528\u8F6C\u5316\u7387\u7EC4\u4EF6
 * @param getLineCoordinate \u7528\u4E8E\u83B7\u53D6\u7279\u5B9A\u7684 line \u7684\u4F4D\u7F6E\u53CA\u914D\u7F6E
 */
function conversionTagComponent(getLineCoordinate) {
    return function (params) {
        var chart = params.chart, options = params.options;
        // @ts-ignore
        var conversionTag = options.conversionTag, filteredData = options.filteredData;
        var data = filteredData || chart.getOptions().data;
        if (conversionTag) {
            var formatter_1 = conversionTag.formatter;
            data.forEach(function (obj, index) {
                if (index <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE]))
                    return;
                var lineOption = getLineCoordinate(obj, index, data, {
                    top: true,
                    name: CONVERSION_TAG_NAME,
                    text: {
                        content: (0,esm/* isFunction */.mf)(formatter_1) ? formatter_1(obj, data) : formatter_1,
                        offsetX: conversionTag.offsetX,
                        offsetY: conversionTag.offsetY,
                        position: 'end',
                        autoRotate: false,
                        style: (0,tslib_es6/* __assign */.pi)({ textAlign: 'start', textBaseline: 'middle' }, conversionTag.style),
                    },
                });
                chart.annotation().line(lineOption);
            });
        }
        return params;
    };
}
//# sourceMappingURL=common.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/geometries/basic.js







/**
 * \u5904\u7406\u5B57\u6BB5\u6570\u636E
 * @param params
 */
function field(params) {
    var chart = params.chart, options = params.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
    var formatData = transformData(data, data, {
        yField: yField,
        maxSize: maxSize,
        minSize: minSize,
    });
    // \u7ED8\u5236\u6F0F\u6597\u56FE
    chart.data(formatData);
    return params;
}
/**
 * geometry\u5904\u7406
 * @param params
 */
function basic_geometry(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, yField = options.yField, color = options.color, tooltip = options.tooltip, label = options.label, _a = options.shape, shape = _a === void 0 ? 'funnel' : _a, funnelStyle = options.funnelStyle, state = options.state;
    var _b = getTooltipMapping(tooltip, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
    base_geometry({
        chart: chart,
        options: {
            type: 'interval',
            xField: xField,
            yField: FUNNEL_MAPPING_VALUE,
            colorField: xField,
            tooltipFields: (0,esm/* isArray */.kJ)(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
            mapping: {
                shape: shape,
                tooltip: formatter,
                color: color,
                style: funnelStyle,
            },
            label: label,
            state: state,
        },
    });
    var geo = findGeometry(params.chart, 'interval');
    geo.adjust('symmetric');
    return params;
}
/**
 * \u8F6C\u7F6E\u5904\u7406
 * @param params
 */
function transpose(params) {
    var chart = params.chart, options = params.options;
    var isTransposed = options.isTransposed;
    chart.coordinate({
        type: 'rect',
        actions: !isTransposed ? [['transpose'], ['scale', 1, -1]] : [],
    });
    return params;
}
/**
 * \u8F6C\u5316\u7387\u7EC4\u4EF6
 * @param params
 */
function basic_conversionTag(params) {
    var options = params.options, chart = params.chart;
    var maxSize = options.maxSize;
    // \u83B7\u53D6\u5F62\u72B6\u4F4D\u7F6E\uFF0C\u518D\u8F6C\u5316\u4E3A\u9700\u8981\u7684\u8F6C\u5316\u7387\u4F4D\u7F6E
    var dataArray = (0,esm/* get */.U2)(chart, ['geometries', '0', 'dataArray'], []);
    var size = (0,esm/* get */.U2)(chart, ['options', 'data', 'length']);
    var x = (0,esm/* map */.UI)(dataArray, function (item) { return (0,esm/* get */.U2)(item, ['0', 'nextPoints', '0', 'x']) * size - 0.5; });
    var getLineCoordinate = function (datum, datumIndex, data, initLineOption) {
        var percent = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, initLineOption), { start: [x[datumIndex - 1] || datumIndex - 0.5, percent], end: [x[datumIndex - 1] || datumIndex - 0.5, percent + 0.05] });
    };
    conversionTagComponent(getLineCoordinate)(params);
    return params;
}
/**
 * \u57FA\u7840\u6F0F\u6597
 * @param chart
 * @param options
 */
function basicFunnel(params) {
    return flow(field, basic_geometry, transpose, basic_conversionTag)(params);
}
//# sourceMappingURL=basic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/geometries/compare.js






/**
 * \u5904\u7406\u5B57\u6BB5\u6570\u636E
 * @param params
 */
function compare_field(params) {
    var _a;
    var chart = params.chart, options = params.options;
    var _b = options.data, data = _b === void 0 ? [] : _b, yField = options.yField;
    // \u7ED8\u5236\u6F0F\u6597\u56FE
    chart.data(data);
    chart.scale((_a = {},
        _a[yField] = {
            sync: true,
        },
        _a));
    return params;
}
/**
 * geometry\u5904\u7406
 * @param params
 */
function compare_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, xField = options.xField, yField = options.yField, color = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label = options.label, funnelStyle = options.funnelStyle, state = options.state, showFacetTitle = options.showFacetTitle;
    chart.facet('mirror', {
        fields: [compareField],
        // \u6F0F\u6597\u56FE\u7684\u8F6C\u7F6E\u89C4\u5219\u4E0E\u5206\u9762\u76F8\u53CD\uFF0C\u9ED8\u8BA4\u662F\u5782\u76F4\u5E03\u5C40
        transpose: !isTransposed,
        padding: isTransposed ? 0 : [32, 0, 0, 0],
        showTitle: showFacetTitle,
        eachView: function (view, facet) {
            var index = isTransposed ? facet.rowIndex : facet.columnIndex;
            if (!isTransposed) {
                view.coordinate({
                    type: 'rect',
                    actions: [['transpose'], ['scale', index === 0 ? -1 : 1, -1]],
                });
            }
            var formatterData = transformData(facet.data, data, {
                yField: yField,
                maxSize: maxSize,
                minSize: minSize,
            });
            view.data(formatterData);
            // \u7ED8\u5236\u56FE\u5F62
            var _a = getTooltipMapping(tooltip, [xField, yField, compareField]), fields = _a.fields, formatter = _a.formatter;
            var defaultFacetLabel = isTransposed
                ? {
                    offset: index === 0 ? 10 : -23,
                    position: (index === 0 ? 'bottom' : 'top'),
                }
                : {
                    offset: 10,
                    position: 'left',
                    style: {
                        textAlign: index === 0 ? 'end' : 'start',
                    },
                };
            base_geometry({
                chart: view,
                options: {
                    type: 'interval',
                    xField: xField,
                    yField: FUNNEL_MAPPING_VALUE,
                    colorField: xField,
                    tooltipFields: (0,esm/* isArray */.kJ)(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
                    mapping: {
                        // todo \u6682\u65F6\u4E0D\u63D0\u4F9B \u91D1\u5B57\u5854 shape\uFF0C\u540E\u7EED\u9700\u8981\u81EA\u5B9A\u4E49\u4E0B\u5F62\u72B6
                        shape: 'funnel',
                        tooltip: formatter,
                        color: color,
                        style: funnelStyle,
                    },
                    label: label === false ? false : deepAssign({}, defaultFacetLabel, label),
                    state: state,
                },
            });
        },
    });
    return params;
}
function compareConversionTag(params) {
    // @ts-ignore
    var chart = params.chart, index = params.index, options = params.options;
    var conversionTag = options.conversionTag, isTransposed = options.isTransposed;
    ((0,esm/* isNumber */.hj)(index) ? [chart] : chart.views).forEach(function (view, viewIndex) {
        // \u83B7\u53D6\u5F62\u72B6\u4F4D\u7F6E\uFF0C\u518D\u8F6C\u5316\u4E3A\u9700\u8981\u7684\u8F6C\u5316\u7387\u4F4D\u7F6E
        var dataArray = (0,esm/* get */.U2)(view, ['geometries', '0', 'dataArray'], []);
        var size = (0,esm/* get */.U2)(view, ['options', 'data', 'length']);
        var x = (0,esm/* map */.UI)(dataArray, function (item) { return (0,esm/* get */.U2)(item, ['0', 'nextPoints', '0', 'x']) * size - 0.5; });
        var getLineCoordinate = function (datum, datumIndex, data, initLineOption) {
            var ratio = (index || viewIndex) === 0 ? -1 : 1;
            return deepAssign({}, initLineOption, {
                start: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE]],
                end: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE] + 0.05],
                text: isTransposed
                    ? {
                        style: {
                            textAlign: 'start',
                        },
                    }
                    : {
                        offsetX: conversionTag !== false ? ratio * conversionTag.offsetX : 0,
                        style: {
                            textAlign: (index || viewIndex) === 0 ? 'end' : 'start',
                        },
                    },
            });
        };
        conversionTagComponent(getLineCoordinate)(deepAssign({}, {
            chart: view,
            options: options,
        }));
    });
}
/**
 * \u8F6C\u5316\u7387\u7EC4\u4EF6
 * @param params
 */
function compare_conversionTag(params) {
    var chart = params.chart;
    // @ts-ignore
    chart.once('beforepaint', function () { return compareConversionTag(params); });
    return params;
}
/**
 * \u5BF9\u6BD4\u6F0F\u6597
 * @param chart
 * @param options
 */
function compareFunnel(params) {
    return flow(compare_field, compare_geometry, compare_conversionTag)(params);
}
//# sourceMappingURL=compare.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/geometries/dynamic-height.js







/**
 * \u52A8\u6001\u9AD8\u5EA6\u6F0F\u6597\u56FE
 * @param params
 * \u9700\u6C42: \u6BCF\u4E2A\u6F0F\u6597\u9879\u7684\u9AD8\u5EA6\u6839\u636E yfield \u7B49\u6BD4\u751F\u6210\u3002\u6F0F\u6597\u4E0A\u4E0B\u5BBD\u5EA6\u6BD4\u4E3A2\uFF0C\u5373\u659C\u7387\u4E3A 2\u3002
 * \u5B9E\u73B0\u65B9\u5F0F: \u4F7F\u7528 g2 \u591A\u8FB9\u5F62\uFF0Cdata -> \u70B9\u5750\u6807 -> \u7ED8\u5236
 * \u4EE5\u6F0F\u6597\u5E95\u90E8\u4E2D\u5FC3\u70B9\u4E3A\u5750\u6807\u8F74\u539F\u70B9\uFF0C\u6F0F\u6597\u5728 -0.5 <= x <= 0.5, 0 <= y <= 1 \u7684\u6B63\u65B9\u5F62\u4E2D\u7ED8\u5236
 * \u5148\u8BA1\u7B97\u7B2C\u4E00\u8C61\u9650\u7684\u70B9, \u7B2C\u4E8C\u8C61\u9650\u7684\u70B9\u5373\u4E3A\u955C\u50CF x \u8F74\u53D6\u53CD\u3002
 * \u7B2C\u4E00\u8C61\u9650\u5171\u9700\u8BA1\u7B97 data.length + 1 \u4E2A\u70B9\uFF0C\u5728 y = 4x - 1 \u4E0A\u3002\u9996\u5C3E\u5206\u522B\u662F[0.5, 1], [0.25, 0]\u3002\u6839\u636E data \u8BA1\u7B97\u51FA y \u503C\uFF0C\u4ECE\u800C\u5F97\u5230 y \u503C
 */
/**
 * \u5904\u7406\u6570\u636E
 * @param params
 */
function dynamic_height_field(params) {
    var chart = params.chart, options = params.options;
    var _a = options.data, data = _a === void 0 ? [] : _a, yField = options.yField;
    // \u8BA1\u7B97\u5404\u6570\u636E\u9879\u6240\u5360\u9AD8\u5EA6
    var sum = (0,esm/* reduce */.u4)(data, function (total, item) {
        return total + (item[yField] || 0);
    }, 0);
    var max = (0,esm/* maxBy */.UT)(data, yField)[yField];
    var formatData = (0,esm/* map */.UI)(data, function (row, index) {
        // \u50A8\u5B58\u56DB\u4E2A\u70B9 x\uFF0Cy \u5750\u6807\uFF0C\u65B9\u5411\u4E3A\u987A\u65F6\u9488\uFF0C\u5373 [\u5DE6\u4E0A, \u53F3\u4E0A\uFF0C\u53F3\u4E0B\uFF0C\u5DE6\u4E0B]
        var x = [];
        var y = [];
        row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum;
        // \u83B7\u53D6\u5DE6\u4E0A\u89D2\uFF0C\u53F3\u4E0A\u89D2\u5750\u6807
        if (index) {
            var preItemX = data[index - 1][PLOYGON_X];
            var preItemY = data[index - 1][PLOYGON_Y];
            x[0] = preItemX[3];
            y[0] = preItemY[3];
            x[1] = preItemX[2];
            y[1] = preItemY[2];
        }
        else {
            x[0] = -0.5;
            y[0] = 1;
            x[1] = 0.5;
            y[1] = 1;
        }
        // \u83B7\u53D6\u53F3\u4E0B\u89D2\u5750\u6807
        y[2] = y[1] - row[FUNNEL_TOTAL_PERCENT];
        x[2] = (y[2] + 1) / 4;
        y[3] = y[2];
        x[3] = -x[2];
        // \u8D4B\u503C
        row[PLOYGON_X] = x;
        row[PLOYGON_Y] = y;
        row[FUNNEL_PERCENT] = (row[yField] || 0) / max;
        row[FUNNEL_CONVERSATION] = [(0,esm/* get */.U2)(data, [index - 1, yField]), row[yField]];
        return row;
    });
    chart.data(formatData);
    return params;
}
/**
 * geometry\u5904\u7406
 * @param params
 */
function dynamic_height_geometry(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, yField = options.yField, color = options.color, tooltip = options.tooltip, label = options.label, funnelStyle = options.funnelStyle, state = options.state;
    var _a = getTooltipMapping(tooltip, [xField, yField]), fields = _a.fields, formatter = _a.formatter;
    // \u7ED8\u5236\u6F0F\u6597\u56FE
    base_geometry({
        chart: chart,
        options: {
            type: 'polygon',
            xField: PLOYGON_X,
            yField: PLOYGON_Y,
            colorField: xField,
            tooltipFields: (0,esm/* isArray */.kJ)(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
            label: label,
            state: state,
            mapping: {
                tooltip: formatter,
                color: color,
                style: funnelStyle,
            },
        },
    });
    return params;
}
/**
 * \u8F6C\u7F6E\u5904\u7406
 * @param params
 */
function dynamic_height_transpose(params) {
    var chart = params.chart, options = params.options;
    var isTransposed = options.isTransposed;
    chart.coordinate({
        type: 'rect',
        actions: isTransposed ? [['transpose'], ['reflect', 'x']] : [],
    });
    return params;
}
/**
 * \u8F6C\u5316\u7387\u7EC4\u4EF6
 * @param params
 */
function dynamic_height_conversionTag(params) {
    var getLineCoordinate = function (datum, datumIndex, data, initLineOption) {
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, initLineOption), { start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]], end: [datum[PLOYGON_X][1] + 0.05, datum[PLOYGON_Y][1]] });
    };
    conversionTagComponent(getLineCoordinate)(params);
    return params;
}
/**
 * \u52A8\u6001\u9AD8\u5EA6\u6F0F\u6597
 * @param chart
 * @param options
 */
function dynamicHeightFunnel(params) {
    return flow(dynamic_height_field, dynamic_height_geometry, dynamic_height_transpose, dynamic_height_conversionTag)(params);
}
//# sourceMappingURL=dynamic-height.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/geometries/facet.js


/**
 * \u5904\u7406\u5B57\u6BB5\u6570\u636E
 * @param params
 */
function facet_field(params) {
    var _a;
    var chart = params.chart, options = params.options;
    var _b = options.data, data = _b === void 0 ? [] : _b, yField = options.yField;
    // \u7ED8\u5236\u6F0F\u6597\u56FE
    chart.data(data);
    chart.scale((_a = {},
        _a[yField] = {
            sync: true,
        },
        _a));
    return params;
}
/**
 * geometry\u5904\u7406
 * @param params
 */
function facet_geometry(params) {
    var chart = params.chart, options = params.options;
    var seriesField = options.seriesField, isTransposed = options.isTransposed, showFacetTitle = options.showFacetTitle;
    chart.facet('rect', {
        fields: [seriesField],
        padding: [isTransposed ? 0 : 32, 10, 0, 10],
        showTitle: showFacetTitle,
        eachView: function (view, facet) {
            basicFunnel(deepAssign({}, params, {
                chart: view,
                options: {
                    data: facet.data,
                },
            }));
        },
    });
    return params;
}
/**
 * \u5206\u9762\u6F0F\u6597
 * @param chart
 * @param options
 */
function facetFunnel(params) {
    return flow(facet_field, facet_geometry)(params);
}
//# sourceMappingURL=facet.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/interactions/funnel-conversion-tag.js






/**
 * Funnel \u8F6C\u5316\u7387\u8DDF\u968F legend \u53D8\u5316\u4E8B\u4EF6
 */
var ConversionTagAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(ConversionTagAction, _super);
    function ConversionTagAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.rendering = false;
        return _this;
    }
    ConversionTagAction.prototype.change = function (options) {
        var _this = this;
        // \u9632\u6B62\u591A\u6B21\u91CD\u590D\u6E32\u67D3
        if (!this.rendering) {
            var seriesField = options.seriesField, compareField = options.compareField;
            var conversionTag_1 = compareField ? compareConversionTag : basic_conversionTag;
            var view = this.context.view;
            // \u517C\u5BB9\u5206\u9762\u6F0F\u6597\u56FE
            var views = seriesField || compareField ? view.views : [view];
            (0,esm/* map */.UI)(views, function (v, index) {
                // \u9632\u6B62\u5F71\u54CD\u5176\u4ED6 annotations \u88AB\u53BB\u9664
                var annotationController = v.getController('annotation');
                var annotations = (0,esm/* filter */.hX)((0,esm/* get */.U2)(annotationController, ['option'], []), function (_a) {
                    var name = _a.name;
                    return name !== CONVERSION_TAG_NAME;
                });
                annotationController.clear(true);
                (0,esm/* each */.S6)(annotations, function (annotation) {
                    if (typeof annotation === 'object') {
                        v.annotation()[annotation.type](annotation);
                    }
                });
                var data = (0,esm/* get */.U2)(v, ['filteredData'], v.getOptions().data);
                conversionTag_1({
                    chart: v,
                    index: index,
                    options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { 
                        // @ts-ignore
                        filteredData: transformData(data, data, options) }),
                });
                v.filterData(data);
                _this.rendering = true;
                v.render(true);
            });
        }
        this.rendering = false;
    };
    return ConversionTagAction;
}(action_base));

//# sourceMappingURL=funnel-conversion-tag.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/interactions/index.js


var FUNNEL_CONVERSION_TAG = 'funnel-conversion-tag';
var FUNNEL_LEGEND_FILTER = 'funnel-afterrender';
var interactionStart = { trigger: 'afterrender', action: "".concat(FUNNEL_CONVERSION_TAG, ":change") };
registerAction(FUNNEL_CONVERSION_TAG, ConversionTagAction);
registerInteraction(FUNNEL_LEGEND_FILTER, {
    start: [interactionStart],
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/adaptor.js












/**
 *
 * \u5404\u5F0F\u6F0F\u6597\u56FEgeometry\u5B9E\u73B0\u7EC6\u8282\u6709\u8F83\u5927\u4E0D\u540C,
 * 1. \u666E\u901A\u6F0F\u6597\u56FE\uFF1Ainterval.shape('funnel')
 * 2. \u5BF9\u6BD4\u6F0F\u6597\u56FE\uFF1A\u5206\u9762
 * 3. \u52A8\u6001\u9AD8\u5EA6\u6F0F\u6597\u56FE\uFF1Apolypon
 * 4. \u5206\u9762\u6F0F\u6597\u56FE\uFF1A\u666E\u901A + list \u5206\u9762
* /

/**
 * options \u5904\u7406
 * @param params
 */
function funnel_adaptor_defaultOptions(params) {
    var options = params.options;
    var compareField = options.compareField, xField = options.xField, yField = options.yField, locale = options.locale, funnelStyle = options.funnelStyle, data = options.data;
    var i18n = getLocale(locale);
    var defaultOption = {
        label: compareField
            ? {
                fields: [xField, yField, compareField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
                formatter: function (datum) { return "".concat(datum[yField]); },
            }
            : {
                fields: [xField, yField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
                offset: 0,
                position: 'middle',
                formatter: function (datum) { return "".concat(datum[xField], " ").concat(datum[yField]); },
            },
        tooltip: {
            title: xField,
            formatter: function (datum) {
                return { name: datum[xField], value: datum[yField] };
            },
        },
        conversionTag: {
            // conversionTag \u7684\u8BA1\u7B97\u548C\u663E\u793A\u903B\u8F91\u7EDF\u4E00\u4FDD\u6301\u4E00\u81F4
            formatter: function (datum) {
                return "".concat(i18n.get(['conversionTag', 'label']), ": ").concat(conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]));
            },
        },
    };
    // \u6F0F\u6597\u56FE\u6837\u5F0F
    var style;
    if (compareField || funnelStyle) {
        style = function (datum) {
            return deepAssign({}, 
            // \u5BF9\u6BD4\u6F0F\u6597\u56FE\u9ED8\u8BA4\u63CF\u8FB9
            compareField && { lineWidth: 1, stroke: '#fff' }, (0,esm/* isFunction */.mf)(funnelStyle) ? funnelStyle(datum) : funnelStyle);
        };
    }
    return deepAssign({ options: defaultOption }, params, { options: { funnelStyle: style, data: (0,esm/* clone */.d9)(data) } });
}
/**
 * geometry\u5904\u7406
 * @param params
 */
function funnel_adaptor_geometry(params) {
    var options = params.options;
    var compareField = options.compareField, dynamicHeight = options.dynamicHeight, seriesField = options.seriesField;
    if (seriesField) {
        return facetFunnel(params);
    }
    if (compareField) {
        return compareFunnel(params);
    }
    if (dynamicHeight) {
        return dynamicHeightFunnel(params);
    }
    return basicFunnel(params);
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function funnel_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a)))(params);
}
/**
 * \u5750\u6807\u8F74
 * @param params
 */
function funnel_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function funnel_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend;
    if (legend === false) {
        chart.legend(false);
    }
    else {
        chart.legend(legend);
        // TODO FIX: legend-click \u65F6\u95F4\u548C\u8F6C\u5316\u7387\u7EC4\u4EF6\u4E4B\u95F4\u7684\u5173\u8054
    }
    return params;
}
/**
 * Interaction \u914D\u7F6E
 * @param params
 */
function adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    // @ts-ignore
    var interactions = options.interactions, dynamicHeight = options.dynamicHeight;
    (0,esm/* each */.S6)(interactions, function (i) {
        if (i.enable === false) {
            chart.removeInteraction(i.type);
        }
        else {
            chart.interaction(i.type, i.cfg || {});
        }
    });
    // \u52A8\u6001\u9AD8\u5EA6  \u4E0D\u8FDB\u884C\u4EA4\u4E92\u64CD\u4F5C
    if (!dynamicHeight) {
        chart.interaction(FUNNEL_LEGEND_FILTER, {
            start: [(0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, interactionStart), { arg: options })],
        });
    }
    else {
        chart.removeInteraction(FUNNEL_LEGEND_FILTER);
    }
    return params;
}
/**
 * \u6F0F\u6597\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function funnel_adaptor_adaptor(params) {
    return flow(funnel_adaptor_defaultOptions, funnel_adaptor_geometry, funnel_adaptor_meta, funnel_adaptor_axis, common_tooltip, adaptor_interaction, funnel_adaptor_legend, animation, common_theme, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/funnel/index.js








var Funnel = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Funnel, _super);
    function Funnel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'funnel';
        return _this;
    }
    Funnel.getDefaultOptions = function () {
        return constant_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u6F0F\u6597\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     */
    Funnel.prototype.getDefaultOptions = function () {
        // \u7531\u4E8E\u4E0D\u540C\u6F0F\u6597\u56FE defaultOption \u6709\u90E8\u5206\u903B\u8F91\u4E0D\u540C\uFF0C\u6B64\u5904\u4EC5\u5904\u7406 core.getDefaultOptions \u8986\u76D6\u8303\u56F4\uFF0Cfunnel \u7684 defaulOption \u4E3A\u4E0D\u5206\u6563\u903B\u8F91\u7EDF\u4E00\u5199\u5230 adaptor \u7684 defaultOption \u4E2D
        return Funnel.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u6F0F\u6597\u56FE \u7684\u9002\u914D\u5668
     */
    Funnel.prototype.getSchemaAdaptor = function () {
        return funnel_adaptor_adaptor;
    };
    /**
     * \u8BBE\u7F6E\u72B6\u6001
     * @param type \u72B6\u6001\u7C7B\u578B\uFF0C\u652F\u6301 'active' | 'inactive' | 'selected' \u4E09\u79CD
     * @param conditions \u6761\u4EF6\uFF0C\u652F\u6301\u6570\u7EC4
     * @param status \u662F\u5426\u6FC0\u6D3B\uFF0C\u9ED8\u8BA4 true
     */
    Funnel.prototype.setState = function (type, condition, status) {
        if (status === void 0) { status = true; }
        var elements = getAllElementsRecursively(this.chart);
        (0,esm/* each */.S6)(elements, function (ele) {
            if (condition(ele.getData())) {
                ele.setState(type, status);
            }
        });
    };
    /**
     * \u83B7\u53D6\u72B6\u6001
     */
    Funnel.prototype.getStates = function () {
        var elements = getAllElementsRecursively(this.chart);
        var stateObjects = [];
        (0,esm/* each */.S6)(elements, function (element) {
            var data = element.getData();
            var states = element.getStates();
            (0,esm/* each */.S6)(states, function (state) {
                stateObjects.push({ data: data, state: state, geometry: element.geometry, element: element });
            });
        });
        return stateObjects;
    };
    // \u5185\u90E8\u53D8\u91CF
    /** \u6F0F\u6597 \u8F6C\u5316\u7387 \u5B57\u6BB5 */
    Funnel.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
    /** \u6F0F\u6597 \u767E\u5206\u6BD4 \u5B57\u6BB5 */
    Funnel.PERCENT_FIELD = FUNNEL_PERCENT;
    /** \u6F0F\u6597 \u603B\u8F6C\u6362\u7387\u767E\u5206\u6BD4 \u5B57\u6BB5 */
    Funnel.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
    return Funnel;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/constants.js
var constants_a;
var RANGE_VALUE = 'range';
var RANGE_TYPE = 'type';
var PERCENT = 'percent';
var DEFAULT_COLOR = '#f0f0f0';
/** \u4EEA\u8868\u76D8\u7531 \u6307\u9488\u548C\u8868\u76D8 \u7EC4\u6210 */
var INDICATEOR_VIEW_ID = 'indicator-view';
var RANGE_VIEW_ID = 'range-view';
/**
 * \u4EEA\u8868\u76D8\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var gauge_constants_DEFAULT_OPTIONS = {
    percent: 0,
    range: {
        ticks: [],
    },
    innerRadius: 0.9,
    radius: 0.95,
    startAngle: (-7 / 6) * Math.PI,
    endAngle: (1 / 6) * Math.PI,
    syncViewPadding: true,
    axis: {
        line: null,
        label: {
            offset: -24,
            style: {
                textAlign: 'center',
                textBaseline: 'middle',
            },
        },
        subTickLine: {
            length: -8,
        },
        tickLine: {
            length: -12,
        },
        grid: null,
    },
    indicator: {
        pointer: {
            style: {
                lineWidth: 5,
                lineCap: 'round',
            },
        },
        pin: {
            style: {
                r: 9.75,
                lineWidth: 4.5,
                fill: '#fff',
            },
        },
    },
    statistic: {
        title: false,
    },
    meta: (constants_a = {},
        // \u4E24\u4E2A view \u7684 scale \u540C\u6B65\u5230 v \u4E0A
        constants_a[RANGE_VALUE] = {
            sync: 'v',
        },
        constants_a[PERCENT] = {
            sync: 'v',
            tickCount: 5,
            tickInterval: 0.2,
        },
        constants_a),
    animation: false,
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/utils.js


/**
 * \u5C06 range \u751F\u6210\u4E3A data \u6570\u636E
 * @param range
 * @param key
 * @returns {GaugeRangeData}
 */
function processRangeData(range, percent) {
    return (range
        // \u6620\u5C04\u4E3A stack \u7684\u6570\u636E
        .map(function (r, idx) {
        var _a;
        return _a = {}, _a[RANGE_VALUE] = r - (range[idx - 1] || 0), _a[RANGE_TYPE] = "".concat(idx), _a[PERCENT] = percent, _a;
    }));
}
/**
 * \u83B7\u53D6 \u4EEA\u8868\u76D8 \u6307\u9488\u6570\u636E
 * @param percent
 */
function getIndicatorData(percent) {
    var _a;
    return [(_a = {}, _a[PERCENT] = (0,esm/* clamp */.uZ)(percent, 0, 1), _a)];
}
/**
 * \u83B7\u53D6\u4EEA\u8868\u76D8 \u8868\u76D8\u5F27\u5F62\u6570\u636E
 * @param percent
 * @param range
 */
function getRangeData(percent, range) {
    var ticks = (0,esm/* get */.U2)(range, ['ticks'], []);
    var clampTicks = (0,esm/* size */.dp)(ticks) ? (0,esm/* uniq */.jj)(ticks) : [0, (0,esm/* clamp */.uZ)(percent, 0, 1), 1];
    if (!clampTicks[0]) {
        clampTicks.shift();
    }
    return processRangeData(clampTicks, percent);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/adaptor.js








/**
 * geometry \u5904\u7406
 * @param params
 */
function gauge_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var percent = options.percent, range = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type = options.type, meter = options.meter;
    var color = range.color, rangeWidth = range.width;
    // \u6307\u6807 & \u6307\u9488
    // \u5982\u679C\u5F00\u542F\u5728\u5E94\u7528
    if (indicator) {
        var indicatorData = getIndicatorData(percent);
        var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
        v1.data(indicatorData);
        v1.point()
            .position("".concat(PERCENT, "*1"))
            .shape(indicator.shape || 'gauge-indicator')
            // \u4F20\u5165\u6307\u9488\u7684\u6837\u5F0F\u5230\u81EA\u5B9A\u4E49 shape \u4E2D
            .customInfo({
            defaultColor: chart.getTheme().defaultColor,
            indicator: indicator,
        });
        v1.coordinate('polar', {
            startAngle: startAngle,
            endAngle: endAngle,
            radius: innerRadius * radius, // \u5916\u90E8\u7684 innerRadius * radius = \u8FD9\u91CC\u7684 radius
        });
        v1.axis(PERCENT, axis);
        // \u4E00\u90E8\u5206\u5E94\u7528\u5230 scale \u4E2D
        v1.scale(PERCENT, pick(axis, AXIS_META_CONFIG_KEYS));
    }
    // \u8F85\u52A9 range
    // [{ range: 1, type: '0', percent: \u539F\u59CB\u8FDB\u5EA6\u767E\u5206\u6BD4 }]
    var rangeData = getRangeData(percent, options.range);
    var v2 = chart.createView({ id: RANGE_VIEW_ID });
    v2.data(rangeData);
    var rangeColor = (0,esm/* isString */.HD)(color) ? [color, DEFAULT_COLOR] : color;
    var ext = interval_interval({
        chart: v2,
        options: {
            xField: '1',
            yField: RANGE_VALUE,
            seriesField: RANGE_TYPE,
            rawFields: [PERCENT],
            isStack: true,
            interval: {
                color: rangeColor,
                style: gaugeStyle,
                shape: type === 'meter' ? 'meter-gauge' : null,
            },
            args: {
                zIndexReversed: true,
                sortZIndex: true,
            },
            minColumnWidth: rangeWidth,
            maxColumnWidth: rangeWidth,
        },
    }).ext;
    var geometry = ext.geometry;
    // \u4F20\u5165\u5230\u81EA\u5B9A\u4E49 shape \u4E2D
    geometry.customInfo({ meter: meter });
    v2.coordinate('polar', {
        innerRadius: innerRadius,
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle,
    }).transpose();
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function gauge_adaptor_meta(params) {
    var _a;
    return flow(common_scale((_a = {
            range: {
                min: 0,
                max: 1,
                maxLimit: 1,
                minLimit: 0,
            }
        },
        _a[PERCENT] = {},
        _a)))(params);
}
/**
 * \u7EDF\u8BA1\u6307\u6807\u6587\u6863
 * @param params
 */
function statistic(params, updated) {
    var chart = params.chart, options = params.options;
    var statistic = options.statistic, percent = options.percent;
    // \u5148\u6E05\u7A7A\u6807\u6CE8\uFF0C\u518D\u91CD\u65B0\u6E32\u67D3
    chart.getController('annotation').clear(true);
    if (statistic) {
        var contentOption = statistic.content;
        var transformContent = void 0;
        // \u5F53\u8BBE\u7F6E content \u7684\u65F6\u5019\uFF0C\u8BBE\u7F6E\u9ED8\u8BA4\u6837\u5F0F
        if (contentOption) {
            transformContent = deepAssign({}, {
                content: "".concat((percent * 100).toFixed(2), "%"),
                style: {
                    opacity: 0.75,
                    fontSize: '30px',
                    lineHeight: 1,
                    textAlign: 'center',
                    color: 'rgba(44,53,66,0.85)',
                },
            }, contentOption);
        }
        renderGaugeStatistic(chart, { statistic: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, statistic), { content: transformContent }) }, { percent: percent });
    }
    if (updated) {
        chart.render(true);
    }
    return params;
}
/**
 * tooltip \u914D\u7F6E
 */
function adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip) {
        chart.tooltip(deepAssign({
            showTitle: false,
            showMarkers: false,
            containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
            domStyles: {
                'g2-tooltip': {
                    padding: '4px 8px',
                    fontSize: '10px',
                },
            },
            customContent: function (x, data) {
                var percent = (0,esm/* get */.U2)(data, [0, 'data', PERCENT], 0);
                return "".concat((percent * 100).toFixed(2), "%");
            },
        }, tooltip));
    }
    else {
        // \u9ED8\u8BA4\uFF0C\u4E0D\u5C55\u793A tooltip
        chart.tooltip(false);
    }
    return params;
}
/**
 * other \u914D\u7F6E
 * @param params
 */
function other(params) {
    var chart = params.chart;
    chart.legend(false);
    return params;
}
/**
 * \u5BF9\u5916\u66B4\u9732\u7684 adaptor
 */

/**
 * \u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function gauge_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, 
    // animation \u914D\u7F6E\u5FC5\u987B\u5728 createView \u4E4B\u524D\uFF0C\u4E0D\u7136\u65E0\u6CD5\u8BA9\u5B50 View \u751F\u6548
    animation, gauge_adaptor_geometry, gauge_adaptor_meta, adaptor_tooltip, statistic, common_interaction, common_annotation(), other
    // ... \u5176\u4ED6\u7684 adaptor flow
    )(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/shapes/indicator.js


// \u81EA\u5B9A\u4E49Shape \u90E8\u5206
registerShape('point', 'gauge-indicator', {
    draw: function (cfg, container) {
        // \u4F7F\u7528 customInfo \u4F20\u9012\u53C2\u6570
        var _a = cfg.customInfo, indicator = _a.indicator, defaultColor = _a.defaultColor;
        var _b = indicator, pointer = _b.pointer, pin = _b.pin;
        var group = container.addGroup();
        // \u83B7\u53D6\u6781\u5750\u6807\u7CFB\u4E0B\u753B\u5E03\u4E2D\u5FC3\u70B9
        var center = this.parsePoint({ x: 0, y: 0 });
        // \u7ED8\u5236\u6307\u9488
        if (pointer) {
            // pointer
            group.addShape('line', {
                name: 'pointer',
                attrs: (0,tslib_es6/* __assign */.pi)({ x1: center.x, y1: center.y, x2: cfg.x, y2: cfg.y, stroke: defaultColor }, pointer.style),
            });
        }
        // pin
        if (pin) {
            group.addShape('circle', {
                name: 'pin',
                attrs: (0,tslib_es6/* __assign */.pi)({ x: center.x, y: center.y, stroke: defaultColor }, pin.style),
            });
        }
        return group;
    },
});
//# sourceMappingURL=indicator.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/shapes/meter-gauge.js


/**
 * \u81EA\u5B9A\u4E49 Shape \u90E8\u5206: \u81EA\u5B9A\u4E49\u7C73\u8F68\u4EEA\u8868\u76D8
 * \u5B9A\u4E49 STEP, STEP_RATIO. \u53EF\u7ED8\u5236\u533A\u57DF: 1 / (STEP + 1) * i -> 1 / (STEP + 1) * i + (STEP_RATIO / (STEP + 1))
 */
registerShape('interval', 'meter-gauge', {
    draw: function (cfg, container) {
        // \u4F7F\u7528 customInfo \u4F20\u9012\u53C2\u6570
        var _a = cfg.customInfo.meter, meter = _a === void 0 ? {} : _a;
        var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? 0.5 : _c;
        STEP = STEP < 1 ? 1 : STEP;
        // stepRatio \u53D6\u503C\u8303\u56F4: (0, 1]
        STEP_RATIO = (0,esm/* clamp */.uZ)(STEP_RATIO, 0, 1);
        var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
        var GAP = 0;
        if (STEP_RATIO > 0 && STEP_RATIO < 1) {
            var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;
            GAP = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
        }
        var INTERVAL = (GAP / (1 - STEP_RATIO)) * STEP_RATIO;
        var group = container.addGroup();
        // \u7ED8\u5236\u56FE\u5F62\u7684\u65F6\u5019\uFF0C\u7559\u4E0B gap
        var center = this.coordinate.getCenter();
        var radius = this.coordinate.getRadius();
        var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
        for (var startAngle = START_ANGLE; startAngle < END_ANGLE;) {
            var endAngle = void 0;
            var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP);
            if (r < INTERVAL) {
                endAngle = startAngle + (INTERVAL - r);
            }
            else {
                startAngle += INTERVAL + GAP - r;
                endAngle = startAngle + INTERVAL;
            }
            var path = Util.getSectorPath(center.x, center.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
            group.addShape('path', {
                name: 'meter-gauge',
                attrs: {
                    path: path,
                    fill: cfg.color,
                    stroke: cfg.color,
                    lineWidth: 0.5,
                },
            });
            startAngle = endAngle + GAP;
        }
        return group;
    },
});
//# sourceMappingURL=meter-gauge.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/gauge/index.js





// \u6CE8\u518C shape



/**
 * \u4EEA\u8868\u76D8
 */
var Gauge = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Gauge, _super);
    function Gauge() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'gauge';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u4EEA\u8868\u76D8 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Gauge.getDefaultOptions = function () {
        return gauge_constants_DEFAULT_OPTIONS;
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @param percent
     */
    Gauge.prototype.changeData = function (percent) {
        this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        this.updateOption({ percent: percent });
        var indicatorView = this.chart.views.find(function (v) { return v.id === INDICATEOR_VIEW_ID; });
        if (indicatorView) {
            indicatorView.data(getIndicatorData(percent));
        }
        var rangeView = this.chart.views.find(function (v) { return v.id === RANGE_VIEW_ID; });
        if (rangeView) {
            rangeView.data(getRangeData(percent, this.options.range));
        }
        // todo \u540E\u7EED\u8BA9 G2 \u5C42\u5728 afterrender \u4E4B\u540E\uFF0C\u6765\u91CD\u7ED8 annotations
        statistic({ chart: this.chart, options: this.options }, true);
        this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E
     * \u4F9B base \u4F7F\u7528
     */
    Gauge.prototype.getDefaultOptions = function () {
        return Gauge.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Gauge.prototype.getSchemaAdaptor = function () {
        return gauge_adaptor_adaptor;
    };
    return Gauge;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/transform/histogram.js

// \u8FDB\u884C\u8F6C\u6362\u5F97\u5230\u503C\u6240\u5728\u7684 range
function getBinKey(value, binWidth, binNumber) {
    // \u505A\u4E00\u70B9\u7279\u6B8A\u5904\u7406
    if (binNumber === 1) {
        return [0, binWidth];
    }
    var index = Math.floor(value / binWidth);
    return [binWidth * index, binWidth * (index + 1)];
}
// \u9ED8\u8BA4 sturges \u8F6C\u6362
function sturges(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
/**
 * \u5BF9\u6570\u636E\u8FDB\u884C\u767E\u5206\u6BD4\u5316
 * @param data
 * @param binField
 * @param binWidth
 * @param binNumber
 * @param stackField
 */
function binHistogram(data, binField, binWidth, binNumber, stackField) {
    var originData_copy = (0,esm/* clone */.d9)(data);
    // \u6839\u636E binField \u5BF9\u6E90\u6570\u636E\u8FDB\u884C\u6392\u5E8F
    (0,esm/* sortBy */.MR)(originData_copy, binField);
    // \u83B7\u53D6\u6E90\u6570\u636E binField \u7684 range
    var values = (0,esm/* valuesOfKey */.I)(originData_copy, binField);
    var range = (0,esm/* getRange */.rx)(values);
    var rangeWidth = range.max - range.min;
    // \u8BA1\u7B97\u5206\u7BB1\uFF0C\u76F4\u65B9\u56FE\u5206\u7BB1\u7684\u8BA1\u7B97\u57FA\u4E8E binWidth\uFF0C\u5982\u914D\u7F6E\u4E86 binNumber \u5219\u5C06\u5176\u8F6C\u4E3A binWidth \u8FDB\u884C\u8BA1\u7B97
    var _binWidth = binWidth;
    if (!binWidth && binNumber) {
        _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
    }
    // \u5F53 binWidth \u548C binNumber \u90FD\u6CA1\u6709\u6307\u5B9A\u7684\u60C5\u51B5\uFF0C\u91C7\u7528 Sturges formula \u81EA\u52A8\u751F\u6210 binWidth
    if (!binWidth && !binNumber) {
        var _defaultBinNumber = sturges(values);
        _binWidth = rangeWidth / _defaultBinNumber;
    }
    // \u6784\u5EFA key - StatisticData \u7ED3\u6784
    var bins = {};
    var groups = (0,esm/* groupBy */.vM)(originData_copy, stackField);
    // \u5224\u65AD\u5206\u7EC4\u662F\u5426\u4E3A\u7A7A\uFF0C\u5982\u679C\u4E3A\u7A7A\uFF0C\u8BF4\u660E\u6CA1\u6709 stackField \u5B57\u6BB5
    if ((0,esm/* isEmpty */.xb)(groups)) {
        (0,esm/* each */.S6)(originData_copy, function (data) {
            var value = data[binField];
            var bin = getBinKey(value, _binWidth, binNumber);
            var binKey = "".concat(bin[0], "-").concat(bin[1]);
            if (!(0,esm/* hasKey */.wH)(bins, binKey)) {
                bins[binKey] = { range: bin, count: 0 };
            }
            bins[binKey].count += 1;
        });
    }
    else {
        Object.keys(groups).forEach(function (groupKey) {
            (0,esm/* each */.S6)(groups[groupKey], function (data) {
                var value = data[binField];
                var bin = getBinKey(value, _binWidth, binNumber);
                var binKey = "".concat(bin[0], "-").concat(bin[1]);
                var groupKeyBinKey = "".concat(binKey, "-").concat(groupKey);
                if (!(0,esm/* hasKey */.wH)(bins, groupKeyBinKey)) {
                    bins[groupKeyBinKey] = { range: bin, count: 0 };
                    bins[groupKeyBinKey][stackField] = groupKey;
                }
                bins[groupKeyBinKey].count += 1;
            });
        });
    }
    // \u5C06\u5206\u7BB1\u6570\u636E\u8F6C\u6362\u4E3A plotData \u624D\u662F\u56FE\u8868\u6240\u9700\u8981\u7684
    var plotData = [];
    (0,esm/* each */.S6)(bins, function (bin) {
        plotData.push(bin);
    });
    return plotData;
}
//# sourceMappingURL=histogram.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/histogram/constant.js


/** \u76F4\u65B9\u56FE xField */
var HISTOGRAM_X_FIELD = 'range';
/** \u76F4\u65B9\u56FE yField */
var HISTOGRAM_Y_FIELD = 'count';
/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var histogram_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    columnStyle: {
        stroke: '#FFFFFF',
    },
    tooltip: {
        shared: true,
        showMarkers: false,
    },
    interactions: [{ type: 'active-region' }],
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/histogram/adaptor.js







/**
 * geometry \u5904\u7406
 * @param params
 */
function histogram_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color = options.color, stackField = options.stackField, legend = options.legend, columnStyle = options.columnStyle;
    // \u5904\u7406\u6570\u636E
    var plotData = binHistogram(data, binField, binWidth, binNumber, stackField);
    chart.data(plotData);
    var p = deepAssign({}, params, {
        options: {
            xField: HISTOGRAM_X_FIELD,
            yField: HISTOGRAM_Y_FIELD,
            seriesField: stackField,
            isStack: true,
            interval: {
                color: color,
                style: columnStyle,
            },
        },
    });
    interval_interval(p);
    // \u56FE\u4F8B
    if (legend && stackField) {
        chart.legend(stackField, legend);
    }
    else {
        chart.legend(false);
    }
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function histogram_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis;
    return flow(common_scale((_a = {},
        _a[HISTOGRAM_X_FIELD] = xAxis,
        _a[HISTOGRAM_Y_FIELD] = yAxis,
        _a)))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function histogram_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(HISTOGRAM_X_FIELD, false);
    }
    else {
        chart.axis(HISTOGRAM_X_FIELD, xAxis);
    }
    if (yAxis === false) {
        chart.axis(HISTOGRAM_Y_FIELD, false);
    }
    else {
        chart.axis(HISTOGRAM_Y_FIELD, yAxis);
    }
    return params;
}
/**
 * label \u914D\u7F6E
 * @param params
 */
function histogram_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label;
    var geometry = findGeometry(chart, 'interval');
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: [HISTOGRAM_Y_FIELD],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * \u76F4\u65B9\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function histogram_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, pattern('columnStyle'), histogram_adaptor_geometry, histogram_adaptor_meta, histogram_adaptor_axis, common_state, histogram_adaptor_label, common_tooltip, common_interaction, animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/histogram/index.js





var Histogram = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Histogram, _super);
    function Histogram() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'histogram';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Histogram.getDefaultOptions = function () {
        return histogram_constant_DEFAULT_OPTIONS;
    };
    Histogram.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this.options, binField = _a.binField, binNumber = _a.binNumber, binWidth = _a.binWidth, stackField = _a.stackField;
        this.chart.changeData(binHistogram(data, binField, binWidth, binNumber, stackField));
    };
    /**
     * \u83B7\u53D6\u76F4\u65B9\u56FE\u7684\u9002\u914D\u5668
     */
    Histogram.prototype.getDefaultOptions = function () {
        return Histogram.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u76F4\u65B9\u56FE\u7684\u9002\u914D\u5668
     */
    Histogram.prototype.getSchemaAdaptor = function () {
        return histogram_adaptor_adaptor;
    };
    return Histogram;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/line/constants.js


/**
 * \u6298\u7EBF\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var line_constants_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
            type: 'x',
        },
    },
    legend: {
        position: 'top-left',
        radio: {},
    },
    isStack: false,
});
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/line/interactions/marker-active.js



var MarkerActiveAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(MarkerActiveAction, _super);
    function MarkerActiveAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MarkerActiveAction.prototype.active = function () {
        var view = this.getView();
        var evt = this.context.event;
        if (evt.data) {
            // items: \u6570\u7EC4\u5BF9\u8C61\uFF0C\u5F53\u524D tooltip \u663E\u793A\u7684\u6BCF\u6761\u5185\u5BB9
            var items_1 = evt.data.items;
            var points = view.geometries.filter(function (geom) { return geom.type === 'point'; });
            (0,esm/* each */.S6)(points, function (point) {
                (0,esm/* each */.S6)(point.elements, function (element) {
                    var active = (0,esm/* findIndex */.cx)(items_1, function (item) { return item.data === element.data; }) !== -1;
                    element.setState('active', active);
                });
            });
        }
    };
    MarkerActiveAction.prototype.reset = function () {
        var view = this.getView();
        var points = view.geometries.filter(function (geom) { return geom.type === 'point'; });
        (0,esm/* each */.S6)(points, function (point) {
            (0,esm/* each */.S6)(point.elements, function (element) {
                element.setState('active', false);
            });
        });
    };
    MarkerActiveAction.prototype.getView = function () {
        return this.context.view;
    };
    return MarkerActiveAction;
}(action_base));

//# sourceMappingURL=marker-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/line/interactions/index.js


registerAction('marker-active', MarkerActiveAction);
registerInteraction('marker-active', {
    start: [
        {
            trigger: 'tooltip:show',
            action: 'marker-active:active',
        },
    ],
    end: [
        {
            trigger: 'tooltip:hide',
            action: 'marker-active:reset',
        },
    ],
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/line/index.js





var plots_line_Line = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Line, _super);
    function Line() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'line';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u6298\u7EBF\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Line.getDefaultOptions = function () {
        return line_constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    Line.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this, chart = _a.chart, options = _a.options;
        meta({ chart: chart, options: options });
        this.chart.changeData(data);
    };
    /**
     * \u83B7\u53D6 \u6298\u7EBF\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Line.prototype.getDefaultOptions = function () {
        return Line.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u6298\u7EBF\u56FE \u7684\u9002\u914D\u5668
     */
    Line.prototype.getSchemaAdaptor = function () {
        return adaptor;
    };
    return Line;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/contants.js


/**
 * \u997C\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var contants_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    legend: {
        position: 'right',
        radio: {},
    },
    tooltip: {
        shared: false,
        showTitle: false,
        showMarkers: false,
    },
    label: {
        layout: { type: 'limit-in-plot', cfg: { action: 'ellipsis' } },
    },
    /** \u997C\u56FE\u6837\u5F0F, \u4E0D\u5F71\u54CD\u6697\u9ED1\u4E3B\u9898 */
    pieStyle: {
        stroke: 'white',
        lineWidth: 1,
    },
    /** \u997C\u56FE\u4E2D\u5FC3\u6587\u672C\u9ED8\u8BA4\u6837\u5F0F */
    statistic: {
        title: {
            style: { fontWeight: 300, color: '#4B535E', textAlign: 'center', fontSize: '20px', lineHeight: 1 },
        },
        content: {
            style: {
                fontWeight: 'bold',
                color: 'rgba(44,53,66,0.85)',
                textAlign: 'center',
                fontSize: '32px',
                lineHeight: 1,
            },
        },
    },
    /** \u9ED8\u8BA4\u5173\u95ED text-annotation \u52A8\u753B */
    theme: {
        components: {
            annotation: {
                text: {
                    animate: false,
                },
            },
        },
    },
});
//# sourceMappingURL=contants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/matrix.js


var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
/**
 * \u77E9\u9635\u53D8\u6362
 * @param actions
 * @param matrix
 */
function matrix_transform(actions, matrix) {
    var ulMatrix = matrix ? (0,tslib_es6/* __spreadArray */.ev)([], matrix, true) : (0,tslib_es6/* __spreadArray */.ev)([], ORIGIN_MATRIX, true);
    return Util.transform(ulMatrix, actions);
}
//# sourceMappingURL=matrix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/legend-active.js




/**
 * \u997C\u56FE \u56FE\u4F8B\u6FC0\u6D3B action
 */
var PieLegendAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(PieLegendAction, _super);
    function PieLegendAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u83B7\u53D6\u6FC0\u6D3B\u7684\u56FE\u5F62\u5143\u7D20
     */
    PieLegendAction.prototype.getActiveElements = function () {
        var delegateObject = Util.getDelegationObject(this.context);
        if (delegateObject) {
            var view = this.context.view;
            var component = delegateObject.component, item_1 = delegateObject.item;
            var field_1 = component.get('field');
            if (field_1) {
                var elements = view.geometries[0].elements;
                return elements.filter(function (ele) { return ele.getModel().data[field_1] === item_1.value; });
            }
        }
        return [];
    };
    /**
     * \u83B7\u53D6\u6FC0\u6D3B\u7684\u6807\u7B7E
     */
    PieLegendAction.prototype.getActiveElementLabels = function () {
        var view = this.context.view;
        var elements = this.getActiveElements();
        var labels = view.geometries[0].labelsContainer.getChildren();
        return labels.filter(function (label) { return elements.find(function (ele) { return (0,esm/* isEqual */.Xy)(ele.getData(), label.get('data')); }); });
    };
    PieLegendAction.prototype.transfrom = function (offset) {
        if (offset === void 0) { offset = 7.5; }
        var elements = this.getActiveElements();
        var elementLabels = this.getActiveElementLabels();
        elements.forEach(function (element, idx) {
            var labelShape = elementLabels[idx];
            var coordinate = element.geometry.coordinate;
            if (coordinate.isPolar && coordinate.isTransposed) {
                var _a = Util.getAngle(element.getModel(), coordinate), startAngle = _a.startAngle, endAngle = _a.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = offset;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                element.shape.setMatrix(matrix_transform([['t', x, y]]));
                labelShape.setMatrix(matrix_transform([['t', x, y]]));
            }
        });
    };
    PieLegendAction.prototype.active = function () {
        this.transfrom();
    };
    /**
     * \u6FC0\u6D3B\u6001\u8FD8\u539F
     */
    PieLegendAction.prototype.reset = function () {
        this.transfrom(0);
    };
    return PieLegendAction;
}(action_base));

//# sourceMappingURL=legend-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/interactions/util.js
/**
 * \u83B7\u53D6\u5F53\u524D\u4E8B\u4EF6\u76F8\u5173\u7684\u56FE\u8868\u5143\u7D20
 * @param context \u4EA4\u4E92\u7684\u4E0A\u4E0B\u6587
 * @ignore
 */
function util_getCurrentElement(context) {
    var event = context.event;
    var element;
    var target = event.target;
    if (target) {
        element = target.get('element');
    }
    return element;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/interactions/actions/statistic-active.js





/**
 * Pie \u4E2D\u5FC3\u6587\u672C\u4E8B\u4EF6\u7684 Action
 */
var StatisticAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(StatisticAction, _super);
    function StatisticAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StatisticAction.prototype.getAnnotations = function (_view) {
        var view = _view || this.context.view;
        // @ts-ignore
        return view.getController('annotation').option;
    };
    StatisticAction.prototype.getInitialAnnotation = function () {
        return this.initialAnnotation;
    };
    StatisticAction.prototype.init = function () {
        var _this = this;
        var view = this.context.view;
        view.removeInteraction('tooltip');
        view.on('afterchangesize', function () {
            var annotations = _this.getAnnotations(view);
            _this.initialAnnotation = annotations;
        });
    };
    StatisticAction.prototype.change = function (arg) {
        var _a = this.context, view = _a.view, event = _a.event;
        if (!this.initialAnnotation) {
            this.initialAnnotation = this.getAnnotations();
        }
        var data = (0,esm/* get */.U2)(event, ['data', 'data']);
        if (event.type.match('legend-item')) {
            var delegateObject = Util.getDelegationObject(this.context);
            // @ts-ignore
            var colorField_1 = view.getGroupedFields()[0];
            if (delegateObject && colorField_1) {
                var item_1 = delegateObject.item;
                data = view.getData().find(function (d) { return d[colorField_1] === item_1.value; });
            }
        }
        if (data) {
            var annotations = (0,esm/* get */.U2)(arg, 'annotations', []);
            var statistic = (0,esm/* get */.U2)(arg, 'statistic', {});
            // \u5148\u6E05\u7A7A\u6807\u6CE8\uFF0C\u518D\u91CD\u65B0\u6E32\u67D3
            view.getController('annotation').clear(true);
            // \u5148\u8FDB\u884C\u5176\u4ED6 annotations\uFF0C\u518D\u53BB\u6E32\u67D3\u7EDF\u8BA1\u6587\u672C
            (0,esm/* each */.S6)(annotations, function (annotation) {
                if (typeof annotation === 'object') {
                    view.annotation()[annotation.type](annotation);
                }
            });
            renderStatistic(view, { statistic: statistic, plotType: 'pie' }, data);
            view.render(true);
        }
        // \u4EA4\u4E92\u7684\u65F6\u5019\uFF0C\u628A shape \u63D0\u524D
        var ele = util_getCurrentElement(this.context);
        if (ele) {
            ele.shape.toFront();
        }
    };
    StatisticAction.prototype.reset = function () {
        var view = this.context.view;
        var annotationController = view.getController('annotation');
        annotationController.clear(true);
        var initialStatistic = this.getInitialAnnotation();
        (0,esm/* each */.S6)(initialStatistic, function (a) {
            view.annotation()[a.type](a);
        });
        view.render(true);
    };
    return StatisticAction;
}(action_base));

//# sourceMappingURL=statistic-active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/interactions/index.js



var PIE_STATISTIC = 'pie-statistic';
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction('pie-statistic-active', {
    start: [{ trigger: 'element:mouseenter', action: 'pie-statistic:change' }],
    end: [{ trigger: 'element:mouseleave', action: 'pie-statistic:reset' }],
});
registerAction('pie-legend', PieLegendAction);
registerInteraction('pie-legend-active', {
    start: [{ trigger: 'legend-item:mouseenter', action: 'pie-legend:active' }],
    end: [{ trigger: 'legend-item:mouseleave', action: 'pie-legend:reset' }],
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/utils.js


/**
 * \u83B7\u53D6\u603B\u8BA1\u503C
 * @param data
 * @param field
 */
function getTotalValue(data, field) {
    var total = null;
    (0,esm/* each */.S6)(data, function (item) {
        if (typeof item[field] === 'number') {
            total += item[field];
        }
    });
    return total;
}
/**
 * pie label offset adaptor
 */
function adaptOffset(type, offset) {
    var defaultOffset;
    switch (type) {
        case 'inner':
            defaultOffset = '-30%';
            if ((0,esm/* isString */.HD)(offset) && offset.endsWith('%')) {
                return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
            }
            return offset < 0 ? offset : defaultOffset;
        case 'outer':
            defaultOffset = 12;
            if ((0,esm/* isString */.HD)(offset) && offset.endsWith('%')) {
                return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
            }
            return offset > 0 ? offset : defaultOffset;
        default:
            return offset;
    }
}
/**
 * \u5224\u65AD\u6570\u636E\u662F\u5426\u5168\u90E8\u4E3A 0
 * @param data
 * @param angleField
 */
function isAllZero(data, angleField) {
    return (0,esm/* every */.yW)(processIllegalData(data, angleField), function (d) { return d[angleField] === 0; });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/adaptor.js











/**
 * \u5B57\u6BB5
 * @param params
 */
function pie_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, angleField = options.angleField, colorField = options.colorField, color = options.color, pieStyle = options.pieStyle, shape = options.shape;
    // \u5904\u7406\u4E0D\u5408\u6CD5\u7684\u6570\u636E
    var processData = processIllegalData(data, angleField);
    if (isAllZero(processData, angleField)) {
        // \u6570\u636E\u5168 0 \u5904\u7406\uFF0C\u8C03\u6574 position \u6620\u5C04
        var percentageField_1 = '$$percentage$$';
        processData = processData.map(function (d) {
            var _a;
            return ((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, d), (_a = {}, _a[percentageField_1] = 1 / processData.length, _a)));
        });
        chart.data(processData);
        var p = deepAssign({}, params, {
            options: {
                xField: '1',
                yField: percentageField_1,
                seriesField: colorField,
                isStack: true,
                interval: {
                    color: color,
                    shape: shape,
                    style: pieStyle,
                },
                args: {
                    zIndexReversed: true,
                    sortZIndex: true,
                },
            },
        });
        interval_interval(p);
    }
    else {
        chart.data(processData);
        var p = deepAssign({}, params, {
            options: {
                xField: '1',
                yField: angleField,
                seriesField: colorField,
                isStack: true,
                interval: {
                    color: color,
                    shape: shape,
                    style: pieStyle,
                },
                args: {
                    zIndexReversed: true,
                    sortZIndex: true,
                },
            },
        });
        interval_interval(p);
    }
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function pie_adaptor_meta(params) {
    var _a;
    var chart = params.chart, options = params.options;
    var meta = options.meta, colorField = options.colorField;
    // meta \u76F4\u63A5\u662F scale \u7684\u4FE1\u606F
    var scales = deepAssign({}, meta);
    chart.scale(scales, (_a = {},
        _a[colorField] = { type: 'cat' },
        _a));
    return params;
}
/**
 * coord \u914D\u7F6E
 * @param params
 */
function pie_adaptor_coordinate(params) {
    var chart = params.chart, options = params.options;
    var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
    chart.coordinate({
        type: 'theta',
        cfg: {
            radius: radius,
            innerRadius: innerRadius,
            startAngle: startAngle,
            endAngle: endAngle,
        },
    });
    return params;
}
/**
 * label \u914D\u7F6E
 * @param params
 */
function pie_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, colorField = options.colorField, angleField = options.angleField;
    var geometry = chart.geometries[0];
    // label \u4E3A false, \u7A7A \u5219\u4E0D\u663E\u793A label
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        var labelCfg = transformLabel(cfg);
        // \u2460 \u63D0\u4F9B\u6A21\u677F\u5B57\u7B26\u4E32\u7684 label content \u914D\u7F6E
        if (labelCfg.content) {
            var content_1 = labelCfg.content;
            labelCfg.content = function (data, dataum, index) {
                var name = data[colorField];
                var value = data[angleField];
                // dymatic get scale, scale is ready this time
                var angleScale = chart.getScaleByField(angleField);
                var percent = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value);
                return (0,esm/* isFunction */.mf)(content_1)
                    ? // append percent (number) to data, users can get origin data from \`dataum._origin\`
                        content_1((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, data), { percent: percent }), dataum, index)
                    : (0,esm/* isString */.HD)(content_1)
                        ? template(content_1, {
                            value: value,
                            name: name,
                            // percentage (string), default keep 2
                            percentage: (0,esm/* isNumber */.hj)(percent) && !(0,esm/* isNil */.UM)(value) ? "".concat((percent * 100).toFixed(2), "%") : null,
                        })
                        : content_1;
            };
        }
        var LABEL_LAYOUT_TYPE_MAP = {
            inner: '',
            outer: 'pie-outer',
            spider: 'pie-spider',
        };
        var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : 'pie-outer';
        var labelLayoutCfg = labelCfg.layout ? (!(0,esm/* isArray */.kJ)(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout) : [];
        labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
        geometry.label({
            // fix: could not create scale, when field is undefined\uFF08attributes \u4E2D\u7684 fields \u5B9A\u4E49\u90FD\u4F1A\u88AB\u7528\u6765\u521B\u5EFA scale\uFF09
            fields: colorField ? [angleField, colorField] : [angleField],
            callback: callback,
            cfg: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, labelCfg), { offset: adaptOffset(labelCfg.type, labelCfg.offset), type: 'pie' }),
        });
    }
    return params;
}
/**
 * statistic options \u5904\u7406
 * 1. \u9ED8\u8BA4\u7EE7\u627F default options \u7684\u6837\u5F0F
 * 2. \u9ED8\u8BA4\u4F7F\u7528 meta \u7684 formatter
 */
function transformStatisticOptions(options) {
    var innerRadius = options.innerRadius, statistic = options.statistic, angleField = options.angleField, colorField = options.colorField, meta = options.meta, locale = options.locale;
    var i18n = getLocale(locale);
    if (innerRadius && statistic) {
        var _a = deepAssign({}, contants_DEFAULT_OPTIONS.statistic, statistic), titleOpt_1 = _a.title, contentOpt_1 = _a.content;
        if (titleOpt_1 !== false) {
            titleOpt_1 = deepAssign({}, {
                formatter: function (datum) {
                    // \u4EA4\u4E92\u4E2D, datum existed.
                    var text = datum
                        ? datum[colorField]
                        : !(0,esm/* isNil */.UM)(titleOpt_1.content)
                            ? titleOpt_1.content
                            : i18n.get(['statistic', 'total']);
                    var metaFormatter = (0,esm/* get */.U2)(meta, [colorField, 'formatter']) || (function (v) { return v; });
                    return metaFormatter(text);
                },
            }, titleOpt_1);
        }
        if (contentOpt_1 !== false) {
            contentOpt_1 = deepAssign({}, {
                formatter: function (datum, data) {
                    var dataValue = datum ? datum[angleField] : getTotalValue(data, angleField);
                    var metaFormatter = (0,esm/* get */.U2)(meta, [angleField, 'formatter']) || (function (v) { return v; });
                    // \u4EA4\u4E92\u4E2D
                    if (datum) {
                        return metaFormatter(dataValue);
                    }
                    return !(0,esm/* isNil */.UM)(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
                },
            }, contentOpt_1);
        }
        return deepAssign({}, { statistic: { title: titleOpt_1, content: contentOpt_1 } }, options);
    }
    return options;
}
/**
 * statistic \u4E2D\u5FC3\u6587\u672C\u914D\u7F6E
 * @param params
 */
function pieAnnotation(params) {
    var chart = params.chart, options = params.options;
    var _a = transformStatisticOptions(options), innerRadius = _a.innerRadius, statistic = _a.statistic;
    // \u5148\u6E05\u7A7A\u6807\u6CE8\uFF0C\u518D\u91CD\u65B0\u6E32\u67D3
    chart.getController('annotation').clear(true);
    // \u5148\u8FDB\u884C\u5176\u4ED6 annotations\uFF0C\u518D\u53BB\u6E32\u67D3\u7EDF\u8BA1\u6587\u672C
    flow(common_annotation())(params);
    /** \u4E2D\u5FC3\u6587\u672C \u6307\u6807\u5361 */
    if (innerRadius && statistic) {
        renderStatistic(chart, { statistic: statistic, plotType: 'pie' });
    }
    return params;
}
/**
 * \u997C\u56FE tooltip \u914D\u7F6E
 * 1. \u5F3A\u5236 tooltip.shared \u4E3A false
 * @param params
 */
function pie_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip, colorField = options.colorField, angleField = options.angleField, data = options.data;
    if (tooltip === false) {
        chart.tooltip(tooltip);
    }
    else {
        chart.tooltip(deepAssign({}, tooltip, { shared: false }));
        // \u4E3B\u8981\u89E3\u51B3 all zero\uFF0C \u5BF9\u4E8E\u975E all zero \u4E0D\u518D\u9002\u7528
        if (isAllZero(data, angleField)) {
            var fields = (0,esm/* get */.U2)(tooltip, 'fields');
            var formatter = (0,esm/* get */.U2)(tooltip, 'formatter');
            if ((0,esm/* isEmpty */.xb)((0,esm/* get */.U2)(tooltip, 'fields'))) {
                fields = [colorField, angleField];
                formatter = formatter || (function (datum) { return ({ name: datum[colorField], value: (0,esm/* toString */.BB)(datum[angleField]) }); });
            }
            chart.geometries[0].tooltip(fields.join('*'), getMappingFunction(fields, formatter));
        }
    }
    return params;
}
/**
 * Interaction \u914D\u7F6E (\u997C\u56FE\u7279\u6B8A\u7684 interaction, \u4E2D\u5FC3\u6587\u672C\u53D8\u66F4\u7684\u65F6\u5019\uFF0C\u9700\u8981\u5C06\u4E00\u4E9B\u914D\u7F6E\u53C2\u6570\u4F20\u8FDB\u53BB\uFF09
 * @param params
 */
function pie_adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    var _a = transformStatisticOptions(options), interactions = _a.interactions, statistic = _a.statistic, annotations = _a.annotations;
    (0,esm/* each */.S6)(interactions, function (i) {
        var _a, _b;
        if (i.enable === false) {
            chart.removeInteraction(i.type);
        }
        else if (i.type === 'pie-statistic-active') {
            // \u53EA\u9488\u5BF9 start \u9636\u6BB5\u7684\u914D\u7F6E\uFF0C\u8FDB\u884C\u6DFB\u52A0\u53C2\u6570\u4FE1\u606F
            var startStages_1 = [];
            if (!((_a = i.cfg) === null || _a === void 0 ? void 0 : _a.start)) {
                startStages_1 = [
                    {
                        trigger: 'element:mouseenter',
                        action: "".concat(PIE_STATISTIC, ":change"),
                        arg: { statistic: statistic, annotations: annotations },
                    },
                ];
            }
            (0,esm/* each */.S6)((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function (stage) {
                startStages_1.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, stage), { arg: { statistic: statistic, annotations: annotations } }));
            });
            chart.interaction(i.type, deepAssign({}, i.cfg, { start: startStages_1 }));
        }
        else {
            chart.interaction(i.type, i.cfg || {});
        }
    });
    return params;
}
/**
 * \u997C\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function pie_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(pattern('pieStyle'), pie_adaptor_geometry, pie_adaptor_meta, common_theme, pie_adaptor_coordinate, common_legend, pie_adaptor_tooltip, pie_adaptor_label, common_state, 
    /** \u6307\u6807\u5361\u4E2D\u5FC3\u6587\u672C \u653E\u5728\u4E0B\u5C42 */
    pieAnnotation, pie_adaptor_interaction, animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/pie/index.js








var Pie = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Pie, _super);
    function Pie() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'pie';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u997C\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Pie.getDefaultOptions = function () {
        return contants_DEFAULT_OPTIONS;
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @param data
     */
    Pie.prototype.changeData = function (data) {
        this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        var prevOptions = this.options;
        var angleField = this.options.angleField;
        var prevData = processIllegalData(prevOptions.data, angleField);
        var curData = processIllegalData(data, angleField);
        // \u5982\u679C\u4E0A\u4E00\u6B21\u6216\u5F53\u524D\u6570\u636E\u5168\u4E3A 0\uFF0C\u5219\u91CD\u65B0\u6E32\u67D3
        if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) {
            this.update({ data: data });
        }
        else {
            this.updateOption({ data: data });
            this.chart.data(curData);
            // todo \u540E\u7EED\u8BA9 G2 \u5C42\u5728 afterrender \u4E4B\u540E\uFF0C\u6765\u91CD\u7ED8 annotations
            pieAnnotation({ chart: this.chart, options: this.options });
            this.chart.render(true);
        }
        this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    /**
     * \u83B7\u53D6 \u997C\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879, \u4F9B base \u83B7\u53D6
     */
    Pie.prototype.getDefaultOptions = function () {
        return Pie.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u997C\u56FE \u7684\u9002\u914D\u5668
     */
    Pie.prototype.getSchemaAdaptor = function () {
        return pie_adaptor_adaptor;
    };
    return Pie;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/progress/constants.js
var constants_DEFAULT_COLOR = ['#FAAD14', '#E8EDF3'];
/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var progress_constants_DEFAULT_OPTIONS = {
    percent: 0.2,
    color: constants_DEFAULT_COLOR,
    animation: {},
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/progress/utils.js


/**
 * \u83B7\u53D6\u8FDB\u5EA6\u6761\u6570\u636E
 */
function getProgressData(percent) {
    var clampPercent = (0,esm/* clamp */.uZ)(isRealNumber(percent) ? percent : 0, 0, 1);
    return [
        {
            // \u7528\u4E8E progressStyle \u7684\u56DE\u8C03\u65B9\u6CD5
            current: "".concat(clampPercent),
            type: 'current',
            percent: clampPercent,
        },
        {
            current: "".concat(clampPercent),
            type: 'target',
            percent: 1,
        },
    ];
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/progress/adaptor.js






/**
 * \u5B57\u6BB5
 * @param params
 */
function progress_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var percent = options.percent, progressStyle = options.progressStyle, color = options.color, barWidthRatio = options.barWidthRatio;
    chart.data(getProgressData(percent));
    var p = deepAssign({}, params, {
        options: {
            xField: 'current',
            yField: 'percent',
            seriesField: 'type',
            widthRatio: barWidthRatio,
            interval: {
                style: progressStyle,
                color: (0,esm/* isString */.HD)(color) ? [color, constants_DEFAULT_COLOR[1]] : color,
            },
            args: {
                zIndexReversed: true,
                sortZIndex: true,
            },
        },
    });
    interval_interval(p);
    // \u5173\u95ED\u7EC4\u4EF6
    chart.tooltip(false);
    chart.axis(false);
    chart.legend(false);
    return params;
}
/**
 * other \u914D\u7F6E
 * @param params
 */
function progress_adaptor_coordinate(params) {
    var chart = params.chart;
    chart.coordinate('rect').transpose();
    return params;
}
/**
 * \u8FDB\u5EA6\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function progress_adaptor_adaptor(params) {
    // @ts-ignore
    return flow(progress_adaptor_geometry, common_scale({}), progress_adaptor_coordinate, animation, common_theme, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/progress/index.js





var Progress = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Progress, _super);
    function Progress() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'process';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u4EEA\u8868\u76D8 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Progress.getDefaultOptions = function () {
        return progress_constants_DEFAULT_OPTIONS;
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @param percent
     */
    Progress.prototype.changeData = function (percent) {
        this.updateOption({ percent: percent });
        this.chart.changeData(getProgressData(percent));
    };
    Progress.prototype.getDefaultOptions = function () {
        return Progress.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u8FDB\u5EA6\u56FE \u7684\u9002\u914D\u5668
     */
    Progress.prototype.getSchemaAdaptor = function () {
        return progress_adaptor_adaptor;
    };
    return Progress;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/ring-progress/adaptor.js





/**
 * coordinate \u914D\u7F6E
 * @param params
 */
function ring_progress_adaptor_coordinate(params) {
    var chart = params.chart, options = params.options;
    var innerRadius = options.innerRadius, radius = options.radius;
    // coordinate
    chart.coordinate('theta', {
        innerRadius: innerRadius,
        radius: radius,
    });
    return params;
}
/**
 * statistic \u914D\u7F6E
 * @param params
 */
function adaptor_statistic(params, updated) {
    var chart = params.chart, options = params.options;
    var innerRadius = options.innerRadius, statistic = options.statistic, percent = options.percent, meta = options.meta;
    // \u5148\u6E05\u7A7A\u6807\u6CE8\uFF0C\u518D\u91CD\u65B0\u6E32\u67D3
    chart.getController('annotation').clear(true);
    /** \u4E2D\u5FC3\u6587\u672C \u6307\u6807\u5361 */
    if (innerRadius && statistic) {
        var metaFormatter = (0,esm/* get */.U2)(meta, ['percent', 'formatter']) || (function (v) { return "".concat((v * 100).toFixed(2), "%"); });
        var contentOpt = statistic.content;
        if (contentOpt) {
            contentOpt = deepAssign({}, contentOpt, {
                content: !(0,esm/* isNil */.UM)(contentOpt.content) ? contentOpt.content : metaFormatter(percent),
            });
        }
        renderStatistic(chart, { statistic: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, statistic), { content: contentOpt }), plotType: 'ring-progress' }, { percent: percent });
    }
    if (updated) {
        chart.render(true);
    }
    return params;
}
/**
 * \u73AF\u5F62\u8FDB\u5EA6\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function ring_progress_adaptor_adaptor(params) {
    return flow(progress_adaptor_geometry, common_scale({}), ring_progress_adaptor_coordinate, adaptor_statistic, animation, common_theme, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/ring-progress/constants.js
/**
 * \u4EEA\u8868\u76D8\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var ring_progress_constants_DEFAULT_OPTIONS = {
    percent: 0.2,
    innerRadius: 0.8,
    radius: 0.98,
    color: ['#FAAD14', '#E8EDF3'],
    statistic: {
        title: false,
        content: {
            style: {
                fontSize: '14px',
                fontWeight: 300,
                fill: '#4D4D4D',
                textAlign: 'center',
                textBaseline: 'middle',
            },
        },
    },
    animation: {},
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/ring-progress/index.js






var RingProgress = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RingProgress, _super);
    function RingProgress() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'ring-process';
        return _this;
    }
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    RingProgress.getDefaultOptions = function () {
        return ring_progress_constants_DEFAULT_OPTIONS;
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @param percent
     */
    RingProgress.prototype.changeData = function (percent) {
        this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        this.updateOption({ percent: percent });
        this.chart.data(getProgressData(percent));
        // todo \u540E\u7EED\u8BA9 G2 \u5C42\u5728 afterrender \u4E4B\u540E\uFF0C\u6765\u91CD\u7ED8 annotations
        adaptor_statistic({ chart: this.chart, options: this.options }, true);
        this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    RingProgress.prototype.getDefaultOptions = function () {
        return RingProgress.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u73AF\u5F62\u8FDB\u5EA6\u56FE \u7684\u9002\u914D\u5668
     */
    RingProgress.prototype.getSchemaAdaptor = function () {
        return ring_progress_adaptor_adaptor;
    };
    return RingProgress;
}(Plot));

//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/d3-regression/dist/d3-regression.js
var d3_regression = __webpack_require__(56645);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/scatter/util.js




var REGRESSION_MAP = {
    exp: d3_regression.regressionExp,
    linear: d3_regression.regressionLinear,
    loess: d3_regression.regressionLoess,
    log: d3_regression.regressionLog,
    poly: d3_regression.regressionPoly,
    pow: d3_regression.regressionPow,
    quad: d3_regression.regressionQuad,
};
/**
 * \u83B7\u53D6\u56DB\u8C61\u9650\u9ED8\u8BA4\u914D\u7F6E
 * @param {number} xBaseline
 * @param {number} yBaseline
 */
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
    // \u6587\u672C\u4FBF\u5B9C\u8DDD\u79BB
    var textOffset = 10;
    // \u56DB\u8C61\u9650\u9ED8\u8BA4\u6837\u5F0F
    var defaultConfig = {
        regionStyle: [
            {
                position: {
                    start: [xBaseline, 'max'],
                    end: ['max', yBaseline],
                },
                style: {
                    fill: '#d8d0c0',
                    opacity: 0.4,
                },
            },
            {
                position: {
                    start: ['min', 'max'],
                    end: [xBaseline, yBaseline],
                },
                style: {
                    fill: '#a3dda1',
                    opacity: 0.4,
                },
            },
            {
                position: {
                    start: ['min', yBaseline],
                    end: [xBaseline, 'min'],
                },
                style: {
                    fill: '#d8d0c0',
                    opacity: 0.4,
                },
            },
            {
                position: {
                    start: [xBaseline, yBaseline],
                    end: ['max', 'min'],
                },
                style: {
                    fill: '#a3dda1',
                    opacity: 0.4,
                },
            },
        ],
        lineStyle: {
            stroke: '#9ba29a',
            lineWidth: 1,
        },
        labelStyle: [
            {
                position: ['max', yBaseline],
                offsetX: -textOffset,
                offsetY: -textOffset,
                style: {
                    textAlign: 'right',
                    textBaseline: 'bottom',
                    fontSize: 14,
                    fill: '#ccc',
                },
            },
            {
                position: ['min', yBaseline],
                offsetX: textOffset,
                offsetY: -textOffset,
                style: {
                    textAlign: 'left',
                    textBaseline: 'bottom',
                    fontSize: 14,
                    fill: '#ccc',
                },
            },
            {
                position: ['min', yBaseline],
                offsetX: textOffset,
                offsetY: textOffset,
                style: {
                    textAlign: 'left',
                    textBaseline: 'top',
                    fontSize: 14,
                    fill: '#ccc',
                },
            },
            {
                position: ['max', yBaseline],
                offsetX: -textOffset,
                offsetY: textOffset,
                style: {
                    textAlign: 'right',
                    textBaseline: 'top',
                    fontSize: 14,
                    fill: '#ccc',
                },
            },
        ],
    };
    return defaultConfig;
}
var splinePath = function (data, config) {
    var view = config.view, _a = config.options, xField = _a.xField, yField = _a.yField;
    var xScaleView = view.getScaleByField(xField);
    var yScaleView = view.getScaleByField(yField);
    var pathData = data.map(function (d) {
        return view.getCoordinate().convert({ x: xScaleView.scale(d[0]), y: yScaleView.scale(d[1]) });
    });
    return path_getSplinePath(pathData, false);
};
var scatter_util_getPath = function (config) {
    var options = config.options;
    var xField = options.xField, yField = options.yField, data = options.data, regressionLine = options.regressionLine;
    var _a = regressionLine.type, type = _a === void 0 ? 'linear' : _a, algorithm = regressionLine.algorithm, customEquation = regressionLine.equation;
    var pathData;
    var equation = null;
    if (algorithm) {
        pathData = (0,esm/* isArray */.kJ)(algorithm) ? algorithm : algorithm(data);
        equation = customEquation;
    }
    else {
        var reg = REGRESSION_MAP[type]()
            .x(function (d) { return d[xField]; })
            .y(function (d) { return d[yField]; });
        pathData = reg(data);
        equation = getRegressionEquation(type, pathData);
    }
    return [splinePath(pathData, config), equation];
};
/**
 * \u8C03\u6574\u6563\u70B9\u56FE meta: { min, max } \u2460 data.length === 1 \u2461 \u6240\u6709\u6570\u636E y \u503C\u76F8\u7B49 \u2462 \u6240\u6709\u6570\u636E x \u503C\u76F8\u7B49
 * @param options
 * @returns
 */
var getMeta = function (options) {
    var _a;
    var _b = options.meta, meta = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data = options.data;
    var xFieldValue = data[0][xField];
    var yFieldValue = data[0][yField];
    var xIsPositiveNumber = xFieldValue > 0;
    var yIsPositiveNumber = yFieldValue > 0;
    /**
     * \u83B7\u5F97\u5BF9\u5E94\u5B57\u6BB5\u7684 min max scale \u914D\u7F6E
     */
    function getMetaMinMax(field, axis) {
        var fieldMeta = (0,esm/* get */.U2)(meta, [field]);
        function getCustomValue(type) {
            return (0,esm/* get */.U2)(fieldMeta, type);
        }
        var range = {};
        if (axis === 'x') {
            if ((0,esm/* isNumber */.hj)(xFieldValue)) {
                if (!(0,esm/* isNumber */.hj)(getCustomValue('min'))) {
                    range['min'] = xIsPositiveNumber ? 0 : xFieldValue * 2;
                }
                if (!(0,esm/* isNumber */.hj)(getCustomValue('max'))) {
                    range['max'] = xIsPositiveNumber ? xFieldValue * 2 : 0;
                }
            }
            return range;
        }
        if ((0,esm/* isNumber */.hj)(yFieldValue)) {
            if (!(0,esm/* isNumber */.hj)(getCustomValue('min'))) {
                range['min'] = yIsPositiveNumber ? 0 : yFieldValue * 2;
            }
            if (!(0,esm/* isNumber */.hj)(getCustomValue('max'))) {
                range['max'] = yIsPositiveNumber ? yFieldValue * 2 : 0;
            }
        }
        return range;
    }
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, meta), (_a = {}, _a[xField] = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, meta[xField]), getMetaMinMax(xField, 'x')), _a[yField] = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, meta[yField]), getMetaMinMax(yField, 'y')), _a));
};
/**
 * \u83B7\u53D6\u56DE\u5F52\u51FD\u6570\u8868\u8FBE\u5F0F
 * @param {string} type - \u56DE\u5F52\u51FD\u6570\u7C7B\u578B
 * @param {D3RegressionResult} res - \u56DE\u5F52\u8BA1\u7B97\u7ED3\u679C\u96C6
 * @return {string}
 */
function getRegressionEquation(type, res) {
    var _a, _b, _c;
    var roundByPrecision = function (n, p) {
        if (p === void 0) { p = 4; }
        return Math.round(n * Math.pow(10, p)) / Math.pow(10, p);
    };
    var safeFormat = function (value) { return (Number.isFinite(value) ? roundByPrecision(value) : '?'); };
    switch (type) {
        case 'linear':
            // y = ax + b
            return "y = ".concat(safeFormat(res.a), "x + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
        case 'exp':
            // y = ae^(bx)
            return "y = ".concat(safeFormat(res.a), "e^(").concat(safeFormat(res.b), "x), R^2 = ").concat(safeFormat(res.rSquared));
        case 'log':
            // y = a \xB7 ln(x) + b
            return "y = ".concat(safeFormat(res.a), "ln(x) + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
        case 'quad':
            // y = ax^2 + bx + c
            return "y = ".concat(safeFormat(res.a), "x^2 + ").concat(safeFormat(res.b), "x + ").concat(safeFormat(res.c), ", R^2 = ").concat(safeFormat(res.rSquared));
        case 'poly':
            // y = anx^n + ... + a1x + a0
            // eslint-disable-next-line no-case-declarations
            var temp = "y = ".concat(safeFormat((_a = res.coefficients) === null || _a === void 0 ? void 0 : _a[0]), " + ").concat(safeFormat((_b = res.coefficients) === null || _b === void 0 ? void 0 : _b[1]), "x + ").concat(safeFormat((_c = res.coefficients) === null || _c === void 0 ? void 0 : _c[2]), "x^2");
            for (var i = 3; i < res.coefficients.length; ++i) {
                temp += " + ".concat(safeFormat(res.coefficients[i]), "x^").concat(i);
            }
            return "".concat(temp, ", R^2 = ").concat(safeFormat(res.rSquared));
        case 'pow':
            // y = ax^b
            return "y = ".concat(safeFormat(res.a), "x^").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
    }
    return null;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/scatter/adaptor.js







/**
 * \u6563\u70B9\u56FE\u9ED8\u8BA4\u7F8E\u89C2
 * \u2460 data.length === 1 \u2461 \u6240\u6709\u6570\u636E y \u503C\u76F8\u7B49 \u2462 \u6240\u6709\u6570\u636E x \u503C\u76F8\u7B49
 * @param params
 * @returns params
 */
function transformOptions(options) {
    var _a = options.data, data = _a === void 0 ? [] : _a, xField = options.xField, yField = options.yField;
    if (data.length) {
        // x y \u5B57\u6BB5\u77E5\u5426\u53EA\u6709\u4E00\u4E2A\u503C\uFF0C\u5982\u679C\u53EA\u6709\u4E00\u4E2A\u503C\uFF0C\u5219\u8FDB\u884C\u4F18\u5316
        var isOneX = true;
        var isOneY = true;
        var prev = data[0];
        var curr = void 0;
        for (var i = 1; i < data.length; i++) {
            curr = data[i];
            if (prev[xField] !== curr[xField]) {
                isOneX = false;
            }
            if (prev[yField] !== curr[yField]) {
                isOneY = false;
            }
            // \u5982\u679C\u90FD\u4E0D\u662F oneValue\uFF0C\u90A3\u4E48\u53EF\u63D0\u524D\u8DF3\u51FA\u5FAA\u73AF
            if (!isOneX && !isOneY) {
                break;
            }
            prev = curr;
        }
        var keys = [];
        isOneX && keys.push(xField);
        isOneY && keys.push(yField);
        var meta_1 = pick(getMeta(options), keys);
        return deepAssign({}, options, { meta: meta_1 });
    }
    return options;
}
/**
 * \u5B57\u6BB5
 * @param params
 */
function scatter_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, type = options.type, color = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
    var size = options.size;
    var tooltip = options.tooltip;
    if (sizeField) {
        if (!size) {
            size = [2, 8];
        }
        if ((0,esm/* isNumber */.hj)(size)) {
            size = [size, size];
        }
    }
    if (tooltip && !tooltip.fields) {
        tooltip = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, tooltip), { fields: [xField, yField, colorField, sizeField, shapeField] });
    }
    // \u6570\u636E
    chart.data(data);
    // geometry
    point_point(deepAssign({}, params, {
        options: {
            seriesField: colorField,
            point: {
                color: color,
                shape: shape,
                size: size,
                style: pointStyle,
            },
            tooltip: tooltip,
        },
    }));
    var geometry = findGeometry(chart, 'point');
    // \u6570\u636E\u8C03\u6574
    if (type) {
        geometry.adjust(type);
    }
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function scatter_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    var newOptions = transformOptions(options);
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a)))(deepAssign({}, params, { options: newOptions }));
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function scatter_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    chart.axis(xField, xAxis);
    chart.axis(yField, yAxis);
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function scatter_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
    /** legend \u4E0D\u4E3A false, \u5219\u5C55\u793A\u56FE\u4F8B, \u4F18\u5148\u5C55\u793A color \u5206\u7C7B\u56FE\u4F8B */
    var showLegend = legend !== false;
    if (colorField) {
        chart.legend(colorField, showLegend ? legend : false);
    }
    // \u4F18\u5148\u53D6 shapeLegend, \u5426\u5219\u53D6 legend
    if (shapeField) {
        if (shapeLegend) {
            chart.legend(shapeField, shapeLegend);
        }
        else {
            chart.legend(shapeField, shapeLegend === false ? false : legend);
        }
    }
    if (sizeField) {
        chart.legend(sizeField, sizeLegend ? sizeLegend : false);
    }
    /** \u9ED8\u8BA4\u4E0D\u5C55\u793A shape \u56FE\u4F8B\uFF0C\u5F53 shapeLegend \u4E3A undefined \u4E5F\u4E0D\u5C55\u793A\u56FE\u4F8B */
    /** \u9ED8\u8BA4\u6CA1\u6709 sizeField\uFF0C\u5219\u9690\u85CF\u8FDE\u7EED\u56FE\u4F8B */
    if (!showLegend && !shapeLegend && !sizeLegend) {
        chart.legend(false);
    }
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function scatter_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField;
    var scatterGeometry = findGeometry(chart, 'point');
    // label \u4E3A false, \u7A7A \u5219\u4E0D\u663E\u793A label
    if (!label) {
        scatterGeometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        scatterGeometry.label({
            fields: [yField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * annotation \u914D\u7F6E
 * - \u7279\u6B8A annotation: quadrant(\u56DB\u8C61\u9650)
 * @param params
 */
function scatterAnnotation(params) {
    var options = params.options;
    var quadrant = options.quadrant;
    var annotationOptions = [];
    if (quadrant) {
        var _a = quadrant.xBaseline, xBaseline = _a === void 0 ? 0 : _a, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
        var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
        // \u4EC5\u652F\u6301\u56DB\u8C61\u9650
        var quadrants = new Array(4).join(',').split(',');
        quadrants.forEach(function (_, index) {
            annotationOptions.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ type: 'region', top: false }, defaultConfig_1.regionStyle[index].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index]) }), (0,tslib_es6/* __assign */.pi)({ type: 'text', top: true }, deepAssign({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
        });
        // \u751F\u6210\u5750\u6807\u8F74
        annotationOptions.push({
            type: 'line',
            top: false,
            start: ['min', yBaseline],
            end: ['max', yBaseline],
            style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle),
        }, {
            type: 'line',
            top: false,
            start: [xBaseline, 'min'],
            end: [xBaseline, 'max'],
            style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle),
        });
    }
    return flow(common_annotation(annotationOptions))(params);
}
// \u8D8B\u52BF\u7EBF
function regressionLine(params) {
    var options = params.options, chart = params.chart;
    var regressionLine = options.regressionLine;
    if (regressionLine) {
        var style_1 = regressionLine.style, _a = regressionLine.equationStyle, equationStyle_1 = _a === void 0 ? {} : _a, _b = regressionLine.top, top_1 = _b === void 0 ? false : _b, _c = regressionLine.showEquation, showEquation_1 = _c === void 0 ? false : _c;
        var defaultStyle_1 = {
            stroke: '#9ba29a',
            lineWidth: 2,
            opacity: 0.5,
        };
        var defaulEquationStyle_1 = {
            x: 20,
            y: 20,
            textAlign: 'left',
            textBaseline: 'middle',
            fontSize: 14,
            fillOpacity: 0.5,
        };
        chart.annotation().shape({
            top: top_1,
            render: function (container, view) {
                var group = container.addGroup({
                    id: "".concat(chart.id, "-regression-line"),
                    name: 'regression-line-group',
                });
                var _a = scatter_util_getPath({
                    view: view,
                    options: options,
                }), path = _a[0], equation = _a[1];
                group.addShape('path', {
                    name: 'regression-line',
                    attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ path: path }, defaultStyle_1), style_1),
                });
                if (showEquation_1) {
                    group.addShape('text', {
                        name: 'regression-equation',
                        attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, defaulEquationStyle_1), equationStyle_1), { text: equation }),
                    });
                }
            },
        });
    }
    return params;
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function scatter_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip) {
        chart.tooltip(tooltip);
    }
    else if (tooltip === false) {
        chart.tooltip(false);
    }
    return params;
}
/**
 * \u6563\u70B9\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function scatter_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(scatter_adaptor_geometry, scatter_adaptor_meta, scatter_adaptor_axis, scatter_adaptor_legend, scatter_adaptor_tooltip, scatter_adaptor_label, 
    // \u9700\u8981\u5728 interaction \u524D\u9762
    brushInteraction, common_slider, common_scrollbar, common_interaction, scatterAnnotation, animation, common_theme, regressionLine)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/scatter/constant.js


/**
 * \u6563\u70B9\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var scatter_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    size: 4,
    tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: true,
        crosshairs: {
            type: 'xy',
        },
    },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/interactions/drag-move.js

registerInteraction('drag-move', {
    start: [{ trigger: 'plot:mousedown', action: 'scale-translate:start' }],
    processing: [
        {
            trigger: 'plot:mousemove',
            action: 'scale-translate:translate',
            throttle: { wait: 100, leading: true, trailing: false },
        },
    ],
    end: [{ trigger: 'plot:mouseup', action: 'scale-translate:end' }],
});
//# sourceMappingURL=drag-move.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/scatter/interactions/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/scatter/index.js







var Scatter = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Scatter, _super);
    function Scatter(container, options) {
        var _this = _super.call(this, container, options) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'scatter';
        // \u76D1\u542C brush \u4E8B\u4EF6\uFF0C\u5904\u7406 meta
        _this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function (evt) {
            var _a, _b;
            // \u8FD0\u884C\u65F6\uFF0C\u8BFB\u53D6 option
            var _c = _this, options = _c.options, chart = _c.chart;
            if (((_a = evt.data) === null || _a === void 0 ? void 0 : _a.source) === range_filter_EVENTS.FILTER) {
                var filteredData = _this.chart.filterData(_this.chart.getData());
                scatter_adaptor_meta({ chart: chart, options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { data: filteredData }) });
            }
            if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === range_filter_EVENTS.RESET) {
                scatter_adaptor_meta({ chart: chart, options: options });
            }
        });
        return _this;
    }
    /**
     * \u83B7\u53D6 \u6563\u70B9\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Scatter.getDefaultOptions = function () {
        return scatter_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    Scatter.prototype.changeData = function (data) {
        this.updateOption(transformOptions(deepAssign({}, this.options, { data: data })));
        var _a = this, options = _a.options, chart = _a.chart;
        scatter_adaptor_meta({ chart: chart, options: options });
        this.chart.changeData(data);
    };
    /**
     * \u83B7\u53D6 \u6563\u70B9\u56FE \u7684\u9002\u914D\u5668
     */
    Scatter.prototype.getSchemaAdaptor = function () {
        return scatter_adaptor_adaptor;
    };
    Scatter.prototype.getDefaultOptions = function () {
        return Scatter.getDefaultOptions();
    };
    return Scatter;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/stock/constant.js


var Y_FIELD = '$$stock-range$$';
var TREND_FIELD = 'trend';
var TREND_UP = 'up';
var TREND_DOWN = 'down';
/** tooltip \u914D\u7F6E */
var DEFAULT_TOOLTIP_OPTIONS = {
    showMarkers: false,
    showCrosshairs: true,
    shared: true,
    crosshairs: {
        type: 'xy',
        follow: true,
        text: function (type, defaultContent, items) {
            var textContent;
            if (type === 'x') {
                var item = items[0];
                textContent = item ? item.title : defaultContent;
            }
            else {
                textContent = defaultContent;
            }
            return {
                position: type === 'y' ? 'start' : 'end',
                content: textContent,
                style: {
                    fill: '#dfdfdf',
                },
            };
        },
        // \u81EA\u5B9A\u4E49 crosshairs textBackground \u6837\u5F0F
        textBackground: {
            padding: [2, 4],
            style: {
                fill: '#666',
            },
        },
    },
};
/**
 * \u6563\u70B9\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var stock_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    // \u8BBE\u7F6E\u9ED8\u8BA4\u56FE\u8868 tooltips
    tooltip: DEFAULT_TOOLTIP_OPTIONS,
    interactions: [{ type: 'tooltip' }],
    legend: {
        position: 'top-left',
    },
    risingFill: '#ef5350',
    fallingFill: '#26a69a',
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/stock/utils.js



/**
 * @desc \u80A1\u7968\u56FE\u6570\u636E\u5904\u7406
 * @param data
 * @param yField
 */
function getStockData(data, yField) {
    return (0,esm/* map */.UI)(data, function (item) {
        var obj = item && (0,tslib_es6/* __assign */.pi)({}, item);
        if ((0,esm/* isArray */.kJ)(yField) && obj) {
            var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
            obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
            obj[Y_FIELD] = [obj[open_1], obj[close_1], obj[high], obj[low]];
        }
        return obj;
    });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/stock/adaptor.js






/**
 * \u56FE\u8868\u914D\u7F6E\u5904\u7406
 * @param params
 */
function stock_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var yField = options.yField;
    var data = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip = options.tooltip, stockStyle = options.stockStyle;
    chart.data(getStockData(data, yField));
    var tooltipOptions = tooltip;
    if (tooltipOptions !== false) {
        tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
    }
    schema_schema(deepAssign({}, params, {
        options: {
            schema: {
                shape: 'candle',
                color: [risingFill, fallingFill],
                style: stockStyle,
            },
            yField: Y_FIELD,
            seriesField: TREND_FIELD,
            rawFields: yField,
            tooltip: tooltipOptions,
        },
    }));
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function stock_adaptor_meta(params) {
    var _a, _b;
    var chart = params.chart, options = params.options;
    var meta = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
    var baseMeta = (_a = {},
        _a[xField] = {
            type: 'timeCat',
            tickCount: 6,
        },
        _a[TREND_FIELD] = {
            values: [TREND_UP, TREND_DOWN],
        },
        _a);
    var scales = deepAssign(baseMeta, meta, (_b = {},
        _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS),
        _b[Y_FIELD] = pick(yAxis, AXIS_META_CONFIG_KEYS),
        _b));
    chart.scale(scales);
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function stock_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(Y_FIELD, false);
    }
    else {
        chart.axis(Y_FIELD, yAxis);
    }
    return params;
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function stock_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip !== false) {
        chart.tooltip(tooltip);
    }
    else {
        chart.tooltip(false);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function stock_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend;
    if (legend) {
        chart.legend(TREND_FIELD, legend);
    }
    else if (legend === false) {
        chart.legend(false);
    }
    return params;
}
/**
 * K\u7EBF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function stock_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    flow(common_theme, stock_adaptor_geometry, stock_adaptor_meta, stock_adaptor_axis, stock_adaptor_tooltip, stock_adaptor_legend, common_interaction, animation, common_annotation(), common_slider)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/stock/index.js





var Stock = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Stock, _super);
    function Stock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'stock';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u6563\u70B9\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Stock.getDefaultOptions = function () {
        return stock_constant_DEFAULT_OPTIONS;
    };
    /**
     * \u9ED8\u8BA4\u914D\u7F6E
     *  g2/g2plot\u9ED8 \u8BA4 \u914D \u7F6E -->  \u56FE \u8868 \u9ED8 \u8BA4 \u914D \u7F6E  --> \u5F00 \u53D1 \u8005 \u81EA \u5B9A \u4E49 \u914D \u7F6E  --> \u6700 \u7EC8 \u7ED8 \u56FE \u914D \u7F6E
     */
    Stock.prototype.getDefaultOptions = function () {
        return Stock.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u8721\u70DB\u56FE \u7684\u9002\u914D\u5668
     */
    Stock.prototype.getSchemaAdaptor = function () {
        return stock_adaptor_adaptor;
    };
    /**
     * @override
     * @param data
     */
    Stock.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var yField = this.options.yField;
        this.chart.changeData(getStockData(data, yField));
    };
    return Stock;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-line/utils.js

function getTinyData(data) {
    return (0,esm/* map */.UI)(data || [], function (y, x) { return ({ x: "".concat(x), y: y }); });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-line/constants.js


var X_FIELD = 'x';
var constants_Y_FIELD = 'y';
var constants_DEFAULT_TOOLTIP_OPTIONS = {
    showTitle: false,
    shared: true,
    showMarkers: false,
    customContent: function (x, data) { return "".concat((0,esm/* get */.U2)(data, [0, 'data', 'y'], 0)); },
    containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
    itemTpl: '<span>{value}</span>',
    domStyles: {
        'g2-tooltip': {
            padding: '2px 4px',
            fontSize: '10px',
        },
    },
    showCrosshairs: true,
    crosshairs: {
        type: 'x',
    },
};
/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var tiny_line_constants_DEFAULT_OPTIONS = {
    appendPadding: 2,
    tooltip: (0,tslib_es6/* __assign */.pi)({}, constants_DEFAULT_TOOLTIP_OPTIONS),
    animation: {},
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-area/adaptor.js






/**
 * \u5B57\u6BB5
 * @param params
 */
function tiny_area_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, color = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
    var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
    var seriesData = getTinyData(data);
    chart.data(seriesData);
    var primary = deepAssign({}, params, {
        options: {
            xField: X_FIELD,
            yField: constants_Y_FIELD,
            area: { color: color, style: areaStyle },
            line: lineOptions,
            point: pointOptions,
        },
    });
    var second = deepAssign({}, primary, { options: { tooltip: false } });
    var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
    // area geometry \u5904\u7406
    area_area(primary);
    line_line(second);
    point_point(pointParams);
    chart.axis(false);
    chart.legend(false);
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function tiny_area_adaptor_meta(params) {
    var _a, _b;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, data = options.data;
    var seriesData = getTinyData(data);
    return flow(common_scale((_a = {},
        _a[X_FIELD] = xAxis,
        _a[constants_Y_FIELD] = yAxis,
        _a), (_b = {},
        _b[X_FIELD] = {
            type: 'cat',
        },
        _b[constants_Y_FIELD] = adjustYMetaByZero(seriesData, constants_Y_FIELD),
        _b)))(params);
}
/**
 * \u8FF7\u4F60\u9762\u79EF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function tiny_area_adaptor_adaptor(params) {
    return flow(pattern('areaStyle'), tiny_area_adaptor_geometry, tiny_area_adaptor_meta, common_tooltip, common_theme, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-area/constants.js


/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var tiny_area_constants_DEFAULT_OPTIONS = {
    appendPadding: 2,
    tooltip: (0,tslib_es6/* __assign */.pi)({}, constants_DEFAULT_TOOLTIP_OPTIONS),
    // \u9ED8\u8BA4\u6837\u5F0F
    color: 'l(90) 0:#E5EDFE 1:#ffffff',
    areaStyle: {
        fillOpacity: 0.6,
    },
    line: {
        size: 1,
        color: '#5B8FF9',
    },
    animation: {},
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-area/index.js





var TinyArea = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TinyArea, _super);
    function TinyArea() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'tiny-area';
        return _this;
    }
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    TinyArea.getDefaultOptions = function () {
        return tiny_area_constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    TinyArea.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this, chart = _a.chart, options = _a.options;
        tiny_area_adaptor_meta({ chart: chart, options: options });
        chart.changeData(getTinyData(data));
    };
    TinyArea.prototype.getDefaultOptions = function () {
        return TinyArea.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u8FF7\u4F60\u9762\u79EF\u56FE \u7684\u9002\u914D\u5668
     */
    TinyArea.prototype.getSchemaAdaptor = function () {
        return tiny_area_adaptor_adaptor;
    };
    return TinyArea;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-column/adaptor.js







/**
 * \u5B57\u6BB5
 * @param params
 */
function tiny_column_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, color = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
    var seriesData = getTinyData(data);
    chart.data(seriesData);
    var p = deepAssign({}, params, {
        options: {
            xField: X_FIELD,
            yField: constants_Y_FIELD,
            widthRatio: columnWidthRatio,
            interval: {
                style: columnStyle,
                color: color,
            },
        },
    });
    interval_interval(p);
    chart.axis(false);
    chart.legend(false);
    chart.interaction('element-active');
    return params;
}
/**
 * \u8FF7\u4F60\u67F1\u5F62\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function tiny_column_adaptor_adaptor(params) {
    return flow(common_theme, pattern('columnStyle'), tiny_column_adaptor_geometry, tiny_area_adaptor_meta, common_tooltip, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-column/constants.js


var tiny_column_constants_DEFAULT_TOOLTIP_OPTIONS = {
    showTitle: false,
    shared: true,
    showMarkers: false,
    customContent: function (x, data) { return "".concat((0,esm/* get */.U2)(data, [0, 'data', 'y'], 0)); },
    containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
    itemTpl: '<span>{value}</span>',
    domStyles: {
        'g2-tooltip': {
            padding: '2px 4px',
            fontSize: '10px',
        },
    },
};
/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var tiny_column_constants_DEFAULT_OPTIONS = {
    appendPadding: 2,
    tooltip: (0,tslib_es6/* __assign */.pi)({}, tiny_column_constants_DEFAULT_TOOLTIP_OPTIONS),
    animation: {},
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-column/index.js





var TinyColumn = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TinyColumn, _super);
    function TinyColumn() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'tiny-column';
        return _this;
    }
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    TinyColumn.getDefaultOptions = function () {
        return tiny_column_constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    TinyColumn.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this, chart = _a.chart, options = _a.options;
        tiny_area_adaptor_meta({ chart: chart, options: options });
        chart.changeData(getTinyData(data));
    };
    TinyColumn.prototype.getDefaultOptions = function () {
        return TinyColumn.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u8FF7\u4F60\u67F1\u5F62\u56FE \u7684\u9002\u914D\u5668
     */
    TinyColumn.prototype.getSchemaAdaptor = function () {
        return tiny_column_adaptor_adaptor;
    };
    return TinyColumn;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-line/adaptor.js







/**
 * \u5B57\u6BB5
 * @param params
 */
function tiny_line_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, color = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
    var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
    var seriesData = getTinyData(data);
    chart.data(seriesData);
    // line geometry \u5904\u7406
    var primary = deepAssign({}, params, {
        options: {
            xField: X_FIELD,
            yField: constants_Y_FIELD,
            line: {
                color: color,
                style: lineStyle,
            },
            point: pointMapping,
        },
    });
    var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
    line_line(primary);
    point_point(pointParams);
    chart.axis(false);
    chart.legend(false);
    return params;
}
/**
 * \u8FF7\u4F60\u6298\u7EBF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function tiny_line_adaptor_adaptor(params) {
    return flow(tiny_line_adaptor_geometry, tiny_area_adaptor_meta, common_theme, common_tooltip, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/tiny-line/index.js





var TinyLine = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(TinyLine, _super);
    function TinyLine() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'tiny-line';
        return _this;
    }
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    TinyLine.getDefaultOptions = function () {
        return tiny_line_constants_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    TinyLine.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = this, chart = _a.chart, options = _a.options;
        tiny_area_adaptor_meta({ chart: chart, options: options });
        chart.changeData(getTinyData(data));
    };
    TinyLine.prototype.getDefaultOptions = function () {
        return TinyLine.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u8FF7\u4F60\u6298\u7EBF\u56FE \u7684\u9002\u914D\u5668
     */
    TinyLine.prototype.getSchemaAdaptor = function () {
        return tiny_line_adaptor_adaptor;
    };
    return TinyLine;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/utils.js
































/**
 * \u53EF\u5728 multi-view \u4E2D\u4F7F\u7528\u7684 plots
 */
var PLOT_ADAPTORS = {
    line: adaptor,
    pie: pie_adaptor_adaptor,
    column: column_adaptor_adaptor,
    bar: bar_adaptor_adaptor,
    area: adaptor_adaptor,
    gauge: gauge_adaptor_adaptor,
    'tiny-line': tiny_line_adaptor_adaptor,
    'tiny-column': tiny_column_adaptor_adaptor,
    'tiny-area': tiny_area_adaptor_adaptor,
    'ring-progress': ring_progress_adaptor_adaptor,
    progress: progress_adaptor_adaptor,
    scatter: scatter_adaptor_adaptor,
    histogram: histogram_adaptor_adaptor,
    funnel: funnel_adaptor_adaptor,
    stock: stock_adaptor_adaptor,
};
/**
 * \u83B7\u53D6\u6307\u5B9A plot \u7684 class contructor
 * @param {string} plot
 */
var PLOT_CONSTRUCTOR = {
    line: plots_line_Line,
    pie: Pie,
    column: Column,
    bar: Bar,
    area: area_Area,
    gauge: Gauge,
    'tiny-line': TinyLine,
    'tiny-column': TinyColumn,
    'tiny-area': TinyArea,
    'ring-progress': RingProgress,
    progress: Progress,
    scatter: Scatter,
    histogram: Histogram,
    funnel: Funnel,
    stock: Stock,
};
/**
 * \u5728 mix \u56FE\u8868\u4EE5\u53CA facet \u56FE\u8868\u4E2D\uFF0CdefaultOptions \u8FDB\u884C\u590D\u5199\u7B80\u5316
 */
var DEFAULT_OPTIONS_MAP = {
    pie: { label: false },
    column: { tooltip: { showMarkers: false } },
    bar: { tooltip: { showMarkers: false } },
};
/**
 * \u6267\u884C plot \u7684 adaptor, \u9ED8\u8BA4\u90FD\u5E26\u4E0A defaultOptions
 * @param {string} plot
 */
function execPlotAdaptor(plot, view, options) {
    var cls = PLOT_CONSTRUCTOR[plot];
    if (!cls) {
        console.error("could not find ".concat(plot, " plot"));
        return;
    }
    var module = PLOT_ADAPTORS[plot];
    module({
        chart: view,
        options: deepAssign({}, cls.getDefaultOptions(), (0,esm/* get */.U2)(DEFAULT_OPTIONS_MAP, plot, {}), options),
    });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/adaptor.js








/**
 * geometry \u5904\u7406
 * @param params
 */
function multiView(params) {
    var chart = params.chart, options = params.options;
    var views = options.views, legend = options.legend;
    (0,esm/* each */.S6)(views, function (v) {
        var region = v.region, data = v.data, meta = v.meta, axes = v.axes, coordinate = v.coordinate, interactions = v.interactions, annotations = v.annotations, tooltip = v.tooltip, geometries = v.geometries;
        // 1. \u521B\u5EFA view
        var viewOfG2 = chart.createView({
            region: region,
        });
        // 2. data
        viewOfG2.data(data);
        // 3. meta
        var scales = {};
        if (axes) {
            (0,esm/* each */.S6)(axes, function (axis, field) {
                scales[field] = pick(axis, AXIS_META_CONFIG_KEYS);
            });
        }
        scales = deepAssign({}, meta, scales);
        viewOfG2.scale(scales);
        // 4. x y axis
        if (!axes) {
            viewOfG2.axis(false);
        }
        else {
            (0,esm/* each */.S6)(axes, function (axis, field) {
                viewOfG2.axis(field, axis);
            });
        }
        // 5. coordinate
        viewOfG2.coordinate(coordinate);
        // 6. geometry
        (0,esm/* each */.S6)(geometries, function (geometry) {
            var ext = base_geometry({
                chart: viewOfG2,
                options: geometry,
            }).ext;
            // adjust
            var adjust = geometry.adjust;
            if (adjust) {
                ext.geometry.adjust(adjust);
            }
        });
        // 7. interactions
        (0,esm/* each */.S6)(interactions, function (interaction) {
            if (interaction.enable === false) {
                viewOfG2.removeInteraction(interaction.type);
            }
            else {
                viewOfG2.interaction(interaction.type, interaction.cfg);
            }
        });
        // 8. annotations
        (0,esm/* each */.S6)(annotations, function (annotation) {
            viewOfG2.annotation()[annotation.type]((0,tslib_es6/* __assign */.pi)({}, annotation));
        });
        // 9. animation (\u5148\u505A\u52A8\u753B)
        if (typeof v.animation === 'boolean') {
            viewOfG2.animate(false);
        }
        else {
            viewOfG2.animate(true);
            // 9.1 \u6240\u6709\u7684 Geometry \u90FD\u4F7F\u7528\u540C\u4E00\u52A8\u753B\uFF08\u5404\u4E2A\u56FE\u5F62\u5982\u6709\u533A\u522B\uFF0Ctodo \u81EA\u884C\u8986\u76D6\uFF09
            (0,esm/* each */.S6)(viewOfG2.geometries, function (g) {
                g.animate(v.animation);
            });
        }
        if (tooltip) {
            // 10. tooltip
            viewOfG2.interaction('tooltip');
            viewOfG2.tooltip(tooltip);
        }
    });
    // legend
    if (!legend) {
        chart.legend(false);
    }
    else {
        (0,esm/* each */.S6)(legend, function (l, field) {
            chart.legend(field, l);
        });
    }
    // tooltip
    chart.tooltip(options.tooltip);
    return params;
}
/**
 * \u652F\u6301\u5D4C\u5957\u4F7F\u7528 g2plot \u5185\u7F6E\u56FE\u8868
 * @param params
 */
function multiPlot(params) {
    var chart = params.chart, options = params.options;
    var plots = options.plots, _a = options.data, data = _a === void 0 ? [] : _a;
    (0,esm/* each */.S6)(plots, function (plot) {
        var type = plot.type, region = plot.region, _a = plot.options, options = _a === void 0 ? {} : _a, top = plot.top;
        var tooltip = options.tooltip;
        if (top) {
            execPlotAdaptor(type, chart, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, options), { data: data }));
            return;
        }
        var viewOfG2 = chart.createView((0,tslib_es6/* __assign */.pi)({ region: region }, pick(options, PLOT_CONTAINER_OPTIONS)));
        if (tooltip) {
            // \u914D\u7F6E tooltip \u4EA4\u4E92
            viewOfG2.interaction('tooltip');
        }
        execPlotAdaptor(type, viewOfG2, (0,tslib_es6/* __assign */.pi)({ data: data }, options));
    });
    return params;
}
/**
 * \u5904\u7406\u7F29\u7565\u8F74\u7684 adaptor (mix)
 * @param params
 */
function adaptor_slider(params) {
    var chart = params.chart, options = params.options;
    chart.option('slider', options.slider);
    return params;
}
/**
 * \u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function mix_adaptor_adaptor(params) {
    return flow(animation, // \u591A view \u7684\u56FE\uFF0C\u52A8\u753B\u914D\u7F6E\u653E\u5230\u6700\u524D\u9762
    multiView, multiPlot, common_interaction, animation, common_theme, common_tooltip, adaptor_slider, common_annotation()
    // ... \u5176\u4ED6\u7684 adaptor flow
    )(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/interactions/utils.js


/**
 * \u83B7\u53D6\u56FE\u8868\u5143\u7D20\u5BF9\u5E94\u5B57\u6BB5\u7684\u503C
 * @param element \u56FE\u8868\u5143\u7D20
 * @param field \u5B57\u6BB5\u540D
 * @ignore
 */
function utils_getElementValue(element, field) {
    var model = element.getModel();
    var record = model.data;
    var value;
    if ((0,esm/* isArray */.kJ)(record)) {
        value = record[0][field];
    }
    else {
        value = record[field];
    }
    return value;
}
/**
 * @ignore
 * \u6E05\u7406 highlight \u6548\u679C
 * @param view View \u6216\u8005 Chart
 */
function utils_clearHighlight(view) {
    var elements = getAllElements(view);
    (0,esm/* each */.S6)(elements, function (el) {
        if (el.hasState('active')) {
            el.setState('active', false);
        }
        if (el.hasState('selected')) {
            el.setState('selected', false);
        }
        if (el.hasState('inactive')) {
            el.setState('inactive', false);
        }
    });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/interactions/association.js





/**
 * \u5B58\u5728\u591A\u4E2A view \u65F6\uFF0Cview \u4E4B\u95F4\u7684\u8054\u52A8\u4EA4\u4E92
 *
 * \u63D0\u4F9B\u56DB\u4E2A\u53CD\u9988 action\uFF0C\u5747\u63A5\u53D7\u53C2\u6570\uFF1AlinkField \u5173\u8054\u5B57\u6BB5\uFF0Cdim \u7EF4\u5EA6
 * 1. showTooltip
 * 2. active
 * 3. highlight
 * 4. selected
 *
 * \u9644\u52A0\uFF0C\u4E24\u4E2A\u7ED3\u675F\u53CD\u9988 action\uFF1A
 * 1. hidetooltip
 * 2. reset \u6E05\u9664\u6FC0\u6D3B\u548C\u9AD8\u4EAE\u72B6\u6001
 */
var Association = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Association, _super);
    function Association() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u83B7\u53D6\u5173\u8054\u7684 elements
     *
     * - \u5982\u679C dim \u53C2\u6570\u5B58\u5728\uFF0C\u6839\u636E dim \u83B7\u53D6\u76F8\u5E94\u7684 field\u3002\u4E0E linkField \u4E0D\u5339\u914D\u5219 return
     * - \u5426\u5219 dim \u53C2\u6570\u4E0D\u5B58\u5728\uFF0C\u4E14 linkField \u5B58\u5728\uFF0C\u5219\u4F5C\u4E3A\u5173\u8054\u5B57\u6BB5
     * - \u5426\u5219\u82E5 linkField \u4E0D\u5B58\u5728\uFF0C\u5219\u83B7\u53D6\u7B2C\u4E00\u4E2A\u5206\u7C7B\u5B57\u6BB5
     * @returns EventItem[]
     */
    Association.prototype.getAssociationItems = function (views, params) {
        var _a;
        var event = this.context.event;
        var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
        var items = [];
        if ((_a = event.data) === null || _a === void 0 ? void 0 : _a.data) {
            var data_1 = event.data.data;
            (0,esm/* each */.S6)(views, function (v) {
                var _a, _b;
                var field = linkField;
                if (dim === 'x') {
                    field = v.getXScale().field;
                }
                else if (dim === 'y') {
                    field = (_a = v.getYScales().find(function (s) { return s.field === field; })) === null || _a === void 0 ? void 0 : _a.field;
                }
                else if (!field) {
                    field = (_b = v.getGroupScales()[0]) === null || _b === void 0 ? void 0 : _b.field;
                }
                if (!field) {
                    return;
                }
                var elements = (0,esm/* map */.UI)(getAllElements(v), function (ele) {
                    var active = false;
                    var inactive = false;
                    var dataValue = (0,esm/* isArray */.kJ)(data_1) ? (0,esm/* get */.U2)(data_1[0], field) : (0,esm/* get */.U2)(data_1, field);
                    if (utils_getElementValue(ele, field) === dataValue) {
                        active = true;
                    }
                    else {
                        inactive = true;
                    }
                    return { element: ele, view: v, active: active, inactive: inactive };
                });
                items.push.apply(items, elements);
            });
        }
        return items;
    };
    /**
     * \u6240\u6709\u540C\u4E00\u5C42\u7EA7\u7684 tooltip \u663E\u793A
     */
    Association.prototype.showTooltip = function (params) {
        var siblings = getSiblingViews(this.context.view);
        var elements = this.getAssociationItems(siblings, params);
        (0,esm/* each */.S6)(elements, function (ele) {
            if (ele.active) {
                var box = ele.element.shape.getCanvasBBox();
                ele.view.showTooltip({ x: box.minX + box.width / 2, y: box.minY + box.height / 2 });
            }
        });
    };
    /**
     * \u9690\u85CF\u540C\u4E00\u5C42\u7EA7\u7684 tooltip
     */
    Association.prototype.hideTooltip = function () {
        var siblings = getSiblingViews(this.context.view);
        (0,esm/* each */.S6)(siblings, function (sibling) {
            sibling.hideTooltip();
        });
    };
    /**
     * \u8BBE\u7F6E active \u72B6\u6001
     */
    Association.prototype.active = function (params) {
        var views = getViews(this.context.view);
        var items = this.getAssociationItems(views, params);
        (0,esm/* each */.S6)(items, function (item) {
            var active = item.active, element = item.element;
            if (active) {
                element.setState('active', true);
            }
        });
    };
    /**
     * \u8BBE\u7F6E selected \u72B6\u6001
     */
    Association.prototype.selected = function (params) {
        var views = getViews(this.context.view);
        var items = this.getAssociationItems(views, params);
        (0,esm/* each */.S6)(items, function (item) {
            var active = item.active, element = item.element;
            if (active) {
                element.setState('selected', true);
            }
        });
    };
    /**
     * \u8FDB\u884C\u9AD8\u4EAE => \u8BBE\u7F6E inactive \u72B6\u6001
     */
    Association.prototype.highlight = function (params) {
        var views = getViews(this.context.view);
        var items = this.getAssociationItems(views, params);
        (0,esm/* each */.S6)(items, function (item) {
            var inactive = item.inactive, element = item.element;
            if (inactive) {
                element.setState('inactive', true);
            }
        });
    };
    Association.prototype.reset = function () {
        var views = getViews(this.context.view);
        (0,esm/* each */.S6)(views, function (v) {
            utils_clearHighlight(v);
        });
    };
    return Association;
}(action_base));
registerAction('association', Association);
/**
 * \u76F8\u90BB view \u7684 active \u8054\u52A8\uFF08\u76F8\u540C\u7EF4\u503C\u7684 tooltip \u8054\u52A8\uFF09
 */
registerInteraction('association-active', {
    start: [{ trigger: 'element:mouseenter', action: 'association:active' }],
    end: [{ trigger: 'element:mouseleave', action: 'association:reset' }],
});
/**
 * \u76F8\u90BB view \u7684 active \u8054\u52A8\uFF08\u76F8\u540C\u7EF4\u503C\u7684 tooltip \u8054\u52A8\uFF09
 */
registerInteraction('association-selected', {
    start: [{ trigger: 'element:mouseenter', action: 'association:selected' }],
    end: [{ trigger: 'element:mouseleave', action: 'association:reset' }],
});
/**
 * \u76F8\u90BB view \u7684 highlight \u8054\u52A8, \u7A81\u51FA\u5F53\u524D element
 */
registerInteraction('association-highlight', {
    start: [{ trigger: 'element:mouseenter', action: 'association:highlight' }],
    end: [{ trigger: 'element:mouseleave', action: 'association:reset' }],
});
/**
 * \u76F8\u90BB view \u7684 tooltip \u8054\u52A8\uFF0C\u6839\u636E groupField \u8FDB\u884C\u5173\u8054\uFF08\u76F8\u540C\u7EF4\u503C\u7684 tooltip \u8054\u52A8\uFF09
 */
registerInteraction('association-tooltip', {
    start: [{ trigger: 'element:mousemove', action: 'association:showTooltip' }],
    end: [{ trigger: 'element:mouseleave', action: 'association:hideTooltip' }],
});
//# sourceMappingURL=association.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/interactions/index.js
/**
 * \u76F8\u90BB view \u7684\u8054\u52A8\u4EA4\u4E92
 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/mix/index.js




/**
 * \u591A\u56FE\u5C42\u56FE\u5F62\uFF0C\u91CA\u653E G2 80% \u7684\u529F\u80FD\uFF0C\u53EF\u4EE5\u7528\u6765\u505A\uFF1A
 * 1. \u56FE\u5C42\u53E0\u52A0\u7684\u56FE\uFF1A
 *   - \u6298\u7EBF + \u7F6E\u4FE1\u5EA6\u533A\u95F4\u8FED\u4EE3
 *   - \u5D4C\u5957\u997C\u56FE
 *   - ...
 * 2. \u56FE\u5C42\u5212\u5206\u7684\u56FE
 *   - \u591A\u7EF4\u56FE
 *   - \u67F1\u997C\u7EC4\u5408\u56FE
 *   - ...
 */
var Mix = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Mix, _super);
    function Mix() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'mix';
        return _this;
    }
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Mix.prototype.getSchemaAdaptor = function () {
        return mix_adaptor_adaptor;
    };
    return Mix;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/lab.js

/** \u5B9E\u9A8C\u5BA4\u56FE\u8868\u6240\u5904\u7684\u9636\u6BB5 */
var Stage;
(function (Stage) {
    Stage["DEV"] = "DEV";
    Stage["BETA"] = "BETA";
    Stage["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
/**
 * \u4E0D\u540C\u9636\u6BB5\u6253\u5370\u4E00\u4E9B\u6D88\u606F\u7ED9\u5F00\u53D1\u8005
 * @param stage
 */
function notice(stage, plotType) {
    console.warn(stage === Stage.DEV
        ? "Plot '".concat(plotType, "' is in DEV stage, just give us issues.")
        : stage === Stage.BETA
            ? "Plot '".concat(plotType, "' is in BETA stage, DO NOT use it in production env.")
            : stage === Stage.STABLE
                ? "Plot '".concat(plotType, "' is in STABLE stage, import it by \\"import { ").concat(plotType, " } from '@antv/g2plot'\\".")
                : 'invalid Stage type.');
}
/**
 * \u5B9E\u9A8C\u5BA4\u56FE\u8868\uFF0C\u5B9E\u9A8C\u5BA4\u4E2D\u7684\u56FE\u8868\u5206\u6210\u4E0D\u540C\u7684\u9636\u6BB5\u3002
 */
var Lab = /** @class */ (function () {
    function Lab() {
    }
    Object.defineProperty(Lab, "MultiView", {
        get: function () {
            notice(Stage.STABLE, 'MultiView');
            return Mix;
        },
        enumerable: false,
        configurable: true
    });
    return Lab;
}());

//# sourceMappingURL=lab.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bidirectional-bar/constant.js
var FIRST_AXES_VIEW = 'first-axes-view';
var SECOND_AXES_VIEW = 'second-axes-view';
/** \u5BF9\u79F0\u6761\u5F62\u56FE\u7684\u5206\u7EC4 key \u503C */
var SERIES_FIELD_KEY = 'series-field-key';
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bidirectional-bar/utils.js

/**
 * bidirectional-bar \u5904\u7406\u6570\u636E, \u901A\u8FC7 SERIES_FIELD_KEY \u5B57\u6BB5\u5206\u6210\u5DE6\u53F3\u6570\u636E
 * @param xField
 * @param yField
 * @param data
 */
function utils_transformData(xField, yField, seriesField, data, reverse) {
    var hopeData = [];
    yField.forEach(function (d) {
        data.forEach(function (k) {
            var _a;
            var obj = (_a = {},
                _a[xField] = k[xField],
                _a[seriesField] = d,
                _a[d] = k[d],
                _a);
            hopeData.push(obj);
        });
    });
    var groupData = Object.values((0,esm/* groupBy */.vM)(hopeData, seriesField));
    var _a = groupData[0], data1 = _a === void 0 ? [] : _a, _b = groupData[1], data2 = _b === void 0 ? [] : _b;
    return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];
}
/**
 * \u662F\u5426\u6A2A\u5411\uFF0C\u9ED8\u8BA4\u7A7A\u4E3A\u6A2A\u5411
 * @param layout
 */
function isHorizontal(layout) {
    return layout !== 'vertical';
}
/**
 * \u591A view \u8FDB\u884C\u540C\u6B65 padding \u7684\u81EA\u5B9A\u4E49\u903B\u8F91
 * @param chart
 * @param views
 * @param p
 */
function syncViewPadding(chart, views, p) {
    var v1 = views[0], v2 = views[1];
    var p1 = v1.autoPadding;
    var p2 = v2.autoPadding;
    var _a = chart.__axisPosition, layout = _a.layout, position = _a.position;
    // \u76EE\u524D\u53EA\u80FD\u6839\u636E\u5E03\u5C40\u7684\u6BD4\u4F8B\u6765\u5224\u65AD layout
    if (isHorizontal(layout) && position === 'top') {
        /**
         * \u4FDD\u8BC1 v1 \u7684 left \u548C v2 right \u7684\u95F4\u9694\u76F8\u7B49\uFF0C\u56E0\u4E3A v1 \u6709\u8F74
         * position top \u5373\u4E3A v1 \u5DE6\u8FB9\uFF0C\u4E2D\u95F4\u95F4\u8DDD\u8BBE\u7F6E\u5C31\u4E3A 0
         */
        v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
        v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
    }
    if (isHorizontal(layout) && position === 'bottom') {
        /**
         * \u4FDD\u8BC1 v1 \u7684 left \u548C v2 right \u7684\u95F4\u9694\u76F8\u7B49\uFF0C\u56E0\u4E3A v1 \u6709\u8F74
         * position bottom \u5373\u4E3A v1 \u7684\u53F3\u8FB9\uFF0Cv1 right = right / 2  v2 left = right / 2
         * + 5 \u662F\u4E3A\u4E86 \u8BA9\u90A3\u4E2A\u8F74\u4E0D\u8981\u592A\u8D34\u8FD1\u4E86\uFF0C\u66F4\u597D\u770B
         */
        v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
        v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
    }
    if (!isHorizontal(layout) && position === 'bottom') {
        /**
         * \u4FDD\u8BC1 v1 \u7684 left \u548C v2 left \u7684\u95F4\u9694\u76F8\u7B49 left \u53D6\u6700\u5927\u503C
         * position bottom \u5373\u4E3A v1 \u4E0B\u8FB9\uFF0Cv1 bottom = bottom / 2  v2 top = bottom / 2
         * + 5 \u662F\u4E3A\u4E86 \u8BA9\u90A3\u4E2A\u8F74\u4E0D\u8981\u592A\u8D34\u8FD1\u4E86\uFF0C\u66F4\u597D\u770B
         */
        var left = p1.left >= p2.left ? p1.left : p2.left;
        v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);
        v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);
    }
    // \u5782\u76F4\u72B6\u6001\uFF0C\u4E0D\u5EFA\u8BAE\u8BBE\u7F6Eposition \u4E3A top\uFF0C \u8FD8\u662F\u505A\u4E2A\u517C\u5BB9\u5904\u7406
    if (!isHorizontal(layout) && position === 'top') {
        var left = p1.left >= p2.left ? p1.left : p2.left;
        v1.autoPadding = p.instance(p1.top, p1.right, 0, left);
        v2.autoPadding = p.instance(0, p2.right, p1.top, left);
    }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bidirectional-bar/adaptor.js







/**
 * geometry \u5904\u7406
 * @param params
 */
function bidirectional_bar_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, xField = options.xField, yField = options.yField, color = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend = options.legend, layout = options.layout;
    // \u5904\u7406\u6570\u636E
    var groupData = utils_transformData(xField, yField, SERIES_FIELD_KEY, data, isHorizontal(layout));
    // \u5728\u521B\u5EFA\u5B50 view \u6267\u884C\u540E\u4E0D\u884C\uFF0C\u9700\u8981\u5728\u524D\u9762\u5904\u7406 legend
    if (legend) {
        chart.legend(SERIES_FIELD_KEY, legend);
    }
    else if (legend === false) {
        chart.legend(false);
    }
    // \u521B\u5EFA view
    var firstView;
    var secondView;
    var firstViewData = groupData[0], secondViewData = groupData[1];
    // \u6A2A\u5411
    if (isHorizontal(layout)) {
        firstView = chart.createView({
            region: {
                start: { x: 0, y: 0 },
                end: { x: 0.5, y: 1 },
            },
            id: FIRST_AXES_VIEW,
        });
        firstView.coordinate().transpose().reflect('x');
        secondView = chart.createView({
            region: {
                start: { x: 0.5, y: 0 },
                end: { x: 1, y: 1 },
            },
            id: SECOND_AXES_VIEW,
        });
        secondView.coordinate().transpose();
        // @\u8BF4\u660E: \u6D4B\u8BD5\u53D1\u73B0\uFF0C\u6A2A\u5411\u56E0\u4E3A\u8F74\u7684\u53CD\u8F6C\uFF0C\u9700\u8981\u6570\u636E\u4E5F\u53CD\u8F6C\uFF0C\u4E0D\u7136\u4F1A\u56FE\u5F62\u6E32\u67D3\u662F\u53CD\u7684(\u7FFB\u8F6C\u64CD\u4F5C\u8FDB\u5165\u5230 transform \u4E2D\u5904\u7406)
        firstView.data(firstViewData);
        secondView.data(secondViewData);
    }
    else {
        // \u7EB5\u5411
        firstView = chart.createView({
            region: {
                start: { x: 0, y: 0 },
                end: { x: 1, y: 0.5 },
            },
            id: FIRST_AXES_VIEW,
        });
        secondView = chart.createView({
            region: {
                start: { x: 0, y: 0.5 },
                end: { x: 1, y: 1 },
            },
            id: SECOND_AXES_VIEW,
        });
        secondView.coordinate().reflect('y');
        firstView.data(firstViewData);
        secondView.data(secondViewData);
    }
    var left = deepAssign({}, params, {
        chart: firstView,
        options: {
            widthRatio: widthRatio,
            xField: xField,
            yField: yField[0],
            seriesField: SERIES_FIELD_KEY,
            interval: {
                color: color,
                style: barStyle,
            },
        },
    });
    interval_interval(left);
    var right = deepAssign({}, params, {
        chart: secondView,
        options: {
            xField: xField,
            yField: yField[1],
            seriesField: SERIES_FIELD_KEY,
            widthRatio: widthRatio,
            interval: {
                color: color,
                style: barStyle,
            },
        },
    });
    interval_interval(right);
    return params;
}
/**
 * meta \u914D\u7F6E
 * - \u5BF9\u79F0\u6761\u5F62\u56FE\u5BF9\u6570\u636E\u8FDB\u884C\u4E86\u5904\u7406\uFF0C\u901A\u8FC7 SERIES_FIELD_KEY \u6765\u5BF9\u4E24\u6761 yField \u6570\u636E\u8FDB\u884C\u5206\u7C7B
 * @param params
 */
function bidirectional_bar_adaptor_meta(params) {
    var _a, _b, _c;
    var options = params.options, chart = params.chart;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    var firstView = findViewById(chart, FIRST_AXES_VIEW);
    var secondView = findViewById(chart, SECOND_AXES_VIEW);
    var aliasMap = {};
    (0,esm/* keys */.XP)((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function (metaKey) {
        if ((0,esm/* get */.U2)(options === null || options === void 0 ? void 0 : options.meta, [metaKey, 'alias'])) {
            aliasMap[metaKey] = options.meta[metaKey].alias;
        }
    });
    chart.scale((_a = {},
        _a[SERIES_FIELD_KEY] = {
            sync: true,
            formatter: function (v) {
                return (0,esm/* get */.U2)(aliasMap, v, v);
            },
        },
        _a));
    common_scale((_b = {},
        _b[xField] = xAxis,
        _b[yField[0]] = yAxis[yField[0]],
        _b))(deepAssign({}, params, { chart: firstView }));
    common_scale((_c = {},
        _c[xField] = xAxis,
        _c[yField[1]] = yAxis[yField[1]],
        _c))(deepAssign({}, params, { chart: secondView }));
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function bidirectional_bar_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout = options.layout;
    var firstView = findViewById(chart, FIRST_AXES_VIEW);
    var secondView = findViewById(chart, SECOND_AXES_VIEW);
    // \u7B2C\u4E8C\u4E2A view axis \u59CB\u7EC8\u9690\u85CF; \u6CE8\u610F bottom \u7684\u65F6\u5019\uFF0C\u53EA\u9690\u85CF label\uFF0C\u5176\u4ED6\u5171\u7528\u914D\u7F6E
    // @ts-ignore
    if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === 'bottom') {
        // fixme \u76F4\u63A5\u8BBE\u7F6E label: null \u4F1A\u5BFC\u81F4 tickLine \u65E0\u6CD5\u663E\u793A
        secondView.axis(xField, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, xAxis), { label: { formatter: function () { return ''; } } }));
    }
    else {
        secondView.axis(xField, false);
    }
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A firstView \u8F74
    if (xAxis === false) {
        firstView.axis(xField, false);
    }
    else {
        firstView.axis(xField, (0,tslib_es6/* __assign */.pi)({ 
            // \u4E0D\u540C\u5E03\u5C40 firstView \u7684\u5750\u6807\u8F74\u663E\u793A\u4F4D\u7F6E
            position: isHorizontal(layout) ? 'top' : 'bottom' }, xAxis));
    }
    if (yAxis === false) {
        firstView.axis(yField[0], false);
        secondView.axis(yField[1], false);
    }
    else {
        firstView.axis(yField[0], yAxis[yField[0]]);
        secondView.axis(yField[1], yAxis[yField[1]]);
    }
    /**
     *  \u8FD9\u4E2A\u6CE8\u5165\uFF0C\u4E3B\u8981\u662F\u5728syncViewPadding\u65F6\u5019\u62FF\u5230\u76F8\u5BF9\u5E94\u7684\u914D\u7F6E\uFF1A\u5E03\u5C40\u548C\u8F74\u7684\u4F4D\u7F6E
     *  TODO \u4E4B\u540E\u5E0C\u671B g2 View \u5BF9\u8C61\u53EF\u4EE5\u5F00\u653E setter \u53EF\u4EE5\u8BBE\u7F6E\u4E00\u4E9B\u9700\u8981\u7684\u4E1C\u897F
     */
    //@ts-ignore
    chart.__axisPosition = {
        position: firstView.getOptions().axes[xField].position,
        layout: layout,
    };
    return params;
}
/**
 * interaction \u914D\u7F6E
 * @param params
 */
function bidirectional_bar_adaptor_interaction(params) {
    var chart = params.chart;
    common_interaction(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
    common_interaction(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
    return params;
}
/**
 * limitInPlot
 * @param params
 */
function adaptor_limitInPlot(params) {
    var chart = params.chart, options = params.options;
    var yField = options.yField, yAxis = options.yAxis;
    common_limitInPlot(deepAssign({}, params, {
        chart: findViewById(chart, FIRST_AXES_VIEW),
        options: {
            yAxis: yAxis[yField[0]],
        },
    }));
    common_limitInPlot(deepAssign({}, params, {
        chart: findViewById(chart, SECOND_AXES_VIEW),
        options: {
            yAxis: yAxis[yField[1]],
        },
    }));
    return params;
}
/**
 * theme
 * @param params
 */
function adaptor_theme(params) {
    var chart = params.chart;
    common_theme(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
    common_theme(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
    common_theme(params);
    return params;
}
/**
 * animation
 * @param params
 */
function adaptor_animation(params) {
    var chart = params.chart;
    animation(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
    animation(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
    return params;
}
/**
 * label \u914D\u7F6E (1. \u8BBE\u7F6E offset \u504F\u79FB\u91CF\u9ED8\u8BA4\u503C 2. leftView \u504F\u79FB\u91CF\u9700\u8981 *= -1)
 * @param params
 */
function bidirectional_bar_adaptor_label(params) {
    var _this = this;
    var _a, _b;
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField, layout = options.layout;
    var firstView = findViewById(chart, FIRST_AXES_VIEW);
    var secondView = findViewById(chart, SECOND_AXES_VIEW);
    var leftGeometry = findGeometry(firstView, 'interval');
    var rightGeometry = findGeometry(secondView, 'interval');
    if (!label) {
        leftGeometry.label(false);
        rightGeometry.label(false);
    }
    else {
        var callback = label.callback, cfg_1 = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        /** ---- \u8BBE\u7F6E\u9ED8\u8BA4\u914D\u7F6E ---- */
        // \u9ED8\u8BA4\u5C45\u4E2D
        if (!cfg_1.position) {
            cfg_1.position = 'middle';
        }
        if (cfg_1.offset === undefined) {
            cfg_1.offset = 2;
        }
        /** ---- leftView label \u8BBE\u7F6E ---- */
        var leftLabelCfg = (0,tslib_es6/* __assign */.pi)({}, cfg_1);
        if (isHorizontal(layout)) {
            // \u8BBE\u7F6E textAlign \u9ED8\u8BA4\u503C
            var textAlign = ((_a = leftLabelCfg.style) === null || _a === void 0 ? void 0 : _a.textAlign) || (cfg_1.position === 'middle' ? 'center' : 'left');
            cfg_1.style = deepAssign({}, cfg_1.style, { textAlign: textAlign });
            var textAlignMap = { left: 'right', right: 'left', center: 'center' };
            leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: textAlignMap[textAlign] });
        }
        else {
            var positionMap_1 = { top: 'bottom', bottom: 'top', middle: 'middle' };
            if (typeof cfg_1.position === 'string') {
                cfg_1.position = positionMap_1[cfg_1.position];
            }
            else if (typeof cfg_1.position === 'function') {
                cfg_1.position = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return positionMap_1[cfg_1.position.apply(_this, args)];
                };
            }
            // \u8BBE\u7F6E textBaseline \u9ED8\u8BA4\u503C
            var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || 'bottom';
            leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline: textBaseline });
            var textBaselineMap = { top: 'bottom', bottom: 'top', middle: 'middle' };
            cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: textBaselineMap[textBaseline] });
        }
        leftGeometry.label({
            fields: [yField[0]],
            callback: callback,
            cfg: transformLabel(leftLabelCfg),
        });
        rightGeometry.label({
            fields: [yField[1]],
            callback: callback,
            cfg: transformLabel(cfg_1),
        });
    }
    return params;
}
/**
 * \u5BF9\u79F0\u6761\u5F62\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function bidirectional_bar_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(bidirectional_bar_adaptor_geometry, bidirectional_bar_adaptor_meta, bidirectional_bar_adaptor_axis, adaptor_limitInPlot, adaptor_theme, bidirectional_bar_adaptor_label, common_tooltip, bidirectional_bar_adaptor_interaction, adaptor_animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bidirectional-bar/index.js







var BidirectionalBar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(BidirectionalBar, _super);
    function BidirectionalBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'bidirectional-bar';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    BidirectionalBar.getDefaultOptions = function () {
        return deepAssign({}, _super.getDefaultOptions.call(this), {
            syncViewPadding: syncViewPadding,
        });
    };
    /**
     * @override
     */
    BidirectionalBar.prototype.changeData = function (data) {
        if (data === void 0) { data = []; }
        this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        // \u66F4\u65B0options
        this.updateOption({ data: data });
        var _a = this.options, xField = _a.xField, yField = _a.yField, layout = _a.layout;
        // \u5904\u7406\u6570\u636E
        var groupData = utils_transformData(xField, yField, SERIES_FIELD_KEY, data, isHorizontal(layout));
        var firstViewData = groupData[0], secondViewData = groupData[1];
        var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
        var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
        // \u66F4\u65B0\u5BF9\u5E94view\u7684data
        firstView.data(firstViewData);
        secondView.data(secondViewData);
        // \u91CD\u65B0\u6E32\u67D3
        this.chart.render(true);
        this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    BidirectionalBar.prototype.getDefaultOptions = function () {
        return BidirectionalBar.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u5BF9\u79F0\u6761\u5F62\u56FE\u7684\u9002\u914D\u5668
     */
    BidirectionalBar.prototype.getSchemaAdaptor = function () {
        return bidirectional_bar_adaptor_adaptor;
    };
    /** \u5BF9\u79F0\u6761\u5F62\u56FE\u5206\u7C7B\u5B57\u6BB5 */
    BidirectionalBar.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
    return BidirectionalBar;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/box/constant.js
var box_constant_a;


var BOX_RANGE = '$$range$$';
var BOX_RANGE_ALIAS = 'low-q1-median-q3-high';
var BOX_SYNC_NAME = '$$y_outliers$$';
var OUTLIERS_VIEW_ID = 'outliers_view';
/**
 * \u9762\u79EF\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var box_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    meta: (box_constant_a = {},
        box_constant_a[BOX_RANGE] = { min: 0, alias: BOX_RANGE_ALIAS },
        box_constant_a),
    // \u9ED8\u8BA4\u533A\u57DF\u4EA4\u4E92
    interactions: [{ type: 'active-region' }],
    // \u9ED8\u8BA4 tooltips \u5171\u4EAB\uFF0C\u4E0D\u663E\u793A markers
    tooltip: {
        showMarkers: false,
        shared: true,
    },
    boxStyle: {
        lineWidth: 1,
    },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/box/utils.js


/**
 * @desc \u5C06\u6570\u636E\u8F6C\u6362\u4E3A box \u9700\u8981\u7684\u7684\u56FE\u8868\u6570\u636E,\u5982\u679CyField\u4E3A\u6570\u7EC4,\u4ECEdata\u4E2D\u89E3\u6784\u51FA\u5BF9\u5E94\u6570\u7EC4\u503C\u5E76\u5199\u5165data,\u5426\u5219\u76F4\u63A5\u8FD4\u56DEdata
 * @param data
 * @param yField
 */
var box_utils_transformData = function (data, yField) {
    var newData = data;
    // formate data when \`yField\` is Array
    if (Array.isArray(yField)) {
        var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
        newData = (0,esm/* map */.UI)(data, function (obj) {
            obj[BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
            return obj;
        });
    }
    return newData;
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/box/adaptor.js








/**
 * \u5B57\u6BB5
 * @param params
 */
function adaptor_field(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, yField = options.yField, groupField = options.groupField, color = options.color, tooltip = options.tooltip, boxStyle = options.boxStyle;
    chart.data(box_utils_transformData(options.data, yField));
    var yFieldName = (0,esm/* isArray */.kJ)(yField) ? BOX_RANGE : yField;
    var rawFields = yField ? ((0,esm/* isArray */.kJ)(yField) ? yField : [yField]) : [];
    var tooltipOptions = tooltip;
    if (tooltipOptions !== false) {
        tooltipOptions = deepAssign({}, { fields: (0,esm/* isArray */.kJ)(yField) ? yField : [] }, tooltipOptions);
    }
    var ext = schema_schema(deepAssign({}, params, {
        options: {
            xField: xField,
            yField: yFieldName,
            seriesField: groupField,
            tooltip: tooltipOptions,
            rawFields: rawFields,
            // \u53EA\u6709\u5F02\u5E38\u70B9\u89C6\u56FE\u5C55\u793A label
            label: false,
            schema: {
                shape: 'box',
                color: color,
                style: boxStyle,
            },
        },
    })).ext;
    if (groupField) {
        ext.geometry.adjust('dodge');
    }
    return params;
}
/**
 * \u521B\u5EFA\u5F02\u5E38\u70B9 view
 */
function outliersPoint(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, data = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding = options.padding, label = options.label;
    if (!outliersField)
        return params;
    var outliersView = chart.createView({ padding: padding, id: OUTLIERS_VIEW_ID });
    var outliersViewData = data.reduce(function (ret, datum) {
        var outliersData = datum[outliersField];
        outliersData.forEach(function (d) {
            var _a;
            return ret.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, datum), (_a = {}, _a[outliersField] = d, _a)));
        });
        return ret;
    }, []);
    outliersView.data(outliersViewData);
    point_point({
        chart: outliersView,
        options: {
            xField: xField,
            yField: outliersField,
            point: { shape: 'circle', style: outliersStyle },
            label: label,
        },
    });
    outliersView.axis(false);
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function box_adaptor_meta(params) {
    var _a, _b;
    var chart = params.chart, options = params.options;
    var meta = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
    var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
    var baseMeta = {};
    // make yField and outliersField share y mate
    if (outliersField) {
        var syncName = BOX_SYNC_NAME;
        baseMeta = (_a = {},
            _a[outliersField] = { sync: syncName, nice: true },
            _a[yFieldName] = { sync: syncName, nice: true },
            _a);
    }
    var scales = deepAssign(baseMeta, meta, (_b = {},
        _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS),
        _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS),
        _b));
    chart.scale(scales);
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function box_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(BOX_RANGE, false);
    }
    else {
        chart.axis(yFieldName, yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function box_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, groupField = options.groupField;
    if (groupField) {
        if (legend) {
            chart.legend(groupField, legend);
        }
        else {
            // Grouped Box Chart default has legend, and it's position is \`bottom\`
            chart.legend(groupField, { position: 'bottom' });
        }
    }
    else {
        chart.legend(false);
    }
    return params;
}
/**
 * \u7BB1\u578B\u56FE\u9002\u914D\u5668
 * @param params
 */
function box_adaptor_adaptor(params) {
    return flow(adaptor_field, outliersPoint, box_adaptor_meta, box_adaptor_axis, box_adaptor_legend, common_tooltip, common_annotation(), common_interaction, animation, common_theme)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/box/index.js





var Box = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Box, _super);
    function Box() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'box';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Box.getDefaultOptions = function () {
        return box_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    Box.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var yField = this.options.yField;
        var outliersView = this.chart.views.find(function (v) { return v.id === OUTLIERS_VIEW_ID; });
        if (outliersView) {
            outliersView.data(data);
        }
        this.chart.changeData(box_utils_transformData(data, yField));
    };
    /**
     * \u83B7\u53D6 \u7BB1\u578B\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     */
    Box.prototype.getDefaultOptions = function () {
        return Box.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u7BB1\u578B\u56FE \u7684\u9002\u914D\u5668
     */
    Box.prototype.getSchemaAdaptor = function () {
        return box_adaptor_adaptor;
    };
    return Box;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bullet/utils.js
/**
 * \u83B7\u53D6\u5206\u7C7B\u5B57\u6BB5 key \u503C \u4E00\u4E2A\u5206\u7C7B\u503C\u7684\u65F6\u5019\uFF0C \u8FD4\u56DE\u975E\u7D22\u5F15 key \u503C\uFF0C\u5728 tooltip \u4E0D\u505A\u7D22\u5F15\u533A\u5206
 * @param values \u6570\u636E\u91CF
 * @param field \u6307\u6807\u5B57\u6BB5
 * @param index \u7D22\u5F15
 * @returns string
 */
function getSeriesFieldKey(values, field, index) {
    return values.length > 1 ? "".concat(field, "_").concat(index) : "".concat(field);
}
/**
 * bullet \u5904\u7406\u6570\u636E
 * @param options
 */
function bullet_utils_transformData(options) {
    var data = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout = options.layout;
    var ds = [];
    var scales = [];
    data.forEach(function (item, index) {
        // \u6784\u5EFA title * range
        var rangeValues = [item[rangeField]].flat();
        rangeValues.sort(function (a, b) { return a - b; });
        rangeValues.forEach(function (d, i) {
            var _a;
            var range = i === 0 ? d : rangeValues[i] - rangeValues[i - 1];
            ds.push((_a = {
                    rKey: "".concat(rangeField, "_").concat(i)
                },
                _a[xField] = xField ? item[xField] : String(index),
                _a[rangeField] = range,
                _a));
        });
        // \u6784\u5EFA title * measure
        var measureValues = [item[measureField]].flat();
        measureValues.forEach(function (d, i) {
            var _a;
            ds.push((_a = {
                    mKey: getSeriesFieldKey(measureValues, measureField, i)
                },
                _a[xField] = xField ? item[xField] : String(index),
                _a[measureField] = d,
                _a));
        });
        // \u6784\u5EFA title * target
        var targetValues = [item[targetField]].flat();
        targetValues.forEach(function (d, i) {
            var _a;
            ds.push((_a = {
                    tKey: getSeriesFieldKey(targetValues, targetField, i)
                },
                _a[xField] = xField ? item[xField] : String(index),
                _a[targetField] = d,
                _a));
        });
        // \u4E3A\u4E86\u53D6\u6700\u5927\u503C\u548C\u6700\u5C0F\u503C\uFF0C\u5148\u5B58\u50A8
        scales.push(item[rangeField], item[measureField], item[targetField]);
    });
    // scales \u662F\u5D4C\u5957\u7684\u9700\u8981\u62CD\u5E73
    var min = Math.min.apply(Math, scales.flat(Infinity));
    var max = Math.max.apply(Math, scales.flat(Infinity));
    // min \u5927\u4E8E 0 \u4ECE 0 \u5F00\u59CB
    min = min > 0 ? 0 : min;
    // \u5782\u76F4\u60C5\u51B5\uFF0C\u9700\u8981\u53CD\u8F6C\u6570\u636E
    if (layout === 'vertical') {
        ds.reverse();
    }
    return { min: min, max: max, ds: ds };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bullet/adaptor.js






/**
 * geometry \u5904\u7406
 * @param params
 */
function bullet_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color = options.color, layout = options.layout, size = options.size, label = options.label;
    // \u5904\u7406\u6570\u636E
    var _a = bullet_utils_transformData(options), min = _a.min, max = _a.max, ds = _a.ds;
    chart.data(ds);
    // rangeGeometry
    var r = deepAssign({}, params, {
        options: {
            xField: xField,
            yField: rangeField,
            seriesField: 'rKey',
            isStack: true,
            label: (0,esm/* get */.U2)(label, 'range'),
            interval: {
                color: (0,esm/* get */.U2)(color, 'range'),
                style: (0,esm/* get */.U2)(bulletStyle, 'range'),
                size: (0,esm/* get */.U2)(size, 'range'),
            },
        },
    });
    interval_interval(r);
    // \u8303\u56F4\u503C\u7684 tooltip \u9690\u85CF\u6389
    chart.geometries[0].tooltip(false);
    // measureGeometry
    var m = deepAssign({}, params, {
        options: {
            xField: xField,
            yField: measureField,
            seriesField: 'mKey',
            isStack: true,
            label: (0,esm/* get */.U2)(label, 'measure'),
            interval: {
                color: (0,esm/* get */.U2)(color, 'measure'),
                style: (0,esm/* get */.U2)(bulletStyle, 'measure'),
                size: (0,esm/* get */.U2)(size, 'measure'),
            },
        },
    });
    interval_interval(m);
    // targetGeometry
    var t = deepAssign({}, params, {
        options: {
            xField: xField,
            yField: targetField,
            seriesField: 'tKey',
            label: (0,esm/* get */.U2)(label, 'target'),
            point: {
                color: (0,esm/* get */.U2)(color, 'target'),
                style: (0,esm/* get */.U2)(bulletStyle, 'target'),
                size: (0,esm/* isFunction */.mf)((0,esm/* get */.U2)(size, 'target'))
                    ? function (data) { return (0,esm/* get */.U2)(size, 'target')(data) / 2; }
                    : (0,esm/* get */.U2)(size, 'target') / 2,
                shape: layout === 'horizontal' ? 'line' : 'hyphen',
            },
        },
    });
    point_point(t);
    // \u6C34\u5E73\u7684\u65F6\u5019\uFF0C\u8981\u8F6C\u6362\u5750\u6807\u8F74
    if (layout === 'horizontal') {
        chart.coordinate().transpose();
    }
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { ext: { data: { min: min, max: max } } });
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function bullet_adaptor_meta(params) {
    var _a, _b;
    var options = params.options, ext = params.ext;
    var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
    var extData = ext.data;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[measureField] = yAxis,
        _a), (_b = {},
        _b[measureField] = { min: extData === null || extData === void 0 ? void 0 : extData.min, max: extData === null || extData === void 0 ? void 0 : extData.max, sync: true },
        _b[targetField] = {
            sync: "".concat(measureField),
        },
        _b[rangeField] = {
            sync: "".concat(measureField),
        },
        _b)))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function bullet_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
    chart.axis("".concat(rangeField), false);
    chart.axis("".concat(targetField), false);
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis("".concat(xField), false);
    }
    else {
        chart.axis("".concat(xField), xAxis);
    }
    if (yAxis === false) {
        chart.axis("".concat(measureField), false);
    }
    else {
        chart.axis("".concat(measureField), yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function bullet_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend;
    chart.removeInteraction('legend-filter');
    // @TODO \u540E\u7EED\u770B\u662F\u5426\u5185\u90E8\u81EA\u5B9A\u4E49\u4E00\u4E2A legend
    chart.legend(legend);
    // \u9ED8\u8BA4\u5173\u95ED\u6389\u6240\u5728 color \u5B57\u6BB5\u7684 legend, \u4ECE\u800C\u4E0D\u5F71\u54CD\u81EA\u5B9A\u4E49\u7684legend
    chart.legend('rKey', false);
    chart.legend('mKey', false);
    chart.legend('tKey', false);
    return params;
}
/**
 * label \u914D\u7F6E
 * @param params
 */
function bullet_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
    var _a = chart.geometries, rangeGeometry = _a[0], measureGeometry = _a[1], targetGeometry = _a[2];
    if ((0,esm/* get */.U2)(label, 'range')) {
        rangeGeometry.label("".concat(rangeField), (0,tslib_es6/* __assign */.pi)({ layout: [{ type: 'limit-in-plot' }] }, transformLabel(label.range)));
    }
    else {
        rangeGeometry.label(false);
    }
    if ((0,esm/* get */.U2)(label, 'measure')) {
        measureGeometry.label("".concat(measureField), (0,tslib_es6/* __assign */.pi)({ layout: [{ type: 'limit-in-plot' }] }, transformLabel(label.measure)));
    }
    else {
        measureGeometry.label(false);
    }
    if ((0,esm/* get */.U2)(label, 'target')) {
        targetGeometry.label("".concat(targetField), (0,tslib_es6/* __assign */.pi)({ layout: [{ type: 'limit-in-plot' }] }, transformLabel(label.target)));
    }
    else {
        targetGeometry.label(false);
    }
    return params;
}
/**
 * \u5B50\u5F39\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function bullet_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    flow(bullet_adaptor_geometry, bullet_adaptor_meta, bullet_adaptor_axis, bullet_adaptor_legend, common_theme, bullet_adaptor_label, common_tooltip, common_interaction, animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bullet/constant.js


/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var bullet_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    layout: 'horizontal',
    size: {
        range: 30,
        measure: 20,
        target: 20,
    },
    xAxis: {
        tickLine: false,
        line: null,
    },
    bulletStyle: {
        range: {
            fillOpacity: 0.5,
        },
    },
    label: {
        measure: {
            position: 'right',
        },
    },
    tooltip: {
        // \u9ED8\u8BA4\u5173\u95ED
        showMarkers: false,
    },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/bullet/index.js





var Bullet = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Bullet, _super);
    function Bullet() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'bullet';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u5B50\u5F39\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Bullet.getDefaultOptions = function () {
        return bullet_constant_DEFAULT_OPTIONS;
    };
    Bullet.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = bullet_utils_transformData(this.options), min = _a.min, max = _a.max, ds = _a.ds;
        // \u5904\u7406scale
        bullet_adaptor_meta({ options: this.options, ext: { data: { min: min, max: max } }, chart: this.chart });
        this.chart.changeData(ds);
    };
    /**
     * \u83B7\u53D6\u5B50\u5F39\u56FE\u7684\u9002\u914D\u5668
     */
    Bullet.prototype.getSchemaAdaptor = function () {
        return bullet_adaptor_adaptor;
    };
    /**
     * \u83B7\u53D6 \u5B50\u5F39\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Bullet.prototype.getDefaultOptions = function () {
        return Bullet.getDefaultOptions();
    };
    return Bullet;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/transform/chord.js
/*
 * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)
 * graph data required (nodes, edges)
 */

var chord_DEFAULT_OPTIONS = {
    y: 0,
    nodeWidthRatio: 0.05,
    weight: false,
    nodePaddingRatio: 0.1,
    id: function (node) { return node.id; },
    source: function (edge) { return edge.source; },
    target: function (edge) { return edge.target; },
    sourceWeight: function (edge) { return edge.value || 1; },
    targetWeight: function (edge) { return edge.value || 1; },
    sortBy: null, // optional, id | weight | frequency | {function}
};
/**
 * \u5904\u7406\u8282\u70B9\u7684value\u3001edges
 * @param nodeById
 * @param edges
 * @param options
 */
function processGraph(nodeById, edges, options) {
    (0,esm/* forIn */.U5)(nodeById, function (node, id) {
        // in edges, out edges
        node.inEdges = edges.filter(function (edge) { return "".concat(options.target(edge)) === "".concat(id); });
        node.outEdges = edges.filter(function (edge) { return "".concat(options.source(edge)) === "".concat(id); });
        // frequency
        node.edges = node.outEdges.concat(node.inEdges);
        node.frequency = node.edges.length;
        // weight
        node.value = 0;
        node.inEdges.forEach(function (edge) {
            node.value += options.targetWeight(edge);
        });
        node.outEdges.forEach(function (edge) {
            node.value += options.sourceWeight(edge);
        });
    });
}
/**
 * \u8282\u70B9\u6392\u5E8F
 * @param nodes
 * @param options
 */
function sortNodes(nodes, options) {
    var sortMethods = {
        weight: function (a, b) { return b.value - a.value; },
        frequency: function (a, b) { return b.frequency - a.frequency; },
        id: function (a, b) { return "".concat(options.id(a)).localeCompare("".concat(options.id(b))); },
    };
    var method = sortMethods[options.sortBy];
    if (!method && (0,esm/* isFunction */.mf)(options.sortBy)) {
        method = options.sortBy;
    }
    if (method) {
        nodes.sort(method);
    }
}
function layoutNodes(nodes, options) {
    var len = nodes.length;
    if (!len) {
        throw new TypeError("Invalid nodes: it's empty!");
    }
    if (options.weight) {
        var nodePaddingRatio_1 = options.nodePaddingRatio;
        if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
            throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');
        }
        var margin_1 = nodePaddingRatio_1 / (2 * len);
        var nodeWidthRatio_1 = options.nodeWidthRatio;
        if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
            throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');
        }
        var totalValue_1 = 0;
        nodes.forEach(function (node) {
            totalValue_1 += node.value;
        });
        nodes.forEach(function (node) {
            node.weight = node.value / totalValue_1;
            node.width = node.weight * (1 - nodePaddingRatio_1);
            node.height = nodeWidthRatio_1;
        });
        nodes.forEach(function (node, index) {
            // x
            var deltaX = 0;
            for (var i = index - 1; i >= 0; i--) {
                deltaX += nodes[i].width + 2 * margin_1;
            }
            var minX = (node.minX = margin_1 + deltaX);
            var maxX = (node.maxX = node.minX + node.width);
            var minY = (node.minY = options.y - nodeWidthRatio_1 / 2);
            var maxY = (node.maxY = minY + nodeWidthRatio_1);
            node.x = [minX, maxX, maxX, minX];
            node.y = [minY, minY, maxY, maxY];
            /* points
             * 3---2
             * |   |
             * 0---1
             */
            // node.x = minX + 0.5 * node.width;
            // node.y = options.y;
        });
    }
    else {
        var deltaX_1 = 1 / len;
        nodes.forEach(function (node, index) {
            node.x = (index + 0.5) * deltaX_1;
            node.y = options.y;
        });
    }
    return nodes;
}
function locatingEdges(nodeById, edges, options) {
    if (options.weight) {
        var valueById_1 = {};
        (0,esm/* forIn */.U5)(nodeById, function (node, id) {
            valueById_1[id] = node.value;
        });
        edges.forEach(function (edge) {
            var sId = options.source(edge);
            var tId = options.target(edge);
            var sNode = nodeById[sId];
            var tNode = nodeById[tId];
            if (sNode && tNode) {
                var sValue = valueById_1[sId];
                var currentSValue = options.sourceWeight(edge);
                var sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;
                var sEnd = sStart + (currentSValue / sNode.value) * sNode.width;
                valueById_1[sId] -= currentSValue;
                var tValue = valueById_1[tId];
                var currentTValue = options.targetWeight(edge);
                var tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;
                var tEnd = tStart + (currentTValue / tNode.value) * tNode.width;
                valueById_1[tId] -= currentTValue;
                var y = options.y;
                edge.x = [sStart, sEnd, tStart, tEnd];
                edge.y = [y, y, y, y];
                // \u5C06edge\u7684source\u4E0Etarget\u7684id\u6362\u4E3A sourceNode\u4E0EtargetNode
                edge.source = sNode;
                edge.target = tNode;
            }
        });
    }
    else {
        edges.forEach(function (edge) {
            var sNode = nodeById[options.source(edge)];
            var tNode = nodeById[options.target(edge)];
            if (sNode && tNode) {
                edge.x = [sNode.x, tNode.x];
                edge.y = [sNode.y, tNode.y];
                // \u5C06edge\u7684source\u4E0Etarget\u7684id\u6362\u4E3A sourceNode\u4E0EtargetNode
                edge.source = sNode;
                edge.target = tNode;
            }
        });
    }
    return edges;
}
function getDefaultOptions(options) {
    return (0,esm/* assign */.f0)({}, chord_DEFAULT_OPTIONS, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
    var options = getDefaultOptions(chordLayoutOptions);
    var nodeById = {};
    var nodes = chordLayoutInputData.nodes;
    var links = chordLayoutInputData.links;
    nodes.forEach(function (node) {
        var id = options.id(node);
        nodeById[id] = node;
    });
    processGraph(nodeById, links, options);
    sortNodes(nodes, options);
    var outputNodes = layoutNodes(nodes, options);
    var outputLinks = locatingEdges(nodeById, links, options);
    return {
        nodes: outputNodes,
        links: outputLinks,
    };
}
//# sourceMappingURL=chord.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/chord/constant.js

var constant_X_FIELD = 'x';
var constant_Y_FIELD = 'y';
var NODE_COLOR_FIELD = 'name';
var EDGE_COLOR_FIELD = 'source';
var chord_constant_DEFAULT_OPTIONS = {
    nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1,
    },
    edgeStyle: {
        opacity: 0.5,
        lineWidth: 2,
    },
    label: {
        fields: ['x', 'name'],
        callback: function (x, name) {
            var centerX = (x[0] + x[1]) / 2;
            var offsetX = centerX > 0.5 ? -4 : 4;
            return {
                offsetX: offsetX,
                content: name,
            };
        },
        labelEmit: true,
        style: {
            fill: '#8c8c8c',
        },
    },
    tooltip: {
        showTitle: false,
        showMarkers: false,
        fields: ['source', 'target', 'value', 'isNode'],
        // \u5185\u7F6E\uFF1Anode \u4E0D\u663E\u793A tooltip (\u4E1A\u52A1\u5C42\u81EA\u884C\u5904\u7406)\uFF0Cedge \u663E\u793A tooltip
        showContent: function (items) {
            return !(0,esm/* get */.U2)(items, [0, 'data', 'isNode']);
        },
        formatter: function (datum) {
            var source = datum.source, target = datum.target, value = datum.value;
            return {
                name: "".concat(source, " -> ").concat(target),
                value: value,
            };
        },
    },
    interactions: [
        {
            type: 'element-active',
        },
    ],
    weight: true,
    nodePaddingRatio: 0.1,
    nodeWidthRatio: 0.05,
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/chord/adaptor.js






function adaptor_transformData(params) {
    // \u5C06\u5F26\u56FE\u6570\u636E\u653E\u5230ext\u4E2D\uFF0CnodeGeometry edgeGeometry\u4F7F\u7528
    var options = params.options;
    var data = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a = options.rawFields, rawFields = _a === void 0 ? [] : _a;
    // \u5C06\u6570\u636E\u8F6C\u6362\u4E3Anode link\u683C\u5F0F
    var chordLayoutInputData = transformDataToNodeLinkData(data, sourceField, targetField, weightField);
    var _b = chordLayout({ weight: true, nodePaddingRatio: nodePaddingRatio, nodeWidthRatio: nodeWidthRatio }, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
    // 1. \u751F\u6210\u7ED8\u5236node\u4F7F\u7528\u6570\u636E
    var nodesData = nodes.map(function (node) {
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(node, (0,tslib_es6/* __spreadArray */.ev)(['id', 'x', 'y', 'name'], rawFields, true))), { isNode: true });
    });
    // 2. \u751F\u6210 edge \u4F7F\u7528\u6570\u636E \uFF08\u540C\u6851\u57FA\u56FE\uFF09
    var edgesData = links.map(function (link) {
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, (0,tslib_es6/* __spreadArray */.ev)(['x', 'y', 'value'], rawFields, true))), { isNode: false });
    });
    return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { ext: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params.ext), { 
            // \u5C06chordData\u653E\u5230ext\u4E2D\uFF0C\u65B9\u4FBF\u4E0B\u9762\u7684geometry\u4F7F\u7528
            chordData: { nodesData: nodesData, edgesData: edgesData } }) });
}
/**
 * scale\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function adaptor_scale(params) {
    var _a;
    var chart = params.chart;
    chart.scale((_a = {
            x: { sync: true, nice: true },
            y: { sync: true, nice: true, max: 1 }
        },
        _a[NODE_COLOR_FIELD] = { sync: 'color' },
        _a[EDGE_COLOR_FIELD] = { sync: 'color' },
        _a));
    return params;
}
/**
 * axis\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function chord_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
/**
 * legend\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function chord_adaptor_legend(params) {
    var chart = params.chart;
    chart.legend(false);
    return params;
}
/**
 * tooltip\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function chord_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    chart.tooltip(tooltip);
    return params;
}
/**
 * coordinate\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function chord_adaptor_coordinate(params) {
    var chart = params.chart;
    chart.coordinate('polar').reflect('y');
    return params;
}
/**
 * nodeGeometry\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function nodeGeometry(params) {
    // node view
    var chart = params.chart, options = params.options;
    var nodesData = params.ext.chordData.nodesData;
    var nodeStyle = options.nodeStyle, label = options.label, tooltip = options.tooltip;
    var nodeView = chart.createView();
    nodeView.data(nodesData);
    // \u9762
    polygon_polygon({
        chart: nodeView,
        options: {
            xField: constant_X_FIELD,
            yField: constant_Y_FIELD,
            seriesField: NODE_COLOR_FIELD,
            polygon: {
                style: nodeStyle,
            },
            label: label,
            tooltip: tooltip,
        },
    });
    return params;
}
/**
 * edgeGeometry\u914D\u7F6E
 * @param params \u53C2\u6570
 */
function edgeGeometry(params) {
    var chart = params.chart, options = params.options;
    var edgesData = params.ext.chordData.edgesData;
    var edgeStyle = options.edgeStyle, tooltip = options.tooltip;
    var edgeView = chart.createView();
    edgeView.data(edgesData);
    // edge
    var edgeOptions = {
        xField: constant_X_FIELD,
        yField: constant_Y_FIELD,
        seriesField: EDGE_COLOR_FIELD,
        edge: {
            style: edgeStyle,
            shape: 'arc',
        },
        tooltip: tooltip,
    };
    edge_edge({
        chart: edgeView,
        options: edgeOptions,
    });
    return params;
}
function chord_adaptor_animation(params) {
    var chart = params.chart, options = params.options;
    var animation = options.animation;
    addViewAnimation(chart, animation, getAllGeometriesRecursively(chart));
    return params;
}
/**
 * \u5F26\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function chord_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, adaptor_transformData, chord_adaptor_coordinate, adaptor_scale, chord_adaptor_axis, chord_adaptor_legend, chord_adaptor_tooltip, edgeGeometry, nodeGeometry, common_interaction, common_state, chord_adaptor_animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/chord/index.js




/**
 *  \u5F26\u56FE Chord
 */
var Chord = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Chord, _super);
    function Chord() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'chord';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9762\u79EF\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Chord.getDefaultOptions = function () {
        return chord_constant_DEFAULT_OPTIONS;
    };
    Chord.prototype.getDefaultOptions = function () {
        return Chord.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Chord.prototype.getSchemaAdaptor = function () {
        return chord_adaptor_adaptor;
    };
    return Chord;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/circle-packing/constant.js
/** \u9ED8\u8BA4\u7684\u6E90\u5B57\u6BB5 */
var RAW_FIELDS = ['x', 'y', 'r', 'name', 'value', 'path', 'depth'];
var circle_packing_constant_DEFAULT_OPTIONS = {
    // \u9ED8\u8BA4\u6309\u7167 name \u5B57\u6BB5\u5BF9\u989C\u8272\u8FDB\u884C\u5206\u7C7B
    colorField: 'name',
    autoFit: true,
    pointStyle: {
        lineWidth: 0,
        stroke: '#fff',
    },
    // \u9ED8\u8BA4\u4E0D\u5F00\u542F\u56FE\u4F8B
    legend: false,
    hierarchyConfig: {
        size: [1, 1],
        padding: 0,
    },
    label: {
        fields: ['name'],
        layout: {
            type: 'limit-in-shape',
        },
    },
    tooltip: {
        showMarkers: false,
        showTitle: false,
    },
    // \u9ED8\u8BA4\u4E0D\u53EF\u4EE5\u4E0B\u94BB
    drilldown: { enabled: false },
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/interactions/actions/drill-down.js




// \u9762\u5305\u5C51\u6587\u5B57\u548C\u5206\u5272\u7B26'/'\u4E4B\u95F4\u7684\u8DDD\u79BB
var PADDING = 4;
// \u9762\u5305\u5C51\u4F4D\u7F6E\u8DDD\u79BB\u6811\u56FE\u7684\u8DDD\u79BB
var PADDING_LEFT = 0;
// \u9762\u5305\u5C51\u4F4D\u7F6E\u8DDD\u79BB\u6811\u56FE\u7684\u9876\u90E8\u8DDD\u79BB
var drill_down_PADDING_TOP = 5;
/** Group name of breadCrumb: \u9762\u5305\u5C51 */
var BREAD_CRUMB_NAME = 'drilldown-bread-crumb';
// \u9762\u5305\u5C51\u9ED8\u8BA4\u914D\u7F6E
var DEFAULT_BREAD_CRUMB_CONFIG = {
    /** \u4F4D\u7F6E\uFF0C\u9ED8\u8BA4\uFF1A\u5DE6\u4E0A\u89D2 */
    position: 'top-left',
    dividerText: '/',
    textStyle: {
        fontSize: 12,
        fill: 'rgba(0, 0, 0, 0.65)',
        cursor: 'pointer',
    },
    activeTextStyle: {
        fill: '#87B5FF',
    },
};
/**
 * hierarchy \u6570\u636E\u8F6C\u6362\u7684\u53C2\u6570
 */
var HIERARCHY_DATA_TRANSFORM_PARAMS = 'hierarchy-data-transform-params';
/**
 * @description \u4E0B\u94BB\u4EA4\u4E92\u7684 action
 * @author liuzhenying
 *
 * \u9002\u7528\u4E8E\uFF1Ahierarchy plot
 */
var DrillDownAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DrillDownAction, _super);
    function DrillDownAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Action name */
        _this.name = 'drill-down';
        // \u5B58\u50A8\u5386\u53F2\u4E0B\u94BB\u6570\u636E
        _this.historyCache = [];
        // \u9762\u5305\u5C51 group
        _this.breadCrumbGroup = null;
        // \u9762\u5305\u5C51\u57FA\u7840\u914D\u7F6E
        _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
        return _this;
    }
    /**
     * \u70B9\u51FB\u4E8B\u4EF6, \u4E0B\u94BB\u6570\u636E\uFF0C\u5E76\u7ED8\u5236\u9762\u5305\u5C51
     */
    DrillDownAction.prototype.click = function () {
        var data = (0,esm/* get */.U2)(this.context, ['event', 'data', 'data']);
        if (!data)
            return false;
        this.drill(data);
        this.drawBreadCrumb();
    };
    /**
     * \u91CD\u7F6E\u4F4D\u7F6E\uFF0C\u521D\u59CB\u5316\u53CA\u89E6\u53D1 chart  afterchangesize \u56DE\u8C03\u65F6\u4F7F\u7528
     */
    DrillDownAction.prototype.resetPosition = function () {
        // \u5F53\u5728\u7B2C\u4E00\u5C42\u7EA7\u672A\u7ED8\u5236\u9762\u5305\u5C51\uFF0C\u6B64\u65F6 changedata \u89E6\u53D1 resetPosition \u51FD\u6570\uFF0C\u9700\u5224\u65AD this.breadCrumbGroup \u662F\u5426\u5B58\u5728
        if (!this.breadCrumbGroup)
            return;
        var coordinate = this.context.view.getCoordinate();
        var breadCrumbGroup = this.breadCrumbGroup;
        var bbox = breadCrumbGroup.getBBox();
        var position = this.getButtonCfg().position;
        // @todo \u540E\u7EED\u62BD\u53D6\u4E00\u4E2A\u51FD\u6570\u6765\u5904\u7406\uFF0C\u4EE5\u53CA\u589E\u52A0 margin \u6216\u8005 padding \u7684\u8BBE\u7F6E
        // \u975E polar \u7684\uFF0C\u9700\u8981\u4F7F\u7528 coordinate\uFF0C\u9664\u5374\u56FE\u8868\u7EC4\u4EF6
        var point = { x: coordinate.start.x, y: coordinate.end.y - (bbox.height + drill_down_PADDING_TOP * 2) };
        if (coordinate.isPolar) {
            // \u9ED8\u8BA4\uFF0C\u5DE6\u4E0A\u89D2\u76F4\u63A5\u51FA\u53D1
            point = { x: 0, y: 0 };
        }
        if (position === 'bottom-left') {
            // \u6D89\u53CA\u5230\u5750\u6807\u53CD\u8F6C\u7684\u95EE\u9898
            point = { x: coordinate.start.x, y: coordinate.start.y };
        }
        /** PADDING_LEFT, PADDING_TOP \u4E0E\u753B\u5E03\u8FB9\u7F18\u7684\u8DDD\u79BB */
        var matrix = Util.transform(null, [['t', point.x + PADDING_LEFT, point.y + bbox.height + drill_down_PADDING_TOP]]);
        breadCrumbGroup.setMatrix(matrix);
    };
    /**
     * \u8FD4\u56DE\u4E0A\u4E00\u5C42
     */
    DrillDownAction.prototype.back = function () {
        if ((0,esm/* size */.dp)(this.historyCache)) {
            this.backTo(this.historyCache.slice(0, -1));
        }
    };
    /**
     * \u91CD\u7F6E
     */
    DrillDownAction.prototype.reset = function () {
        if (this.historyCache[0]) {
            this.backTo(this.historyCache.slice(0, 1));
        }
        // \u6E05\u7A7A
        this.historyCache = [];
        this.hideCrumbGroup();
    };
    /**
     * \u4E0B\u94BB\u6570\u636E\u5E76\u66F4\u65B0 view \u663E\u793A\u5C42
     * @param nodeInfo \u4E0B\u94BB\u6570\u636E
     */
    DrillDownAction.prototype.drill = function (nodeInfo) {
        var view = this.context.view;
        var transformData = (0,esm/* get */.U2)(view, ['interactions', 'drill-down', 'cfg', 'transformData'], function (v) { return v; });
        // \u91CD\u65B0 update \u6570\u636E
        var drillData = transformData((0,tslib_es6/* __assign */.pi)({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
        view.changeData(drillData);
        // \u5B58\u50A8\u5386\u53F2\u8BB0\u5F55
        var historyCache = [];
        var node = nodeInfo;
        while (node) {
            var nodeData = node.data;
            historyCache.unshift({
                id: "".concat(nodeData.name, "_").concat(node.height, "_").concat(node.depth),
                name: nodeData.name,
                // children \u662F\u5B9E\u9645\u6570\u636E
                children: transformData((0,tslib_es6/* __assign */.pi)({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS])),
            });
            node = node.parent;
        }
        this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
    };
    /**
     * \u56DE\u9000\u4E8B\u4EF6\uFF0C\u70B9\u51FB\u9762\u5305\u5C51\u65F6\u89E6\u53D1
     * @param historyCache \u5F53\u524D\u8981\u56DE\u9000\u5230\u7684\u5386\u53F2
     */
    DrillDownAction.prototype.backTo = function (historyCache) {
        if (!historyCache || historyCache.length <= 0) {
            return;
        }
        var view = this.context.view;
        var data = (0,esm/* last */.Z$)(historyCache).children; // \u5904\u7406\u540E\u7684\u6570\u7EC4
        view.changeData(data);
        if (historyCache.length > 1) {
            this.historyCache = historyCache;
            this.drawBreadCrumb();
        }
        else {
            // \u6E05\u7A7A
            this.historyCache = [];
            this.hideCrumbGroup();
        }
    };
    /**
     * \u83B7\u53D6 mix \u9ED8\u8BA4\u7684\u914D\u7F6E\u548C\u7528\u6237\u914D\u7F6E
     */
    DrillDownAction.prototype.getButtonCfg = function () {
        var view = this.context.view;
        var drillDownConfig = (0,esm/* get */.U2)(view, ['interactions', 'drill-down', 'cfg', 'drillDownConfig']);
        return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
    };
    /**
     * \u663E\u793A\u9762\u5305\u5C51
     */
    DrillDownAction.prototype.drawBreadCrumb = function () {
        this.drawBreadCrumbGroup();
        this.resetPosition();
        this.breadCrumbGroup.show();
    };
    /**
     * \u7ED8\u5236 Button \u548C \u6587\u672C
     */
    DrillDownAction.prototype.drawBreadCrumbGroup = function () {
        var _this = this;
        var config = this.getButtonCfg();
        var cache = this.historyCache;
        // \u521D\u59CB\u5316\u9762\u5305\u5C51 group
        if (!this.breadCrumbGroup) {
            this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
                name: BREAD_CRUMB_NAME,
            });
        }
        else {
            this.breadCrumbGroup.clear();
        }
        // \u7ED8\u5236\u9762\u5305\u5C51
        var left = 0;
        cache.forEach(function (record, index) {
            // \u6DFB\u52A0\u6587\u672C
            var textShape = _this.breadCrumbGroup.addShape({
                type: 'text',
                id: record.id,
                name: "".concat(BREAD_CRUMB_NAME, "_").concat(record.name, "_text"),
                attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ text: index === 0 && !(0,esm/* isNil */.UM)(config.rootText) ? config.rootText : record.name }, config.textStyle), { x: left, y: 0 }),
            });
            var textShapeBox = textShape.getBBox();
            left += textShapeBox.width + PADDING;
            // \u589E\u52A0\u6587\u672C\u4E8B\u4EF6
            textShape.on('click', function (event) {
                var _a;
                var targetId = event.target.get('id');
                if (targetId !== ((_a = (0,esm/* last */.Z$)(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
                    var newHistoryCache = cache.slice(0, cache.findIndex(function (d) { return d.id === targetId; }) + 1);
                    _this.backTo(newHistoryCache);
                }
            });
            // active \u6548\u679C\u5185\u7F6E
            textShape.on('mouseenter', function (event) {
                var _a;
                var targetId = event.target.get('id');
                if (targetId !== ((_a = (0,esm/* last */.Z$)(cache)) === null || _a === void 0 ? void 0 : _a.id)) {
                    textShape.attr(config.activeTextStyle);
                }
                else {
                    textShape.attr({ cursor: 'default' });
                }
            });
            textShape.on('mouseleave', function () {
                textShape.attr(config.textStyle);
            });
            if (index < cache.length - 1) {
                // \u6DFB\u52A0\u53CD\u659C\u6760
                var dividerShape = _this.breadCrumbGroup.addShape({
                    type: 'text',
                    name: "".concat(config.name, "_").concat(record.name, "_divider"),
                    attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ text: config.dividerText }, config.textStyle), { x: left, y: 0 }),
                });
                var dividerBox = dividerShape.getBBox();
                left += dividerBox.width + PADDING;
            }
        });
    };
    /**
     * \u9690\u85CF\u9762\u5305\u5C51
     */
    DrillDownAction.prototype.hideCrumbGroup = function () {
        if (this.breadCrumbGroup) {
            this.breadCrumbGroup.hide();
        }
    };
    /**
     * @override
     * destroy: \u9500\u6BC1\u8D44\u6E90
     */
    DrillDownAction.prototype.destroy = function () {
        if (this.breadCrumbGroup) {
            this.breadCrumbGroup.remove();
        }
        _super.prototype.destroy.call(this);
    };
    return DrillDownAction;
}(action_base));

//# sourceMappingURL=drill-down.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/array.js

/* harmony default export */ function array(x) {
  return typeof_default()(x) === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like
  : Array.from(x); // Map, Set, iterable, string, or anything else
}

function shuffle(array) {
  var m = array.length,
    t,
    i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }
  return array;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/pack/enclose.js

/* harmony default export */ function enclose(circles) {
  var i = 0,
    n = (circles = shuffle(Array.from(circles))).length,
    B = [],
    p,
    e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }
  return e;
}
function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x21 = x2 - x1,
    y21 = y2 - y1,
    r21 = r2 - r1,
    l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x,
    y1 = a.y,
    r1 = a.r,
    x2 = b.x,
    y2 = b.y,
    r2 = b.r,
    x3 = c.x,
    y3 = c.y,
    r3 = c.r,
    a2 = x1 - x2,
    a3 = x1 - x3,
    b2 = y1 - y2,
    b3 = y1 - y3,
    c2 = r2 - r1,
    c3 = r3 - r1,
    d1 = x1 * x1 + y1 * y1 - r1 * r1,
    d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
    d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
    ab = a3 * b2 - a2 * b3,
    xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
    xb = (b3 * c2 - b2 * c3) / ab,
    ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
    yb = (a2 * c3 - a3 * c2) / ab,
    A = xb * xb + yb * yb - 1,
    B = 2 * (r1 + xa * xb + ya * yb),
    C = xa * xa + ya * ya - r1 * r1,
    r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/pack/siblings.js


function place(b, a, c) {
  var dx = b.x - a.x,
    x,
    a2,
    dy = b.y - a.y,
    y,
    b2,
    d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6,
    dx = b.x - a.x,
    dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._,
    b = node.next._,
    ab = a.r + b.r,
    dx = (a.x * b.r + b.x * a.r) / ab,
    dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array(circles)).length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle\u2026
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // \u201CCloseness\u201D is determined by linear distance along the front-chain.
    // \u201CAhead\u201D or \u201Cbehind\u201D is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b;
  while ((c = c.next) !== b) a.push(c._);
  c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;
  return c.r;
}
/* harmony default export */ function siblings(circles) {
  packEnclose(circles);
  return circles;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
/* harmony default export */ function constant(x) {
  return function () {
    return x;
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/pack/index.js



function defaultRadius(d) {
  return Math.sqrt(d.value);
}
/* harmony default export */ function pack() {
  var radius = null,
    dx = 1,
    dy = 1,
    padding = constantZero;
  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack.radius = function (x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };
  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };
  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
        i,
        n = children.length,
        r = padding(node) * k || 0,
        e;
      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(9783);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum = 0,
    children = node.children,
    i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}
/* harmony default export */ function hierarchy_count() {
  return this.eachAfter(count);
}
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
var createForOfIteratorHelper = __webpack_require__(96695);
var createForOfIteratorHelper_default = /*#__PURE__*/__webpack_require__.n(createForOfIteratorHelper);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/each.js

/* harmony default export */ function hierarchy_each(callback, that) {
  var index = -1;
  var _iterator = createForOfIteratorHelper_default()(this),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      callback.call(that, node, ++index, this);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return this;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
/* harmony default export */ function eachBefore(callback, that) {
  var node = this,
    nodes = [node],
    children,
    i,
    index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
/* harmony default export */ function eachAfter(callback, that) {
  var node = this,
    nodes = [node],
    next = [],
    children,
    i,
    n,
    index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/find.js

/* harmony default export */ function find(callback, that) {
  var index = -1;
  var _iterator = createForOfIteratorHelper_default()(this),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      if (callback.call(that, node, ++index, this)) {
        return node;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/sum.js
/* harmony default export */ function sum(value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
      children = node.children,
      i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/sort.js
/* harmony default export */ function sort(compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/path.js
/* harmony default export */ function hierarchy_path(end) {
  var start = this,
    ancestor = leastCommonAncestor(start, end),
    nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
    bNodes = b.ancestors(),
    c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
/* harmony default export */ function ancestors() {
  var node = this,
    nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/descendants.js
/* harmony default export */ function descendants() {
  return Array.from(this);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/leaves.js
/* harmony default export */ function leaves() {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/links.js
/* harmony default export */ function links() {
  var root = this,
    links = [];
  root.each(function (node) {
    if (node !== root) {
      // Don\u2019t include the root\u2019s parent, if any.
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var regeneratorRuntime = __webpack_require__(15009);
var regeneratorRuntime_default = /*#__PURE__*/__webpack_require__.n(regeneratorRuntime);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/iterator.js

var _marked = /*#__PURE__*/regeneratorRuntime_default()().mark(_callee);
function _callee() {
  var node, current, next, children, i, n;
  return regeneratorRuntime_default()().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        node = this, next = [node];
      case 1:
        current = next.reverse(), next = [];
      case 2:
        if (!(node = current.pop())) {
          _context.next = 8;
          break;
        }
        _context.next = 5;
        return node;
      case 5:
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
        }
        _context.next = 2;
        break;
      case 8:
        if (next.length) {
          _context.next = 1;
          break;
        }
      case 9:
      case "end":
        return _context.stop();
    }
  }, _marked, this);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/hierarchy/index.js














function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }
  var root = new hierarchy_Node(data),
    node,
    nodes = [root],
    child,
    childs,
    i,
    n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new hierarchy_Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do node.height = height; while ((node = node.parent) && node.height < ++height);
}
function hierarchy_Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
hierarchy_Node.prototype = hierarchy.prototype = defineProperty_default()({
  constructor: hierarchy_Node,
  count: hierarchy_count,
  each: hierarchy_each,
  eachAfter: eachAfter,
  eachBefore: eachBefore,
  find: find,
  sum: sum,
  sort: sort,
  path: hierarchy_path,
  ancestors: ancestors,
  descendants: descendants,
  leaves: leaves,
  links: links,
  copy: node_copy
}, Symbol.iterator, _callee);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/hierarchy/util.js

/** export \u4E00\u4E9B\u5B57\u6BB5\u5E38\u91CF */
/** \u5728\u540C\u5C42\u7EA7\uFF0C\u540C\u4E00\u7236\u8282\u70B9\u4E0B\u7684\u8282\u70B9\u7D22\u5F15\u987A\u5E8F */
var NODE_INDEX_FIELD = 'nodeIndex';
/** child \u8282\u70B9\u6570\u91CF */
var CHILD_NODE_COUNT = 'childNodeCount';
/** \u8282\u70B9\u7684\u7956\u5148\u8282\u70B9 */
var NODE_ANCESTORS_FIELD = 'nodeAncestor';
var INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';
function getField(options, defaultField) {
    var field = options.field, fields = options.fields;
    if ((0,esm/* isString */.HD)(field)) {
        return field;
    }
    if ((0,esm/* isArray */.kJ)(field)) {
        console.warn(INVALID_FIELD_ERR_MSG);
        return field[0];
    }
    console.warn("".concat(INVALID_FIELD_ERR_MSG, " will try to get fields instead."));
    if ((0,esm/* isString */.HD)(fields)) {
        return fields;
    }
    if ((0,esm/* isArray */.kJ)(fields) && fields.length) {
        return fields[0];
    }
    if (defaultField) {
        return defaultField;
    }
    throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
    var nodes = [];
    if (root && root.each) {
        var parent_1;
        var index_1;
        // d3-hierarchy: Invokes the specified function for node and each descendant in **breadth-first order**
        root.each(function (node) {
            var _a, _b;
            if (node.parent !== parent_1) {
                parent_1 = node.parent;
                index_1 = 0;
            }
            else {
                index_1 += 1;
            }
            var ancestors = (0,esm/* filter */.hX)((((_a = node.ancestors) === null || _a === void 0 ? void 0 : _a.call(node)) || []).map(function (d) { return nodes.find(function (n) { return n.name === d.name; }) || d; }), function (_a) {
                var depth = _a.depth;
                return depth > 0 && depth < node.depth;
            });
            node[NODE_ANCESTORS_FIELD] = ancestors;
            node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
            node[NODE_INDEX_FIELD] = index_1;
            nodes.push(node);
        });
    }
    else if (root && root.eachNode) {
        // @antv/hierarchy
        root.eachNode(function (node) {
            nodes.push(node);
        });
    }
    return nodes;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/hierarchy/pack.js



var pack_DEFAULT_OPTIONS = {
    field: 'value',
    as: ['x', 'y', 'r'],
    // \u9ED8\u8BA4\u964D\u5E8F
    sort: function (a, b) { return b.value - a.value; },
};
function pack_pack(data, options) {
    options = (0,esm/* assign */.f0)({}, pack_DEFAULT_OPTIONS, options);
    var as = options.as;
    if (!(0,esm/* isArray */.kJ)(as) || as.length !== 3) {
        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
    }
    var field;
    try {
        field = getField(options);
    }
    catch (e) {
        console.warn(e);
    }
    var packLayout = function (data) {
        return pack().size(options.size).padding(options.padding)(hierarchy(data)
            .sum(function (d) { return d[field]; })
            .sort(options.sort));
    };
    var root = packLayout(data);
    var x = as[0];
    var y = as[1];
    var r = as[2];
    root.each(function (node) {
        node[x] = node.x;
        node[y] = node.y;
        node[r] = node.r;
    });
    return getAllNodes(root);
}
//# sourceMappingURL=pack.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/circle-packing/utils.js





/**
 * circle-packing \u6570\u636E\u8F6C\u6362
 * @param options
 */
function circle_packing_utils_transformData(options) {
    var data = options.data, hierarchyConfig = options.hierarchyConfig, _a = options.rawFields, rawFields = _a === void 0 ? [] : _a, enableDrillDown = options.enableDrillDown;
    var nodes = pack_pack(data, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, hierarchyConfig), { field: 'value', as: ['x', 'y', 'r'] }));
    var result = [];
    nodes.forEach(function (node) {
        var _a;
        var path = node.data.name;
        var ancestorNode = (0,tslib_es6/* __assign */.pi)({}, node);
        while (ancestorNode.depth > 1) {
            path = "".concat((_a = ancestorNode.parent.data) === null || _a === void 0 ? void 0 : _a.name, " / ").concat(path);
            ancestorNode = ancestorNode.parent;
        }
        // \u5F00\u542F\u4E0B\u94BB\uFF0C\u4EC5\u52A0\u8F7D depth <= 2 \u7684\u6570\u636E (\u52A0\u8F7D\u4E24\u5C42)
        if (enableDrillDown && node.depth > 2) {
            return null;
        }
        var nodeInfo = deepAssign({}, node.data, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(node.data, rawFields)), { path: path }), node));
        nodeInfo.ext = hierarchyConfig;
        nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig: hierarchyConfig, rawFields: rawFields, enableDrillDown: enableDrillDown };
        result.push(nodeInfo);
    });
    return result;
}
/**
 * \u6839\u636E\u4F20\u5165\u7684 padding \u548C \u73B0\u6709\u7684 \u753B\u5E03\u5927\u5C0F\uFF0C \u8F93\u51FA\u9488\u5BF9\u5706\u5F62\u89C6\u56FE\u5E03\u5C40\u9700\u8981\u7684 finalPadding \u4EE5\u53CA finalSize
 * @param params
 */
function resolvePaddingForCircle(padding, appendPadding, containerSize) {
    var tempPadding = resolveAllPadding([padding, appendPadding]);
    var top = tempPadding[0], right = tempPadding[1], bottom = tempPadding[2], left = tempPadding[3]; // \u6CA1\u8BBE\u5B9A\uFF0C\u9ED8\u8BA4\u662F [0, 0, 0, 0]
    var width = containerSize.width, height = containerSize.height;
    // \u6709\u4E86 tempPadding \u4ECB\u5165\u4EE5\u540E\uFF0C\u8BA1\u7B97\u51FAcoordinate\u8303\u56F4\u5BBD\u9AD8\u7684\u6700\u5C0F\u503C minSize = circle-packing\u7684\u76F4\u5F84
    var wSize = width - (left + right);
    var hSize = height - (top + bottom);
    var minSize = Math.min(wSize, hSize); // circle-packing\u7684\u76F4\u5F84
    // \u5F97\u5230\u5C45\u4E2D\u540E\u5404\u65B9\u5411\u5269\u4F59\u7684 padding
    var restWidthPadding = (wSize - minSize) / 2;
    var restHeightPadding = (hSize - minSize) / 2;
    var finalTop = top + restHeightPadding;
    var finalRight = right + restWidthPadding;
    var finalBottom = bottom + restHeightPadding;
    var finalLeft = left + restWidthPadding;
    var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];
    var finalSize = minSize < 0 ? 0 : minSize; // \u9632\u6B62\u4E3A\u8D1F\u6570
    return { finalPadding: finalPadding, finalSize: finalSize };
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/circle-packing/adaptor.js








/**
 * \u83B7\u53D6\u9ED8\u8BA4 option
 * @param params
 */
function circle_packing_adaptor_defaultOptions(params) {
    var chart = params.chart;
    var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
    return deepAssign({
        options: {
            size: function (_a) {
                var r = _a.r;
                return r * diameter;
            }, // \u5F53autofit\uFF1Afalse\u65F6\uFF0C\u9ED8\u8BA4\u7ED9\u56FA\u5B9A\u534A\u5F84
        },
    }, params);
}
/**
 * padding \u914D\u7F6E
 * @param params
 */
function padding(params) {
    var options = params.options, chart = params.chart;
    // \u901A\u8FC7\u6539\u53D8 padding\uFF0C\u4FEE\u6539 coordinate \u7684\u7ED8\u5236\u533A\u57DF
    var containerSize = chart.viewBBox;
    var padding = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
    var tempAppendPadding = appendPadding;
    if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
        var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, (0,esm/* get */.U2)(drilldown, ['breadCrumb', 'position']));
        tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
    }
    var finalPadding = resolvePaddingForCircle(padding, tempAppendPadding, containerSize).finalPadding;
    chart.padding = finalPadding;
    chart.appendPadding = 0;
    return params;
}
/**
 * \u5B57\u6BB5
 * @param params
 */
function circle_packing_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var padding = chart.padding, appendPadding = chart.appendPadding;
    var color = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a = options.rawFields, rawFields = _a === void 0 ? [] : _a, drilldown = options.drilldown;
    var data = circle_packing_utils_transformData({
        data: options.data,
        hierarchyConfig: hierarchyConfig,
        enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
        rawFields: rawFields,
    });
    chart.data(data);
    var containerSize = chart.viewBBox;
    var finalSize = resolvePaddingForCircle(padding, appendPadding, containerSize).finalSize;
    // \u6709sizeField\u7684\u65F6\u5019\uFF0C\u4F8B\u5982 value \uFF0C\u53EF\u4EE5\u9009\u62E9\u6620\u5C04 size \u51FD\u6570\uFF0C\u81EA\u5DF1\u8BA1\u7B97\u51FA\u6620\u5C04\u7684\u534A\u5F84
    var circleSize = function (_a) {
        var r = _a.r;
        return r * finalSize;
    }; // \u9ED8\u8BA4\u914D\u7F6E
    if (sizeField) {
        circleSize = function (d) { return d[sizeField] * finalSize; }; // \u76EE\u524D\u53EA\u6709 r \u901A\u9053\u6620\u5C04\u6548\u679C\u4F1A\u6B63\u5E38
    }
    // geometry
    point_point(deepAssign({}, params, {
        options: {
            xField: 'x',
            yField: 'y',
            seriesField: colorField,
            sizeField: sizeField,
            rawFields: (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], RAW_FIELDS, true), rawFields, true),
            point: {
                color: color,
                style: pointStyle,
                shape: 'circle',
                size: circleSize,
            },
        },
    }));
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function circle_packing_adaptor_meta(params) {
    return flow(common_scale({}, {
        // \u5FC5\u987B\u5F3A\u5236\u4E3A nice
        x: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
        y: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
    }))(params);
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function circle_packing_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip === false) {
        chart.tooltip(false);
    }
    else {
        var tooltipOptions = tooltip;
        // \u8BBE\u7F6E\u4E86 fields\uFF0C\u5C31\u4E0D\u8FDB\u884C customItems \u4E86; \u8BBE\u7F6E formatter \u65F6\uFF0C\u9700\u8981\u642D\u914D fields
        if (!(0,esm/* get */.U2)(tooltip, 'fields')) {
            tooltipOptions = deepAssign({}, {
                customItems: function (items) {
                    return items.map(function (item) {
                        var scales = (0,esm/* get */.U2)(chart.getOptions(), 'scales');
                        var nameFormatter = (0,esm/* get */.U2)(scales, ['name', 'formatter'], function (v) { return v; });
                        var valueFormatter = (0,esm/* get */.U2)(scales, ['value', 'formatter'], function (v) { return v; });
                        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { name: nameFormatter(item.data.name), value: valueFormatter(item.data.value) });
                    });
                },
            }, tooltipOptions);
        }
        chart.tooltip(tooltipOptions);
    }
    return params;
}
/**
 * \u5750\u6807\u8F74, \u9ED8\u8BA4\u5173\u95ED
 * @param params
 */
function circle_packing_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
function adaptorInteraction(options) {
    var drilldown = options.drilldown, _a = options.interactions, interactions = _a === void 0 ? [] : _a;
    if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
        return deepAssign({}, options, {
            interactions: (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], interactions, true), [
                {
                    type: 'drill-down',
                    cfg: { drillDownConfig: drilldown, transformData: circle_packing_utils_transformData, enableDrillDown: true },
                },
            ], false),
        });
    }
    return options;
}
/**
 * \u4EA4\u4E92\u914D\u7F6E
 * @param params
 * @returns
 */
function circle_packing_adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    common_interaction({
        chart: chart,
        options: adaptorInteraction(options),
    });
    return params;
}
/**
 * \u77E9\u5F62\u6811\u56FE
 * @param chart
 * @param options
 */
function circle_packing_adaptor_adaptor(params) {
    return flow(pattern('pointStyle'), circle_packing_adaptor_defaultOptions, padding, common_theme, circle_packing_adaptor_meta, circle_packing_adaptor_geometry, circle_packing_adaptor_axis, common_legend, circle_packing_adaptor_tooltip, circle_packing_adaptor_interaction, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/interactions/drill-down.js



/**
 * \u5224\u65AD\u662F\u5426\u4E3A\u7236\u8282\u70B9
 */
function isParentNode(context) {
    var data = (0,esm/* get */.U2)(context, ['event', 'data', 'data'], {});
    return (0,esm/* isArray */.kJ)(data.children) && data.children.length > 0;
}
/**
 * \u5224\u65AD\u662F\u5426\u5728\u4E2D\u5FC3
 */
function inCenter(context) {
    var coordinate = context.view.getCoordinate();
    var innerRadius = coordinate.innerRadius;
    if (innerRadius) {
        var _a = context.event, x = _a.x, y = _a.y;
        var _b = coordinate.center, centerX = _b.x, centerY = _b.y;
        var r = coordinate.getRadius() * innerRadius;
        var distance = Math.sqrt(Math.pow((centerX - x), 2) + Math.pow((centerY - y), 2));
        return distance < r;
    }
    return false;
}
registerAction('drill-down-action', DrillDownAction);
registerInteraction('drill-down', {
    showEnable: [
        { trigger: 'element:mouseenter', action: 'cursor:pointer', isEnable: isParentNode },
        { trigger: 'element:mouseleave', action: 'cursor:default' },
        // \u4E2D\u5FC3\u5904\uFF0C\u80AF\u5B9A\u4F1A\u89E6\u53D1 element:mouseleave \u64CD\u4F5C
        { trigger: 'element:mouseleave', action: 'cursor:pointer', isEnable: inCenter },
    ],
    start: [
        {
            trigger: 'element:click',
            isEnable: isParentNode,
            action: ['drill-down-action:click'],
        },
        {
            trigger: 'afterchangesize',
            action: ['drill-down-action:resetPosition'],
        },
        {
            // \u70B9\u51FB\u4E2D\u5FC3\uFF0C\u8FD4\u56DE\u4E0A\u4E00\u5C42
            trigger: 'click',
            isEnable: inCenter,
            action: ['drill-down-action:back'],
        },
    ],
});
//# sourceMappingURL=drill-down.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/circle-packing/interactions/index.js
/** \u5F15\u5165 drill-down \u4EA4\u4E92 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/circle-packing/index.js





/**
 *  CirclePacking
 * @usage hierarchy, proportions
 */
var CirclePacking = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(CirclePacking, _super);
    function CirclePacking() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'circle-packing';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9762\u79EF\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    CirclePacking.getDefaultOptions = function () {
        return circle_packing_constant_DEFAULT_OPTIONS;
    };
    CirclePacking.prototype.getDefaultOptions = function () {
        return CirclePacking.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    CirclePacking.prototype.getSchemaAdaptor = function () {
        return circle_packing_adaptor_adaptor;
    };
    /**
     * \u8986\u5199\u7236\u7C7B\u7684\u65B9\u6CD5
     */
    CirclePacking.prototype.triggerResize = function () {
        if (!this.chart.destroyed) {
            // \u9996\u5148\u81EA\u9002\u5E94\u5BB9\u5668\u7684\u5BBD\u9AD8
            this.chart.forceFit(); // g2 \u5185\u90E8\u6267\u884C changeSize\uFF0CchangeSize \u4E2D\u6267\u884C render(true)
            this.chart.clear();
            this.execAdaptor(); // \u6838\u5FC3\uFF1A\u5BBD\u9AD8\u66F4\u65B0\u4E4B\u540E\u8BA1\u7B97padding
            // \u6E32\u67D3
            this.chart.render(true);
        }
    };
    return CirclePacking;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/constant.js

var LEFT_AXES_VIEW = 'left-axes-view';
var RIGHT_AXES_VIEW = 'right-axes-view';
var DEFAULT_YAXIS_CONFIG = {
    nice: true,
    label: {
        autoHide: true,
        autoRotate: false,
    },
};
var DEFAULT_LEFT_YAXIS_CONFIG = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, DEFAULT_YAXIS_CONFIG), { position: 'left' });
var DEFAULT_RIGHT_YAXIS_CONFIG = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, DEFAULT_YAXIS_CONFIG), { position: 'right', grid: null });
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/types.js
var AxisType;
(function (AxisType) {
    AxisType["Left"] = "Left";
    AxisType["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function (DualAxesGeometry) {
    DualAxesGeometry["Line"] = "line";
    DualAxesGeometry["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/util/option.js





/**
 * \u6839\u636E GeometryOption \u5224\u65AD geometry \u662F\u5426\u4E3A line
 */
function isLine(geometryOption) {
    return (0,esm/* get */.U2)(geometryOption, 'geometry') === DualAxesGeometry.Line;
}
/**
 * \u6839\u636E GeometryOption \u5224\u65AD geometry \u662F\u5426\u4E3A Column
 */
function isColumn(geometryOption) {
    return (0,esm/* get */.U2)(geometryOption, 'geometry') === DualAxesGeometry.Column;
}
/**
 * \u83B7\u53D6 GeometryOption
 * @param geometryOption
 * @param axis
 */
function getGeometryOption(xField, yField, geometryOption) {
    // \u7A7A\u9ED8\u8BA4\u4E3A\u7EBF
    return isColumn(geometryOption)
        ? deepAssign({}, {
            geometry: DualAxesGeometry.Column,
            label: geometryOption.label && geometryOption.isRange
                ? {
                    content: function (item) {
                        var _a;
                        return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
                    },
                }
                : undefined,
        }, geometryOption)
        : (0,tslib_es6/* __assign */.pi)({ geometry: DualAxesGeometry.Line }, geometryOption);
}
/**
 * \u517C\u5BB9\u4E00\u4E9B\u5C5E\u6027 \u4E3A arr \u548C obj \u7684\u4E24\u79CD\u60C5\u51B5\uFF0C \u5982 yAxis\uFF0Cannotations
 * \u4E3A\u4E86\u9632\u6B62\u5DE6\u53F3 yField \u76F8\u540C\uFF0C\u5BFC\u81F4\u53D8\u6210 object \u4E4B\u540E\u88AB\u8986\u76D6\uFF0C\u6240\u4EE5\u90FD\u8F6C\u53D8\u6210\u6570\u7EC4\u7684\u5F62\u5F0F
 * @param yField
 * @param transformAttribute
 */
function transformObjectToArray(yField, transformAttribute) {
    var y1 = yField[0], y2 = yField[1];
    if ((0,esm/* isArray */.kJ)(transformAttribute)) {
        // \u5C06\u6570\u7EC4\u8865\u9F50\u4E3A\u4E24\u4E2A
        var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
        return [a1_1, a2_1];
    }
    var a1 = (0,esm/* get */.U2)(transformAttribute, y1);
    var a2 = (0,esm/* get */.U2)(transformAttribute, y2);
    return [a1, a2];
}
/**
 * \u83B7\u53D6\u9ED8\u8BA4\u503C
 * @param yAxis
 * @param axisType
 */
function getYAxisWithDefault(yAxis, axisType) {
    if (axisType === AxisType.Left) {
        return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
    }
    else if (axisType === AxisType.Right) {
        return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
    }
    return yAxis;
}
//# sourceMappingURL=option.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/util/geometry.js






/**
 * \u7ED8\u5236\u5355\u4E2A\u56FE\u5F62
 * @param params
 */
function drawSingleGeometry(params) {
    var options = params.options, chart = params.chart;
    var geometryOption = options.geometryOption;
    var isStack = geometryOption.isStack, color = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
    var FIELD_KEY = ['xField', 'yField'];
    if (isLine(geometryOption)) {
        // \u7ED8\u5236\u7EBF
        line_line(deepAssign({}, params, {
            options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(options, FIELD_KEY)), geometryOption), { line: {
                    color: geometryOption.color,
                    style: geometryOption.lineStyle,
                } }),
        }));
        // \u7ED8\u5236\u70B9
        point_point(deepAssign({}, params, {
            options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && (0,tslib_es6/* __assign */.pi)({ color: color, shape: 'circle' }, geometryOption.point) }),
        }));
        // adjust
        var adjust_1 = [];
        if (isGroup) {
            adjust_1.push({
                type: 'dodge',
                dodgeBy: groupField || seriesField,
                customOffset: 0,
            });
        }
        if (isStack) {
            adjust_1.push({
                type: 'stack',
            });
        }
        if (adjust_1.length) {
            (0,esm/* each */.S6)(chart.geometries, function (g) {
                g.adjust(adjust_1);
            });
        }
    }
    if (isColumn(geometryOption)) {
        column_adaptor_adaptor(deepAssign({}, params, {
            options: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(options, FIELD_KEY)), geometryOption), { widthRatio: geometryOption.columnWidthRatio, interval: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(geometryOption, ['color'])), { style: geometryOption.columnStyle }) }),
        }));
    }
    return params;
}
//# sourceMappingURL=geometry.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/util/legend.js




/**
 * \u83B7\u53D6 view \u7684 legendItem\uFF0C\u4F9B\u5B58\u5728\u4E0D\u542B\u6709 seriesField \u7684\u56FE\u5F62\u4F7F\u7528
 * @param params
 */
function getViewLegendItems(params) {
    var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend = params.legend;
    var userMarker = (0,esm/* get */.U2)(legend, 'marker');
    var geometry = findGeometry(view, isLine(geometryOption) ? 'line' : 'interval');
    if (!geometryOption.seriesField) {
        var legendItemName = (0,esm/* get */.U2)(view, "options.scales.".concat(yField, ".alias")) || yField;
        // \u8FD4\u56DE g2 \u8BBE\u7F6E\u7684\u56FE\u4F8B
        var colorAttribute = geometry.getAttribute('color');
        var color = view.getTheme().defaultColor;
        if (colorAttribute) {
            color = Util.getMappingValue(colorAttribute, legendItemName, (0,esm/* get */.U2)(colorAttribute, ['values', 0], color));
        }
        var marker = ((0,esm/* isFunction */.mf)(userMarker)
            ? userMarker
            : !(0,esm/* isEmpty */.xb)(userMarker) &&
                deepAssign({}, {
                    style: {
                        stroke: color,
                        fill: color,
                    },
                }, userMarker)) ||
            (isLine(geometryOption)
                ? {
                    symbol: function (x, y, r) {
                        return [
                            ['M', x - r, y],
                            ['L', x + r, y],
                        ];
                    },
                    style: {
                        lineWidth: 2,
                        r: 6,
                        stroke: color,
                    },
                }
                : {
                    symbol: 'square',
                    style: {
                        fill: color,
                    },
                });
        return [
            {
                value: yField,
                name: legendItemName,
                marker: marker,
                isGeometry: true,
                viewId: view.id,
            },
        ];
    }
    var attributes = geometry.getGroupAttributes();
    return (0,esm/* reduce */.u4)(attributes, function (items, attr) {
        var attrItems = Util.getLegendItems(view, geometry, attr, view.getTheme(), userMarker);
        return items.concat(attrItems);
    }, []);
}
//# sourceMappingURL=legend.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/util/render-sider.js


/**
 * \u53F3\u4FA7 View \u8FDB\u884C slider \u8FC7\u6EE4
 * \u7531\u4E8E\u53CC\u8F74\u56FE\u662F\u591A View , \u9700\u8981\u76D1\u542C\u5DE6\u4FA7 Slider \u7684 change \u4E8B\u4EF6\u6765\u540C\u6B65\u53F3\u4FA7 View
 * @param { View } view \u53F3\u4FA7\u89C6\u56FE
 * @param { number[] } sliderValue \u6ED1\u5757\u5F53\u524D\u503C
 * @returns void
 */
var doSliderFilter = function (view, sliderValue) {
    var min = sliderValue[0], max = sliderValue[1];
    var data = view.getOptions().data;
    var xScale = view.getXScale();
    var dataSize = (0,esm/* size */.dp)(data);
    if (!xScale || !dataSize) {
        return;
    }
    var isHorizontal = true;
    var values = (0,esm/* valuesOfKey */.I)(data, xScale.field);
    var xValues = isHorizontal ? values : values.reverse();
    var xTickCount = (0,esm/* size */.dp)(xValues);
    var minIndex = Math.floor(min * (xTickCount - 1));
    var maxIndex = Math.floor(max * (xTickCount - 1));
    // \u589E\u52A0 x \u8F74\u7684\u8FC7\u6EE4\u5668
    view.filter(xScale.field, function (value) {
        var idx = xValues.indexOf(value);
        return idx > -1 ? number_isBetween(idx, minIndex, maxIndex) : true;
    });
    view.getRootView().render(true);
};
//# sourceMappingURL=render-sider.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/adaptor.js












/**
 * transformOptions\uFF0C\u53CC\u8F74\u56FE\u6574\u4F53\u7684\u53D6\u53C2\u903B\u8F91\u5982\u4E0B
 * 1. get index getOptions: \u5BF9\u5E94\u7684\u662F\u9ED8\u8BA4\u7684\u56FE\u8868\u53C2\u6570\uFF0C\u5982 appendPadding\uFF0CsyncView \u7B49
 * 2. get adpator transformOption: \u5BF9\u5E94\u7684\u662F\u53CC\u8F74\u56FE\u7684\u9ED8\u8BA4\u53C2\u6570\uFF0CdeepAssign \u4F18\u5148\u7EA7\u4ECE\u4F4E\u5230\u9AD8\u5982\u4E0B
 *    2.1 defaultoption\uFF0C\u5982 tooltip\uFF0Clegend
 *    2.2 \u7528\u6237\u586B\u5199 options
 *    2.3 \u6839\u636E\u7528\u6237\u586B\u5199\u7684 options \u8865\u5145\u7684\u6570\u7EC4\u578B options\uFF0C\u5982 yaxis\uFF0CGeometryOption\uFF0C\u56E0\u4E3A deepAssign \u65E0\u6CD5 assign \u6570\u7EC4
 *
 * @param params
 */
function adaptor_transformOptions(params) {
    var _a;
    var options = params.options;
    var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
    var allLine = (0,esm/* every */.yW)(geometryOptions, function (_a) {
        var geometry = _a.geometry;
        return geometry === DualAxesGeometry.Line || geometry === undefined;
    });
    return deepAssign({}, {
        options: {
            geometryOptions: [],
            meta: (_a = {},
                _a[xField] = {
                    // \u9ED8\u8BA4\u4E3A cat \u7C7B\u578B
                    type: 'cat',
                    // x \u8F74\u4E00\u5B9A\u662F\u540C\u6B65 scale \u7684
                    sync: true,
                    // \u5982\u679C\u6709\u6CA1\u6709\u67F1\u5B50\uFF0C\u5219
                    range: allLine ? [0, 1] : undefined,
                },
                _a),
            tooltip: {
                showMarkers: allLine,
                // \u5B58\u5728\u67F1\u72B6\u56FE\uFF0C\u4E0D\u663E\u793A crosshairs
                showCrosshairs: allLine,
                shared: true,
                crosshairs: {
                    type: 'x',
                },
            },
            interactions: !allLine
                ? [{ type: 'legend-visible-filter' }, { type: 'active-region' }]
                : [{ type: 'legend-visible-filter' }],
            legend: {
                position: 'top-left',
            },
        },
    }, params, {
        options: {
            // yAxis
            yAxis: transformObjectToArray(yField, options.yAxis),
            // geometryOptions
            geometryOptions: [
                getGeometryOption(xField, yField[0], geometryOptions[0]),
                getGeometryOption(xField, yField[1], geometryOptions[1]),
            ],
            // annotations
            annotations: transformObjectToArray(yField, options.annotations),
        },
    });
}
/**
 * \u521B\u5EFA \u53CC\u8F74\u56FE \u4E2D\u7ED8\u5236\u56FE\u5F62\u7684 view\uFF0C\u63D0\u524D\u521B\u5EFA\u662F\u56E0\u4E3A theme \u9002\u914D\u5668\u7684\u9700\u8981
 * @param params
 */
function createViews(params) {
    var _a, _b;
    var chart = params.chart, options = params.options;
    var geometryOptions = options.geometryOptions;
    var SORT_MAP = { line: 0, column: 1 };
    // \u5305\u542B\u914D\u7F6E\uFF0Cid\uFF0C\u6570\u636E\u7684\u7ED3\u6784
    var geometries = [
        { type: (_a = geometryOptions[0]) === null || _a === void 0 ? void 0 : _a.geometry, id: LEFT_AXES_VIEW },
        { type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry, id: RIGHT_AXES_VIEW },
    ];
    // \u5C06\u7EBF\u7684 view \u653E\u7F6E\u5728\u66F4\u4E0A\u4E00\u5C42\uFF0C\u9632\u6B62\u7EBF\u67F1\u906E\u6321\u3002\u5148\u67F1\u540E\u5148
    geometries.sort(function (a, b) { return -SORT_MAP[a.type] + SORT_MAP[b.type]; }).forEach(function (g) { return chart.createView({ id: g.id }); });
    return params;
}
/**
 * \u7ED8\u5236\u56FE\u5F62
 * @param params
 */
function dual_axes_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data = options.data, tooltip = options.tooltip;
    // \u5305\u542B\u914D\u7F6E\uFF0Cid\uFF0C\u6570\u636E\u7684\u7ED3\u6784
    var geometries = [
        (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, geometryOptions[0]), { id: LEFT_AXES_VIEW, data: data[0], yField: yField[0] }),
        (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, geometryOptions[1]), { id: RIGHT_AXES_VIEW, data: data[1], yField: yField[1] }),
    ];
    geometries.forEach(function (geometry) {
        var id = geometry.id, data = geometry.data, yField = geometry.yField;
        // \u767E\u5206\u6BD4\u67F1\u72B6\u56FE\u9700\u8981\u989D\u5916\u5904\u7406\u4E00\u6B21\u6570\u636E
        var isPercent = isColumn(geometry) && geometry.isPercent;
        var formatData = isPercent ? percent(data, yField, xField, yField) : data;
        var view = findViewById(chart, id).data(formatData);
        var tooltipOptions = isPercent
            ? (0,tslib_es6/* __assign */.pi)({ formatter: function (datum) { return ({
                    name: datum[geometry.seriesField] || yField,
                    value: (Number(datum[yField]) * 100).toFixed(2) + '%',
                }); } }, tooltip) : tooltip;
        // \u7ED8\u5236\u56FE\u5F62
        drawSingleGeometry({
            chart: view,
            options: {
                xField: xField,
                yField: yField,
                tooltip: tooltipOptions,
                geometryOption: geometry,
            },
        });
    });
    return params;
}
function adaptor_color(params) {
    var _a;
    var chart = params.chart, options = params.options;
    var geometryOptions = options.geometryOptions;
    var themeColor = ((_a = chart.getTheme()) === null || _a === void 0 ? void 0 : _a.colors10) || [];
    var start = 0;
    /* \u4E3A geometry \u6DFB\u52A0\u9ED8\u8BA4 color\u3002
     * 1. \u82E5 geometryOptions \u5B58\u5728 color\uFF0C\u5219\u5728 drawGeometry \u65F6\u5DF2\u5904\u7406
     * 2. \u82E5 \u4E0D\u5B58\u5728 color\uFF0C\u83B7\u53D6 Geometry group scales\u4E2A\u6570\uFF0C\u5728 theme color 10 \u4E2D\u63D0\u53D6
     * 3. \u4E3A\u9632\u6B62 group \u8FC7\u591A\u5BFC\u81F4\u53F3\u8272\u677F\u65E0\u503C\u6216\u503C\u5F88\u5C11\uFF0C\u53F3 view \u9762\u677F\u5728\u4F9D\u6B21\u63D0\u53D6\u5269\u4E0B\u7684 N \u4E2A \u540E\u518D concat \u4E00\u6B21 themeColor
     * 4. \u4E3A\u7B80\u4FBF\u83B7\u53D6 Geometry group scales\u4E2A\u6570\uFF0C\u5728\u7ED8\u5236\u5B8C\u540E\u518D\u6267\u884C color
     * 5. \u8003\u8651\u4E4B\u540E\u5C06\u4E0D\u540C view \u4F7F\u7528\u540C\u4E00\u4E2A\u8272\u677F\u7684\u9700\u6C42\u6C89\u6DC0\u5230 g2
     */
    chart.once('beforepaint', function () {
        (0,esm/* each */.S6)(geometryOptions, function (geometryOption, index) {
            var view = findViewById(chart, index === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
            if (geometryOption.color)
                return;
            var groupScale = view.getGroupScales();
            var count = (0,esm/* get */.U2)(groupScale, [0, 'values', 'length'], 1);
            var color = themeColor.slice(start, start + count).concat(index === 0 ? [] : themeColor);
            view.geometries.forEach(function (geometry) {
                if (geometryOption.seriesField) {
                    geometry.color(geometryOption.seriesField, color);
                }
                else {
                    geometry.color(color[0]);
                }
            });
            start += count;
        });
        chart.render(true);
    });
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function dual_axes_adaptor_meta(params) {
    var _a, _b;
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField[0]] = yAxis[0],
        _a))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
    common_scale((_b = {},
        _b[xField] = xAxis,
        _b[yField[1]] = yAxis[1],
        _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function dual_axes_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var leftView = findViewById(chart, LEFT_AXES_VIEW);
    var rightView = findViewById(chart, RIGHT_AXES_VIEW);
    var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
    chart.axis(xField, false);
    chart.axis(yField[0], false);
    chart.axis(yField[1], false);
    // \u5DE6 View
    leftView.axis(xField, xAxis);
    leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
    // \u53F3 Y \u8F74
    rightView.axis(xField, false);
    rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
    return params;
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function dual_axes_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    var leftView = findViewById(chart, LEFT_AXES_VIEW);
    var rightView = findViewById(chart, RIGHT_AXES_VIEW);
    // tooltip \u7ECF\u8FC7 getDefaultOption \u5904\u7406\u540E\uFF0C\u4E00\u5B9A\u4E0D\u4E3A undefined
    chart.tooltip(tooltip);
    // \u5728 view \u4E0A\u6DFB\u52A0 tooltip\uFF0C\u4F7F\u5F97 shared \u548C interaction active-region \u8D77\u4F5C\u7528
    // view \u5E94\u8BE5\u7EE7\u627F chart \u91CC\u7684 shared\uFF0C\u4F46\u662F\u4ECE\u8868\u73B0\u770B\u6765\uFF0C\u7EE7\u627F\u6709\u70B9\u95EE\u9898
    leftView.tooltip({
        shared: true,
    });
    rightView.tooltip({
        shared: true,
    });
    return params;
}
/**
 * interaction \u914D\u7F6E
 * @param params
 */
function dual_axes_adaptor_interaction(params) {
    var chart = params.chart;
    common_interaction(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
    common_interaction(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
    return params;
}
/**
 * annotation \u914D\u7F6E
 * @param params
 */
function adaptor_annotation(params) {
    var chart = params.chart, options = params.options;
    var annotations = options.annotations;
    var a1 = (0,esm/* get */.U2)(annotations, [0]);
    var a2 = (0,esm/* get */.U2)(annotations, [1]);
    common_annotation(a1)(deepAssign({}, params, {
        chart: findViewById(chart, LEFT_AXES_VIEW),
        options: {
            annotations: a1,
        },
    }));
    common_annotation(a2)(deepAssign({}, params, {
        chart: findViewById(chart, RIGHT_AXES_VIEW),
        options: {
            annotations: a2,
        },
    }));
    return params;
}
function dual_axes_adaptor_theme(params) {
    var chart = params.chart;
    /*
     * \u53CC\u8F74\u56FE\u4E2D\uFF0C\u90E8\u5206\u7EC4\u4EF6\u662F\u7ED8\u5236\u5728\u5B50 view \u5C42\uFF08\u4F8B\u5982 axis\uFF0Cline\uFF09\uFF0C\u90E8\u5206\u7EC4\u4EF6\u662F\u7ED8\u5236\u5728 chart \uFF08\u4F8B\u5982 legend)
     * \u4E3A chart \u548C \u5B50 view \u5747\u6CE8\u518C theme\uFF0C\u4F7F\u5176\u81EA\u884C\u9075\u5FAA G2 theme geometry > view > chart \u8FDB\u884C\u6E32\u67D3\u3002
     */
    common_theme(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
    common_theme(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
    common_theme(params);
    return params;
}
function dual_axes_adaptor_animation(params) {
    var chart = params.chart;
    animation(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
    animation(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
    return params;
}
/**
 * \u53CC\u8F74\u56FE limitInPlot
 * @param params
 */
function dual_axes_adaptor_limitInPlot(params) {
    var chart = params.chart, options = params.options;
    var yAxis = options.yAxis;
    common_limitInPlot(deepAssign({}, params, {
        chart: findViewById(chart, LEFT_AXES_VIEW),
        options: {
            yAxis: yAxis[0],
        },
    }));
    common_limitInPlot(deepAssign({}, params, {
        chart: findViewById(chart, RIGHT_AXES_VIEW),
        options: {
            yAxis: yAxis[1],
        },
    }));
    return params;
}
/**
 * legend \u914D\u7F6E
 * \u4F7F\u7528 custom\uFF0C\u4FBF\u4E8E\u548C\u7C7B\u4F3C\u4E8E\u5206\u7EC4\u67F1\u72B6\u56FE-\u5355\u6298\u7EBF\u56FE\u7684\u903B\u8F91\u7EDF\u4E00
 * @param params
 */
function dual_axes_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data = options.data;
    var leftView = findViewById(chart, LEFT_AXES_VIEW);
    var rightView = findViewById(chart, RIGHT_AXES_VIEW);
    if (legend === false) {
        chart.legend(false);
    }
    else if ((0,esm/* isObject */.Kn)(legend) && legend.custom === true) {
        chart.legend(legend);
    }
    else {
        var leftLegend_1 = (0,esm/* get */.U2)(geometryOptions, [0, 'legend'], legend);
        var rightLegend_1 = (0,esm/* get */.U2)(geometryOptions, [1, 'legend'], legend);
        // \u5747\u4F7F\u7528\u81EA\u5B9A\u4E49\u56FE\u4F8B
        chart.once('beforepaint', function () {
            var leftItems = data[0].length
                ? getViewLegendItems({
                    view: leftView,
                    geometryOption: geometryOptions[0],
                    yField: yField[0],
                    legend: leftLegend_1,
                })
                : [];
            var rightItems = data[1].length
                ? getViewLegendItems({
                    view: rightView,
                    geometryOption: geometryOptions[1],
                    yField: yField[1],
                    legend: rightLegend_1,
                })
                : [];
            chart.legend(deepAssign({}, legend, {
                custom: true,
                // todo \u4FEE\u6539\u7C7B\u578B\u5B9A\u4E49
                // @ts-ignore
                items: leftItems.concat(rightItems),
            }));
        });
        if (geometryOptions[0].seriesField) {
            leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
        }
        if (geometryOptions[1].seriesField) {
            rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
        }
        // \u81EA\u5B9A\u4E49\u56FE\u4F8B\u4EA4\u4E92
        chart.on('legend-item:click', function (evt) {
            var delegateObject = (0,esm/* get */.U2)(evt, 'gEvent.delegateObject', {});
            if (delegateObject && delegateObject.item) {
                var _a = delegateObject.item, field_1 = _a.value, isGeometry = _a.isGeometry, viewId = _a.viewId;
                // geometry \u7684\u65F6\u5019\uFF0C\u76F4\u63A5\u4F7F\u7528 view.changeVisible
                if (isGeometry) {
                    var idx = (0,esm/* findIndex */.cx)(yField, function (yF) { return yF === field_1; });
                    if (idx > -1) {
                        var geometries = (0,esm/* get */.U2)(findViewById(chart, viewId), 'geometries');
                        (0,esm/* each */.S6)(geometries, function (g) {
                            g.changeVisible(!delegateObject.item.unchecked);
                        });
                    }
                }
                else {
                    var legendItem_1 = (0,esm/* get */.U2)(chart.getController('legend'), 'option.items', []);
                    // \u5206\u7EC4\u67F1\u7EBF\u56FE
                    (0,esm/* each */.S6)(chart.views, function (view) {
                        // \u5355\u6298\u67F1\u56FE
                        var groupScale = view.getGroupScales();
                        (0,esm/* each */.S6)(groupScale, function (scale) {
                            if (scale.values && scale.values.indexOf(field_1) > -1) {
                                view.filter(scale.field, function (value) {
                                    var curLegendItem = (0,esm/* find */.sE)(legendItem_1, function (item) { return item.value === value; });
                                    // \u4F7F\u7528 legend \u4E2D\u7684 unchecked \u6765\u5224\u65AD\uFF0C\u4F7F\u5F97\u652F\u6301\u5173\u95ED\u591A\u4E2A\u56FE\u4F8B
                                    return !curLegendItem.unchecked;
                                });
                            }
                        });
                        chart.render(true);
                    });
                }
            }
        });
    }
    return params;
}
/**
 * \u53CC\u8F74\u56FE slider \u9002\u914D\u5668
 * @param params
 */
function dual_axes_adaptor_slider(params) {
    var chart = params.chart, options = params.options;
    var slider = options.slider;
    var leftView = findViewById(chart, LEFT_AXES_VIEW);
    var rightView = findViewById(chart, RIGHT_AXES_VIEW);
    if (slider) {
        // \u5DE6 View
        leftView.option('slider', slider);
        // \u76D1\u542C\u5DE6\u4FA7 slider \u6539\u53D8\u4E8B\u4EF6\uFF0C \u540C\u6B65\u53F3\u4FA7 View \u89C6\u56FE
        leftView.on('slider:valuechanged', function (evt) {
            var _a = evt.event, value = _a.value, originValue = _a.originValue;
            if ((0,esm/* isEqual */.Xy)(value, originValue)) {
                return;
            }
            doSliderFilter(rightView, value);
        });
        chart.once('afterpaint', function () {
            // \u521D\u59CB\u5316\u6570\u636E\uFF0C\u914D\u7F6E\u9ED8\u8BA4\u503C\u65F6\u9700\u8981\u540C\u6B65
            if (!(0,esm/* isBoolean */.jn)(slider)) {
                var start = slider.start, end = slider.end;
                if (start || end) {
                    doSliderFilter(rightView, [start, end]);
                }
            }
        });
    }
    return params;
}
/**
 * \u53CC\u6298\u7EBF\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function dual_axes_adaptor_adaptor(params) {
    // transformOptions \u4E00\u5B9A\u5728\u6700\u524D\u9762\u5904\u7406\uFF1Bcolor legend \u4F7F\u7528\u4E86 beforepaint\uFF0C\u4E3A\u4FBF\u4E8E\u7406\u89E3\u653E\u5728\u6700\u540E\u9762
    return flow(adaptor_transformOptions, createViews, 
    // \u4E3B\u9898\u9760\u524D\u8BBE\u7F6E\uFF0C\u4F5C\u4E3A\u6700\u4F4E\u4F18\u5148\u7EA7
    dual_axes_adaptor_theme, dual_axes_adaptor_geometry, dual_axes_adaptor_meta, dual_axes_adaptor_axis, dual_axes_adaptor_limitInPlot, dual_axes_adaptor_tooltip, dual_axes_adaptor_interaction, adaptor_annotation, dual_axes_adaptor_animation, adaptor_color, dual_axes_adaptor_legend, dual_axes_adaptor_slider)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/dual-axes/index.js




var DualAxes = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(DualAxes, _super);
    function DualAxes() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B: \u53CC\u8F74\u56FE */
        _this.type = 'dual-axes';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u53CC\u8F74\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    DualAxes.prototype.getDefaultOptions = function () {
        return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
            yAxis: [],
            syncViewPadding: true,
        });
    };
    /**
     * \u83B7\u53D6\u53CC\u8F74\u56FE\u7684\u9002\u914D\u5668
     */
    DualAxes.prototype.getSchemaAdaptor = function () {
        return dual_axes_adaptor_adaptor;
    };
    return DualAxes;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/facet/utils.js





/**
 *
 * @param params \u5206\u9762\u56FE \u53C2\u6570
 * @returns facet eachView \u7684\u56DE\u8C03\u8BBE\u7F6E\u6BCF\u4E2A view \u7684\u5C55\u793A
 */
function execViewAdaptor(viewOfG2, options) {
    var data = options.data, coordinate = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation = options.animation, tooltip = options.tooltip, axes = options.axes, meta = options.meta, geometries = options.geometries;
    // 1. data, optional
    if (data) {
        viewOfG2.data(data);
    }
    // 2. meta \u914D\u7F6E
    var scales = {};
    if (axes) {
        (0,esm/* each */.S6)(axes, function (axis, field) {
            scales[field] = pick(axis, AXIS_META_CONFIG_KEYS);
        });
    }
    scales = deepAssign({}, meta, scales);
    viewOfG2.scale(scales);
    // 3. coordinate \u914D\u7F6E (\u9ED8\u8BA4\u7531\u9876\u5C42\u51B3\u5B9A)
    if (coordinate) {
        viewOfG2.coordinate(coordinate);
    }
    // 4. axis \u8F74\u914D\u7F6E (\u9ED8\u8BA4\u7531\u9876\u5C42\u51B3\u5B9A\uFF0C\u4F46\u53EF\u4EE5\u901A\u8FC7 false \u5F3A\u5236\u5173\u95ED)
    if (axes === false) {
        viewOfG2.axis(false);
    }
    else {
        (0,esm/* each */.S6)(axes, function (axis, field) {
            viewOfG2.axis(field, axis);
        });
    }
    (0,esm/* each */.S6)(geometries, function (geometry) {
        // Geometry
        var ext = base_geometry({
            chart: viewOfG2,
            options: geometry,
        }).ext;
        // Geometry adjust
        var adjust = geometry.adjust;
        if (adjust) {
            ext.geometry.adjust(adjust);
        }
    });
    // 5. interactions
    (0,esm/* each */.S6)(interactions, function (interaction) {
        if (interaction.enable === false) {
            viewOfG2.removeInteraction(interaction.type);
        }
        else {
            viewOfG2.interaction(interaction.type, interaction.cfg);
        }
    });
    // 6. annotations
    (0,esm/* each */.S6)(annotations, function (annotation) {
        viewOfG2.annotation()[annotation.type]((0,tslib_es6/* __assign */.pi)({}, annotation));
    });
    // 7. animation (\u5148\u505A\u52A8\u753B)
    addViewAnimation(viewOfG2, animation);
    if (tooltip) {
        // 8. tooltip
        viewOfG2.interaction('tooltip');
        viewOfG2.tooltip(tooltip);
    }
    else if (tooltip === false) {
        viewOfG2.removeInteraction('tooltip');
    }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/facet/adaptor.js







function facetAdaptor(params) {
    var chart = params.chart, options = params.options;
    var facetType = options.type, data = options.data, fields = options.fields, eachView = options.eachView;
    var restFacetCfg = (0,esm/* omit */.CE)(options, [
        'type',
        'data',
        'fields',
        'eachView',
        'axes',
        'meta',
        'tooltip',
        'coordinate',
        'theme',
        'legend',
        'interactions',
        'annotations',
    ]);
    // 1. data
    chart.data(data);
    // 2. facet
    chart.facet(facetType, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, restFacetCfg), { fields: fields, eachView: function (viewOfG2, facet) {
            var viewOptions = eachView(viewOfG2, facet);
            if (viewOptions.geometries) {
                execViewAdaptor(viewOfG2, viewOptions);
            }
            else {
                var plot = viewOptions;
                var plotOptions = plot.options;
                // @ts-ignore \u4EEA\u8868\u76D8\u6CA1 tooltip
                if (plotOptions.tooltip) {
                    // \u914D\u7F6E tooltip \u4EA4\u4E92
                    viewOfG2.interaction('tooltip');
                }
                execPlotAdaptor(plot.type, viewOfG2, plotOptions);
            }
        } }));
    return params;
}
function adaptor_component(params) {
    var chart = params.chart, options = params.options;
    var axes = options.axes, meta = options.meta, tooltip = options.tooltip, coordinate = options.coordinate, theme = options.theme, legend = options.legend, interactions = options.interactions, annotations = options.annotations;
    // 3. meta \u914D\u7F6E
    var scales = {};
    if (axes) {
        (0,esm/* each */.S6)(axes, function (axis, field) {
            scales[field] = pick(axis, AXIS_META_CONFIG_KEYS);
        });
    }
    scales = deepAssign({}, meta, scales);
    chart.scale(scales);
    // 4. coordinate \u914D\u7F6E
    chart.coordinate(coordinate);
    // 5. axis \u8F74\u914D\u7F6E (\u9ED8\u8BA4\u4E0D\u5C55\u793A)
    if (!axes) {
        chart.axis(false);
    }
    else {
        (0,esm/* each */.S6)(axes, function (axis, field) {
            chart.axis(field, axis);
        });
    }
    // 6. tooltip \u914D\u7F6E
    if (tooltip) {
        chart.interaction('tooltip');
        chart.tooltip(tooltip);
    }
    else if (tooltip === false) {
        chart.removeInteraction('tooltip');
    }
    // 7. legend \u914D\u7F6E\uFF08\u9ED8\u8BA4\u5C55\u793A\uFF09
    chart.legend(legend);
    // theme \u914D\u7F6E
    if (theme) {
        chart.theme(theme);
    }
    // 8. interactions
    (0,esm/* each */.S6)(interactions, function (interaction) {
        if (interaction.enable === false) {
            chart.removeInteraction(interaction.type);
        }
        else {
            chart.interaction(interaction.type, interaction.cfg);
        }
    });
    // 9. annotations
    (0,esm/* each */.S6)(annotations, function (annotation) {
        chart.annotation()[annotation.type]((0,tslib_es6/* __assign */.pi)({}, annotation));
    });
    return params;
}
/**
 * \u5206\u9762\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function facet_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, facetAdaptor, adaptor_component)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/facet/constant.js
/**
 * \u5206\u9762\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var facet_constant_DEFAULT_OPTIONS = {
    title: {
        style: {
            fontSize: 12,
            fill: 'rgba(0,0,0,0.65)',
        },
    },
    rowTitle: {
        style: {
            fontSize: 12,
            fill: 'rgba(0,0,0,0.65)',
        },
    },
    columnTitle: {
        style: {
            fontSize: 12,
            fill: 'rgba(0,0,0,0.65)',
        },
    },
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/facet/index.js




var facet_Facet = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Facet, _super);
    function Facet() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'area';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u5206\u9762\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Facet.getDefaultOptions = function () {
        return facet_constant_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u5206\u9762\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Facet.prototype.getDefaultOptions = function () {
        return Facet.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u5206\u9762\u56FE \u7684\u9002\u914D\u5668
     */
    Facet.prototype.getSchemaAdaptor = function () {
        return facet_adaptor_adaptor;
    };
    return Facet;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/heatmap/adaptor.js






function heatmap_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, type = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color = options.color, tooltip = options.tooltip, heatmapStyle = options.heatmapStyle, meta = options.meta;
    chart.data(data);
    var geometryType = 'polygon';
    if (type === 'density') {
        geometryType = 'heatmap';
    }
    var _a = getTooltipMapping(tooltip, [xField, yField, colorField]), fields = _a.fields, formatter = _a.formatter;
    /**
     * The ratio between the actual size and the max available size, must be in range \`[0,1]\`.
     *
     * If the \`sizeRatio\` attribute is undefined or it exceeds the range,
     * \`checkedSizeRatio\` would be set to 1 as default.
     */
    var checkedSizeRatio = 1;
    if (sizeRatio || sizeRatio === 0) {
        if (!shape && !sizeField) {
            console.warn('sizeRatio is not in effect: Must define shape or sizeField first');
        }
        else if (sizeRatio < 0 || sizeRatio > 1) {
            console.warn('sizeRatio is not in effect: It must be a number in [0,1]');
        }
        else {
            checkedSizeRatio = sizeRatio;
        }
    }
    base_geometry(deepAssign({}, params, {
        options: {
            type: geometryType,
            colorField: colorField,
            tooltipFields: fields,
            shapeField: sizeField || '',
            label: undefined,
            mapping: {
                tooltip: formatter,
                shape: shape &&
                    (sizeField
                        ? function (dautm) {
                            var field = data.map(function (row) { return row[sizeField]; });
                            var _a = (meta === null || meta === void 0 ? void 0 : meta[sizeField]) || {}, min = _a.min, max = _a.max;
                            min = (0,esm/* isNumber */.hj)(min) ? min : Math.min.apply(Math, field);
                            max = (0,esm/* isNumber */.hj)(max) ? max : Math.max.apply(Math, field);
                            return [shape, ((0,esm/* get */.U2)(dautm, sizeField) - min) / (max - min), checkedSizeRatio];
                        }
                        : function () { return [shape, 1, checkedSizeRatio]; }),
                color: color || (colorField && chart.getTheme().sequenceColors.join('-')),
                style: heatmapStyle,
            },
        },
    }));
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function heatmap_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a)))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function heatmap_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(yField, false);
    }
    else {
        chart.axis(yField, yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function heatmap_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
    /** legend \u4E0D\u4E3A false, \u5219\u5C55\u793A\u56FE\u4F8B, \u4F18\u5148\u5C55\u793A color \u5206\u7C7B\u56FE\u4F8B */
    var showLegend = legend !== false;
    if (colorField) {
        chart.legend(colorField, showLegend ? legend : false);
    }
    // \u65E7\u7248\u672C: \u6709 sizeField \u5C31\u6709 sizeLegend. \u8FD9\u91CC\u9ED8\u8BA4\u7EE7\u627F\u4E0B legend \u914D\u7F6E
    if (sizeField) {
        chart.legend(sizeField, sizeLegend === undefined ? legend : sizeLegend);
    }
    /** \u9ED8\u8BA4\u6CA1\u6709 sizeField\uFF0C\u5219\u9690\u85CF\u8FDE\u7EED\u56FE\u4F8B */
    if (!showLegend && !sizeLegend) {
        chart.legend(false);
    }
    return params;
}
/**
 * fixme \u540E\u7EED\u786E\u8BA4\u4E0B\uFF0C\u6570\u636E\u6807\u7B7E\u7684\u903B\u8F91\u4E3A\u5565\u548C\u901A\u7528\u7684\u4E0D\u4E00\u81F4
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function heatmap_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, colorField = options.colorField, type = options.type;
    var geometry = findGeometry(chart, type === 'density' ? 'heatmap' : 'polygon');
    if (!label) {
        geometry.label(false);
    }
    else if (colorField) {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: [colorField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * \u6781\u5750\u6807
 * @param params
 */
function heatmap_adaptor_coordinate(params) {
    var _a, _b;
    var chart = params.chart, options = params.options;
    var coordinate = options.coordinate, reflect = options.reflect;
    var coordinateOption = deepAssign({ actions: [] }, coordinate !== null && coordinate !== void 0 ? coordinate : { type: 'rect' });
    if (reflect) {
        (_b = (_a = coordinateOption.actions) === null || _a === void 0 ? void 0 : _a.push) === null || _b === void 0 ? void 0 : _b.call(_a, ['reflect', reflect]);
    }
    chart.coordinate(coordinateOption);
    return params;
}
/**
 * \u70ED\u529B\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function heatmap_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, pattern('heatmapStyle'), heatmap_adaptor_meta, heatmap_adaptor_coordinate, heatmap_adaptor_geometry, heatmap_adaptor_axis, heatmap_adaptor_legend, common_tooltip, heatmap_adaptor_label, common_annotation(), common_interaction, animation, common_state)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/heatmap/constant.js


/**
 * \u8272\u5757\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var heatmap_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    type: 'polygon',
    legend: false,
    coordinate: {
        type: 'rect',
    },
    xAxis: {
        tickLine: null,
        line: null,
        grid: {
            alignTick: false,
            line: {
                style: {
                    lineWidth: 1,
                    lineDash: null,
                    stroke: '#f0f0f0',
                },
            },
        },
    },
    yAxis: {
        grid: {
            alignTick: false,
            line: {
                style: {
                    lineWidth: 1,
                    lineDash: null,
                    stroke: '#f0f0f0',
                },
            },
        },
    },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/heatmap/shapes/circle.js


registerShape('polygon', 'circle', {
    draw: function (cfg, group) {
        var _a, _b;
        var cx = cfg.x;
        var cy = cfg.y;
        var points = this.parsePoints(cfg.points);
        var width = Math.abs(points[2].x - points[1].x);
        var height = Math.abs(points[1].y - points[0].y);
        var maxRadius = Math.min(width, height) / 2;
        var value = Number(cfg.shape[1]);
        var sizeRatio = Number(cfg.shape[2]);
        var radiusRatio = Math.sqrt(sizeRatio);
        var radius = maxRadius * radiusRatio * Math.sqrt(value);
        var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
        var polygon = group.addShape('circle', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: cx, y: cy, r: radius }, cfg.defaultStyle), cfg.style), { fill: fill }),
        });
        return polygon;
    },
});
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/heatmap/shapes/square.js


registerShape('polygon', 'square', {
    draw: function (cfg, group) {
        var _a, _b;
        var cx = cfg.x;
        var cy = cfg.y;
        var points = this.parsePoints(cfg.points);
        var width = Math.abs(points[2].x - points[1].x);
        var height = Math.abs(points[1].y - points[0].y);
        var maxSideLength = Math.min(width, height);
        var value = Number(cfg.shape[1]);
        var sizeRatio = Number(cfg.shape[2]);
        var lenRatio = Math.sqrt(sizeRatio);
        var sideLength = maxSideLength * lenRatio * Math.sqrt(value);
        var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
        var polygon = group.addShape('rect', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: cx - sideLength / 2, y: cy - sideLength / 2, width: sideLength, height: sideLength }, cfg.defaultStyle), cfg.style), { fill: fill }),
        });
        return polygon;
    },
});
//# sourceMappingURL=square.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/heatmap/index.js




// registered shapes


var heatmap_Heatmap = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Heatmap, _super);
    function Heatmap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'heatmap';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u67F1\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Heatmap.getDefaultOptions = function () {
        return heatmap_constant_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6\u76F4\u65B9\u56FE\u7684\u9002\u914D\u5668
     */
    Heatmap.prototype.getSchemaAdaptor = function () {
        return heatmap_adaptor_adaptor;
    };
    /**
     * \u83B7\u53D6 \u8272\u5757\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Heatmap.prototype.getDefaultOptions = function () {
        return Heatmap.getDefaultOptions();
    };
    return Heatmap;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/liquid/utils.js
var CAT_VALUE = 'liquid';
/**
 * \u83B7\u53D6\u6C34\u6CE2\u56FE\u6570\u636E
 */
function getLiquidData(percent) {
    return [{ percent: percent, type: CAT_VALUE }];
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/liquid/adaptor.js






/**
 * geometry \u5904\u7406
 * @param params
 */
function liquid_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var percent = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape, shapeStyle = options.shapeStyle, animation = options.animation;
    chart.scale({
        percent: {
            min: 0,
            max: 1,
        },
    });
    chart.data(getLiquidData(percent));
    var color = options.color || chart.getTheme().defaultColor;
    var p = deepAssign({}, params, {
        options: {
            xField: 'type',
            yField: 'percent',
            // radius \u653E\u5230 columnWidthRatio \u4E2D\u3002
            // \u4FDD\u8BC1\u6A2A\u5411\u7684\u5927\u5C0F\u662F\u6839\u636E  radius \u751F\u6210\u7684
            widthRatio: radius,
            interval: {
                color: color,
                style: liquidStyle,
                shape: 'liquid-fill-gauge',
            },
        },
    });
    var ext = interval_interval(p).ext;
    var geometry = ext.geometry;
    var background = chart.getTheme().background;
    var customInfo = {
        percent: percent,
        radius: radius,
        outline: outline,
        wave: wave,
        shape: shape,
        shapeStyle: shapeStyle,
        background: background,
        animation: animation,
    };
    // \u5C06 radius \u4F20\u5165\u5230\u81EA\u5B9A\u4E49 shape \u4E2D
    geometry.customInfo(customInfo);
    // \u5173\u95ED\u7EC4\u4EF6
    chart.legend(false);
    chart.axis(false);
    chart.tooltip(false);
    return params;
}
/**
 * \u7EDF\u8BA1\u6307\u6807\u6587\u6863
 * @param params
 */
function liquid_adaptor_statistic(params, updated) {
    var chart = params.chart, options = params.options;
    var statistic = options.statistic, percent = options.percent, meta = options.meta;
    // \u5148\u6E05\u7A7A\u6807\u6CE8\uFF0C\u518D\u91CD\u65B0\u6E32\u67D3
    chart.getController('annotation').clear(true);
    var metaFormatter = (0,esm/* get */.U2)(meta, ['percent', 'formatter']) || (function (v) { return "".concat((v * 100).toFixed(2), "%"); });
    var contentOpt = statistic.content;
    if (contentOpt) {
        contentOpt = deepAssign({}, contentOpt, {
            content: !(0,esm/* isNil */.UM)(contentOpt.content) ? contentOpt.content : metaFormatter(percent),
        });
    }
    renderStatistic(chart, { statistic: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, statistic), { content: contentOpt }), plotType: 'liquid' }, { percent: percent });
    if (updated) {
        chart.render(true);
    }
    return params;
}
/**
 * \u6C34\u6CE2\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function liquid_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API (\u4E3B\u9898\u524D\u7F6E\uFF0C\u4F1A\u5F71\u54CD\u7ED8\u5236\u7684\u53D6\u8272)
    return flow(common_theme, pattern('liquidStyle'), liquid_adaptor_geometry, liquid_adaptor_statistic, common_scale({}), animation, common_interaction)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/liquid/constants.js
/**
 * \u6C34\u6CE2\u56FE\u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var liquid_constants_DEFAULT_OPTIONS = {
    radius: 0.9,
    statistic: {
        title: false,
        content: {
            style: {
                opacity: 0.75,
                fontSize: '30px',
                lineHeight: '30px',
                textAlign: 'center',
            },
        },
    },
    outline: {
        border: 2,
        distance: 0,
    },
    wave: {
        count: 3,
        length: 192,
    },
    shape: 'circle',
};
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/liquid/shapes/liquid.js




var DURATION = 5000;
/**
 * \u4E00\u4E2A\u7EBF\u6027\u6620\u5C04\u7684\u51FD\u6570
 * @param min
 * @param max
 * @param factor
 */
function liquid_lerp(min, max, factor) {
    return min + (max - min) * factor;
}
/**
 * \u6CE2\u6D6A\u7684 attrs
 * @param cfg
 */
function getFillAttrs(cfg) {
    var attrs = (0,tslib_es6/* __assign */.pi)({ opacity: 1 }, cfg.style);
    if (cfg.color && !attrs.fill) {
        attrs.fill = cfg.color;
    }
    return attrs;
}
/**
 * shape \u7684 attrs
 * @param cfg
 */
function getLineAttrs(cfg) {
    var defaultAttrs = {
        fill: '#fff',
        fillOpacity: 0,
        lineWidth: 4,
    };
    var attrs = (0,esm/* mix */.CD)({}, defaultAttrs, cfg.style);
    if (cfg.color && !attrs.stroke) {
        attrs.stroke = cfg.color;
    }
    if ((0,esm/* isNumber */.hj)(cfg.opacity)) {
        attrs.opacity = attrs.strokeOpacity = cfg.opacity;
    }
    return attrs;
}
/**
 * \u7528\u8D1D\u585E\u5C14\u66F2\u7EBF\u6A21\u62DF\u6B63\u5F26\u6CE2
 * Using Bezier curves to fit sine wave.
 * There is 4 control points for each curve of wave,
 * which is at 1/4 wave length of the sine wave.
 *
 * The control points for a wave from (a) to (d) are a-b-c-d:
 *          c *----* d
 *     b *
 *       |
 * ... a * ..................
 *
 * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
 *
 * @param x          x position of the left-most point (a)
 * @param stage      0-3, stating which part of the wave it is
 * @param waveLength wave length of the sine wave
 * @param amplitude  wave amplitude
 * @return \u6B63\u5F26\u7247\u6BB5\u66F2\u7EBF
 */
function getWaterWavePositions(x, stage, waveLength, amplitude) {
    if (stage === 0) {
        return [
            [x + ((1 / 2) * waveLength) / Math.PI / 2, amplitude / 2],
            [x + ((1 / 2) * waveLength) / Math.PI, amplitude],
            [x + waveLength / 4, amplitude],
        ];
    }
    if (stage === 1) {
        return [
            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), amplitude],
            [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), amplitude / 2],
            [x + waveLength / 4, 0],
        ];
    }
    if (stage === 2) {
        return [
            [x + ((1 / 2) * waveLength) / Math.PI / 2, -amplitude / 2],
            [x + ((1 / 2) * waveLength) / Math.PI, -amplitude],
            [x + waveLength / 4, -amplitude],
        ];
    }
    return [
        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 2), -amplitude],
        [x + (((1 / 2) * waveLength) / Math.PI / 2) * (Math.PI - 1), -amplitude / 2],
        [x + waveLength / 4, 0],
    ];
}
/**
 * \u83B7\u53D6\u6C34\u6CE2\u8DEF\u5F84
 * @param radius          \u534A\u5F84
 * @param waterLevel      \u6C34\u4F4D
 * @param waveLength      \u6CE2\u957F
 * @param phase           \u76F8\u4F4D
 * @param amplitude       \u9707\u5E45
 * @param cx              \u5706\u5FC3x
 * @param cy              \u5706\u5FC3y
 * @return path            \u8DEF\u5F84
 * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
 */
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
    var curves = Math.ceil(((2 * radius) / waveLength) * 4) * 4;
    var path = [];
    var _phase = phase;
    // map phase to [-Math.PI * 2, 0]
    while (_phase < -Math.PI * 2) {
        _phase += Math.PI * 2;
    }
    while (_phase > 0) {
        _phase -= Math.PI * 2;
    }
    _phase = (_phase / Math.PI / 2) * waveLength;
    var left = cx - radius + _phase - radius * 2;
    /**
     * top-left corner as start point
     *
     * draws this point
     *  |
     * \\|/
     *  ~~~~~~~~
     *  |      |
     *  +------+
     */
    path.push(['M', left, waterLevel]);
    /**
     * top wave
     *
     * ~~~~~~~~ <- draws this sine wave
     * |      |
     * +------+
     */
    var waveRight = 0;
    for (var c = 0; c < curves; ++c) {
        var stage = c % 4;
        var pos = getWaterWavePositions((c * waveLength) / 4, stage, waveLength, amplitude);
        path.push([
            'C',
            pos[0][0] + left,
            -pos[0][1] + waterLevel,
            pos[1][0] + left,
            -pos[1][1] + waterLevel,
            pos[2][0] + left,
            -pos[2][1] + waterLevel,
        ]);
        if (c === curves - 1) {
            waveRight = pos[2][0];
        }
    }
    /**
     * top-right corner
     *
     *                       ~~~~~~~~
     * 3. draws this line -> |      | <- 1. draws this line
     *                       +------+
     *                          ^
     *                          |
     *                  2. draws this line
     */
    path.push(['L', waveRight + left, cy + radius]);
    path.push(['L', left, cy + radius]);
    path.push(['Z']);
    // path.push(['L', left, waterLevel]);
    return path;
}
/**
 * \u6DFB\u52A0\u6C34\u6CE2
 * @param x           \u4E2D\u5FC3x
 * @param y           \u4E2D\u5FC3y
 * @param level       \u6C34\u4F4D\u7B49\u7EA7 0\uFF5E1
 * @param waveCount   \u6C34\u6CE2\u6570
 * @param waveAttrs      \u8272\u503C
 * @param group       \u56FE\u7EC4
 * @param clip        \u7528\u4E8E\u526A\u5207\u7684\u56FE\u5F62
 * @param radius      \u7ED8\u5236\u56FE\u5F62\u7684\u9AD8\u5EA6
 * @param waveLength  \u6CE2\u7684\u957F\u5EA6
 */
function addWaterWave(x, y, level, waveCount, waveAttrs, group, clip, radius, waveLength, animation) {
    // \u76D2\u5B50\u5C5E\u6027 \u989C\u8272 \u5BBD\u9AD8
    var fill = waveAttrs.fill, opacity = waveAttrs.opacity;
    var bbox = clip.getBBox();
    var width = bbox.maxX - bbox.minX;
    var height = bbox.maxY - bbox.minY;
    // \u5FAA\u73AF waveCount \u4E2A\u6570
    for (var idx = 0; idx < waveCount; idx++) {
        var factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
        // \u753B\u6CE2
        var wave = group.addShape('path', {
            name: "waterwave-path",
            attrs: {
                // \u6CE2\u5F62\u8DEF\u5F84\u914D\u7F6E
                path: getWaterWavePath(radius, bbox.minY + height * level, waveLength, 0, width / 32, // \u6CE2\u5E45\u9AD8\u5EA6
                x, y),
                fill: fill,
                opacity: liquid_lerp(0.2, 0.9, factor) * opacity,
            },
        });
        try {
            // \u9ED8\u8BA4 underfind \u5F00\u542F\u52A8\u753B
            if (animation === false)
                return;
            var matrix = matrix_transform([['t', waveLength, 0]]);
            wave.stopAnimate();
            wave.animate({ matrix: matrix }, {
                duration: liquid_lerp(0.5 * DURATION, DURATION, factor),
                repeat: true,
            });
        }
        catch (e) {
            // TODO off-screen canvas \u4E2D\u52A8\u753B\u4F1A\u627E\u4E0D\u5230 canvas
            console.warn('off-screen group animate error!');
        }
    }
}
/**
 *
 * @param x \u4E2D\u5FC3 x
 * @param y \u4E2D\u5FC3 y
 * @param width \u5916\u63A5\u77E9\u5F62\u7684\u5BBD
 * @param height \u5916\u63A5\u77E9\u5F62\u7684\u9AD8
 */
function pin(x, y, width, height) {
    var w = (width * 2) / 3;
    var h = Math.max(w, height);
    var r = w / 2;
    // attrs of the upper circle
    var cx = x;
    var cy = r + y - h / 2;
    var theta = Math.asin(r / ((h - r) * 0.85));
    var dy = Math.sin(theta) * r;
    var dx = Math.cos(theta) * r;
    // the start point of the path
    var x0 = cx - dx;
    var y0 = cy + dy;
    // control point
    var cpX = x;
    var cpY = cy + r / Math.sin(theta);
    return "\\n      M ".concat(x0, " ").concat(y0, "\\n      A ").concat(r, " ").concat(r, " 0 1 1 ").concat(x0 + dx * 2, " ").concat(y0, "\\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x, " ").concat(y + h / 2, "\\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x0, " ").concat(y0, "\\n      Z \\n    ");
}
/**
 *
 * @param x \u4E2D\u5FC3 x
 * @param y \u4E2D\u5FC3 y
 * @param width \u5916\u63A5\u77E9\u5F62\u7684\u5BBD
 * @param height \u5916\u63A5\u77E9\u5F62\u7684\u9AD8
 */
function liquid_circle(x, y, width, height) {
    var rx = width / 2;
    var ry = height / 2;
    return "\\n      M ".concat(x, " ").concat(y - ry, " \\n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(ry * 2, "\\n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(-ry * 2, "\\n      Z\\n    ");
}
/**
 *
 * @param x \u4E2D\u5FC3 x
 * @param y \u4E2D\u5FC3 y
 * @param width \u5916\u63A5\u77E9\u5F62\u7684\u5BBD
 * @param height \u5916\u63A5\u77E9\u5F62\u7684\u9AD8
 */
function diamond(x, y, width, height) {
    var h = height / 2;
    var w = width / 2;
    return "\\n      M ".concat(x, " ").concat(y - h, "\\n      L ").concat(x + w, " ").concat(y, "\\n      L ").concat(x, " ").concat(y + h, "\\n      L ").concat(x - w, " ").concat(y, "\\n      Z\\n    ");
}
/**
 *
 * @param x \u4E2D\u5FC3 x
 * @param y \u4E2D\u5FC3 y
 * @param width \u5916\u63A5\u77E9\u5F62\u7684\u5BBD
 * @param height \u5916\u63A5\u77E9\u5F62\u7684\u9AD8
 */
function triangle(x, y, width, height) {
    var h = height / 2;
    var w = width / 2;
    return "\\n      M ".concat(x, " ").concat(y - h, "\\n      L ").concat(x + w, " ").concat(y + h, "\\n      L ").concat(x - w, " ").concat(y + h, "\\n      Z\\n    ");
}
/**
 *
 * @param x \u4E2D\u5FC3 x
 * @param y \u4E2D\u5FC3 y
 * @param width \u5916\u63A5\u77E9\u5F62\u7684\u5BBD
 * @param height \u5916\u63A5\u77E9\u5F62\u7684\u9AD8
 */
function liquid_rect(x, y, width, height) {
    var GOLDEN_SECTION_RATIO = 0.618;
    var h = height / 2;
    var w = (width / 2) * GOLDEN_SECTION_RATIO;
    return "\\n      M ".concat(x - w, " ").concat(y - h, "\\n      L ").concat(x + w, " ").concat(y - h, "\\n      L ").concat(x + w, " ").concat(y + h, "\\n      L ").concat(x - w, " ").concat(y + h, "\\n      Z\\n    ");
}
var builtInShapeByName = {
    pin: pin,
    circle: liquid_circle,
    diamond: diamond,
    triangle: triangle,
    rect: liquid_rect,
};
registerShape('interval', 'liquid-fill-gauge', {
    draw: function (cfg, container) {
        var cx = 0.5;
        var cy = 0.5;
        var customInfo = cfg.customInfo;
        var _a = customInfo, percent = _a.percent, radio = _a.radius, shape = _a.shape, shapeStyle = _a.shapeStyle, background = _a.background, animation = _a.animation;
        var outline = customInfo.outline;
        var wave = customInfo.wave;
        var border = outline.border, distance = outline.distance;
        var waveCount = wave.count, waveLength = wave.length;
        // \u83B7\u53D6\u6700\u5C0F minX
        var minX = (0,esm/* reduce */.u4)(cfg.points, function (r, p) {
            return Math.min(r, p.x);
        }, Infinity);
        var center = this.parsePoint({ x: cx, y: cy });
        var minXPoint = this.parsePoint({ x: minX, y: cy });
        var halfWidth = center.x - minXPoint.x;
        // \u4FDD\u8BC1\u534A\u5F84\u662F \u753B\u5E03\u5BBD\u9AD8\u6700\u5C0F\u503C\u7684 radius \u503C
        var radius = Math.min(halfWidth, minXPoint.y * radio);
        var waveAttrs = getFillAttrs(cfg);
        var outlineAttrs = getLineAttrs((0,esm/* mix */.CD)({}, cfg, outline));
        var innerRadius = radius - border / 2;
        var buildPath = typeof shape === 'function' ? shape : builtInShapeByName[shape] || builtInShapeByName['circle'];
        var shapePath = buildPath(center.x, center.y, innerRadius * 2, innerRadius * 2);
        // 1. \u5F53 shapeStyle \u4E0D\u4E3A\u7A7A\u65F6\uFF0C\u7ED8\u5236\u5F62\u72B6\u6837\u5F0F\u4F5C\u4E3A\u80CC\u666F
        if (shapeStyle) {
            container.addShape('path', {
                name: 'shape',
                attrs: (0,tslib_es6/* __assign */.pi)({ path: shapePath }, shapeStyle),
            });
        }
        // \u6BD4\u4F8B\u5927\u4E8E 0 \u65F6\u624D\u7ED8\u5236\u6C34\u6CE2
        if (percent > 0) {
            // 2. \u7ED8\u5236\u4E00\u4E2A\u6CE2
            var waves = container.addGroup({
                name: 'waves',
            });
            // 3. \u6CE2\u5BF9\u5E94\u7684 clip \u88C1\u526A\u5F62\u72B6
            var clipPath = waves.setClip({
                type: 'path',
                attrs: {
                    path: shapePath,
                },
            });
            // 4. \u7ED8\u5236\u6CE2\u5F62
            addWaterWave(center.x, center.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength, animation);
        }
        // 5. \u7ED8\u5236\u4E00\u4E2A distance \u5BBD\u7684 border
        container.addShape('path', {
            name: 'distance',
            attrs: {
                path: shapePath,
                fill: 'transparent',
                lineWidth: border + distance * 2,
                stroke: background === 'transparent' ? '#fff' : background,
            },
        });
        // 6. \u7ED8\u5236\u4E00\u4E2A border \u5BBD\u7684 border
        container.addShape('path', {
            name: 'wrap',
            attrs: (0,esm/* mix */.CD)(outlineAttrs, {
                path: shapePath,
                fill: 'transparent',
                lineWidth: border,
            }),
        });
        return container;
    },
});
//# sourceMappingURL=liquid.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/liquid/index.js





// register liquid shape



/**
 * \u4F20\u8BF4\u4E2D\u7684\u6C34\u6CE2\u56FE
 */
var Liquid = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Liquid, _super);
    function Liquid() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'liquid';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u997C\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Liquid.getDefaultOptions = function () {
        return liquid_constants_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u6C34\u6CE2\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879, \u4F9B base \u83B7\u53D6
     */
    Liquid.prototype.getDefaultOptions = function () {
        return Liquid.getDefaultOptions();
    };
    /**
     * \u66F4\u65B0\u6570\u636E
     * @param percent
     */
    Liquid.prototype.changeData = function (percent) {
        this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
        this.updateOption({ percent: percent });
        this.chart.data(getLiquidData(percent));
        liquid_adaptor_statistic({ chart: this.chart, options: this.options }, true);
        this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, chart_event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Liquid.prototype.getSchemaAdaptor = function () {
        return liquid_adaptor_adaptor;
    };
    return Liquid;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radar/adaptor.js




/**
 * geometry \u914D\u7F6E\u5904\u7406
 * @param params
 */
function radar_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, lineStyle = options.lineStyle, color = options.color, pointOptions = options.point, areaOptions = options.area;
    chart.data(data);
    // \u96F7\u8FBE\u56FE \u4E3B geometry
    var primary = deepAssign({}, params, {
        options: {
            line: {
                style: lineStyle,
                color: color,
            },
            point: pointOptions
                ? (0,tslib_es6/* __assign */.pi)({ color: color }, pointOptions) : pointOptions,
            area: areaOptions
                ? (0,tslib_es6/* __assign */.pi)({ color: color }, areaOptions) : areaOptions,
            // label \u4E0D\u4F20\u9012\u7ED9\u5404\u4E2A geometry adaptor\uFF0C\u7531 label adaptor \u5904\u7406
            label: undefined,
        },
    });
    // \u526F Geometry
    var second = deepAssign({}, primary, {
        options: {
            tooltip: false,
        },
    });
    // \u4F18\u5148\u4F7F\u7528 point.state, \u5176\u6B21\u53D6\u4E3B\u5143\u7D20\u7684 state \u72B6\u6001\u6837\u5F0F\u914D\u7F6E
    var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
    var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
    line_line(primary);
    point_point(pointParams);
    area_area(second);
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function radar_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a)))(params);
}
/**
 * coord \u914D\u7F6E
 * @param params
 */
function coord(params) {
    var chart = params.chart, options = params.options;
    var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
    chart.coordinate('polar', {
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle,
    });
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function radar_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
    chart.axis(xField, xAxis);
    chart.axis(yField, yAxis);
    return params;
}
/**
 * label \u914D\u7F6E
 * @param params
 */
function radar_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField;
    var geometry = findGeometry(chart, 'line');
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: [yField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * \u96F7\u8FBE\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function radar_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(radar_adaptor_geometry, radar_adaptor_meta, common_theme, coord, radar_adaptor_axis, common_legend, common_tooltip, radar_adaptor_label, common_interaction, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radar/interactions/radar-tooltip-action.js



var RadarTooltipController = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RadarTooltipController, _super);
    function RadarTooltipController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RadarTooltipController.prototype, "name", {
        get: function () {
            return 'radar-tooltip';
        },
        enumerable: false,
        configurable: true
    });
    RadarTooltipController.prototype.getTooltipItems = function (point) {
        var _a = this.getTooltipCfg(), shared = _a.shared, cfgTitle = _a.title;
        var hintItems = _super.prototype.getTooltipItems.call(this, point);
        if (hintItems.length > 0) {
            var geometry_1 = this.view.geometries[0];
            var dataArray = geometry_1.dataArray;
            var title_1 = hintItems[0].name;
            var result_1 = [];
            dataArray.forEach(function (mappingData) {
                mappingData.forEach(function (d) {
                    var items = Util.getTooltipItems(d, geometry_1);
                    var item = items[0];
                    if (!shared && item && item.name === title_1) {
                        var displayTitle = (0,esm/* isNil */.UM)(cfgTitle) ? title_1 : cfgTitle;
                        result_1.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { name: item.title, title: displayTitle }));
                    }
                    else if (shared && item) {
                        var displayTitle = (0,esm/* isNil */.UM)(cfgTitle) ? item.name || title_1 : cfgTitle;
                        result_1.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { name: item.title, title: displayTitle }));
                    }
                });
            });
            return result_1;
        }
        return [];
    };
    return RadarTooltipController;
}(tooltip));

registerComponentController('radar-tooltip', RadarTooltipController);
/**
 * \u96F7\u8FBE\u56FE tooltip \u6FC0\u6D3B action
 */
var RadarTooltipAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RadarTooltipAction, _super);
    function RadarTooltipAction() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RadarTooltipAction.prototype.init = function () {
        var view = this.context.view;
        view.removeInteraction('tooltip');
    };
    RadarTooltipAction.prototype.show = function () {
        var event = this.context.event;
        var controller = this.getTooltipController();
        controller.showTooltip({ x: event.x, y: event.y });
    };
    RadarTooltipAction.prototype.hide = function () {
        var controller = this.getTooltipController();
        controller.hideTooltip();
    };
    RadarTooltipAction.prototype.getTooltipController = function () {
        var view = this.context.view;
        return view.getController('radar-tooltip');
    };
    return RadarTooltipAction;
}(action_base));

//# sourceMappingURL=radar-tooltip-action.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radar/interactions/index.js


registerAction('radar-tooltip', RadarTooltipAction);
registerInteraction('radar-tooltip', {
    start: [{ trigger: 'plot:mousemove', action: 'radar-tooltip:show' }],
    end: [{ trigger: 'plot:mouseleave', action: 'radar-tooltip:hide' }],
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radar/index.js





var Radar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Radar, _super);
    function Radar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'radar';
        return _this;
    }
    /**
     * @override
     * @param data
     */
    Radar.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        this.chart.changeData(data);
    };
    /**
     * \u83B7\u53D6 \u96F7\u8FBE\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Radar.prototype.getDefaultOptions = function () {
        return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
            xAxis: {
                label: {
                    offset: 15,
                },
                grid: {
                    line: {
                        type: 'line',
                    },
                },
            },
            yAxis: {
                grid: {
                    line: {
                        type: 'circle',
                    },
                },
            },
            legend: {
                position: 'top',
            },
            tooltip: {
                shared: true,
                showCrosshairs: true,
                showMarkers: true,
                crosshairs: {
                    type: 'xy',
                    line: {
                        style: {
                            stroke: '#565656',
                            lineDash: [4],
                        },
                    },
                    follow: true,
                },
            },
        });
    };
    /**
     * \u83B7\u53D6 \u96F7\u8FBE\u56FE \u7684\u9002\u914D\u5668
     */
    Radar.prototype.getSchemaAdaptor = function () {
        return radar_adaptor_adaptor;
    };
    return Radar;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radial-bar/utils.js

function getScaleMax(maxAngle, yField, data) {
    var yData = data.map(function (item) { return item[yField]; }).filter(function (v) { return v !== undefined; });
    var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
    var formatRadian = Math.abs(maxAngle) % 360;
    if (!formatRadian) {
        return maxValue;
    }
    return (maxValue * 360) / formatRadian;
}
/**
 * \u83B7\u53D6\u5806\u53E0\u4E4B\u540E\u7684\u6570\u636E
 */
function getStackedData(data, xField, yField) {
    var stackedData = [];
    data.forEach(function (item) {
        var valueItem = stackedData.find(function (v) { return v[xField] === item[xField]; });
        if (valueItem) {
            valueItem[yField] += item[yField] || null;
        }
        else {
            stackedData.push((0,tslib_es6/* __assign */.pi)({}, item));
        }
    });
    return stackedData;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radial-bar/adaptor.js






/**
 * geometry \u5904\u7406
 * @param params
 */
function radial_bar_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var style = options.barStyle, color = options.color, tooltip = options.tooltip, colorField = options.colorField, type = options.type, xField = options.xField, yField = options.yField, data = options.data, shape = options.shape;
    // \u5904\u7406\u4E0D\u5408\u6CD5\u7684\u6570\u636E
    var processData = processIllegalData(data, yField);
    chart.data(processData);
    var p = deepAssign({}, params, {
        options: {
            tooltip: tooltip,
            seriesField: colorField,
            interval: {
                style: style,
                color: color,
                shape: shape || (type === 'line' ? 'line' : 'intervel'),
            },
            // \u67F1\u5B50\u7684\u4E00\u4E9B\u6837\u5F0F\u8BBE\u7F6E\uFF1A\u67F1\u5B50\u6700\u5C0F\u5BBD\u5EA6\u3001\u67F1\u5B50\u6700\u5927\u5BBD\u5EA6\u3001\u67F1\u5B50\u80CC\u666F
            minColumnWidth: options.minBarWidth,
            maxColumnWidth: options.maxBarWidth,
            columnBackground: options.barBackground,
        },
    });
    interval_interval(p);
    if (type === 'line') {
        point_point({
            chart: chart,
            options: { xField: xField, yField: yField, seriesField: colorField, point: { shape: 'circle', color: color } },
        });
    }
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function radial_bar_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var yField = options.yField, xField = options.xField, data = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
    var actualData = isStack && !isGroup && colorField ? getStackedData(data, xField, yField) : data;
    var processData = processIllegalData(actualData, yField);
    return flow(common_scale((_a = {},
        _a[yField] = {
            min: 0,
            max: getScaleMax(maxAngle, yField, processData),
        },
        _a)))(params);
}
/**
 * coordinate \u914D\u7F6E
 * @param params
 */
function radial_bar_adaptor_coordinate(params) {
    var chart = params.chart, options = params.options;
    var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
    chart
        .coordinate({
        type: 'polar',
        cfg: {
            radius: radius,
            innerRadius: innerRadius,
            startAngle: startAngle,
            endAngle: endAngle,
        },
    })
        .transpose();
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function radial_bar_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xField = options.xField, xAxis = options.xAxis;
    chart.axis(xField, xAxis);
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function radial_bar_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, yField = options.yField;
    var intervalGeometry = findGeometry(chart, 'interval');
    // label \u4E3A false, \u7A7A \u5219\u4E0D\u663E\u793A label
    if (!label) {
        intervalGeometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        intervalGeometry.label({
            fields: [yField],
            callback: callback,
            cfg: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, transformLabel(cfg)), { type: 'polar' }),
        });
    }
    return params;
}
/**
 * \u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function radial_bar_adaptor_adaptor(params) {
    return flow(pattern('barStyle'), radial_bar_adaptor_geometry, radial_bar_adaptor_meta, radial_bar_adaptor_axis, radial_bar_adaptor_coordinate, common_interaction, animation, common_theme, common_tooltip, common_legend, common_annotation(), radial_bar_adaptor_label)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radial-bar/constant.js


/**
 * \u7389\u73CF\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var radial_bar_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    interactions: [{ type: 'element-active' }],
    legend: false,
    tooltip: {
        showMarkers: false,
    },
    xAxis: {
        grid: null,
        tickLine: null,
        line: null,
    },
    maxAngle: 240,
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/radial-bar/index.js




/**
 * \u7389\u73CF\u56FE
 */
var RadialBar = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(RadialBar, _super);
    function RadialBar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'radial-bar';
        return _this;
    }
    RadialBar.getDefaultOptions = function () {
        return radial_bar_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    RadialBar.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        // \u66F4\u65B0\u7389\u73CF\u56FE\u7684 scale
        radial_bar_adaptor_meta({ chart: this.chart, options: this.options });
        this.chart.changeData(data);
    };
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u914D\u7F6E
     */
    RadialBar.prototype.getDefaultOptions = function () {
        return RadialBar.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    RadialBar.prototype.getSchemaAdaptor = function () {
        return radial_bar_adaptor_adaptor;
    };
    return RadialBar;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/rose/adaptor.js





/**
 * geometry \u914D\u7F6E\u5904\u7406
 * @param params
 */
function rose_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, sectorStyle = options.sectorStyle, shape = options.shape, color = options.color;
    // \u88C5\u8F7D\u6570\u636E
    chart.data(data);
    flow(interval_interval)(deepAssign({}, params, {
        options: {
            marginRatio: 1,
            interval: {
                style: sectorStyle,
                color: color,
                shape: shape,
            },
        },
    }));
    return params;
}
/**
 * label \u914D\u7F6E
 * @param params
 */
function rose_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, xField = options.xField;
    var geometry = findGeometry(chart, 'interval');
    // label \u4E3A false \u4E0D\u663E\u793A label
    if (label === false) {
        geometry.label(false);
    }
    else if ((0,esm/* isObject */.Kn)(label)) {
        var callback = label.callback, fields = label.fields, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback", "fields"]);
        var offset = cfg.offset;
        var layout = cfg.layout;
        // \u5F53 label \u5728 shape \u5916\u90E8\u663E\u793A\u65F6\uFF0C\u8BBE\u7F6E 'limit-in-shape' \u4F1A
        // \u9020\u6210 label \u4E0D\u663E\u793A\u3002
        if (offset === undefined || offset >= 0) {
            layout = layout ? ((0,esm/* isArray */.kJ)(layout) ? layout : [layout]) : [];
            cfg.layout = (0,esm/* filter */.hX)(layout, function (v) { return v.type !== 'limit-in-shape'; });
            cfg.layout.length || delete cfg.layout;
        }
        geometry.label({
            fields: fields || [xField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    else {
        invariant_log(LEVEL.WARN, label === null, 'the label option must be an Object.');
        geometry.label({ fields: [xField] });
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function rose_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, seriesField = options.seriesField;
    if (legend === false) {
        chart.legend(false);
    }
    else if (seriesField) {
        chart.legend(seriesField, legend);
    }
    return params;
}
/**
 * coord \u914D\u7F6E
 * @param params
 */
function rose_adaptor_coordinate(params) {
    var chart = params.chart, options = params.options;
    var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
    chart.coordinate({
        type: 'polar',
        cfg: {
            radius: radius,
            innerRadius: innerRadius,
            startAngle: startAngle,
            endAngle: endAngle,
        },
    });
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function rose_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a)))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function rose_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    // \u4E3A falsy \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (!xAxis) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (!yAxis) {
        chart.axis(yField, false);
    }
    else {
        chart.axis(yField, yAxis);
    }
    return params;
}
/**
 * \u73AB\u7470\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function rose_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    flow(pattern('sectorStyle'), rose_adaptor_geometry, rose_adaptor_meta, rose_adaptor_label, rose_adaptor_coordinate, rose_adaptor_axis, rose_adaptor_legend, common_tooltip, common_interaction, animation, common_theme, common_annotation(), common_state)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/rose/constant.js


/**
 * \u73AB\u7470\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var rose_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    xAxis: false,
    yAxis: false,
    legend: {
        position: 'right',
        radio: {},
    },
    sectorStyle: {
        stroke: '#fff',
        lineWidth: 1,
    },
    label: {
        layout: {
            type: 'limit-in-shape',
        },
    },
    tooltip: {
        shared: true,
        showMarkers: false,
    },
    interactions: [{ type: 'active-region' }],
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/rose/index.js




var Rose = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Rose, _super);
    function Rose() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u73AB\u7470\u56FE */
        _this.type = 'rose';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u73AB\u7470\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Rose.getDefaultOptions = function () {
        return rose_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    Rose.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        this.chart.changeData(data);
    };
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u7684 options \u914D\u7F6E\u9879
     */
    Rose.prototype.getDefaultOptions = function () {
        return Rose.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u73AB\u7470\u56FE \u7684\u9002\u914D\u5668
     */
    Rose.prototype.getSchemaAdaptor = function () {
        return rose_adaptor_adaptor;
    };
    return Rose;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/constant.js
var sankey_constant_X_FIELD = 'x';
var sankey_constant_Y_FIELD = 'y';
var COLOR_FIELD = 'name';
var NODES_VIEW_ID = 'nodes';
var EDGES_VIEW_ID = 'edges';
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/circle.js

/**
 * \u6839\u636E edges \u83B7\u53D6\u5BF9\u5E94\u7684 node \u7ED3\u6784
 */
function getNodes(edges, sourceField, targetField) {
    var nodes = [];
    edges.forEach(function (e) {
        var source = e[sourceField];
        var target = e[targetField];
        if (!nodes.includes(source)) {
            nodes.push(source);
        }
        if (!nodes.includes(target)) {
            nodes.push(target);
        }
    });
    return nodes;
}
/**
 * \u6839\u636E edges \u83B7\u53D6\u5BF9\u5E94\u7684 dfs \u90BB\u63A5\u77E9\u9635
 */
function getMatrix(edges, nodes, sourceField, targetField) {
    var graphMatrix = {};
    nodes.forEach(function (pre) {
        graphMatrix[pre] = {};
        nodes.forEach(function (next) {
            graphMatrix[pre][next] = 0;
        });
    });
    edges.forEach(function (edge) {
        graphMatrix[edge[sourceField]][edge[targetField]] = 1;
    });
    return graphMatrix;
}
/**
 * \u4F7F\u7528 DFS \u601D\u8DEF\u5207\u65AD\u6851\u57FA\u56FE\u6570\u636E\u4E2D\u7684\u73AF\uFF08\u4F1A\u4E22\u5931\u6570\u636E\uFF09\uFF0C\u4FDD\u8BC1\u987A\u5E8F
 * @param data
 * @param sourceField
 * @param targetField
 */
function cutoffCircle(edges, sourceField, targetField) {
    if (!(0,esm/* isArray */.kJ)(edges))
        return [];
    // \u5F85\u5220\u9664\u7684\u73AF\u72B6\u7ED3\u6784
    var removedData = [];
    // \u83B7\u53D6\u6240\u6709\u7684\u8282\u70B9
    var nodes = getNodes(edges, sourceField, targetField);
    // \u83B7\u53D6\u8282\u70B9\u4E0E\u8FB9\u7684\u90BB\u63A5\u77E9\u9635
    var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
    // visited\uFF1A\u6807\u8BB0\u8282\u70B9\u8BBF\u95EE\u72B6\u6001, 0\uFF1A\u672A\u8BBF\u95EE,1\uFF1A\u8BBF\u95EE\u4E2D, -1\uFF1A\u5DF2\u8BBF\u95EE
    var visited = {};
    // \u521D\u59CB\u5316visited
    nodes.forEach(function (node) {
        visited[node] = 0;
    });
    // \u56FE\u7684\u6DF1\u5EA6\u904D\u5386\u51FD\u6570
    function DFS(dfsNode) {
        // \u8282\u70B9\u72B6\u6001\u7F6E\u4E3A\u6B63\u5728\u8BBF\u95EE
        visited[dfsNode] = 1;
        nodes.forEach(function (node) {
            if (graphMatrix[dfsNode][node] != 0) {
                // \u5F53\u524D\u8282\u70B9\u5728\u8BBF\u95EE\u4E2D\uFF0C\u518D\u6B21\u88AB\u8BBF\u95EE\uFF0C\u8BC1\u660E\u6709\u73AF\uFF0C\u79FB\u52A8\u5230 removeData
                if (visited[node] == 1) {
                    // \u62FC\u63A5\u4E3A\u5B57\u7B26\u4E32\uFF0C\u65B9\u4FBF\u6700\u540E\u8FC7\u6EE4
                    removedData.push("".concat(dfsNode, "_").concat(node));
                }
                else if (visited[node] == -1) {
                    // \u5F53\u524D\u7ED3\u70B9\u53CA\u540E\u8FB9\u7684\u7ED3\u70B9\u90FD\u88AB\u8BBF\u95EE\u8FC7\uFF0C\u76F4\u63A5\u8DF3\u81F3\u4E0B\u4E00\u4E2A\u7ED3\u70B9
                    return;
                }
                else {
                    DFS(node); // \u5426\u5219\u9012\u5F52\u8BBF\u95EE
                }
            }
        });
        //\u904D\u5386\u8FC7\u6240\u6709\u76F8\u8FDE\u7684\u7ED3\u70B9\u540E\uFF0C\u628A\u672C\u8282\u70B9\u6807\u8BB0\u4E3A-1
        visited[dfsNode] = -1;
    }
    // \u5BF9\u6BCF\u4E2A\u8282\u70B9\u6267\u884C dfs \u64CD\u4F5C
    nodes.forEach(function (node) {
        //\u8BE5\u7ED3\u70B9\u540E\u8FB9\u7684\u7ED3\u70B9\u90FD\u88AB\u8BBF\u95EE\u8FC7\u4E86\uFF0C\u8DF3\u8FC7\u5B83
        if (visited[node] == -1) {
            return;
        }
        DFS(node);
    });
    if (removedData.length !== 0) {
        console.warn("sankey data contains circle, ".concat(removedData.length, " records removed."), removedData);
    }
    // \u8FC7\u6EE4 remove \u8DEF\u5F84
    return edges.filter(function (edge) { return removedData.findIndex(function (i) { return i === "".concat(edge[sourceField], "_").concat(edge[targetField]); }) < 0; });
}
//# sourceMappingURL=circle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/sankey/align.js

function targetDepth(d) {
    return d.target.depth;
}
function left(node) {
    return node.depth;
}
function right(node, n) {
    return n - 1 - node.height;
}
function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0,esm/* minBy */.F)(node.sourceLinks, targetDepth) - 1 : 0;
}
//# sourceMappingURL=align.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/sankey/helper.js
function helper_constant(x) {
    return function () {
        return x;
    };
}
function sumBy(arr, func) {
    var r = 0;
    for (var i = 0; i < arr.length; i++) {
        r += func(arr[i]);
    }
    return r;
}
/**
 * \u8BA1\u7B97\u6700\u5927\u503C
 * @param arr
 * @param func
 */
function maxValueBy(arr, func) {
    var r = -Infinity;
    for (var i = 0; i < arr.length; i++) {
        r = Math.max(func(arr[i]), r);
    }
    return r;
}
/**
 * \u8BA1\u7B97\u6700\u5C0F\u503C
 * @param arr
 * @param func
 */
function minValueBy(arr, func) {
    var r = Infinity;
    for (var i = 0; i < arr.length; i++) {
        r = Math.min(func(arr[i]), r);
    }
    return r;
}
//# sourceMappingURL=helper.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/sankey/sankey.js


function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
    return a.y0 - b.y0;
}
function value(d) {
    return d.value;
}
function defaultId(d) {
    return d.index;
}
function defaultNodes(graph) {
    return graph.nodes;
}
function defaultLinks(graph) {
    return graph.links;
}
function sankey_find(nodeById, id) {
    var node = nodeById.get(id);
    if (!node)
        throw new Error('missing: ' + id);
    return node;
}
function computeLinkBreadths(_a) {
    var nodes = _a.nodes;
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        var y0 = node.y0;
        var y1 = y0;
        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
            var link = _c[_b];
            link.y0 = y0 + link.width / 2;
            y0 += link.width;
        }
        for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
            var link = _e[_d];
            link.y1 = y1 + link.width / 2;
            y1 += link.width;
        }
    }
}
function Sankey() {
    var x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent
    var dx = 24; // nodeWidth
    var dy = 8, py; // nodePadding
    var id = defaultId;
    var align = justify;
    var depth;
    var sort;
    var linkSort;
    var nodes = defaultNodes;
    var links = defaultLinks;
    var iterations = 6;
    function sankey(arg) {
        var graph = {
            nodes: nodes(arg),
            links: links(arg),
        };
        computeNodeLinks(graph);
        computeNodeValues(graph);
        computeNodeDepths(graph);
        computeNodeHeights(graph);
        computeNodeBreadths(graph);
        computeLinkBreadths(graph);
        return graph;
    }
    sankey.update = function (graph) {
        computeLinkBreadths(graph);
        return graph;
    };
    sankey.nodeId = function (_) {
        return arguments.length ? ((id = typeof _ === 'function' ? _ : helper_constant(_)), sankey) : id;
    };
    sankey.nodeAlign = function (_) {
        return arguments.length ? ((align = typeof _ === 'function' ? _ : helper_constant(_)), sankey) : align;
    };
    sankey.nodeDepth = function (_) {
        return arguments.length ? ((depth = typeof _ === 'function' ? _ : _), sankey) : depth;
    };
    sankey.nodeSort = function (_) {
        return arguments.length ? ((sort = _), sankey) : sort;
    };
    sankey.nodeWidth = function (_) {
        return arguments.length ? ((dx = +_), sankey) : dx;
    };
    sankey.nodePadding = function (_) {
        return arguments.length ? ((dy = py = +_), sankey) : dy;
    };
    sankey.nodes = function (_) {
        return arguments.length ? ((nodes = typeof _ === 'function' ? _ : helper_constant(_)), sankey) : nodes;
    };
    sankey.links = function (_) {
        return arguments.length ? ((links = typeof _ === 'function' ? _ : helper_constant(_)), sankey) : links;
    };
    sankey.linkSort = function (_) {
        return arguments.length ? ((linkSort = _), sankey) : linkSort;
    };
    sankey.size = function (_) {
        return arguments.length ? ((x0 = y0 = 0), (x1 = +_[0]), (y1 = +_[1]), sankey) : [x1 - x0, y1 - y0];
    };
    sankey.extent = function (_) {
        return arguments.length
            ? ((x0 = +_[0][0]), (x1 = +_[1][0]), (y0 = +_[0][1]), (y1 = +_[1][1]), sankey)
            : [
                [x0, y0],
                [x1, y1],
            ];
    };
    sankey.iterations = function (_) {
        return arguments.length ? ((iterations = +_), sankey) : iterations;
    };
    function computeNodeLinks(_a) {
        var nodes = _a.nodes, links = _a.links;
        nodes.forEach(function (node, idx) {
            node.index = idx;
            node.sourceLinks = [];
            node.targetLinks = [];
        });
        var nodeById = new Map(nodes.map(function (d) { return [id(d), d]; }));
        links.forEach(function (link, idx) {
            link.index = idx;
            var source = link.source, target = link.target;
            if (typeof source !== 'object')
                source = link.source = sankey_find(nodeById, source);
            if (typeof target !== 'object')
                target = link.target = sankey_find(nodeById, target);
            source.sourceLinks.push(link);
            target.targetLinks.push(link);
        });
        if (linkSort != null) {
            for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
                sourceLinks.sort(linkSort);
                targetLinks.sort(linkSort);
            }
        }
    }
    function computeNodeValues(_a) {
        var nodes = _a.nodes;
        for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
            var node = nodes_3[_i];
            node.value =
                node.fixedValue === undefined
                    ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value))
                    : node.fixedValue;
        }
    }
    function computeNodeDepths(_a) {
        var nodes = _a.nodes;
        var n = nodes.length;
        var current = new Set(nodes);
        var next = new Set();
        var x = 0;
        while (current.size) {
            current.forEach(function (node) {
                node.depth = x;
                for (var _i = 0, _a = node.sourceLinks; _i < _a.length; _i++) {
                    var target = _a[_i].target;
                    next.add(target);
                }
            });
            if (++x > n)
                throw new Error('circular link');
            current = next;
            next = new Set();
        }
        // \u5982\u679C\u914D\u7F6E\u4E86 depth\uFF0C\u5219\u8BBE\u7F6E\u81EA\u5B9A\u4E49 depth
        if (depth) {
            var maxDepth = Math.max(maxValueBy(nodes, function (d) { return d.depth; }) + 1, 0);
            var node = void 0;
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                node.depth = depth.call(null, node, maxDepth);
            }
        }
    }
    function computeNodeHeights(_a) {
        var nodes = _a.nodes;
        var n = nodes.length;
        var current = new Set(nodes);
        var next = new Set();
        var x = 0;
        while (current.size) {
            current.forEach(function (node) {
                node.height = x;
                for (var _i = 0, _a = node.targetLinks; _i < _a.length; _i++) {
                    var source = _a[_i].source;
                    next.add(source);
                }
            });
            if (++x > n)
                throw new Error('circular link');
            current = next;
            next = new Set();
        }
    }
    function computeNodeLayers(_a) {
        var nodes = _a.nodes;
        var x = Math.max(maxValueBy(nodes, function (d) { return d.depth; }) + 1, 0);
        var kx = (x1 - x0 - dx) / (x - 1);
        var columns = new Array(x).fill(0).map(function () { return []; });
        for (var _i = 0, nodes_4 = nodes; _i < nodes_4.length; _i++) {
            var node = nodes_4[_i];
            var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
            node.layer = i;
            node.x0 = x0 + i * kx;
            node.x1 = node.x0 + dx;
            if (columns[i])
                columns[i].push(node);
            else
                columns[i] = [node];
        }
        if (sort)
            for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {
                var column = columns_1[_b];
                column.sort(sort);
            }
        return columns;
    }
    function initializeNodeBreadths(columns) {
        var ky = minValueBy(columns, function (c) { return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value); });
        for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
            var nodes_6 = columns_2[_i];
            var y = y0;
            for (var _a = 0, nodes_5 = nodes_6; _a < nodes_5.length; _a++) {
                var node = nodes_5[_a];
                node.y0 = y;
                node.y1 = y + node.value * ky;
                y = node.y1 + py;
                for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
                    var link = _c[_b];
                    link.width = link.value * ky;
                }
            }
            y = (y1 - y + py) / (nodes_6.length + 1);
            for (var i = 0; i < nodes_6.length; ++i) {
                var node = nodes_6[i];
                node.y0 += y * (i + 1);
                node.y1 += y * (i + 1);
            }
            reorderLinks(nodes_6);
        }
    }
    function computeNodeBreadths(graph) {
        var columns = computeNodeLayers(graph);
        py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function (c) { return c.length; }) - 1));
        initializeNodeBreadths(columns);
        for (var i = 0; i < iterations; ++i) {
            var alpha = Math.pow(0.99, i);
            var beta = Math.max(1 - alpha, (i + 1) / iterations);
            relaxRightToLeft(columns, alpha, beta);
            relaxLeftToRight(columns, alpha, beta);
        }
    }
    // Reposition each node based on its incoming (target) links.
    function relaxLeftToRight(columns, alpha, beta) {
        for (var i = 1, n = columns.length; i < n; ++i) {
            var column = columns[i];
            for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
                var target = column_1[_i];
                var y = 0;
                var w = 0;
                for (var _a = 0, _b = target.targetLinks; _a < _b.length; _a++) {
                    var _c = _b[_a], source = _c.source, value_1 = _c.value;
                    var v = value_1 * (target.layer - source.layer);
                    y += targetTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0))
                    continue;
                var dy_1 = (y / w - target.y0) * alpha;
                target.y0 += dy_1;
                target.y1 += dy_1;
                reorderNodeLinks(target);
            }
            if (sort === undefined)
                column.sort(ascendingBreadth);
            if (column.length)
                resolveCollisions(column, beta);
        }
    }
    // Reposition each node based on its outgoing (source) links.
    function relaxRightToLeft(columns, alpha, beta) {
        for (var n = columns.length, i = n - 2; i >= 0; --i) {
            var column = columns[i];
            for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
                var source = column_2[_i];
                var y = 0;
                var w = 0;
                for (var _a = 0, _b = source.sourceLinks; _a < _b.length; _a++) {
                    var _c = _b[_a], target = _c.target, value_2 = _c.value;
                    var v = value_2 * (target.layer - source.layer);
                    y += sourceTop(source, target) * v;
                    w += v;
                }
                if (!(w > 0))
                    continue;
                var dy_2 = (y / w - source.y0) * alpha;
                source.y0 += dy_2;
                source.y1 += dy_2;
                reorderNodeLinks(source);
            }
            if (sort === undefined)
                column.sort(ascendingBreadth);
            if (column.length)
                resolveCollisions(column, beta);
        }
    }
    function resolveCollisions(nodes, alpha) {
        var i = nodes.length >> 1;
        var subject = nodes[i];
        resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
        resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
        resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
        resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
    }
    // Push any overlapping nodes down.
    function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
        for (; i < nodes.length; ++i) {
            var node = nodes[i];
            var dy_3 = (y - node.y0) * alpha;
            if (dy_3 > 1e-6)
                (node.y0 += dy_3), (node.y1 += dy_3);
            y = node.y1 + py;
        }
    }
    // Push any overlapping nodes up.
    function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
        for (; i >= 0; --i) {
            var node = nodes[i];
            var dy_4 = (node.y1 - y) * alpha;
            if (dy_4 > 1e-6)
                (node.y0 -= dy_4), (node.y1 -= dy_4);
            y = node.y0 - py;
        }
    }
    function reorderNodeLinks(_a) {
        var sourceLinks = _a.sourceLinks, targetLinks = _a.targetLinks;
        if (linkSort === undefined) {
            for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {
                var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;
                sourceLinks_2.sort(ascendingTargetBreadth);
            }
            for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {
                var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;
                targetLinks_2.sort(ascendingSourceBreadth);
            }
        }
    }
    function reorderLinks(nodes) {
        if (linkSort === undefined) {
            for (var _i = 0, nodes_7 = nodes; _i < nodes_7.length; _i++) {
                var _a = nodes_7[_i], sourceLinks = _a.sourceLinks, targetLinks = _a.targetLinks;
                sourceLinks.sort(ascendingTargetBreadth);
                targetLinks.sort(ascendingSourceBreadth);
            }
        }
    }
    // Returns the target.y0 that would produce an ideal link from source to target.
    function targetTop(source, target) {
        var y = source.y0 - ((source.sourceLinks.length - 1) * py) / 2;
        for (var _i = 0, _a = source.sourceLinks; _i < _a.length; _i++) {
            var _b = _a[_i], node = _b.target, width = _b.width;
            if (node === target)
                break;
            y += width + py;
        }
        for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {
            var _e = _d[_c], node = _e.source, width = _e.width;
            if (node === source)
                break;
            y -= width;
        }
        return y;
    }
    // Returns the source.y0 that would produce an ideal link from source to target.
    function sourceTop(source, target) {
        var y = target.y0 - ((target.targetLinks.length - 1) * py) / 2;
        for (var _i = 0, _a = target.targetLinks; _i < _a.length; _i++) {
            var _b = _a[_i], node = _b.source, width = _b.width;
            if (node === source)
                break;
            y += width + py;
        }
        for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
            var _e = _d[_c], node = _e.target, width = _e.width;
            if (node === target)
                break;
            y -= width;
        }
        return y;
    }
    return sankey;
}
//# sourceMappingURL=sankey.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/sankey/index.js
/**
 * \u6851\u57FA\u56FE\u5E03\u5C40\u4EE3\u7801\uFF0CFork from https://github.com/d3/d3-sankey/tree/master/src
 * \u4E3B\u8981\u4FEE\u6539\uFF1A
 * 1. \u5220\u9664 d3-array \u4F9D\u8D56
 * 2. \u4FEE\u6539\u4E00\u4E9B set map \u7684\u904D\u5386
 * 3. \u6570\u7EC4\u521B\u5EFA\u51FA [empty] \u5BFC\u81F4\u51FA\u9519
 * 4. \u901A\u8FC7 align \u65B9\u6CD5\u5B9E\u73B0 depth \u81EA\u5B9A\u4E49
 */



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/layout.js


var ALIGN_METHOD = {
    left: left,
    right: right,
    center: center,
    justify: justify,
};
/**
 * \u9ED8\u8BA4\u503C
 */
var layout_DEFAULT_OPTIONS = {
    nodeId: function (node) { return node.index; },
    nodeAlign: 'justify',
    nodeWidth: 0.008,
    nodePadding: 0.03,
    nodeSort: undefined,
};
/**
 * \u83B7\u5F97 align function
 * @param nodeAlign
 * @param nodeDepth
 */
function getNodeAlignFunction(nodeAlign) {
    var func = (0,esm/* isString */.HD)(nodeAlign) ? ALIGN_METHOD[nodeAlign] : (0,esm/* isFunction */.mf)(nodeAlign) ? nodeAlign : null;
    return func || justify;
}
function layout_getDefaultOptions(sankeyLayoutOptions) {
    return (0,esm/* assign */.f0)({}, layout_DEFAULT_OPTIONS, sankeyLayoutOptions);
}
/**
 * \u6851\u57FA\u56FE\u5229\u7528\u6570\u636E\u8FDB\u884C\u5E03\u5C40\u7684\u51FD\u6570\uFF0C\u6700\u7EC8\u8FD4\u56DE\u8282\u70B9\u3001\u8FB9\u7684\u4F4D\u7F6E\uFF080 - 1 \u7684\u4FE1\u606F\uFF09
 * \u5C06\u4F1A\u4FEE\u6539 data \u6570\u636E
 * @param sankeyLayoutOptions
 * @param data
 */
function sankeyLayout(sankeyLayoutOptions, data) {
    var options = layout_getDefaultOptions(sankeyLayoutOptions);
    var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
    var sankeyProcessor = Sankey()
        // .links((d: any) => d.links)
        // .nodes((d: any) => d.nodes)
        .nodeSort(nodeSort)
        .nodeWidth(nodeWidth)
        .nodePadding(nodePadding)
        .nodeDepth(nodeDepth)
        .nodeAlign(getNodeAlignFunction(nodeAlign))
        .extent([
        [0, 0],
        [1, 1],
    ])
        .nodeId(nodeId);
    // \u8FDB\u884C\u6851\u57FA\u56FE\u5E03\u5C40\u5904\u7406
    var layoutData = sankeyProcessor(data);
    // post process (x, y), etc.
    var nodes = layoutData.nodes
        .map(function (node) {
        var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
        /* points
         * 3---2
         * |   |
         * 0---1
         */
        node.x = [x0, x1, x1, x0];
        node.y = [y0, y0, y1, y1];
        return node;
    })
        .filter(function (node) {
        return node.name !== null;
    });
    var links = layoutData.links
        .map(function (edge) {
        var source = edge.source, target = edge.target;
        var sx = source.x1;
        var tx = target.x0;
        edge.x = [sx, sx, tx, tx];
        var offset = edge.width / 2;
        edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];
        return edge;
    })
        .filter(function (edge) {
        var source = edge.source, target = edge.target;
        return source.name !== null && target.name !== null;
    });
    return { nodes: nodes, links: links };
}
//# sourceMappingURL=layout.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/helper.js





/**
 * \u662F\u5426\u662F node-link \u7C7B\u578B\u7684\u6570\u636E\u7ED3\u6784
 * @param dataTyp
 * @returns
 */
function isNodeLink(dataType) {
    return dataType === 'node-link';
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
    return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
    return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
/**
 * \u5C06\u6851\u57FA\u56FE\u914D\u7F6E\u7ECF\u8FC7 layout\uFF0C\u751F\u6210\u6700\u7EC8\u7684 view \u6570\u636E
 * @param options
 * @param width
 * @param height
 */
function transformToViewsData(options, width, height) {
    var dataType = options.dataType, data = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a = options.rawFields, rawFields = _a === void 0 ? [] : _a;
    var sankeyLayoutInputData;
    if (!isNodeLink(dataType)) {
        sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data, sourceField, targetField), sourceField, targetField, weightField, rawFields);
    }
    else {
        sankeyLayoutInputData = data;
    }
    // 3. layout \u4E4B\u540E\u7684\u6570\u636E
    var _b = sankeyLayout({
        nodeAlign: nodeAlign,
        nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
        nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
        nodeSort: nodeSort,
        nodeDepth: nodeDepth,
    }, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
    // 4. \u751F\u6210\u7ED8\u56FE\u6570\u636E
    return {
        nodes: nodes.map(function (node) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(node, (0,tslib_es6/* __spreadArray */.ev)(['x', 'y', 'name'], rawFields, true))), { isNode: true });
        }),
        edges: links.map(function (link) {
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, (0,tslib_es6/* __spreadArray */.ev)(['x', 'y', 'value'], rawFields, true))), { isNode: false });
        }),
    };
}
//# sourceMappingURL=helper.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/adaptor.js








/**
 * \u9ED8\u8BA4\u914D\u7F6E\u9879 \u5904\u7406
 * @param params
 */
function sankey_adaptor_defaultOptions(params) {
    var options = params.options;
    var _a = options.rawFields, rawFields = _a === void 0 ? [] : _a;
    return deepAssign({}, {
        options: {
            tooltip: {
                fields: (0,esm/* uniq */.jj)((0,tslib_es6/* __spreadArray */.ev)(['name', 'source', 'target', 'value', 'isNode'], rawFields, true)),
            },
            label: {
                fields: (0,esm/* uniq */.jj)((0,tslib_es6/* __spreadArray */.ev)(['x', 'name'], rawFields, true)),
            },
        },
    }, params);
}
/**
 * geometry \u5904\u7406
 * @param params
 */
function sankey_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var color = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label = options.label, tooltip = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState, _a = options.rawFields, rawFields = _a === void 0 ? [] : _a;
    // 1. \u7EC4\u4EF6\uFF0C\u4F18\u5148\u8BBE\u7F6E\uFF0C\u56E0\u4E3A\u5B50 view \u4F1A\u7EE7\u627F\u914D\u7F6E
    chart.legend(false);
    chart.tooltip(tooltip);
    chart.axis(false);
    // y \u955C\u50CF\u4E00\u4E0B\uFF0C\u9632\u6B62\u56FE\u5F62\u987A\u5E8F\u548C\u6570\u636E\u987A\u5E8F\u53CD\u4E86
    chart.coordinate().reflect('y');
    // 2. node edge views
    // @ts-ignore
    var _b = transformToViewsData(options, chart.width, chart.height), nodes = _b.nodes, edges = _b.edges;
    // edge view
    var edgeView = chart.createView({ id: EDGES_VIEW_ID });
    edgeView.data(edges);
    edge_edge({
        chart: edgeView,
        // @ts-ignore
        options: {
            xField: sankey_constant_X_FIELD,
            yField: sankey_constant_Y_FIELD,
            seriesField: COLOR_FIELD,
            rawFields: (0,tslib_es6/* __spreadArray */.ev)(['source', 'target'], rawFields, true),
            edge: {
                color: color,
                style: edgeStyle,
                shape: 'arc',
            },
            tooltip: tooltip,
            state: edgeState,
        },
    });
    var nodeView = chart.createView({ id: NODES_VIEW_ID });
    nodeView.data(nodes);
    polygon_polygon({
        chart: nodeView,
        options: {
            xField: sankey_constant_X_FIELD,
            yField: sankey_constant_Y_FIELD,
            seriesField: COLOR_FIELD,
            polygon: {
                color: color,
                style: nodeStyle,
            },
            label: label,
            tooltip: tooltip,
            state: nodeState,
        },
    });
    chart.interaction('element-active');
    // scale
    chart.scale({
        x: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
        y: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
        name: { sync: 'color', type: 'cat' },
    });
    return params;
}
/**
 * \u52A8\u753B
 * @param params
 */
function sankey_adaptor_animation(params) {
    var chart = params.chart, options = params.options;
    var animation = options.animation;
    var geometries = (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], chart.views[0].geometries, true), chart.views[1].geometries, true);
    addViewAnimation(chart, animation, geometries);
    return params;
}
/**
 * \u8282\u70B9\u62D6\u52A8
 * @param params
 */
function nodeDraggable(params) {
    var chart = params.chart, options = params.options;
    var nodeDraggable = options.nodeDraggable;
    var DRAG_INTERACTION = 'sankey-node-draggable';
    if (nodeDraggable) {
        chart.interaction(DRAG_INTERACTION);
    }
    else {
        chart.removeInteraction(DRAG_INTERACTION);
    }
    return params;
}
/**
 * Interaction \u914D\u7F6E
 * @param params
 */
function sankey_adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    var _a = options.interactions, interactions = _a === void 0 ? [] : _a;
    var nodeInteractions = [].concat(interactions, options.nodeInteractions || []);
    var edgeInteractions = [].concat(interactions, options.edgeInteractions || []);
    var nodeView = findViewById(chart, NODES_VIEW_ID);
    var edgeView = findViewById(chart, EDGES_VIEW_ID);
    nodeInteractions.forEach(function (i) {
        if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
            nodeView.removeInteraction(i.type);
        }
        else {
            nodeView.interaction(i.type, i.cfg || {});
        }
    });
    edgeInteractions.forEach(function (i) {
        if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
            edgeView.removeInteraction(i.type);
        }
        else {
            edgeView.interaction(i.type, i.cfg || {});
        }
    });
    return params;
}
/**
 * \u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function sankey_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(sankey_adaptor_defaultOptions, sankey_adaptor_geometry, sankey_adaptor_interaction, nodeDraggable, sankey_adaptor_animation, common_theme
    // ... \u5176\u4ED6\u7684 adaptor flow
    )(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/interactions/actions/node-drag.js





var SankeyNodeDragAction = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(SankeyNodeDragAction, _super);
    function SankeyNodeDragAction() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * \u662F\u5426\u5728\u62D6\u62FD\u4E2D\u7684\u6807\u8BB0
         */
        _this.isDragging = false;
        return _this;
    }
    /**
     * \u5F53\u524D\u64CD\u4F5C\u7684\u662F\u5426\u662F element
     */
    SankeyNodeDragAction.prototype.isNodeElement = function () {
        var shape = (0,esm/* get */.U2)(this.context, 'event.target');
        if (shape) {
            var element = shape.get('element');
            return element && element.getModel().data.isNode;
        }
        return false;
    };
    SankeyNodeDragAction.prototype.getNodeView = function () {
        return findViewById(this.context.view, NODES_VIEW_ID);
    };
    SankeyNodeDragAction.prototype.getEdgeView = function () {
        return findViewById(this.context.view, EDGES_VIEW_ID);
    };
    /**
     * \u83B7\u53D6\u5F53\u524D\u64CD\u4F5C\u7684 index
     * @param element
     */
    SankeyNodeDragAction.prototype.getCurrentDatumIdx = function (element) {
        return this.getNodeView().geometries[0].elements.indexOf(element);
    };
    /**
     * \u70B9\u51FB\u4E0B\u53BB\uFF0C\u5F00\u59CB
     */
    SankeyNodeDragAction.prototype.start = function () {
        // \u8BB0\u5F55\u5F00\u59CB\u4E86\u7684\u72B6\u6001
        if (this.isNodeElement()) {
            this.prevPoint = {
                x: (0,esm/* get */.U2)(this.context, 'event.x'),
                y: (0,esm/* get */.U2)(this.context, 'event.y'),
            };
            var element = this.context.event.target.get('element');
            var idx = this.getCurrentDatumIdx(element);
            if (idx === -1) {
                return;
            }
            this.currentElementIdx = idx;
            this.context.isDragging = true;
            this.isDragging = true;
            // \u5173\u95ED\u52A8\u753B\u5E76\u6682\u5B58\u914D\u7F6E
            this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
            this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
            this.getNodeView().animate(false);
            this.getEdgeView().animate(false);
        }
    };
    /**
     * \u79FB\u52A8\u8FC7\u7A0B\u4E2D\uFF0C\u5E73\u79FB
     */
    SankeyNodeDragAction.prototype.translate = function () {
        if (this.isDragging) {
            var chart = this.context.view;
            var currentPoint = {
                x: (0,esm/* get */.U2)(this.context, 'event.x'),
                y: (0,esm/* get */.U2)(this.context, 'event.y'),
            };
            var x = currentPoint.x - this.prevPoint.x;
            var y = currentPoint.y - this.prevPoint.y;
            var nodeView = this.getNodeView();
            var element = nodeView.geometries[0].elements[this.currentElementIdx];
            // \u4FEE\u6539\u6570\u636E
            if (element && element.getModel()) {
                var prevDatum = element.getModel().data;
                var data = nodeView.getOptions().data;
                var coordinate = nodeView.getCoordinate();
                var datumGap_1 = {
                    x: x / coordinate.getWidth(),
                    y: y / coordinate.getHeight(),
                };
                var nextDatum = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, prevDatum), { x: prevDatum.x.map(function (x) { return (x += datumGap_1.x); }), y: prevDatum.y.map(function (y) { return (y += datumGap_1.y); }) });
                // \u5904\u7406\u4E00\u4E0B\u5728 [0, 1] \u8303\u56F4
                // 1. \u66F4\u65B0 node \u6570\u636E
                var newData = (0,tslib_es6/* __spreadArray */.ev)([], data, true);
                newData[this.currentElementIdx] = nextDatum;
                nodeView.data(newData);
                // 2. \u66F4\u65B0 edge \u6570\u636E
                var name_1 = prevDatum.name;
                var edgeView = this.getEdgeView();
                var edgeData = edgeView.getOptions().data;
                edgeData.forEach(function (datum) {
                    // 2.1 \u4EE5\u8BE5 node \u4E3A source \u7684\u8FB9\uFF0C\u4FEE\u6539 [x0, x1, x2, x3] \u4E2D\u7684 x0, x1
                    if (datum.source === name_1) {
                        datum.x[0] += datumGap_1.x;
                        datum.x[1] += datumGap_1.x;
                        datum.y[0] += datumGap_1.y;
                        datum.y[1] += datumGap_1.y;
                    }
                    // 2.2 \u4EE5\u8BE5 node \u4E3A target \u7684\u8FB9\uFF0C\u4FEE\u6539 [x0, x1, x2, x3] \u4E2D\u7684 x2, x3
                    if (datum.target === name_1) {
                        datum.x[2] += datumGap_1.x;
                        datum.x[3] += datumGap_1.x;
                        datum.y[2] += datumGap_1.y;
                        datum.y[3] += datumGap_1.y;
                    }
                });
                edgeView.data(edgeData);
                // 3. \u66F4\u65B0\u6700\u65B0\u4F4D\u7F6E
                this.prevPoint = currentPoint;
                // node edge \u90FD\u6539\u53D8\u4E86\uFF0C\u6240\u4EE5\u8981\u4ECE\u5E95\u5C42 render
                chart.render(true);
            }
        }
    };
    /**
     * \u7ED3\u8BBA\uFF0C\u6E05\u9664\u72B6\u6001
     */
    SankeyNodeDragAction.prototype.end = function () {
        this.isDragging = false;
        this.context.isDragging = false;
        this.prevPoint = null;
        this.currentElementIdx = null;
        // \u8FD8\u539F\u52A8\u753B
        this.getNodeView().animate(this.prevNodeAnimateCfg);
        this.getEdgeView().animate(this.prevEdgeAnimateCfg);
    };
    return SankeyNodeDragAction;
}(action_base));

//# sourceMappingURL=node-drag.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/interactions/node-draggable.js


registerAction('sankey-node-drag', SankeyNodeDragAction);
registerInteraction('sankey-node-draggable', {
    showEnable: [
        { trigger: 'polygon:mouseenter', action: 'cursor:pointer' },
        { trigger: 'polygon:mouseleave', action: 'cursor:default' },
    ],
    start: [{ trigger: 'polygon:mousedown', action: 'sankey-node-drag:start' }],
    processing: [
        { trigger: 'plot:mousemove', action: 'sankey-node-drag:translate' },
        { isEnable: function (context) { return context.isDragging; }, trigger: 'plot:mousemove', action: 'cursor:move' },
    ],
    end: [{ trigger: 'plot:mouseup', action: 'sankey-node-drag:end' }],
});
//# sourceMappingURL=node-draggable.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/interactions/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sankey/index.js







// \u6851\u57FA\u56FE\u5185\u7F6E\u4EA4\u4E92

/**
 *  \u6851\u57FA\u56FE Sankey
 */
var sankey_Sankey = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Sankey, _super);
    function Sankey() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'sankey';
        return _this;
    }
    Sankey.getDefaultOptions = function () {
        return {
            appendPadding: 8,
            syncViewPadding: true,
            nodeStyle: {
                opacity: 1,
                fillOpacity: 1,
                lineWidth: 1,
            },
            edgeStyle: {
                opacity: 0.3,
                lineWidth: 0,
            },
            edgeState: {
                active: {
                    style: {
                        opacity: 0.8,
                        lineWidth: 0,
                    },
                },
            },
            label: {
                formatter: function (_a) {
                    var name = _a.name;
                    return name;
                },
                callback: function (x) {
                    var isLast = x[1] === 1; // \u6700\u540E\u4E00\u5217\u9760\u8FB9\u7684\u8282\u70B9
                    return {
                        style: {
                            fill: '#545454',
                            textAlign: isLast ? 'end' : 'start',
                        },
                        offsetX: isLast ? -8 : 8,
                    };
                },
                layout: [
                    {
                        type: 'hide-overlap',
                    },
                ],
            },
            tooltip: {
                showTitle: false,
                showMarkers: false,
                shared: false,
                // \u5185\u7F6E\uFF1Anode \u4E0D\u663E\u793A tooltip\uFF0Cedge \u663E\u793A tooltip
                showContent: function (items) {
                    return !(0,esm/* get */.U2)(items, [0, 'data', 'isNode']);
                },
                formatter: function (datum) {
                    var source = datum.source, target = datum.target, value = datum.value;
                    return {
                        name: source + ' -> ' + target,
                        value: value,
                    };
                },
            },
            nodeWidthRatio: 0.008,
            nodePaddingRatio: 0.01,
            animation: {
                appear: {
                    animation: 'wave-in',
                },
                enter: {
                    animation: 'wave-in',
                },
            },
        };
    };
    /**
     * @override
     * @param data
     */
    Sankey.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        var _a = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a.nodes, edges = _a.edges;
        var nodesView = findViewById(this.chart, NODES_VIEW_ID);
        var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
        nodesView.changeData(nodes);
        edgesView.changeData(edges);
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Sankey.prototype.getSchemaAdaptor = function () {
        return sankey_adaptor_adaptor;
    };
    /**
     * \u83B7\u53D6 \u6761\u5F62\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Sankey.prototype.getDefaultOptions = function () {
        return Sankey.getDefaultOptions();
    };
    return Sankey;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sunburst/constant.js



/**
 * \u7956\u5148\u8282\u70B9\uFF0C\u975E root \u6839\u8282\u70B9
 */
var SUNBURST_ANCESTOR_FIELD = 'ancestor-node';
var SUNBURST_Y_FIELD = 'value';
var SUNBURST_PATH_FIELD = 'path';
/** \u9ED8\u8BA4\u7684\u6E90\u5B57\u6BB5 */
var constant_RAW_FIELDS = [
    SUNBURST_PATH_FIELD,
    NODE_INDEX_FIELD,
    NODE_ANCESTORS_FIELD,
    CHILD_NODE_COUNT,
    'name',
    'depth',
    'height',
];
/**
 * \u65ED\u65E5\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var sunburst_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    innerRadius: 0,
    radius: 0.85,
    // \u5206\u5C42\u914D\u7F6E
    hierarchyConfig: {
        // \u6570\u503C\u5B57\u6BB5\uFF0C\u9ED8\u8BA4\u662F value\uFF08\u53EF\u914D\u7F6E\uFF09
        field: 'value',
    },
    // \u7EC4\u4EF6
    tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20,
        showTitle: false,
    },
    legend: false,
    // \u6837\u5F0F\u8BBE\u7F6E
    sunburstStyle: {
        lineWidth: 0.5,
        stroke: '#FFF',
    },
    // \u9ED8\u8BA4\u5F00\u542F\u4EA4\u4E92
    drilldown: { enabled: true },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/round.js
/* harmony default export */ function treemap_round(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/dice.js
/* harmony default export */ function dice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
    node,
    i = -1,
    n = nodes.length,
    k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/partition.js


/* harmony default export */ function src_partition() {
  var dx = 1,
    dy = 1,
    padding = 0,
    round = false;
  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(treemap_round);
    return root;
  }
  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        dice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
        y0 = node.y0,
        x1 = node.x1 - padding,
        y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };
  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };
  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };
  return partition;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/hierarchy/partition.js



var partition_DEFAULT_OPTIONS = {
    field: 'value',
    size: [1, 1],
    round: false,
    padding: 0,
    // \u9ED8\u8BA4\u964D\u5E8F
    sort: function (a, b) { return b.value - a.value; },
    as: ['x', 'y'],
    // \u662F\u5426\u5FFD\u7565 parentValue, \u5F53\u8BBE\u7F6E\u4E3A true \u65F6\uFF0C\u7236\u8282\u70B9\u7684\u6743\u91CD\u7531\u5B50\u5143\u7D20\u51B3\u5B9A
    ignoreParentValue: true,
};
function partition(data, options) {
    options = (0,esm/* assign */.f0)({}, partition_DEFAULT_OPTIONS, options);
    var as = options.as;
    if (!(0,esm/* isArray */.kJ)(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
    }
    var field;
    try {
        field = getField(options);
    }
    catch (e) {
        console.warn(e);
    }
    var partition = function (data) {
        return src_partition().size(options.size).round(options.round).padding(options.padding)(
        /**
         * d3Hierarchy \u5E03\u5C40\u4E2D\u9700\u6307\u5B9A sum \u51FD\u6570\u8BA1\u7B97 node \u503C\uFF0C\u89C4\u5219\u662F\uFF1A\u4ECE\u5F53\u524D node \u5F00\u59CB\u4EE5 post-order traversal \u7684\u6B21\u5E8F\u4E3A\u5F53\u524D\u8282\u70B9\u4EE5\u53CA\u6BCF\u4E2A\u540E\u4EE3\u8282\u70B9\u8C03\u7528\u6307\u5B9A\u7684 value \u51FD\u6570\uFF0C\u5E76\u8FD4\u56DE\u5F53\u524D node\u3002
         * for example:
         * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
         * parent \u6240\u5F97\u7684\u8BA1\u7B97\u503C\u662F sum(node(parent)) + sum(node(child1)) + sum(node(child2))
         * sum \u51FD\u6570\u4E2D\uFF0Cd \u4E3A\u7528\u6237\u4F20\u5165\u7684 data, children \u4E3A\u4FDD\u7559\u5B57\u6BB5
         */
        hierarchy(data)
            .sum(function (d) {
            return (0,esm/* size */.dp)(d.children)
                ? options.ignoreParentValue
                    ? 0
                    : d[field] - (0,esm/* reduce */.u4)(d.children, function (a, b) { return a + b[field]; }, 0)
                : d[field];
        })
            .sort(options.sort));
    };
    var root = partition(data);
    /*
     * points:
     *   3  2
     *   0  1
     */
    var x = as[0];
    var y = as[1];
    root.each(function (node) {
        var _a, _b;
        node[x] = [node.x0, node.x1, node.x1, node.x0];
        node[y] = [node.y1, node.y1, node.y0, node.y0];
        // \u65ED\u65E5\u56FE\u517C\u5BB9\u4E0B \u65E7\u7248\u672C
        node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
        node.data.name = node.name;
        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
            if (as.indexOf(prop) === -1) {
                delete node[prop];
            }
        });
    });
    return getAllNodes(root);
}
//# sourceMappingURL=partition.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x, c) {
  return x + c.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y, c) {
  return Math.max(y, c.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}
/* harmony default export */ function cluster() {
  var separation = defaultSeparation,
    dx = 1,
    dy = 1,
    nodeSize = false;
  function cluster(root) {
    var previousNode,
      x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function (node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root),
      right = leafRight(root),
      x0 = left.x - separation(left, right) / 2,
      x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };
  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/stratify.js


var preroot = {
    depth: -1
  },
  ambiguous = {};
function stratify_defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
/* harmony default export */ function stratify() {
  var id = stratify_defaultId,
    parentId = defaultParentId;
  function stratify(data) {
    var nodes = Array.from(data),
      n = nodes.length,
      d,
      i,
      root,
      parent,
      node,
      nodeId,
      nodeKey,
      nodeByKey = new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new hierarchy_Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function (node) {
      node.depth = node.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }
  stratify.id = function (x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };
  stratify.parentId = function (x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };
  return stratify;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/tree.js

function tree_defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
    change = 0,
    children = v.children,
    i = children.length,
    w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-\u2019s ancestor is a sibling of v, returns vi-\u2019s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(hierarchy_Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0),
    node,
    nodes = [tree],
    child,
    children,
    i,
    n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ function src_tree() {
  var separation = tree_defaultSeparation,
    dx = 1,
    dy = 1,
    nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.\u2019s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
        right = root,
        bottom = root;
      root.eachBefore(function (node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
        tx = s - left.x,
        kx = dx / (right.x + s + tx),
        ky = dy / (bottom.depth || 1);
      root.eachBefore(function (node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
      siblings = v.parent.children,
      w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
        vop = v,
        vim = w,
        vom = vip.parent.children[0],
        sip = vip.m,
        sop = vop.m,
        sim = vim.m,
        som = vom.m,
        shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };
  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/slice.js
/* harmony default export */ function slice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
    node,
    i = -1,
    n = nodes.length,
    k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/squarify.js


var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
    nodes = parent.children,
    row,
    nodeValue,
    i0 = 0,
    i1 = 0,
    n = nodes.length,
    dx,
    dy,
    value = parent.value,
    sumValue,
    minValue,
    maxValue,
    newRatio,
    minRatio,
    alpha,
    beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) dice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else slice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
/* harmony default export */ var squarify = ((function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };
  return squarify;
})(phi));
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/index.js




/* harmony default export */ function treemap() {
  var tile = squarify,
    round = false,
    dx = 1,
    dy = 1,
    paddingStack = [0],
    paddingInner = constantZero,
    paddingTop = constantZero,
    paddingRight = constantZero,
    paddingBottom = constantZero,
    paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(treemap_round);
    return root;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth],
      x0 = node.x0 + p,
      y0 = node.y0 + p,
      x1 = node.x1 - p,
      y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };
  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };
  treemap.tile = function (x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };
  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };
  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };
  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };
  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };
  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };
  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };
  return treemap;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/binary.js
/* harmony default export */ function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
    i,
    n = nodes.length,
    sum,
    sums = new Array(n + 1);
  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }
  partition(0, n, parent.value, x0, y0, x1, y1);
  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }
    var valueOffset = sums[i],
      valueTarget = value / 2 + valueOffset,
      k = i + 1,
      hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset,
      valueRight = value - valueLeft;
    if (x1 - x0 > y1 - y0) {
      var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/sliceDice.js


/* harmony default export */ function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? slice : dice)(parent, x0, y0, x1, y1);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/treemap/resquarify.js



/* harmony default export */ var resquarify = ((function custom(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows,
        row,
        nodes,
        i,
        j = -1,
        n,
        m = rows.length,
        value = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) dice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);else slice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };
  return resquarify;
})(phi));
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/d3-hierarchy/src/index.js















;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/hierarchy/treemap.js



var treemap_DEFAULT_OPTIONS = {
    field: 'value',
    tile: 'treemapSquarify',
    size: [1, 1],
    round: false,
    ignoreParentValue: true,
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    as: ['x', 'y'],
    // \u9ED8\u8BA4\u964D\u5E8F
    sort: function (a, b) { return b.value - a.value; },
    // \u7EB5\u6A2A\u6BD4, treemapSquarify \u5E03\u5C40\u65F6\u53EF\u7528\uFF0C\u9ED8\u8BA4\u9EC4\u91D1\u5206\u5272\u6BD4\u4F8B
    ratio: 0.5 * (1 + Math.sqrt(5)),
};
function getTileMethod(tile, ratio) {
    return tile === 'treemapSquarify' ? src_namespaceObject[tile].ratio(ratio) : src_namespaceObject[tile];
}
function treemap_treemap(data, options) {
    options = (0,esm/* assign */.f0)({}, treemap_DEFAULT_OPTIONS, options);
    var as = options.as;
    if (!(0,esm/* isArray */.kJ)(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
    }
    var field;
    try {
        field = getField(options);
    }
    catch (e) {
        console.warn(e);
    }
    var tileMethod = getTileMethod(options.tile, options.ratio);
    var partition = function (data) {
        return treemap()
            .tile(tileMethod)
            .size(options.size)
            .round(options.round)
            .padding(options.padding)
            .paddingInner(options.paddingInner)
            .paddingOuter(options.paddingOuter)
            .paddingTop(options.paddingTop)
            .paddingRight(options.paddingRight)
            .paddingBottom(options.paddingBottom)
            .paddingLeft(options.paddingLeft)(
        /**
         * d3Hierarchy \u5E03\u5C40\u4E2D\u9700\u6307\u5B9A sum \u51FD\u6570\u8BA1\u7B97 node \u503C\uFF0C\u89C4\u5219\u662F\uFF1A\u4ECE\u5F53\u524D node \u5F00\u59CB\u4EE5 post-order traversal \u7684\u6B21\u5E8F\u4E3A\u5F53\u524D\u8282\u70B9\u4EE5\u53CA\u6BCF\u4E2A\u540E\u4EE3\u8282\u70B9\u8C03\u7528\u6307\u5B9A\u7684 value \u51FD\u6570\uFF0C\u5E76\u8FD4\u56DE\u5F53\u524D node\u3002
         * for example:
         * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
         * parent \u6240\u5F97\u7684\u8BA1\u7B97\u503C\u662F sum(node(parent)) + sum(node(child1)) + sum(node(child2))
         * ignoreParentValue \u4E3A true(\u9ED8\u8BA4) \u65F6\uFF0C\u7236\u5143\u7D20\u7684\u503C\u7531\u5B50\u5143\u7D20\u7D2F\u52A0\u800C\u6765\uFF0C\u8BE5\u503C\u4E3A 0 + 5 + 5 = 10
         * ignoreParentValue \u4E3A false \u65F6\uFF0C\u7236\u5143\u7D20\u7684\u503C\u7531\u5F53\u524D\u8282\u70B9 \u53CA\u5B50\u5143\u7D20\u7D2F\u52A0\u800C\u6765\uFF0C\u8BE5\u503C\u4E3A 10 + 5 + 5 = 20
         * sum \u51FD\u6570\u4E2D\uFF0Cd \u4E3A\u7528\u6237\u4F20\u5165\u7684 data, children \u4E3A\u4FDD\u7559\u5B57\u6BB5
         */
        hierarchy(data)
            .sum(function (d) { return (options.ignoreParentValue && d.children ? 0 : d[field]); })
            .sort(options.sort));
    };
    var root = partition(data);
    /*
     * points:
     *   3  2
     *   0  1
     */
    var x = as[0];
    var y = as[1];
    root.each(function (node) {
        node[x] = [node.x0, node.x1, node.x1, node.x0];
        node[y] = [node.y1, node.y1, node.y0, node.y0];
        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
            if (as.indexOf(prop) === -1) {
                delete node[prop];
            }
        });
    });
    return getAllNodes(root);
}
//# sourceMappingURL=treemap.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sunburst/utils.js







/**
 * sunburst \u5904\u7406\u6570\u636E
 * @param options
 */
function sunburst_utils_transformData(options) {
    var data = options.data, colorField = options.colorField, rawFields = options.rawFields, _a = options.hierarchyConfig, hierarchyConfig = _a === void 0 ? {} : _a;
    var activeDepth = hierarchyConfig.activeDepth;
    var transform = {
        partition: partition,
        treemap: treemap_treemap,
    };
    // @ts-ignore \u517C\u5BB9\u65E7\u7248\u672C\uFF0C\u652F\u6301 seriesField \u6765\u4F5C\u4E3A hierarchyConfig.field
    var seriesField = options.seriesField;
    // @ts-ignore \u517C\u5BB9\u65E7\u7248\u672C\uFF0C\u652F\u6301\u77E9\u9635\u6811\u56FE\u5F62\u72B6\u7684\u65ED\u65E5\u56FE
    var type = options.type || 'partition';
    var nodes = transform[type](data, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ field: seriesField || 'value' }, (0,esm/* omit */.CE)(hierarchyConfig, ['activeDepth'])), { 
        // @ts-ignore
        type: "hierarchy.".concat(type), as: ['x', 'y'] }));
    var result = [];
    nodes.forEach(function (node) {
        var _a;
        var _b, _c, _d, _e, _f;
        if (node.depth === 0) {
            return null;
        }
        if (activeDepth > 0 && node.depth > activeDepth) {
            return null;
        }
        var path = node.data.name;
        var ancestorNode = (0,tslib_es6/* __assign */.pi)({}, node);
        while (ancestorNode.depth > 1) {
            path = "".concat((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name, " / ").concat(path);
            ancestorNode = ancestorNode.parent;
        }
        var nodeInfo = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, pick(node.data, (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (rawFields || []), true), [hierarchyConfig.field], false))), (_a = {}, _a[SUNBURST_PATH_FIELD] = path, _a[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a)), node);
        // note: \u517C\u5BB9\u65E7\u7248\u672C
        if (seriesField) {
            nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
        }
        if (colorField) {
            nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
        }
        nodeInfo.ext = hierarchyConfig;
        nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig: hierarchyConfig, colorField: colorField, rawFields: rawFields };
        result.push(nodeInfo);
    });
    return result;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sunburst/adaptor.js








/**
 * geometry \u914D\u7F6E\u5904\u7406
 * @param params
 */
function sunburst_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var color = options.color, _a = options.colorField, colorField = _a === void 0 ? SUNBURST_ANCESTOR_FIELD : _a, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b, shape = options.shape;
    var data = sunburst_utils_transformData(options);
    chart.data(data);
    // \u7279\u6B8A\u5904\u7406\u4E0B\u6837\u5F0F\uFF0C\u5982\u679C\u6CA1\u6709\u8BBE\u7F6E fillOpacity \u7684\u65F6\u5019\uFF0C\u9ED8\u8BA4\u6839\u636E\u5C42\u7EA7\u8FDB\u884C\u586B\u5145\u900F\u660E\u5EA6
    var style;
    if (sunburstStyle) {
        style = function (datum) {
            return deepAssign({}, {
                fillOpacity: Math.pow(0.85, datum.depth),
            }, (0,esm/* isFunction */.mf)(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
        };
    }
    // geometry
    polygon_polygon(deepAssign({}, params, {
        options: {
            xField: 'x',
            yField: 'y',
            seriesField: colorField,
            rawFields: (0,esm/* uniq */.jj)((0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], constant_RAW_FIELDS, true), rawFields, true)),
            polygon: {
                color: color,
                style: style,
                shape: shape,
            },
        },
    }));
    return params;
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function sunburst_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function sunburst_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label;
    var geometry = findGeometry(chart, 'polygon');
    // \u9ED8\u8BA4\u4E0D\u5C55\u793A\uFF0Cundefined \u4E5F\u4E0D\u5C55\u793A
    if (!label) {
        geometry.label(false);
    }
    else {
        var _a = label.fields, fields = _a === void 0 ? ['name'] : _a, callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["fields", "callback"]);
        geometry.label({
            fields: fields,
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * coord \u914D\u7F6E
 * @param params
 */
function sunburst_adaptor_coordinate(params) {
    var chart = params.chart, options = params.options;
    var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
    var coord = chart.coordinate({
        type: 'polar',
        cfg: {
            innerRadius: innerRadius,
            radius: radius,
        },
    });
    if (reflect) {
        coord.reflect(reflect);
    }
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function sunburst_adaptor_meta(params) {
    var _a;
    var options = params.options;
    var hierarchyConfig = options.hierarchyConfig, meta = options.meta;
    return flow(common_scale({}, (_a = {},
        _a[SUNBURST_Y_FIELD] = (0,esm/* get */.U2)(meta, (0,esm/* get */.U2)(hierarchyConfig, ['field'], 'value')),
        _a)))(params);
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function sunburst_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip;
    if (tooltip === false) {
        chart.tooltip(false);
    }
    else {
        var tooltipOptions = tooltip;
        // \u8BBE\u7F6E\u4E86 fields\uFF0C\u5C31\u4E0D\u8FDB\u884C customItems \u4E86; \u8BBE\u7F6E formatter \u65F6\uFF0C\u9700\u8981\u642D\u914D fields
        if (!(0,esm/* get */.U2)(tooltip, 'fields')) {
            tooltipOptions = deepAssign({}, {
                customItems: function (items) {
                    return items.map(function (item) {
                        var scales = (0,esm/* get */.U2)(chart.getOptions(), 'scales');
                        var pathFormatter = (0,esm/* get */.U2)(scales, [SUNBURST_PATH_FIELD, 'formatter'], function (v) { return v; });
                        var valueFormatter = (0,esm/* get */.U2)(scales, [SUNBURST_Y_FIELD, 'formatter'], function (v) { return v; });
                        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, item), { name: pathFormatter(item.data[SUNBURST_PATH_FIELD]), value: valueFormatter(item.data.value) });
                    });
                },
            }, tooltipOptions);
        }
        chart.tooltip(tooltipOptions);
    }
    return params;
}
function adaptor_adaptorInteraction(options) {
    var drilldown = options.drilldown, _a = options.interactions, interactions = _a === void 0 ? [] : _a;
    if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
        return deepAssign({}, options, {
            interactions: (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], interactions, true), [
                {
                    type: 'drill-down',
                    cfg: { drillDownConfig: drilldown, transformData: sunburst_utils_transformData },
                },
            ], false),
        });
    }
    return options;
}
/**
 * \u4EA4\u4E92\u914D\u7F6E
 * @param params
 * @returns
 */
function sunburst_adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    var drilldown = options.drilldown;
    common_interaction({
        chart: chart,
        options: adaptor_adaptorInteraction(options),
    });
    // \u9002\u5E94\u4E0B\u94BB\u4EA4\u4E92\u9762\u5305\u5C51
    if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
        // \u4E3A\u9762\u5305\u5C51\u7559\u51FA 25px \u7684\u7A7A\u95F4
        chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, (0,esm/* get */.U2)(drilldown, ['breadCrumb', 'position']));
    }
    return params;
}
/**
 * \u65ED\u65E5\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function sunburst_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(common_theme, pattern('sunburstStyle'), sunburst_adaptor_geometry, sunburst_adaptor_axis, sunburst_adaptor_meta, common_legend, sunburst_adaptor_coordinate, sunburst_adaptor_tooltip, sunburst_adaptor_label, sunburst_adaptor_interaction, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sunburst/interactions/index.js
/** \u5F15\u5165 drill-down \u4EA4\u4E92 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/sunburst/index.js






var Sunburst = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Sunburst, _super);
    function Sunburst() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'sunburst';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u65ED\u65E5\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Sunburst.getDefaultOptions = function () {
        return sunburst_constant_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u65ED\u65E5\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Sunburst.prototype.getDefaultOptions = function () {
        return Sunburst.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u65ED\u65E5\u56FE\u7684\u9002\u914D\u5668
     */
    Sunburst.prototype.getSchemaAdaptor = function () {
        return sunburst_adaptor_adaptor;
    };
    /** \u65ED\u65E5\u56FE \u8282\u70B9\u7684\u7956\u5148\u8282\u70B9 */
    Sunburst.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
    /** \u65ED\u65E5\u56FE \u8282\u70B9\u7684\u8DEF\u5F84 */
    Sunburst.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
    /** \u8282\u70B9\u7684\u7956\u5148\u8282\u70B9 */
    Sunburst.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
    return Sunburst;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/treemap/utils.js




function findInteraction(interactions, interactionType) {
    if (!(0,esm/* isArray */.kJ)(interactions))
        return undefined;
    return interactions.find(function (i) { return i.type === interactionType; });
}
function enableInteraction(interactions, interactionType) {
    var interaction = findInteraction(interactions, interactionType);
    return interaction && interaction.enable !== false;
}
/**
 * \u662F\u5426\u5141\u8BB8\u4E0B\u94BB\u4EA4\u4E92
 * @param interactions
 * @param interactionType
 * @returns
 */
function enableDrillInteraction(options) {
    var interactions = options.interactions, drilldown = options.drilldown;
    // \u517C\u5BB9\u65E7\u7248\u672C, treemap-drill-down
    return (0,esm/* get */.U2)(drilldown, 'enabled') || enableInteraction(interactions, 'treemap-drill-down');
}
function resetDrillDown(chart) {
    var drillDownInteraction = chart.interactions['drill-down'];
    if (!drillDownInteraction)
        return;
    // @ts-ignore
    var drillDownAction = drillDownInteraction.context.actions.find(function (i) { return i.name === 'drill-down-action'; });
    drillDownAction.reset();
}
function treemap_utils_transformData(options) {
    var data = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
    var nodes = treemap_treemap(data, (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, hierarchyConfig), { 
        // @ts-ignore
        type: 'hierarchy.treemap', field: 'value', as: ['x', 'y'] }));
    var result = [];
    nodes.forEach(function (node) {
        if (node.depth === 0) {
            return null;
        }
        // \u5F00\u542F\u4E0B\u94BB\uFF0C\u4EC5\u52A0\u8F7D depth === 1 \u7684\u6570\u636E
        if (enableDrillDown && node.depth !== 1) {
            return null;
        }
        // \u4E0D\u5F00\u542F\u4E0B\u94BB\uFF0C\u52A0\u8F7D\u6240\u6709\u53F6\u5B50\u8282\u70B9
        if (!enableDrillDown && node.children) {
            return null;
        }
        // path \u4FE1\u606F\u4EC5\u6311\u9009\u5FC5\u8981\u7956\u5148\u5143\u7D20\u5C5E\u6027\uFF0C\u56E0\u4E3A\u5728\u6709\u4E9B\u5C5E\u6027\u662F\u4E0D\u5FC5\u8981(x, y), \u6216\u662F\u4E0D\u51C6\u786E\u7684(\u4E0B\u94BB\u65F6\u7684 depth)\uFF0C\u4E0D\u5BF9\u5916\u900F\u51FA
        var curPath = node.ancestors().map(function (n) { return ({
            data: n.data,
            height: n.height,
            value: n.value,
        }); });
        // \u5728\u4E0B\u94BB\u6811\u56FE\u4E2D\uFF0C\u6BCF\u6B21\u7ED8\u5236\u7684\u662F\u5F53\u524D\u5C42\u7EA7\u4FE1\u606F\uFF0C\u5C06\u7236\u5143\u7D20\u7684\u5C42\u7EA7\u4FE1\u606F\uFF08data.path) \u505A\u4E00\u5C42\u62FC\u63A5\u3002
        var path = enableDrillDown && (0,esm/* isArray */.kJ)(data.path) ? curPath.concat(data.path.slice(1)) : curPath;
        var nodeInfo = Object.assign({}, node.data, (0,tslib_es6/* __assign */.pi)({ x: node.x, y: node.y, depth: node.depth, value: node.value, path: path }, node));
        if (!node.data[colorField] && node.parent) {
            var ancestorNode = node.ancestors().find(function (n) { return n.data[colorField]; });
            nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
        }
        else {
            nodeInfo[colorField] = node.data[colorField];
        }
        nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig: hierarchyConfig, colorField: colorField, enableDrillDown: enableDrillDown };
        result.push(nodeInfo);
    });
    return result;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/treemap/adaptor.js








/**
 * \u83B7\u53D6\u9ED8\u8BA4 option
 * @param params
 */
function treemap_adaptor_defaultOptions(params) {
    var options = params.options;
    var colorField = options.colorField;
    return deepAssign({
        options: {
            rawFields: ['value'],
            tooltip: {
                fields: ['name', 'value', colorField, 'path'],
                formatter: function (data) {
                    return {
                        name: data.name,
                        value: data.value,
                    };
                },
            },
        },
    }, params);
}
/**
 * \u5B57\u6BB5
 * @param params
 */
function treemap_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var color = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
    var data = treemap_utils_transformData({
        data: options.data,
        colorField: options.colorField,
        enableDrillDown: enableDrillInteraction(options),
        hierarchyConfig: hierarchyConfig,
    });
    chart.data(data);
    // geometry
    polygon_polygon(deepAssign({}, params, {
        options: {
            xField: 'x',
            yField: 'y',
            seriesField: colorField,
            rawFields: rawFields,
            polygon: {
                color: color,
                style: rectStyle,
            },
        },
    }));
    // \u505A\u4E00\u4E2A\u53CD\u8F6C\uFF0C\u8FD9\u6837\u914D\u5408\u6392\u5E8F\uFF0C\u53EF\u4EE5\u5C06\u6700\u5927\u503C\u653E\u5230\u5DE6\u4E0A\u89D2\uFF0C\u6700\u5C0F\u503C\u653E\u5230\u53F3\u4E0B\u89D2
    chart.coordinate().reflect('y');
    return params;
}
/**
 * \u5750\u6807\u8F74
 * @param params
 */
function treemap_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
function treemap_adaptor_adaptorInteraction(options) {
    var drilldown = options.drilldown, _a = options.interactions, interactions = _a === void 0 ? [] : _a;
    var enableDrillDown = enableDrillInteraction(options);
    if (enableDrillDown) {
        return deepAssign({}, options, {
            interactions: (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], interactions, true), [
                {
                    type: 'drill-down',
                    // \u{1F693} \u8FD9\u4E0D\u662F\u4E00\u4E2A\u89C4\u8303\u7684 API\uFF0C\u540E\u7EED\u4F1A\u53D8\u66F4\u3002\u614E\u91CD\u53C2\u8003
                    cfg: { drillDownConfig: drilldown, transformData: treemap_utils_transformData },
                },
            ], false),
        });
    }
    return options;
}
/**
 * Interaction \u914D\u7F6E
 * @param params
 */
function treemap_adaptor_interaction(params) {
    var chart = params.chart, options = params.options;
    var interactions = options.interactions, drilldown = options.drilldown;
    common_interaction({
        chart: chart,
        options: treemap_adaptor_adaptorInteraction(options),
    });
    // \u9002\u914D view-zoom
    var viewZoomInteraction = findInteraction(interactions, 'view-zoom');
    if (viewZoomInteraction) {
        // \u5F00\u542F\u7F29\u653E interaction \u540E\uFF0C\u5219\u963B\u6B62\u9ED8\u8BA4\u6EDA\u52A8\u4E8B\u4EF6\uFF0C\u907F\u514D\u6574\u4E2A\u7A97\u53E3\u7684\u6EDA\u52A8
        if (viewZoomInteraction.enable !== false) {
            chart.getCanvas().on('mousewheel', function (ev) {
                ev.preventDefault();
            });
        }
        else {
            // \u624B\u52A8\u5173\u95ED\u540E\uFF0C\u6E05\u9664\u3002\u4EC5\u5BF9\u58F0\u660E viewZoomInteraction \u7684\u6E05\u9664\u3002
            chart.getCanvas().off('mousewheel');
        }
    }
    // \u9002\u5E94\u4E0B\u94BB\u4EA4\u4E92\u9762\u5305\u5C51
    var enableDrillDown = enableDrillInteraction(options);
    if (enableDrillDown) {
        // \u4E3A\u9762\u5305\u5C51\u5728\u5E95\u90E8\u7559\u51FA 25px \u7684\u7A7A\u95F4
        chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, (0,esm/* get */.U2)(drilldown, ['breadCrumb', 'position']));
    }
    return params;
}
/**
 * \u77E9\u5F62\u6811\u56FE
 * @param chart
 * @param options
 */
function treemap_adaptor_adaptor(params) {
    return flow(treemap_adaptor_defaultOptions, common_theme, pattern('rectStyle'), treemap_adaptor_geometry, treemap_adaptor_axis, common_legend, common_tooltip, treemap_adaptor_interaction, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/treemap/constant.js
var treemap_constant_DEFAULT_OPTIONS = {
    // \u9ED8\u8BA4\u6309\u7167 name \u5B57\u6BB5\u5BF9\u989C\u8272\u8FDB\u884C\u5206\u7C7B
    colorField: 'name',
    rectStyle: {
        lineWidth: 1,
        stroke: '#fff',
    },
    hierarchyConfig: {
        tile: 'treemapSquarify',
    },
    label: {
        fields: ['name'],
        layout: {
            type: 'limit-in-shape',
        },
    },
    tooltip: {
        showMarkers: false,
        showTitle: false,
    },
    // \u4E0B\u94BB\u4EA4\u4E92\u914D\u7F6E\uFF0C\u9ED8\u8BA4\u4E0D\u5F00\u542F
    drilldown: {
        enabled: false,
        breadCrumb: {
            position: 'bottom-left',
            rootText: '\u521D\u59CB',
            dividerText: '/',
            textStyle: {
                fontSize: 12,
                fill: 'rgba(0, 0, 0, 0.65)',
                cursor: 'pointer',
            },
            activeTextStyle: {
                fill: '#87B5FF',
            },
        },
    },
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/treemap/interactions/index.js
/** \u5F15\u5165 drag-move \u4EA4\u4E92 */

/** \u5F15\u5165 drill-down \u4EA4\u4E92 */

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/treemap/index.js






var Treemap = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Treemap, _super);
    function Treemap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'treemap';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u77E9\u9635\u6811\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Treemap.getDefaultOptions = function () {
        return treemap_constant_DEFAULT_OPTIONS;
    };
    /**
     * changeData
     */
    Treemap.prototype.changeData = function (data) {
        var _a = this.options, colorField = _a.colorField, interactions = _a.interactions, hierarchyConfig = _a.hierarchyConfig;
        this.updateOption({ data: data });
        var transData = treemap_utils_transformData({
            data: data,
            colorField: colorField,
            enableDrillDown: enableInteraction(interactions, 'treemap-drill-down'),
            hierarchyConfig: hierarchyConfig,
        });
        this.chart.changeData(transData);
        resetDrillDown(this.chart);
    };
    /**
     * \u83B7\u53D6 \u77E9\u9635\u6811\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Treemap.prototype.getDefaultOptions = function () {
        return Treemap.getDefaultOptions();
    };
    Treemap.prototype.getSchemaAdaptor = function () {
        return treemap_adaptor_adaptor;
    };
    return Treemap;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/constant.js
// \u4E00\u4E9B\u5B57\u6BB5\u5E38\u91CF\u5B9A\u4E49\uFF0C\u9700\u8981\u5728\u6587\u6863\u521D\u544A\u77E5\u7528\u6237
var ID_FIELD = 'id';
var PATH_FIELD = 'path';
/**
 * \u97E6\u6069\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var venn_constant_DEFAULT_OPTIONS = {
    appendPadding: [10, 0, 20, 0],
    blendMode: 'multiply',
    tooltip: {
        showTitle: false,
        showMarkers: false,
        fields: ['id', 'size'],
        formatter: function (datum) {
            return { name: datum.id, value: datum.size };
        },
    },
    legend: { position: 'top-left' },
    label: {
        style: {
            textAlign: 'center',
            fill: '#fff',
        },
    },
    // \u9ED8\u8BA4\u4E0D\u5F00\u542F \u56FE\u4F8B\u7B5B\u9009\u4EA4\u4E92
    interactions: [{ type: 'legend-filter', enable: false }],
    state: {
        active: {
            style: {
                stroke: '#000',
            },
        },
        selected: {
            style: {
                stroke: '#000',
                lineWidth: 2,
            },
        },
        inactive: {
            style: {
                fillOpacity: 0.3,
                strokeOpacity: 0.3,
            },
        },
    },
    // \u97E6\u6069\u56FE\u7684\u9ED8\u8BA4\u5185\u7F6E\u6CE8\u518C\u7684\u4EA4\u4E92
    defaultInteractions: ['tooltip', 'venn-legend-active'],
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/interactions/util.js
/** tofront: \u540C\u6B65\u6240\u6709\u5143\u7D20\u7684\u4F4D\u7F6E  */
function placeElementsOrdered(view) {
    if (!view) {
        return;
    }
    var elements = view.geometries[0].elements;
    elements.forEach(function (elem) {
        elem.shape.toFront();
    });
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/active.js



var ElementActiveAction = getActionClass('element-active');
var VennElementActive = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(VennElementActive, _super);
    function VennElementActive() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u540C\u6B65\u6240\u6709\u5143\u7D20\u7684\u4F4D\u7F6E
     */
    VennElementActive.prototype.syncElementsPos = function () {
        placeElementsOrdered(this.context.view);
    };
    /** \u6FC0\u6D3B\u56FE\u5F62\u5143\u7D20 */
    VennElementActive.prototype.active = function () {
        _super.prototype.active.call(this);
        this.syncElementsPos();
    };
    /** toggle \u56FE\u5F62\u5143\u7D20\u6FC0\u6D3B\u72B6\u6001 */
    VennElementActive.prototype.toggle = function () {
        _super.prototype.toggle.call(this);
        this.syncElementsPos();
    };
    /** \u91CD\u7F6E */
    VennElementActive.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.syncElementsPos();
    };
    return VennElementActive;
}(ElementActiveAction));

//# sourceMappingURL=active.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/highlight.js



var ElementHighlightAction = getActionClass('element-highlight');
var VennElementHighlight = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(VennElementHighlight, _super);
    function VennElementHighlight() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u540C\u6B65\u6240\u6709\u5143\u7D20\u7684\u4F4D\u7F6E
     */
    VennElementHighlight.prototype.syncElementsPos = function () {
        placeElementsOrdered(this.context.view);
    };
    /** \u9AD8\u4EAE\u56FE\u5F62\u5143\u7D20 */
    VennElementHighlight.prototype.highlight = function () {
        _super.prototype.highlight.call(this);
        this.syncElementsPos();
    };
    /** toggle \u56FE\u5F62\u5143\u7D20\u9AD8\u4EAE\u72B6\u6001 */
    VennElementHighlight.prototype.toggle = function () {
        _super.prototype.toggle.call(this);
        this.syncElementsPos();
    };
    /** \u6E05\u695A */
    VennElementHighlight.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this.syncElementsPos();
    };
    /** \u91CD\u7F6E */
    VennElementHighlight.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.syncElementsPos();
    };
    return VennElementHighlight;
}(ElementHighlightAction));

//# sourceMappingURL=highlight.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/interactions/actions/selected.js



var ElementSelectedAction = getActionClass('element-selected');
var ElementSingleSelectedAction = getActionClass('element-single-selected');
/**
 * \u97E6\u6069\u56FE\u5143\u7D20 \u591A\u9009\u4EA4\u4E92
 */
var VennElementSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(VennElementSelected, _super);
    function VennElementSelected() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u540C\u6B65\u6240\u6709\u5143\u7D20\u7684\u4F4D\u7F6E
     */
    VennElementSelected.prototype.syncElementsPos = function () {
        placeElementsOrdered(this.context.view);
    };
    /** \u6FC0\u6D3B\u56FE\u5F62\u5143\u7D20 */
    VennElementSelected.prototype.selected = function () {
        _super.prototype.selected.call(this);
        this.syncElementsPos();
    };
    /** toggle \u56FE\u5F62\u5143\u7D20\u6FC0\u6D3B\u72B6\u6001 */
    VennElementSelected.prototype.toggle = function () {
        _super.prototype.toggle.call(this);
        this.syncElementsPos();
    };
    /** \u91CD\u7F6E */
    VennElementSelected.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.syncElementsPos();
    };
    return VennElementSelected;
}(ElementSelectedAction));

/**
 * \u97E6\u6069\u56FE\u5143\u7D20 \u5355\u9009\u4EA4\u4E92
 */
var VennElementSingleSelected = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(VennElementSingleSelected, _super);
    function VennElementSingleSelected() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u540C\u6B65\u6240\u6709\u5143\u7D20\u7684\u4F4D\u7F6E
     */
    VennElementSingleSelected.prototype.syncElementsPos = function () {
        placeElementsOrdered(this.context.view);
    };
    /** \u6FC0\u6D3B\u56FE\u5F62\u5143\u7D20 */
    VennElementSingleSelected.prototype.selected = function () {
        _super.prototype.selected.call(this);
        this.syncElementsPos();
    };
    /** toggle \u56FE\u5F62\u5143\u7D20\u6FC0\u6D3B\u72B6\u6001 */
    VennElementSingleSelected.prototype.toggle = function () {
        _super.prototype.toggle.call(this);
        this.syncElementsPos();
    };
    /** \u91CD\u7F6E */
    VennElementSingleSelected.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.syncElementsPos();
    };
    return VennElementSingleSelected;
}(ElementSingleSelectedAction));

//# sourceMappingURL=selected.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/interactions/index.js




/** ================== \u6CE8\u518C\u4EA4\u4E92\u53CD\u9988 aciton ================== */
registerAction('venn-element-active', VennElementActive);
registerAction('venn-element-highlight', VennElementHighlight);
registerAction('venn-element-selected', VennElementSelected);
registerAction('venn-element-single-selected', VennElementSingleSelected);
/** ================== \u6CE8\u518C\u4EA4\u4E92 ================== */
// ========= Active \u4EA4\u4E92 =========
registerInteraction('venn-element-active', {
    start: [{ trigger: 'element:mouseenter', action: 'venn-element-active:active' }],
    end: [{ trigger: 'element:mouseleave', action: 'venn-element-active:reset' }],
});
// ========= \u9AD8\u4EAE \u4EA4\u4E92 =========
registerInteraction('venn-element-highlight', {
    start: [{ trigger: 'element:mouseenter', action: 'venn-element-highlight:highlight' }],
    end: [{ trigger: 'element:mouseleave', action: 'venn-element-highlight:reset' }],
});
// ========= Selected \u4EA4\u4E92 =========
// \u70B9\u51FB venn element \uFF08\u53EF\u591A\u9009\uFF09
registerInteraction('venn-element-selected', {
    start: [{ trigger: 'element:click', action: 'venn-element-selected:toggle' }],
    rollback: [{ trigger: 'dblclick', action: ['venn-element-selected:reset'] }],
});
// \u70B9\u51FB venn element \uFF08\u5355\u9009\uFF09
registerInteraction('venn-element-single-selected', {
    start: [{ trigger: 'element:click', action: 'venn-element-single-selected:toggle' }],
    rollback: [{ trigger: 'dblclick', action: ['venn-element-single-selected:reset'] }],
});
// ========= \u97E6\u6069\u56FE\u7684\u56FE\u4F8B\u4E8B\u4EF6\uFF0C\u5355\u72EC\u6CE8\u518C =========
// legend hover\uFF0Celement active
registerInteraction('venn-legend-active', {
    start: [{ trigger: 'legend-item:mouseenter', action: ['list-active:active', 'venn-element-active:active'] }],
    end: [{ trigger: 'legend-item:mouseleave', action: ['list-active:reset', 'venn-element-active:reset'] }],
});
// legend hover\uFF0Celement active
registerInteraction('venn-legend-highlight', {
    start: [
        {
            trigger: 'legend-item:mouseenter',
            action: ['legend-item-highlight:highlight', 'venn-element-highlight:highlight'],
        },
    ],
    end: [{ trigger: 'legend-item:mouseleave', action: ['legend-item-highlight:reset', 'venn-element-highlight:reset'] }],
});
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/label.js


// Step 1
// \u81EA\u5B9A\u4E49 Label \u7C7B
// \u9700\u8981\u7EE7\u627F GeometryLabel \u57FA\u7C7B
var VennLabel = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(VennLabel, _super);
    function VennLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * \u83B7\u53D6\u6BCF\u4E2A label \u7684\u4F4D\u7F6E
     * @param labelCfg
     * @param mappingData
     * @param index
     * @returns label point
     */
    VennLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
        var _a = labelCfg.data, x = _a.x, y = _a.y;
        var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
        return {
            content: labelCfg.content[index],
            x: x + offsetX,
            y: y + offsetY,
        };
    };
    return VennLabel;
}(label_base));
// Step 2: \u6CE8\u518C CustomLabel
registerGeometryLabel('venn', VennLabel);
//# sourceMappingURL=label.js.map
;// CONCATENATED MODULE: ./node_modules/lodash-es/isArray.js
/**
 * Checks if \`value\` is classified as an \`Array\` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns \`true\` if \`value\` is an array, else \`false\`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray_isArray = Array.isArray;

/* harmony default export */ var lodash_es_isArray = (isArray_isArray);

;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/parse-path-string.js

var SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');
// Parses given path string into an array of arrays of path segments
function parse_path_string_parsePathString(pathString) {
    if (!pathString) {
        return null;
    }
    if (lodash_es_isArray(pathString)) {
        return pathString;
    }
    var paramCounts = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0,
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND, function (a, b, c) {
        var params = [];
        var name = b.toLowerCase();
        c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
        });
        if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
        }
        if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
        }
        if (name === 'r') {
            data.push([b].concat(params));
        }
        else {
            while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        }
        return '';
    });
    return data;
}
//# sourceMappingURL=parse-path-string.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/path-2-absolute.js

var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
    return [
        c[0] + (c[0] - p[0]),
        c[1] + (c[1] - p[1]),
    ];
}
function pathToAbsolute(pathString) {
    var pathArray = parsePathString(pathString);
    if (!pathArray || !pathArray.length) {
        return [
            ['M', 0, 0],
        ];
    }
    var needProcess = false; // \u5982\u679C\u5B58\u5728\u5C0F\u5199\u7684\u547D\u4EE4\u6216\u8005 V,H,T,S \u5219\u9700\u8981\u5904\u7406
    for (var i = 0; i < pathArray.length; i++) {
        var cmd = pathArray[i][0];
        // \u5982\u679C\u5B58\u5728\u76F8\u5BF9\u4F4D\u7F6E\u7684\u547D\u4EE4\uFF0C\u5219\u4E2D\u65AD\u8FD4\u56DE
        if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {
            needProcess = true;
            break;
        }
    }
    // \u5982\u679C\u4E0D\u5B58\u5728\u76F8\u5BF9\u547D\u4EE4\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE
    // \u5982\u679C\u5728\u4E1A\u52A1\u4E0A\u90FD\u5199\u7EDD\u5BF9\u8DEF\u5F84\uFF0C\u8FD9\u79CD\u65B9\u5F0F\u6700\u5FEB\uFF0C\u4EC5\u505A\u4E86\u4E00\u6B21\u68C0\u6D4B
    if (!needProcess) {
        return pathArray;
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    var first = pathArray[0];
    if (first[0] === 'M' || first[0] === 'm') {
        x = +first[1];
        y = +first[2];
        mx = x;
        my = y;
        start++;
        res[0] = ['M', x, y];
    }
    for (var i = start, ii = pathArray.length; i < ii; i++) {
        var pa = pathArray[i];
        var preParams = res[i - 1]; // \u53D6\u524D\u4E00\u4E2A\u5DF2\u7ECF\u5904\u7406\u540E\u7684\u8282\u70B9\uFF0C\u5426\u5219\u4F1A\u51FA\u73B0\u95EE\u9898
        var r = [];
        var cmd = pa[0];
        var upCmd = cmd.toUpperCase();
        if (cmd !== upCmd) {
            r[0] = upCmd;
            switch (upCmd) {
                case 'A':
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +pa[6] + x;
                    r[7] = +pa[7] + y;
                    break;
                case 'V':
                    r[1] = +pa[1] + y;
                    break;
                case 'H':
                    r[1] = +pa[1] + x;
                    break;
                case 'M':
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                    r[1] = mx;
                    r[2] = my;
                    break; // for lint
                default:
                    for (var j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +pa[j] + ((j % 2) ? x : y);
                    }
            }
        }
        else { // \u5982\u679C\u672C\u6765\u5DF2\u7ECF\u5927\u5199\uFF0C\u5219\u4E0D\u5904\u7406
            r = pathArray[i];
        }
        // \u9700\u8981\u5728\u5916\u9762\u7EDF\u4E00\u505A\uFF0C\u540C\u65F6\u5904\u7406 V,H,S,T \u7B49\u7279\u6B8A\u6307\u4EE4
        switch (upCmd) {
            case 'Z':
                x = +mx;
                y = +my;
                break;
            case 'H':
                x = r[1];
                r = ['L', x, y];
                break;
            case 'V':
                y = r[1];
                r = ['L', x, y];
                break;
            case 'T':
                x = r[1];
                y = r[2];
                // \u4EE5 x, y \u4E3A\u4E2D\u5FC3\u7684\uFF0C\u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\u7684\u5BF9\u79F0\u70B9
                // \u9700\u8981\u5047\u8BBE\u4E0A\u4E00\u4E2A\u8282\u70B9\u7684\u547D\u4EE4\u4E3A Q
                var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
                r = ['Q', symetricT[0], symetricT[1], x, y];
                break;
            case 'S':
                x = r[r.length - 2];
                y = r[r.length - 1];
                // \u4EE5 x,y \u4E3A\u4E2D\u5FC3\uFF0C\u53D6\u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\uFF0C
                // \u9700\u8981\u5047\u8BBE\u4E0A\u4E00\u4E2A\u7EBF\u6BB5\u4E3A C \u6216\u8005 S
                var length_1 = preParams.length;
                var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
                r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break; // for lint
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
        }
        res.push(r);
    }
    return res;
}
//# sourceMappingURL=path-2-absolute.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;
var mapToEllipse = function (_a, rx, ry, cosphi, sinphi, centerx, centery) {
    var x = _a.x, y = _a.y;
    x *= rx;
    y *= ry;
    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;
    return {
        x: xp + centerx,
        y: yp + centery
    };
};
var approxUnitArc = function (ang1, ang2) {
    // If 90 degree circular arc, use a constant
    // as derived from http://spencermortensen.com/articles/bezier-circle
    var a = ang2 === 1.5707963267948966
        ? 0.551915024494
        : ang2 === -1.5707963267948966
            ? -0.551915024494
            : 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);
    return [
        {
            x: x1 - y1 * a,
            y: y1 + x1 * a
        },
        {
            x: x2 + y2 * a,
            y: y2 - x2 * a
        },
        {
            x: x2,
            y: y2
        }
    ];
};
var vectorAngle = function (ux, uy, vx, vy) {
    var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
    var dot = ux * vx + uy * vy;
    if (dot > 1) {
        dot = 1;
    }
    if (dot < -1) {
        dot = -1;
    }
    return sign * Math.acos(dot);
};
var getArcCenter = function (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq);
    if (radicant < 0) {
        radicant = 0;
    }
    radicant /= (rxsq * pypsq) + (rysq * pxpsq);
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
};
var arcToBezier = function (_a) {
    var px = _a.px, py = _a.py, cx = _a.cx, cy = _a.cy, rx = _a.rx, ry = _a.ry, _b = _a.xAxisRotation, xAxisRotation = _b === void 0 ? 0 : _b, _c = _a.largeArcFlag, largeArcFlag = _c === void 0 ? 0 : _c, _d = _a.sweepFlag, sweepFlag = _d === void 0 ? 0 : _d;
    var curves = [];
    if (rx === 0 || ry === 0) {
        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) +
        Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    var _e = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), centerx = _e[0], centery = _e[1], ang1 = _e[2], ang2 = _e[3];
    // If 'ang2' == 90.0000000001, then \`ratio\` will evaluate to
    // 1.0000000001. This causes \`segments\` to be greater than one, which is an
    // unecessary split, and adds extra points to the bezier curve. To alleviate
    // this issue, we round to 1.0 when the ratio is close to 1.0.
    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1.0 - ratio) < 0.0000001) {
        ratio = 1.0;
    }
    var segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    for (var i = 0; i < segments; i++) {
        curves.push(approxUnitArc(ang1, ang2));
        ang1 += ang2;
    }
    return curves.map(function (curve) {
        var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _a.x, y1 = _a.y;
        var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _b.x, y2 = _b.y;
        var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _c.x, y = _c.y;
        return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
    });
};
function arc_2_cubic_arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2) {
    var curves = arcToBezier({
        px: x1,
        py: y1,
        cx: x2,
        cy: y2,
        rx: rx,
        ry: ry,
        xAxisRotation: angle,
        largeArcFlag: LAF,
        sweepFlag: SF,
    });
    return curves.reduce(function (prev, cur) {
        var x1 = cur.x1, y1 = cur.y1, x2 = cur.x2, y2 = cur.y2, x = cur.x, y = cur.y;
        prev.push(x1, y1, x2, y2, x, y);
        return prev;
    }, []);
}
//# sourceMappingURL=arc-2-cubic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/process/segment-2-cubic.js



function segment_2_cubic_segmentToCubic(segment, params) {
    if ('TQ'.indexOf(segment[0]) < 0) {
        params.qx = null;
        params.qy = null;
    }
    var _a = segment.slice(1), s1 = _a[0], s2 = _a[1];
    switch (segment[0]) {
        case 'M':
            params.x = s1;
            params.y = s2;
            return segment;
        case 'A':
            return ['C'].concat(arcToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));
        case 'Q':
            params.qx = s1;
            params.qy = s2;
            return ['C'].concat(quadToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));
        case 'L':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, segment[1], segment[2]));
        case 'H':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, segment[1], params.y1));
        case 'V':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, params.x1, segment[1]));
        case 'Z':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, params.x, params.y));
        default:
    }
    return segment;
}
//# sourceMappingURL=segment-2-cubic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/path-2-curve.js


function pathToCurve(path, needZCommandIndexes) {
    if (needZCommandIndexes === void 0) { needZCommandIndexes = false; }
    var pathArray = path2Absolute(path);
    var params = {
        x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null,
    };
    var allPathCommands = [];
    var pathCommand = '';
    var ii = pathArray.length;
    var segment;
    var seglen;
    var zCommandIndexes = [];
    for (var i = 0; i < ii; i += 1) {
        if (pathArray[i])
            pathCommand = pathArray[i][0];
        allPathCommands[i] = pathCommand;
        pathArray[i] = segmentToCubic(pathArray[i], params);
        fixArc(pathArray, allPathCommands, i);
        ii = pathArray.length; // solves curveArrays ending in Z
        // keep Z command account for lineJoin
        // @see https://github.com/antvis/util/issues/68
        if (pathCommand === 'Z') {
            zCommandIndexes.push(i);
        }
        segment = pathArray[i];
        seglen = segment.length;
        params.x1 = +segment[seglen - 2];
        params.y1 = +segment[seglen - 1];
        params.x2 = +(segment[seglen - 4]) || params.x1;
        params.y2 = +(segment[seglen - 3]) || params.y1;
    }
    if (needZCommandIndexes) {
        return [pathArray, zCommandIndexes];
    }
    else {
        return pathArray;
    }
}
function fixArc(pathArray, allPathCommands, i) {
    if (pathArray[i].length > 7) {
        pathArray[i].shift();
        var pi = pathArray[i];
        // const ni = i + 1;
        var ni = i;
        while (pi.length) {
            // if created multiple C:s, their original seg is saved
            allPathCommands[i] = 'A';
            // @ts-ignore
            pathArray.splice(ni += 1, 0, ['C'].concat(pi.splice(0, 6)));
        }
        pathArray.splice(i, 1);
    }
}
//# sourceMappingURL=path-2-curve.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/path-intersection.js



var base3 = function (t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function (x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z === null) {
        z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [
        -0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816,
    ];
    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    var sum = 0;
    for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2;
        var xbase = base3(ct, x1, x2, x3, x4);
        var ybase = base3(ct, y1, y2, y3, y4);
        var comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
};
var curveDim = function (x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [];
    var bounds = [[], []];
    var a;
    var b;
    var c;
    var t;
    for (var i = 0; i < 2; ++i) {
        if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
        }
        else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
        }
        if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
                continue;
            }
            t = -c / b;
            if (t > 0 && t < 1) {
                tvalues.push(t);
            }
            continue;
        }
        var b2ac = b * b - 4 * c * a;
        var sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
            continue;
        }
        var t1 = (-b + sqrtb2ac) / (2 * a);
        if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
        }
        var t2 = (-b - sqrtb2ac) / (2 * a);
        if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
        }
    }
    var j = tvalues.length;
    var jlen = j;
    var mt;
    while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
        bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
        min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1]),
        },
        max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1]),
        },
    };
};
var path_intersection_intersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    if (Math.max(x1, x2) < Math.min(x3, x4) ||
        Math.min(x1, x2) > Math.max(x3, x4) ||
        Math.max(y1, y2) < Math.min(y3, y4) ||
        Math.min(y1, y2) > Math.max(y3, y4)) {
        return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
        return;
    }
    var px = nx / denominator;
    var py = ny / denominator;
    var px2 = +px.toFixed(2);
    var py2 = +py.toFixed(2);
    if (px2 < +Math.min(x1, x2).toFixed(2) ||
        px2 > +Math.max(x1, x2).toFixed(2) ||
        px2 < +Math.min(x3, x4).toFixed(2) ||
        px2 > +Math.max(x3, x4).toFixed(2) ||
        py2 < +Math.min(y1, y2).toFixed(2) ||
        py2 > +Math.max(y1, y2).toFixed(2) ||
        py2 < +Math.min(y3, y4).toFixed(2) ||
        py2 > +Math.max(y3, y4).toFixed(2)) {
        return;
    }
    return {
        x: px,
        y: py,
    };
};
var isPointInsideBBox = function (bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var box = function (x, y, width, height) {
    if (x === null) {
        x = y = width = height = 0;
    }
    if (y === null) {
        y = x.y;
        width = x.width;
        height = x.height;
        x = x.x;
    }
    return {
        x: x,
        y: y,
        width: width,
        w: width,
        height: height,
        h: height,
        x2: x + width,
        y2: y + height,
        cx: x + width / 2,
        cy: y + height / 2,
        r1: Math.min(width, height) / 2,
        r2: Math.max(width, height) / 2,
        r0: Math.sqrt(width * width + height * height) / 2,
        path: rectPath(x, y, width, height),
        vb: [x, y, width, height].join(' '),
    };
};
var isBBoxIntersect = function (bbox1, bbox2) {
    // @ts-ignore
    bbox1 = box(bbox1);
    // @ts-ignore
    bbox2 = box(bbox2);
    return (isPointInsideBBox(bbox2, bbox1.x, bbox1.y) ||
        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) ||
        isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) ||
        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) ||
        isPointInsideBBox(bbox1, bbox2.x, bbox2.y) ||
        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) ||
        isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) ||
        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) ||
        (((bbox1.x < bbox2.x2 && bbox1.x > bbox2.x) || (bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)) &&
            ((bbox1.y < bbox2.y2 && bbox1.y > bbox2.y) || (bbox2.y < bbox1.y2 && bbox2.y > bbox1.y))));
};
var bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!isArray(p1x)) {
        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    var t13 = Math.pow(t1, 3);
    var t12 = Math.pow(t1, 2);
    var t2 = t * t;
    var t3 = t2 * t;
    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
    var ax = t1 * p1x + t * c1x;
    var ay = t1 * p1y + t * c1y;
    var cx = t1 * c2x + t * p2x;
    var cy = t1 * c2y + t * p2y;
    var alpha = 90 - (Math.atan2(mx - nx, my - ny) * 180) / Math.PI;
    // (mx > nx || my < ny) && (alpha += 180);
    return {
        x: x,
        y: y,
        m: {
            x: mx,
            y: my,
        },
        n: {
            x: nx,
            y: ny,
        },
        start: {
            x: ax,
            y: ay,
        },
        end: {
            x: cx,
            y: cy,
        },
        alpha: alpha,
    };
};
var interHelper = function (bez1, bez2, justCount) {
    // @ts-ignore
    var bbox1 = bezierBBox(bez1);
    // @ts-ignore
    var bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1);
    var l2 = bezlen.apply(0, bez2);
    var n1 = ~~(l1 / 8);
    var n2 = ~~(l2 / 8);
    var dots1 = [];
    var dots2 = [];
    var xy = {};
    var res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
        dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1,
        });
    }
    for (var i = 0; i < n2 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
        dots2.push({
            x: d.x,
            y: d.y,
            t: i / n2,
        });
    }
    for (var i = 0; i < n1; i++) {
        for (var j = 0; j < n2; j++) {
            var di = dots1[i];
            var di1 = dots1[i + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = path_intersection_intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                    continue;
                }
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                    if (justCount) {
                        // @ts-ignore
                        res++;
                    }
                    else {
                        // @ts-ignore
                        res.push({
                            x: is.x,
                            y: is.y,
                            t1: t1,
                            t2: t2,
                        });
                    }
                }
            }
        }
    }
    return res;
};
var interPathHelper = function (path1, path2, justCount) {
    // @ts-ignore
    path1 = path2Curve(path1);
    // @ts-ignore
    path2 = path2Curve(path2);
    var x1;
    var y1;
    var x2;
    var y2;
    var x1m;
    var y1m;
    var x2m;
    var y2m;
    var bez1;
    var bez2;
    var res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
        var pi = path1[i];
        if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
        }
        else {
            if (pi[0] === 'C') {
                bez1 = [x1, y1].concat(pi.slice(1));
                x1 = bez1[6];
                y1 = bez1[7];
            }
            else {
                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                x1 = x1m;
                y1 = y1m;
            }
            for (var j = 0, jj = path2.length; j < jj; j++) {
                var pj = path2[j];
                if (pj[0] === 'M') {
                    x2 = x2m = pj[1];
                    y2 = y2m = pj[2];
                }
                else {
                    if (pj[0] === 'C') {
                        bez2 = [x2, y2].concat(pj.slice(1));
                        x2 = bez2[6];
                        y2 = bez2[7];
                    }
                    else {
                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                        x2 = x2m;
                        y2 = y2m;
                    }
                    var intr = interHelper(bez1, bez2, justCount);
                    if (justCount) {
                        // @ts-ignore
                        res += intr;
                    }
                    else {
                        // @ts-ignore
                        for (var k = 0, kk = intr.length; k < kk; k++) {
                            intr[k].segment1 = i;
                            intr[k].segment2 = j;
                            intr[k].bez1 = bez1;
                            intr[k].bez2 = bez2;
                        }
                        // @ts-ignore
                        res = res.concat(intr);
                    }
                }
            }
        }
    }
    return res;
};
function pathIntersection(path1, path2) {
    // @ts-ignore
    return interPathHelper(path1, path2);
}
//# sourceMappingURL=path-intersection.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/node_modules/@antv/path-util/esm/index.js
















//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/shape.js





/**
 * \u83B7\u53D6\u586B\u5145\u5C5E\u6027
 * @param cfg \u56FE\u5F62\u7ED8\u5236\u6570\u636E
 */
function shape_getFillAttrs(cfg) {
    // style.fill \u4F18\u5148\u7EA7\u66F4\u9AD8
    return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape('schema', 'venn', {
    draw: function (cfg, container) {
        var data = cfg.data;
        var segments = parse_path_string_parsePathString(data[PATH_FIELD]);
        var fillAttrs = shape_getFillAttrs(cfg);
        var group = container.addGroup({ name: 'venn-shape' });
        group.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, fillAttrs), { path: segments }),
            name: 'venn-path',
        });
        var _a = cfg.customInfo, offsetX = _a.offsetX, offsetY = _a.offsetY;
        var matrix = Util.transform(null, [['t', offsetX, offsetY]]);
        group.setMatrix(matrix);
        return group;
    },
    getMarker: function (markerCfg) {
        var color = markerCfg.color;
        return {
            symbol: 'circle',
            style: {
                lineWidth: 0,
                stroke: color,
                fill: color,
                r: 4,
            },
        };
    },
});
//# sourceMappingURL=shape.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/color/blend.js

/*
 * interpolates between a set of colors uzing a bezier spline
 * blend mode formulas taken from http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/
 */
var blend_each = function (f) {
    return function (c0, c1) {
        var out = [];
        out[0] = f(c0[0], c1[0]);
        out[1] = f(c0[1], c1[1]);
        out[2] = f(c0[2], c1[2]);
        return out;
    };
};
/**
 * \u6DF7\u5408\u65B9\u6CD5\u96C6\u5408
 */
var blendObject = {
    normal: function (a) { return a; },
    multiply: function (a, b) { return (a * b) / 255; },
    screen: function (a, b) { return 255 * (1 - (1 - a / 255) * (1 - b / 255)); },
    overlay: function (a, b) { return (b < 128 ? (2 * a * b) / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255))); },
    darken: function (a, b) { return (a > b ? b : a); },
    lighten: function (a, b) { return (a > b ? a : b); },
    dodge: function (a, b) {
        if (a === 255)
            return 255;
        a = (255 * (b / 255)) / (1 - a / 255);
        return a > 255 ? 255 : a;
    },
    burn: function (a, b) {
        // \u53C2\u8003 w3c \u7684\u5199\u6CD5\uFF0C\u8003\u8651\u9664\u6570\u4E3A 0 \u7684\u60C5\u51B5
        if (b === 255)
            return 255;
        else if (a === 0)
            return 0;
        else
            return 255 * (1 - Math.min(1, (1 - b / 255) / (a / 255)));
    },
};
/**
 * \u83B7\u53D6\u6DF7\u5408\u65B9\u6CD5
 */
var innerBlend = function (mode) {
    if (!blendObject[mode]) {
        throw new Error('unknown blend mode ' + mode);
    }
    return blendObject[mode];
};
/**
 * \u6DF7\u5408\u989C\u8272\uFF0C\u5E76\u5904\u7406\u900F\u660E\u5EA6\u60C5\u51B5
 * \u53C2\u8003\uFF1Ahttps://www.w3.org/TR/compositing/#blending
 * @param c0
 * @param c1
 * @param mode \u6DF7\u5408\u6A21\u5F0F
 * @return rbga
 */
function blend(c0, c1, mode) {
    if (mode === void 0) { mode = 'normal'; }
    // blendRgbArr: \u751F\u6210\u4E0D\u8003\u8651\u900F\u660E\u5EA6\u7684 blend color: [r, g, b]
    var blendRgbArr = blend_each(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
    var _a = colorToArr(c0), r0 = _a[0], g0 = _a[1], b0 = _a[2], a0 = _a[3];
    var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b1 = _b[2], a1 = _b[3];
    var a = Number((a0 + a1 * (1 - a0)).toFixed(2));
    var r = Math.round(((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a) * 255);
    var g = Math.round(((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a) * 255);
    var b = Math.round(((a0 * (1 - a1) * (b0 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b1 / 255)) / a) * 255);
    return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
/**
 * \u7EDF\u4E00\u989C\u8272\u8F93\u5165\u7684\u683C\u5F0F [r, g, b, a]
 * \u53C2\u8003\uFF1Ahttps://www.w3.org/TR/compositing/#blending
 * @param c color
 * @return [r, g, b, a]
 */
function colorToArr(c) {
    var color = c.replace('/s+/g', ''); // \u53BB\u9664\u6240\u6709\u7A7A\u683C
    var rgbaArr;
    // 'red' -> [r, g, b, 1]
    if (typeof color === 'string' && !color.startsWith('rgba') && !color.startsWith('#')) {
        return (rgbaArr = color_util_esm.rgb2arr(color_util_esm.toRGB(color)).concat([1]));
    }
    // rgba(255, 200, 125, 0.5) -> [r, g, b, a]
    if (color.startsWith('rgba'))
        rgbaArr = color.replace('rgba(', '').replace(')', '').split(',');
    // '#fff000' -> [r, g, b, 1]
    if (color.startsWith('#'))
        rgbaArr = color_util_esm.rgb2arr(color).concat([1]); // \u5982\u679C\u662F 16 \u8FDB\u5236\uFF086 \u4F4D\u6570\uFF09\uFF0C\u9ED8\u8BA4\u900F\u660E\u5EA6 1
    // [r, g, b, a] \u524D\u4E09\u4F4D\u53D6\u6574
    return rgbaArr.map(function (item, index) { return (index === 3 ? Number(item) : item | 0); });
}
//# sourceMappingURL=blend.js.map
// EXTERNAL MODULE: ./node_modules/fmin/build/fmin.js
var fmin = __webpack_require__(87026);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/layout/circleintersection.js
var SMALL = 1e-10;
/** Returns the intersection area of a bunch of circles (where each circle
 is an object having an x,y and radius property) */
function intersectionArea(circles, stats) {
    // get all the intersection points of the circles
    var intersectionPoints = getIntersectionPoints(circles);
    // filter out points that aren't included in all the circles
    var innerPoints = intersectionPoints.filter(function (p) {
        return containedInCircles(p, circles);
    });
    var arcArea = 0, polygonArea = 0, i;
    var arcs = [];
    // if we have intersection points that are within all the circles,
    // then figure out the area contained by them
    if (innerPoints.length > 1) {
        // sort the points by angle from the center of the polygon, which lets
        // us just iterate over points to get the edges
        var center = getCenter(innerPoints);
        for (i = 0; i < innerPoints.length; ++i) {
            var p = innerPoints[i];
            p.angle = Math.atan2(p.x - center.x, p.y - center.y);
        }
        innerPoints.sort(function (a, b) {
            return b.angle - a.angle;
        });
        // iterate over all points, get arc between the points
        // and update the areas
        var p2 = innerPoints[innerPoints.length - 1];
        for (i = 0; i < innerPoints.length; ++i) {
            var p1 = innerPoints[i];
            // polygon area updates easily ...
            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
            // updating the arc area is a little more involved
            var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            var arc = null;
            for (var j = 0; j < p1.parentIndex.length; ++j) {
                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                    // figure out the angle halfway between the two points
                    // on the current circle
                    var circle = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y), a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
                    var angleDiff = a2 - a1;
                    if (angleDiff < 0) {
                        angleDiff += 2 * Math.PI;
                    }
                    // and use that angle to figure out the width of the
                    // arc
                    var a = a2 - angleDiff / 2;
                    var width = circleintersection_distance(midPoint, {
                        x: circle.x + circle.radius * Math.sin(a),
                        y: circle.y + circle.radius * Math.cos(a),
                    });
                    // clamp the width to the largest is can actually be
                    // (sometimes slightly overflows because of FP errors)
                    if (width > circle.radius * 2) {
                        width = circle.radius * 2;
                    }
                    // pick the circle whose arc has the smallest width
                    if (arc === null || arc.width > width) {
                        arc = { circle: circle, width: width, p1: p1, p2: p2 };
                    }
                }
            }
            if (arc !== null) {
                arcs.push(arc);
                arcArea += circleArea(arc.circle.radius, arc.width);
                p2 = p1;
            }
        }
    }
    else {
        // no intersection points, is either disjoint - or is completely
        // overlapped. figure out which by examining the smallest circle
        var smallest = circles[0];
        for (i = 1; i < circles.length; ++i) {
            if (circles[i].radius < smallest.radius) {
                smallest = circles[i];
            }
        }
        // make sure the smallest circle is completely contained in all
        // the other circles
        var disjoint = false;
        for (i = 0; i < circles.length; ++i) {
            if (circleintersection_distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                disjoint = true;
                break;
            }
        }
        if (disjoint) {
            arcArea = polygonArea = 0;
        }
        else {
            arcArea = smallest.radius * smallest.radius * Math.PI;
            arcs.push({
                circle: smallest,
                p1: { x: smallest.x, y: smallest.y + smallest.radius },
                p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
                width: smallest.radius * 2,
            });
        }
    }
    polygonArea /= 2;
    if (stats) {
        stats.area = arcArea + polygonArea;
        stats.arcArea = arcArea;
        stats.polygonArea = polygonArea;
        stats.arcs = arcs;
        stats.innerPoints = innerPoints;
        stats.intersectionPoints = intersectionPoints;
    }
    return arcArea + polygonArea;
}
/** returns whether a point is contained by all of a list of circles */
function containedInCircles(point, circles) {
    for (var i = 0; i < circles.length; ++i) {
        if (circleintersection_distance(point, circles[i]) > circles[i].radius + SMALL) {
            return false;
        }
    }
    return true;
}
/** Gets all intersection points between a bunch of circles */
function getIntersectionPoints(circles) {
    var ret = [];
    for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
            var intersect = circleCircleIntersection(circles[i], circles[j]);
            for (var k = 0; k < intersect.length; ++k) {
                var p = intersect[k];
                p.parentIndex = [i, j];
                ret.push(p);
            }
        }
    }
    return ret;
}
/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */
function circleArea(r, width) {
    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
/** euclidean distance between two points */
function circleintersection_distance(p1, p2) {
    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
/** Returns the overlap area of two circles of radius r1 and r2 - that
have their centers separated by distance d. Simpler faster
circle intersection for only two circles */
function circleOverlap(r1, r2, d) {
    // no overlap
    if (d >= r1 + r2) {
        return 0;
    }
    // completely overlapped
    if (d <= Math.abs(r1 - r2)) {
        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    }
    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
    return circleArea(r1, w1) + circleArea(r2, w2);
}
/** Given two circles (containing a x/y/radius attributes),
returns the intersecting points if possible.
note: doesn't handle cases where there are infinitely many
intersection points (circles are equivalent):, or only one intersection point*/
function circleCircleIntersection(p1, p2) {
    var d = circleintersection_distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
    // if to far away, or self contained - can't be done
    if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
        return [];
    }
    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + (a * (p2.x - p1.x)) / d, y0 = p1.y + (a * (p2.y - p1.y)) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
    return [
        { x: x0 + rx, y: y0 - ry },
        { x: x0 - rx, y: y0 + ry },
    ];
}
/** Returns the center of a bunch of points */
function getCenter(points) {
    var center = { x: 0, y: 0 };
    for (var i = 0; i < points.length; ++i) {
        center.x += points[i].x;
        center.y += points[i].y;
    }
    center.x /= points.length;
    center.y /= points.length;
    return center;
}
//# sourceMappingURL=circleintersection.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/layout/diagram.js


function circleMargin(current, interior, exterior) {
    var margin = interior[0].radius - circleintersection_distance(interior[0], current), i, m;
    for (i = 1; i < interior.length; ++i) {
        m = interior[i].radius - circleintersection_distance(interior[i], current);
        if (m <= margin) {
            margin = m;
        }
    }
    for (i = 0; i < exterior.length; ++i) {
        m = circleintersection_distance(exterior[i], current) - exterior[i].radius;
        if (m <= margin) {
            margin = m;
        }
    }
    return margin;
}
// compute the center of some circles by maximizing the margin of
// the center point relative to the circles (interior) after subtracting
// nearby circles (exterior)
function computeTextCentre(interior, exterior) {
    // get an initial estimate by sampling around the interior circles
    // and taking the point with the biggest margin
    var points = [];
    var i;
    for (i = 0; i < interior.length; ++i) {
        var c = interior[i];
        points.push({ x: c.x, y: c.y });
        points.push({ x: c.x + c.radius / 2, y: c.y });
        points.push({ x: c.x - c.radius / 2, y: c.y });
        points.push({ x: c.x, y: c.y + c.radius / 2 });
        points.push({ x: c.x, y: c.y - c.radius / 2 });
    }
    var initial = points[0], margin = circleMargin(points[0], interior, exterior);
    for (i = 1; i < points.length; ++i) {
        var m = circleMargin(points[i], interior, exterior);
        if (m >= margin) {
            initial = points[i];
            margin = m;
        }
    }
    // maximize the margin numerically
    var solution = (0,fmin.nelderMead)(function (p) {
        return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);
    }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
    var ret = { x: solution[0], y: solution[1] };
    // check solution, fallback as needed (happens if fully overlapped
    // etc)
    var valid = true;
    for (i = 0; i < interior.length; ++i) {
        if (circleintersection_distance(ret, interior[i]) > interior[i].radius) {
            valid = false;
            break;
        }
    }
    for (i = 0; i < exterior.length; ++i) {
        if (circleintersection_distance(ret, exterior[i]) < exterior[i].radius) {
            valid = false;
            break;
        }
    }
    if (!valid) {
        if (interior.length == 1) {
            ret = { x: interior[0].x, y: interior[0].y };
        }
        else {
            var areaStats = {};
            intersectionArea(interior, areaStats);
            if (areaStats.arcs.length === 0) {
                ret = { x: 0, y: -1000, disjoint: true };
            }
            else if (areaStats.arcs.length == 1) {
                ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
            }
            else if (exterior.length) {
                // try again without other circles
                ret = computeTextCentre(interior, []);
            }
            else {
                // take average of all the points in the intersection
                // polygon. this should basically never happen
                // and has some issues:
                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777
                ret = getCenter(areaStats.arcs.map(function (a) {
                    return a.p1;
                }));
            }
        }
    }
    return ret;
}
// given a dictionary of {setid : circle}, returns
// a dictionary of setid to list of circles that completely overlap it
function getOverlappingCircles(circles) {
    var ret = {}, circleids = [];
    for (var circleid in circles) {
        circleids.push(circleid);
        ret[circleid] = [];
    }
    for (var i = 0; i < circleids.length; i++) {
        var a = circles[circleids[i]];
        for (var j = i + 1; j < circleids.length; ++j) {
            var b = circles[circleids[j]], d = circleintersection_distance(a, b);
            if (d + b.radius <= a.radius + 1e-10) {
                ret[circleids[j]].push(circleids[i]);
            }
            else if (d + a.radius <= b.radius + 1e-10) {
                ret[circleids[i]].push(circleids[j]);
            }
        }
    }
    return ret;
}
function computeTextCentres(circles, areas) {
    var ret = {}, overlapped = getOverlappingCircles(circles);
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i].sets, areaids = {}, exclude = {};
        for (var j = 0; j < area.length; ++j) {
            areaids[area[j]] = true;
            var overlaps = overlapped[area[j]];
            // keep track of any circles that overlap this area,
            // and don't consider for purposes of computing the text
            // centre
            for (var k = 0; k < overlaps.length; ++k) {
                exclude[overlaps[k]] = true;
            }
        }
        var interior = [], exterior = [];
        for (var setid in circles) {
            if (setid in areaids) {
                interior.push(circles[setid]);
            }
            else if (!(setid in exclude)) {
                exterior.push(circles[setid]);
            }
        }
        var centre = computeTextCentre(interior, exterior);
        ret[area] = centre;
        if (centre.disjoint && areas[i].size > 0) {
            console.log('WARNING: area ' + area + ' not represented on screen');
        }
    }
    return ret;
}
/**
 * \u6839\u636E\u5706\u5FC3(x, y) \u534A\u5F84 r \u8FD4\u56DE\u5706\u7684\u7ED8\u5236 path
 * @param x \u5706\u5FC3\u70B9 x
 * @param y \u5706\u5FC3\u70B9 y
 * @param r \u5706\u7684\u534A\u5F84
 * @returns \u5706\u7684 path
 */
function circlePath(x, y, r) {
    var ret = [];
    // ret.push('\\nM', x, y);
    // ret.push('\\nm', -r, 0);
    // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);
    // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);
    var x0 = x - r;
    var y0 = y;
    ret.push('M', x0, y0);
    ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);
    ret.push('A', r, r, 0, 1, 0, x0, y0);
    return ret.join(' ');
}
// inverse of the circlePath function, returns a circle object from an svg path
function circleFromPath(path) {
    var tokens = path.split(' ');
    return { x: parseFloat(tokens[1]), y: parseFloat(tokens[2]), radius: -parseFloat(tokens[4]) };
}
/** returns a svg path of the intersection area of a bunch of circles */
function intersectionAreaPath(circles) {
    var stats = {};
    intersectionArea(circles, stats);
    var arcs = stats.arcs;
    if (arcs.length === 0) {
        return 'M 0 0';
    }
    else if (arcs.length == 1) {
        var circle = arcs[0].circle;
        return circlePath(circle.x, circle.y, circle.radius);
    }
    else {
        // draw path around arcs
        var ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];
        for (var i = 0; i < arcs.length; ++i) {
            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
            ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
        }
        return ret.join(' ');
    }
}
//# sourceMappingURL=diagram.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/layout/layout.js


/** given a list of set objects, and their corresponding overlaps.
updates the (x, y, radius) attribute on each set such that their positions
roughly correspond to the desired overlaps */
function venn(areas, parameters) {
    parameters = parameters || {};
    parameters.maxIterations = parameters.maxIterations || 500;
    var initialLayout = parameters.initialLayout || bestInitialLayout;
    var loss = parameters.lossFunction || lossFunction;
    // add in missing pairwise areas as having 0 size
    areas = addMissingAreas(areas);
    // initial layout is done greedily
    var circles = initialLayout(areas, parameters);
    // transform x/y coordinates to a vector to optimize
    var initial = [], setids = [];
    var setid;
    for (setid in circles) {
        // eslint-disable-next-line
        if (circles.hasOwnProperty(setid)) {
            initial.push(circles[setid].x);
            initial.push(circles[setid].y);
            setids.push(setid);
        }
    }
    // optimize initial layout from our loss function
    var solution = (0,fmin.nelderMead)(function (values) {
        var current = {};
        for (var i = 0; i < setids.length; ++i) {
            var setid_1 = setids[i];
            current[setid_1] = {
                x: values[2 * i],
                y: values[2 * i + 1],
                radius: circles[setid_1].radius,
                // size : circles[setid].size
            };
        }
        return loss(current, areas);
    }, initial, parameters);
    // transform solution vector back to x/y points
    var positions = solution.x;
    for (var i = 0; i < setids.length; ++i) {
        setid = setids[i];
        circles[setid].x = positions[2 * i];
        circles[setid].y = positions[2 * i + 1];
    }
    return circles;
}
var layout_SMALL = 1e-10;
/** Returns the distance necessary for two circles of radius r1 + r2 to
have the overlap area 'overlap' */
function distanceFromIntersectArea(r1, r2, overlap) {
    // handle complete overlapped circles
    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + layout_SMALL) {
        return Math.abs(r1 - r2);
    }
    return (0,fmin.bisect)(function (distance) {
        return circleOverlap(r1, r2, distance) - overlap;
    }, 0, r1 + r2);
}
/** Missing pair-wise intersection area data can cause problems:
 treating as an unknown means that sets will be laid out overlapping,
 which isn't what people expect. To reflect that we want disjoint sets
 here, set the overlap to 0 for all missing pairwise set intersections */
function addMissingAreas(areas) {
    areas = areas.slice();
    // two circle intersections that aren't defined
    var ids = [], pairs = {};
    var i, j, a, b;
    for (i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.sets.length == 1) {
            ids.push(area.sets[0]);
        }
        else if (area.sets.length == 2) {
            a = area.sets[0];
            b = area.sets[1];
            // @ts-ignore
            pairs[[a, b]] = true;
            // @ts-ignore
            pairs[[b, a]] = true;
        }
    }
    ids.sort(function (a, b) {
        return a > b ? 1 : -1;
    });
    for (i = 0; i < ids.length; ++i) {
        a = ids[i];
        for (j = i + 1; j < ids.length; ++j) {
            b = ids[j];
            // @ts-ignore
            if (!([a, b] in pairs)) {
                areas.push({ sets: [a, b], size: 0 });
            }
        }
    }
    return areas;
}
/// Returns two matrices, one of the euclidean distances between the sets
/// and the other indicating if there are subset or disjoint set relationships
function getDistanceMatrices(areas, sets, setids) {
    // initialize an empty distance matrix between all the points
    var distances = (0,fmin.zerosM)(sets.length, sets.length), constraints = (0,fmin.zerosM)(sets.length, sets.length);
    // compute required distances between all the sets such that
    // the areas match
    areas
        .filter(function (x) {
        return x.sets.length == 2;
    })
        .map(function (current) {
        var left = setids[current.sets[0]], right = setids[current.sets[1]], r1 = Math.sqrt(sets[left].size / Math.PI), r2 = Math.sqrt(sets[right].size / Math.PI), distance = distanceFromIntersectArea(r1, r2, current.size);
        distances[left][right] = distances[right][left] = distance;
        // also update constraints to indicate if its a subset or disjoint
        // relationship
        var c = 0;
        if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {
            c = 1;
        }
        else if (current.size <= 1e-10) {
            c = -1;
        }
        constraints[left][right] = constraints[right][left] = c;
    });
    return { distances: distances, constraints: constraints };
}
/// computes the gradient and loss simulatenously for our constrained MDS optimizer
function constrainedMDSGradient(x, fxprime, distances, constraints) {
    var loss = 0, i;
    for (i = 0; i < fxprime.length; ++i) {
        fxprime[i] = 0;
    }
    for (i = 0; i < distances.length; ++i) {
        var xi = x[2 * i], yi = x[2 * i + 1];
        for (var j = i + 1; j < distances.length; ++j) {
            var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance_1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
            if ((constraint > 0 && distance_1 <= dij) || (constraint < 0 && distance_1 >= dij)) {
                continue;
            }
            loss += 2 * delta * delta;
            fxprime[2 * i] += 4 * delta * (xi - xj);
            fxprime[2 * i + 1] += 4 * delta * (yi - yj);
            fxprime[2 * j] += 4 * delta * (xj - xi);
            fxprime[2 * j + 1] += 4 * delta * (yj - yi);
        }
    }
    return loss;
}
/// takes the best working variant of either constrained MDS or greedy
function bestInitialLayout(areas, params) {
    var initial = greedyLayout(areas, params);
    var loss = params.lossFunction || lossFunction;
    // greedylayout is sufficient for all 2/3 circle cases. try out
    // constrained MDS for higher order problems, take its output
    // if it outperforms. (greedy is aesthetically better on 2/3 circles
    // since it axis aligns)
    if (areas.length >= 8) {
        var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
        if (constrainedLoss + 1e-8 < greedyLoss) {
            initial = constrained;
        }
    }
    return initial;
}
/// use the constrained MDS variant to generate an initial layout
function constrainedMDSLayout(areas, params) {
    params = params || {};
    var restarts = params.restarts || 10;
    // bidirectionally map sets to a rowid  (so we can create a matrix)
    var sets = [], setids = {};
    var i;
    for (i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.sets.length == 1) {
            setids[area.sets[0]] = sets.length;
            sets.push(area);
        }
    }
    var matrices = getDistanceMatrices(areas, sets, setids);
    var distances = matrices.distances;
    var constraints = matrices.constraints;
    // keep distances bounded, things get messed up otherwise.
    // TODO: proper preconditioner?
    var norm = (0,fmin.norm2)(distances.map(fmin.norm2)) / distances.length;
    distances = distances.map(function (row) {
        return row.map(function (value) {
            return value / norm;
        });
    });
    var obj = function (x, fxprime) {
        return constrainedMDSGradient(x, fxprime, distances, constraints);
    };
    var best, current;
    for (i = 0; i < restarts; ++i) {
        var initial = (0,fmin.zeros)(distances.length * 2).map(Math.random);
        current = (0,fmin.conjugateGradient)(obj, initial, params);
        if (!best || current.fx < best.fx) {
            best = current;
        }
    }
    var positions = best.x;
    // translate rows back to (x,y,radius) coordinates
    var circles = {};
    for (i = 0; i < sets.length; ++i) {
        var set = sets[i];
        circles[set.sets[0]] = {
            x: positions[2 * i] * norm,
            y: positions[2 * i + 1] * norm,
            radius: Math.sqrt(set.size / Math.PI),
        };
    }
    if (params.history) {
        for (i = 0; i < params.history.length; ++i) {
            (0,fmin.scale)(params.history[i].x, norm);
        }
    }
    return circles;
}
/** Lays out a Venn diagram greedily, going from most overlapped sets to
least overlapped, attempting to position each new set such that the
overlapping areas to already positioned sets are basically right */
function greedyLayout(areas, params) {
    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
    // define a circle for each set
    var circles = {}, setOverlaps = {};
    var set;
    for (var i = 0; i < areas.length; ++i) {
        var area = areas[i];
        if (area.sets.length == 1) {
            set = area.sets[0];
            circles[set] = {
                x: 1e10,
                y: 1e10,
                // rowid: circles.length, // fix to ->
                rowid: Object.keys(circles).length,
                size: area.size,
                radius: Math.sqrt(area.size / Math.PI),
            };
            setOverlaps[set] = [];
        }
    }
    areas = areas.filter(function (a) {
        return a.sets.length == 2;
    });
    // map each set to a list of all the other sets that overlap it
    for (var i = 0; i < areas.length; ++i) {
        var current = areas[i];
        // eslint-disable-next-line
        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
        var left = current.sets[0], right = current.sets[1];
        // completely overlapped circles shouldn't be positioned early here
        if (current.size + layout_SMALL >= Math.min(circles[left].size, circles[right].size)) {
            weight = 0;
        }
        setOverlaps[left].push({ set: right, size: current.size, weight: weight });
        setOverlaps[right].push({ set: left, size: current.size, weight: weight });
    }
    // get list of most overlapped sets
    var mostOverlapped = [];
    for (set in setOverlaps) {
        // eslint-disable-next-line
        if (setOverlaps.hasOwnProperty(set)) {
            var size = 0;
            for (var i = 0; i < setOverlaps[set].length; ++i) {
                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
            }
            mostOverlapped.push({ set: set, size: size });
        }
    }
    // sort by size desc
    function sortOrder(a, b) {
        return b.size - a.size;
    }
    mostOverlapped.sort(sortOrder);
    // keep track of what sets have been laid out
    var positioned = {};
    function isPositioned(element) {
        return element.set in positioned;
    }
    // adds a point to the output
    function positionSet(point, index) {
        circles[index].x = point.x;
        circles[index].y = point.y;
        positioned[index] = true;
    }
    // add most overlapped set at (0,0)
    positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
    // get distances between all points. TODO, necessary?
    // answer: probably not
    // var distances = venn.getDistanceMatrices(circles, areas).distances;
    for (var i = 1; i < mostOverlapped.length; ++i) {
        var setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
        set = circles[setIndex];
        overlap.sort(sortOrder);
        if (overlap.length === 0) {
            // this shouldn't happen anymore with addMissingAreas
            throw 'ERROR: missing pairwise overlap information';
        }
        var points = [];
        for (var j = 0; j < overlap.length; ++j) {
            // get appropriate distance from most overlapped already added set
            var p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);
            // sample positions at 90 degrees for maximum aesthetics
            points.push({ x: p1.x + d1, y: p1.y });
            points.push({ x: p1.x - d1, y: p1.y });
            points.push({ y: p1.y + d1, x: p1.x });
            points.push({ y: p1.y - d1, x: p1.x });
            // if we have at least 2 overlaps, then figure out where the
            // set should be positioned analytically and try those too
            for (var k = j + 1; k < overlap.length; ++k) {
                var p2 = circles[overlap[k].set], d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);
                var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
                for (var l = 0; l < extraPoints.length; ++l) {
                    points.push(extraPoints[l]);
                }
            }
        }
        // we have some candidate positions for the set, examine loss
        // at each position to figure out where to put it at
        var bestLoss = 1e50, bestPoint = points[0];
        for (var j = 0; j < points.length; ++j) {
            circles[setIndex].x = points[j].x;
            circles[setIndex].y = points[j].y;
            var localLoss = loss(circles, areas);
            if (localLoss < bestLoss) {
                bestLoss = localLoss;
                bestPoint = points[j];
            }
        }
        positionSet(bestPoint, setIndex);
    }
    return circles;
}
/** Given a bunch of sets, and the desired overlaps between these sets - computes
the distance from the actual overlaps to the desired overlaps. Note that
this method ignores overlaps of more than 2 circles */
function lossFunction(sets, overlaps) {
    var output = 0;
    function getCircles(indices) {
        return indices.map(function (i) {
            return sets[i];
        });
    }
    for (var i = 0; i < overlaps.length; ++i) {
        var area = overlaps[i];
        var overlap = void 0;
        if (area.sets.length == 1) {
            continue;
        }
        else if (area.sets.length == 2) {
            var left = sets[area.sets[0]], right = sets[area.sets[1]];
            overlap = circleOverlap(left.radius, right.radius, circleintersection_distance(left, right));
        }
        else {
            overlap = intersectionArea(getCircles(area.sets));
        }
        // eslint-disable-next-line
        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
        output += weight * (overlap - area.size) * (overlap - area.size);
    }
    return output;
}
// orientates a bunch of circles to point in orientation
function orientateCircles(circles, orientation, orientationOrder) {
    if (orientationOrder === null) {
        circles.sort(function (a, b) {
            return b.radius - a.radius;
        });
    }
    else {
        circles.sort(orientationOrder);
    }
    var i;
    // shift circles so largest circle is at (0, 0)
    if (circles.length > 0) {
        var largestX = circles[0].x, largestY = circles[0].y;
        for (i = 0; i < circles.length; ++i) {
            circles[i].x -= largestX;
            circles[i].y -= largestY;
        }
    }
    if (circles.length == 2) {
        // if the second circle is a subset of the first, arrange so that
        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120
        var dist = distance(circles[0], circles[1]);
        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
            circles[1].y = circles[0].y;
        }
    }
    // rotate circles so that second largest is at an angle of 'orientation'
    // from largest
    if (circles.length > 1) {
        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;
        var x = void 0, y = void 0;
        var c = Math.cos(rotation), s = Math.sin(rotation);
        for (i = 0; i < circles.length; ++i) {
            x = circles[i].x;
            y = circles[i].y;
            circles[i].x = c * x - s * y;
            circles[i].y = s * x + c * y;
        }
    }
    // mirror solution if third solution is above plane specified by
    // first two circles
    if (circles.length > 2) {
        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;
        while (angle < 0) {
            angle += 2 * Math.PI;
        }
        while (angle > 2 * Math.PI) {
            angle -= 2 * Math.PI;
        }
        if (angle > Math.PI) {
            var slope = circles[1].y / (1e-10 + circles[1].x);
            for (i = 0; i < circles.length; ++i) {
                var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
                circles[i].x = 2 * d - circles[i].x;
                circles[i].y = 2 * d * slope - circles[i].y;
            }
        }
    }
}
function disjointCluster(circles) {
    // union-find clustering to get disjoint sets
    circles.map(function (circle) {
        circle.parent = circle;
    });
    // path compression step in union find
    function find(circle) {
        if (circle.parent !== circle) {
            circle.parent = find(circle.parent);
        }
        return circle.parent;
    }
    function union(x, y) {
        var xRoot = find(x), yRoot = find(y);
        xRoot.parent = yRoot;
    }
    // get the union of all overlapping sets
    for (var i = 0; i < circles.length; ++i) {
        for (var j = i + 1; j < circles.length; ++j) {
            var maxDistance = circles[i].radius + circles[j].radius;
            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {
                union(circles[j], circles[i]);
            }
        }
    }
    // find all the disjoint clusters and group them together
    var disjointClusters = {};
    var setid;
    for (var i = 0; i < circles.length; ++i) {
        setid = find(circles[i]).parent.setid;
        if (!(setid in disjointClusters)) {
            disjointClusters[setid] = [];
        }
        disjointClusters[setid].push(circles[i]);
    }
    // cleanup bookkeeping
    circles.map(function (circle) {
        delete circle.parent;
    });
    // return in more usable form
    var ret = [];
    for (setid in disjointClusters) {
        // eslint-disable-next-line
        if (disjointClusters.hasOwnProperty(setid)) {
            ret.push(disjointClusters[setid]);
        }
    }
    return ret;
}
function getBoundingBox(circles) {
    var minMax = function (d) {
        var hi = Math.max.apply(null, circles.map(function (c) {
            return c[d] + c.radius;
        })), lo = Math.min.apply(null, circles.map(function (c) {
            return c[d] - c.radius;
        }));
        return { max: hi, min: lo };
    };
    return { xRange: minMax('x'), yRange: minMax('y') };
}
function normalizeSolution(solution, orientation, orientationOrder) {
    if (orientation === null) {
        orientation = Math.PI / 2;
    }
    // work with a list instead of a dictionary, and take a copy so we
    // don't mutate input
    var circles = [], i, setid;
    for (setid in solution) {
        // eslint-disable-next-line
        if (solution.hasOwnProperty(setid)) {
            var previous = solution[setid];
            circles.push({ x: previous.x, y: previous.y, radius: previous.radius, setid: setid });
        }
    }
    // get all the disjoint clusters
    var clusters = disjointCluster(circles);
    // orientate all disjoint sets, get sizes
    for (i = 0; i < clusters.length; ++i) {
        orientateCircles(clusters[i], orientation, orientationOrder);
        var bounds = getBoundingBox(clusters[i]);
        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
        clusters[i].bounds = bounds;
    }
    clusters.sort(function (a, b) {
        return b.size - a.size;
    });
    // orientate the largest at 0,0, and get the bounds
    circles = clusters[0];
    // @ts-ignore fixme \u4ECE\u903B\u8F91\u4E0A\u770B\u4F3C\u4E4E\u662F\u4E0D\u5BF9\u7684\uFF0C\u540E\u7EED\u770B\u770B
    var returnBounds = circles.bounds;
    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;
    function addCluster(cluster, right, bottom) {
        if (!cluster)
            return;
        var bounds = cluster.bounds;
        var xOffset, yOffset, centreing;
        if (right) {
            xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;
        }
        else {
            xOffset = returnBounds.xRange.max - bounds.xRange.max;
            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
            if (centreing < 0)
                xOffset += centreing;
        }
        if (bottom) {
            yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;
        }
        else {
            yOffset = returnBounds.yRange.max - bounds.yRange.max;
            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
            if (centreing < 0)
                yOffset += centreing;
        }
        for (var j = 0; j < cluster.length; ++j) {
            cluster[j].x += xOffset;
            cluster[j].y += yOffset;
            circles.push(cluster[j]);
        }
    }
    var index = 1;
    while (index < clusters.length) {
        addCluster(clusters[index], true, false);
        addCluster(clusters[index + 1], false, true);
        addCluster(clusters[index + 2], true, true);
        index += 3;
        // have one cluster (in top left). lay out next three relative
        // to it in a grid
        returnBounds = getBoundingBox(circles);
    }
    // convert back to solution form
    var ret = {};
    for (i = 0; i < circles.length; ++i) {
        ret[circles[i].setid] = circles[i];
    }
    return ret;
}
/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
a rectangle of width/height - with padding around the borders. also
centers the diagram in the available space at the same time */
function scaleSolution(solution, width, height, padding) {
    var circles = [], setids = [];
    for (var setid in solution) {
        // eslint-disable-next-line
        if (solution.hasOwnProperty(setid)) {
            setids.push(setid);
            circles.push(solution[setid]);
        }
    }
    width -= 2 * padding;
    height -= 2 * padding;
    var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
    if (xRange.max == xRange.min || yRange.max == yRange.min) {
        console.log('not scaling solution: zero size detected');
        return solution;
    }
    var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), 
    // while we're at it, center the diagram too
    xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
    var scaled = {};
    for (var i = 0; i < circles.length; ++i) {
        var circle = circles[i];
        scaled[setids[i]] = {
            radius: scaling * circle.radius,
            x: padding + xOffset + (circle.x - xRange.min) * scaling,
            y: padding + yOffset + (circle.y - yRange.min) * scaling,
        };
    }
    return scaled;
}
//# sourceMappingURL=layout.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/utils.js







/**
 * \u83B7\u53D6 \u989C\u8272\u6620\u5C04
 * @usage colorMap.get(id) => color
 *
 * @returns Map<string, string>
 */
var getColorMap = (0,esm/* memoize */.HP)((function (colorPalette, data, blendMode, setsField) {
    var colorMap = new Map();
    var colorPaletteLen = colorPalette.length;
    data.forEach(function (d, idx) {
        if (d[setsField].length === 1) {
            colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
        }
        else {
            /** \u4E00\u822C\u90FD\u662F\u53EF\u4EE5\u83B7\u53D6\u5230\u989C\u8272\u7684\uFF0C\u5982\u679C\u4E0D\u6B63\u786E \u5C31\u662F\u8F93\u5165\u4E86\u975E\u6CD5\u6570\u636E */
            var colorArr = d[setsField].map(function (id) { return colorMap.get(id); });
            colorMap.set(d[ID_FIELD], colorArr.slice(1).reduce(function (a, b) { return blend(a, b, blendMode); }, colorArr[0]));
        }
    });
    return colorMap;
}), function () {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
    }
    return JSON.stringify(params);
});
/**
 * \u7ED9\u97E6\u6069\u56FE\u6570\u636E\u8FDB\u884C\u5E03\u5C40
 *
 * @param data
 * @param width
 * @param height
 * @param padding
 * @returns \u97E6\u6069\u56FE\u6570\u636E
 */
function layoutVennData(options, width, height, padding) {
    if (padding === void 0) { padding = 0; }
    var data = options.data, setsField = options.setsField, sizeField = options.sizeField;
    // \u5904\u7406\u7A7A\u6570\u636E\u7684\u60C5\u51B5
    if (data.length === 0) {
        invariant_log(LEVEL.WARN, false, 'warn: %s', '\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A');
        return [];
    }
    var vennData = data.map(function (d) {
        var _a;
        return ((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, d), (_a = { sets: d[setsField] || [], size: d[sizeField] }, _a[PATH_FIELD] = '', _a[ID_FIELD] = '', _a)));
    });
    // 1. \u8FDB\u884C\u6392\u5E8F\uFF0C\u907F\u514D\u56FE\u5F62\u5143\u7D20\u906E\u6321
    vennData.sort(function (a, b) { return a.sets.length - b.sets.length; });
    // todo 2. \u53EF\u4EE5\u5728\u8FD9\u91CC\u5904\u7406\u4E0B\u975E\u6CD5\u6570\u636E\u8F93\u5165\uFF0C\u907F\u514D\u76F4\u63A5 crash
    var solution = venn(vennData);
    var circles = scaleSolution(solution, width, height, padding);
    var textCenters = computeTextCentres(circles, vennData);
    vennData.forEach(function (row) {
        var sets = row.sets;
        var id = sets.join(',');
        row[ID_FIELD] = id;
        // \u4FDD\u7559 vennText \u5E03\u5C40\u65B9\u6CD5
        var setCircles = sets.map(function (set) { return circles[set]; });
        var path = intersectionAreaPath(setCircles);
        if (!/[zZ]$/.test(path)) {
            path += ' Z';
        }
        row[PATH_FIELD] = path;
        var center = textCenters[id] || { x: 0, y: 0 };
        (0,esm/* assign */.f0)(row, center);
    });
    return vennData;
}
/**
 * \u68C0\u67E5\u662F\u5426\u5B58\u5728 \u975E\u6CD5\u5143\u7D20
 * @param legalArr \u5408\u6CD5\u96C6\u5408\uFF1A['A', 'B']
 * @param testArr \u68C0\u67E5\u96C6\u5408\uFF1A['A', 'B', 'C'] or ['A', 'C']\uFF08\u5B58\u5728\u975E\u6CD5 'C'\uFF09
 * @return boolean
 */
function islegalSets(legalArr, testArr) {
    for (var i = 0; i < testArr.length; i++) {
        if (!legalArr.includes(testArr[i])) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/adaptor.js










/** \u56FE\u4F8B\u9ED8\u8BA4\u9884\u7559\u7A7A\u95F4 */
var LEGEND_SPACE = 40;
/**
 * \u83B7\u53D6 color \u6620\u5C04
 */
function colorMap(params, data, colorPalette) {
    var chart = params.chart, options = params.options;
    var blendMode = options.blendMode, setsField = options.setsField;
    var _a = chart.getTheme(), colors10 = _a.colors10, colors20 = _a.colors20;
    var palette = colorPalette;
    if (!(0,esm/* isArray */.kJ)(palette)) {
        palette = data.filter(function (d) { return d[setsField].length === 1; }).length <= 10 ? colors10 : colors20;
    }
    var map = getColorMap(palette, data, blendMode, setsField);
    return function (id) { return map.get(id) || palette[0]; };
}
/**
 * color options \u8F6C\u6362
 */
function transformColor(params, data) {
    var options = params.options;
    var color = options.color;
    if (typeof color !== 'function') {
        var colorPalette = typeof color === 'string' ? [color] : color;
        var map_1 = colorMap(params, data, colorPalette);
        return function (datum) { return map_1(datum[ID_FIELD]); };
    }
    return color;
}
/**
 * \u5904\u7406 padding
 */
function adaptor_padding(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, appendPadding = options.appendPadding, padding = options.padding;
    // \u5904\u7406 legend \u7684\u4F4D\u7F6E. \u9ED8\u8BA4\u9884\u7559 40px, \u4E1A\u52A1\u4E0A\u53EF\u4EE5\u901A\u8FC7 appendPadding \u589E\u52A0
    var tempPadding = normalPadding(appendPadding);
    if (legend !== false) {
        tempPadding = getAdjustAppendPadding(appendPadding, (0,esm/* get */.U2)(legend, 'position'), LEGEND_SPACE);
    }
    chart.appendPadding = resolveAllPadding([tempPadding, padding]);
    return params;
}
/**
 * \u5904\u7406\u975E\u6CD5\u6570\u636E
 * @param params
 */
function data(params) {
    var options = params.options;
    /* \u5982\u9047\u5230 \u4EA4\u96C6 \u4E2D\u5B58\u5728 \u975E\u6CD5\u5143\u7D20 \u7684\u60C5\u51B5\uFF0C\u5C31\u8FC7\u6EE4\u6389
     * \u5982\uFF1A
     * data = [
     *   { sets: ['A'], size: 3 }, // \u96C6\u5408
     *   { sets: ['B'], size: 4 }, // \u96C6\u5408
     *   { sets: ['A', 'B'], size: 2 }, // \u4EA4\u96C6
     *   { sets: ['A', 'B', 'C'], size: 2 }, // \u4EA4\u96C6 (\u5B58\u5728\u975E\u6CD5 C\uFF0C\u8FC7\u6EE4\u8BE5\u6761\u6570\u636E)
     *   ...
     * ]
     */
    var data = options['data'];
    if (!data) {
        invariant_log(LEVEL.WARN, false, 'warn: %s', '\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A');
        data = [];
    }
    // \u5408\u6CD5\u5143\u7D20\u7684\u96C6\u5408\uFF1A['A', 'B']
    var currSets = data.filter(function (datum) { return datum.sets.length === 1; }).map(function (datum) { return datum.sets[0]; });
    // \u8FC7\u6EE4 data
    var filterSets = data.filter(function (datum) {
        var sets = datum.sets;
        // \u5B58\u5728\u975E\u6CD5\u5143\u7D20\uFF0C\u5C31\u8FC7\u6EE4\u8FD9\u6761\u6570\u636E
        return islegalSets(currSets, sets);
    });
    if (!(0,esm/* isEqual */.Xy)(filterSets, data))
        invariant_log(LEVEL.WARN, false, 'warn: %s', '\u4EA4\u96C6\u4E2D\u4E0D\u80FD\u51FA\u73B0\u4E0D\u5B58\u5728\u7684\u96C6\u5408, \u8BF7\u8F93\u5165\u5408\u6CD5\u6570\u636E');
    return (0,esm/* deepMix */.b$)({}, params, {
        options: {
            data: filterSets,
        },
    });
}
/**
 * geometry \u5904\u7406
 * @param params
 */
function venn_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
    // \u83B7\u53D6\u5BB9\u5668\u5927\u5C0F
    var _a = normalPadding(chart.appendPadding), t = _a[0], r = _a[1], b = _a[2], l = _a[3];
    // \u5904\u7406 legend \u7684\u4F4D\u7F6E. \u9ED8\u8BA4\u9884\u7559 40px, \u4E1A\u52A1\u4E0A\u53EF\u4EE5\u901A\u8FC7 appendPadding \u589E\u52A0
    var customInfo = { offsetX: l, offsetY: t };
    // coordinateBBox + appendPadding = viewBBox, \u4E0D\u9700\u8981\u518D\u8BA1\u7B97 appendPadding \u90E8\u5206\uFF0C\u56E0\u6B64\u76F4\u63A5\u4F7F\u7528 viewBBox
    var _b = chart.viewBBox, width = _b.width, height = _b.height;
    // \u5904\u7406padding\u8F93\u5165\u4E0D\u5408\u7406\u7684\u60C5\u51B5\uFF0C w \u548C h \u4E0D\u80FD\u4E3A\u8D1F\u6570
    var vennData = layoutVennData(options, Math.max(width - (r + l), 0), Math.max(height - (t + b), 0), 0);
    chart.data(vennData);
    var ext = schema_schema(deepAssign({}, params, {
        options: {
            xField: 'x',
            yField: 'y',
            sizeField: sizeField,
            seriesField: ID_FIELD,
            rawFields: [setsField, sizeField],
            schema: {
                shape: 'venn',
                style: pointStyle,
            },
        },
    })).ext;
    var geometry = ext.geometry;
    geometry.customInfo(customInfo);
    var colorOptions = transformColor(params, vennData);
    // \u97E6\u6069\u56FE\u8BD5\u70B9, color \u901A\u9053\u53EA\u80FD\u6620\u5C04\u4E00\u4E2A\u5B57\u6BB5. \u901A\u8FC7\u5916\u90E8\u67E5\u627E\u83B7\u53D6 datum
    if (typeof colorOptions === 'function') {
        geometry.color(ID_FIELD, function (id) {
            var datum = vennData.find(function (d) { return d[ID_FIELD] === id; });
            var defaultColor = colorMap(params, vennData)(id);
            return colorOptions(datum, defaultColor);
        });
    }
    return params;
}
/**
 * \u5904\u7406 label
 * @param params
 */
function venn_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label;
    // \u83B7\u53D6\u5BB9\u5668\u5927\u5C0F
    var _a = normalPadding(chart.appendPadding), t = _a[0], l = _a[3];
    // \u4F20\u5165 label \u5E03\u5C40\u51FD\u6570\u6240\u9700\u7684 \u81EA\u5B9A\u4E49\u53C2\u6570
    var customLabelInfo = { offsetX: l, offsetY: t };
    var geometry = findGeometry(chart, 'schema');
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: ['id'],
            callback: callback,
            cfg: (0,esm/* deepMix */.b$)({}, transformLabel(cfg), {
                // \u4F7F\u7528 G2 \u7684 \u81EA\u5B9A\u4E49label \u4FEE\u6539\u4F4D\u7F6E
                type: 'venn',
                customLabelInfo: customLabelInfo,
            }),
        });
    }
    return params;
}
/**
 * legend \u914D\u7F6E
 * @param params
 */
function venn_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, sizeField = options.sizeField;
    chart.legend(ID_FIELD, legend);
    // \u5F3A\u5236\u4E0D\u5F00\u542F \u8FDE\u7EED\u56FE\u4F8B
    chart.legend(sizeField, false);
    return params;
}
/**
 * \u9ED8\u8BA4\u5173\u95ED\u5750\u6807\u8F74
 * @param params
 */
function venn_adaptor_axis(params) {
    var chart = params.chart;
    chart.axis(false);
    return params;
}
/**
 * \u97E6\u6069\u56FE interaction \u4EA4\u4E92\u9002\u914D\u5668
 */
function vennInteraction(params) {
    var options = params.options, chart = params.chart;
    var interactions = options.interactions;
    if (interactions) {
        var MAP_1 = {
            'legend-active': 'venn-legend-active',
            'legend-highlight': 'venn-legend-highlight',
        };
        common_interaction(deepAssign({}, params, {
            options: {
                interactions: interactions.map(function (i) { return ((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, i), { type: MAP_1[i.type] || i.type })); }),
            },
        }));
    }
    chart.removeInteraction('legend-active');
    chart.removeInteraction('legend-highlight');
    return params;
}
/**
 * \u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function venn_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    return flow(adaptor_padding, common_theme, data, venn_adaptor_geometry, venn_adaptor_label, common_scale({}), venn_adaptor_legend, venn_adaptor_axis, common_tooltip, vennInteraction, animation
    // ... \u5176\u4ED6\u7684 adaptor flow
    )(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/venn/index.js




/**
 * \u8FD9\u4E2A\u662F\u4E00\u4E2A\u56FE\u8868\u5F00\u53D1\u7684 \u6A21\u677F\u4EE3\u7801\uFF01
 */
var Venn = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Venn, _super);
    function Venn() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'venn';
        return _this;
    }
    Venn.getDefaultOptions = function () {
        return venn_constant_DEFAULT_OPTIONS;
    };
    /**
     * \u83B7\u53D6 \u97E6\u6069\u56FE \u9ED8\u8BA4\u914D\u7F6E
     */
    Venn.prototype.getDefaultOptions = function () {
        return Venn.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6\u9002\u914D\u5668
     */
    Venn.prototype.getSchemaAdaptor = function () {
        return venn_adaptor_adaptor;
    };
    /**
     * \u8986\u5199\u7236\u7C7B\u7684\u65B9\u6CD5
     */
    Venn.prototype.triggerResize = function () {
        if (!this.chart.destroyed) {
            // \u9996\u5148\u81EA\u9002\u5E94\u5BB9\u5668\u7684\u5BBD\u9AD8
            this.chart.forceFit(); // g2 \u5185\u90E8\u6267\u884C changeSize\uFF0CchangeSize \u4E2D\u6267\u884C render(true)
            this.chart.clear();
            this.execAdaptor(); // \u6838\u5FC3\uFF1A\u5BBD\u9AD8\u66F4\u65B0\u4E4B\u540E\u8BA1\u7B97\u5E03\u5C40
            // \u6E32\u67D3
            this.chart.render(true);
        }
    };
    return Venn;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/violin/constant.js


var violin_constant_X_FIELD = 'x';
var VIOLIN_Y_FIELD = 'violinY';
var VIOLIN_SIZE_FIELD = 'violinSize';
var MIN_MAX_FIELD = 'minMax';
var QUANTILE_FIELD = 'quantile';
var MEDIAN_FIELD = 'median';
var VIOLIN_VIEW_ID = 'violin_view';
var MIN_MAX_VIEW_ID = 'min_max_view';
var QUANTILE_VIEW_ID = 'quantile_view';
var MEDIAN_VIEW_ID = 'median_view';
var violin_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    // \u591A view \u7EC4\u6210\uFF0C\u4E00\u5B9A\u8981\u8BBE\u7F6E view padding \u540C\u6B65
    syncViewPadding: true,
    // \u9ED8\u8BA4\u6838\u51FD\u6570
    kde: {
        type: 'triangular',
        sampleSize: 32,
        width: 3,
    },
    // \u9ED8\u8BA4\u5C0F\u63D0\u7434\u8F6E\u5ED3\u6837\u5F0F
    violinStyle: {
        lineWidth: 1,
        fillOpacity: 0.3,
        strokeOpacity: 0.75,
    },
    // \u5750\u6807\u8F74
    xAxis: {
        grid: {
            line: null,
        },
        tickLine: {
            alignTick: false,
        },
    },
    yAxis: {
        grid: {
            line: {
                style: {
                    lineWidth: 0.5,
                    lineDash: [4, 4],
                },
            },
        },
    },
    // \u56FE\u4F8B
    legend: {
        position: 'top-left',
    },
    // Tooltip
    tooltip: {
        showMarkers: false,
    },
    // \u9ED8\u8BA4\u533A\u57DF\u4EA4\u4E92
    // interactions: [{ type: 'active-region' }],
});
//# sourceMappingURL=constant.js.map
// EXTERNAL MODULE: ./node_modules/pdfast/src/index.js
var src = __webpack_require__(53843);
var src_default = /*#__PURE__*/__webpack_require__.n(src);
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/transform/quantile.js
// from https://github.com/simple-statistics
/**
 * This is the internal implementation of quantiles: when you know
 * that the order is sorted, you don't need to re-sort it, and the computations
 * are faster.
 *
 * @param {Array<number>} x sample of one or more data points
 * @param {number} p desired quantile: a number between 0 to 1, inclusive
 * @returns {number} quantile value
 * @throws {Error} if p ix outside of the range from 0 to 1
 * @throws {Error} if x is empty
 * @example
 * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9
 */
function quantile_quantileSorted(x, p) {
    var idx = x.length * p;
    if (x.length === 0) {
        throw new Error('quantile requires at least one data point.');
    }
    else if (p < 0 || p > 1) {
        throw new Error('quantiles must be between 0 and 1');
    }
    else if (p === 1) {
        // If p is 1, directly return the last element
        return x[x.length - 1];
    }
    else if (p === 0) {
        // If p is 0, directly return the first element
        return x[0];
    }
    else if (idx % 1 !== 0) {
        // If p is not integer, return the next element in array
        return x[Math.ceil(idx) - 1];
    }
    else if (x.length % 2 === 0) {
        // If the list has even-length, we'll take the average of this number
        // and the next value, if there is one
        return (x[idx - 1] + x[idx]) / 2;
    }
    else {
        // Finally, in the simple case of an integer value
        // with an odd-length list, return the x value at the index.
        return x[idx];
    }
}
/**
 * \u4EA4\u6362\u6570\u7EC4\u4F4D\u7F6E
 * @param arr T[]
 * @param i number
 * @param j number
 */
function quantile_swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
/**
 * Rearrange items in \`arr\` so that all items in \`[left, k]\` range are the smallest.
 * The \`k\`-th element will have the \`(k - left + 1)\`-th smallest value in \`[left, right]\`.
 *
 * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm
 *
 * @param {Array<number>} arr input array
 * @param {number} k pivot index
 * @param {number} [left] left index
 * @param {number} [right] right index
 * @returns {void} mutates input array
 * @example
 * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];
 * quickselect(arr, 8);
 * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]
 */
function quickselect(arr, k, left, right) {
    left = left || 0;
    right = right || arr.length - 1;
    while (right > left) {
        // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp((2 * z) / 3);
            var sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);
            if (m - n / 2 < 0)
                sd *= -1;
            var newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));
            var newRight = Math.min(right, Math.floor(k + ((n - m) * s) / n + sd));
            quickselect(arr, k, newLeft, newRight);
        }
        var t = arr[k];
        var i = left;
        var j = right;
        quantile_swap(arr, left, k);
        if (arr[right] > t)
            quantile_swap(arr, left, right);
        while (i < j) {
            quantile_swap(arr, i, j);
            i++;
            j--;
            while (arr[i] < t)
                i++;
            while (arr[j] > t)
                j--;
        }
        if (arr[left] === t)
            quantile_swap(arr, left, j);
        else {
            j++;
            quantile_swap(arr, j, right);
        }
        if (j <= k)
            left = j + 1;
        if (k <= j)
            right = j - 1;
    }
}
function quantile_quantile(x, p) {
    var copy = x.slice();
    if (Array.isArray(p)) {
        // rearrange elements so that each element corresponding to a requested
        // quantile is on a place it would be if the array was fully sorted
        multiQuantileSelect(copy, p);
        // Initialize the result array
        var results = [];
        // For each requested quantile
        for (var i = 0; i < p.length; i++) {
            results[i] = quantile_quantileSorted(copy, p[i]);
        }
        return results;
    }
    else {
        var idx = quantileIndex(copy.length, p);
        quantileSelect(copy, idx, 0, copy.length - 1);
        return quantile_quantileSorted(copy, p);
    }
}
function quantileSelect(arr, k, left, right) {
    if (k % 1 === 0) {
        quickselect(arr, k, left, right);
    }
    else {
        k = Math.floor(k);
        quickselect(arr, k, left, right);
        quickselect(arr, k + 1, k + 1, right);
    }
}
function multiQuantileSelect(arr, p) {
    var indices = [0];
    for (var i = 0; i < p.length; i++) {
        indices.push(quantileIndex(arr.length, p[i]));
    }
    indices.push(arr.length - 1);
    indices.sort(compare);
    var stack = [0, indices.length - 1];
    while (stack.length) {
        var r = Math.ceil(stack.pop());
        var l = Math.floor(stack.pop());
        if (r - l <= 1)
            continue;
        var m = Math.floor((l + r) / 2);
        quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));
        stack.push(l, m, m, r);
    }
}
function compare(a, b) {
    return a - b;
}
function quantileIndex(len, p) {
    var idx = len * p;
    if (p === 1) {
        // If p is 1, directly return the last index
        return len - 1;
    }
    else if (p === 0) {
        // If p is 0, directly return the first index
        return 0;
    }
    else if (idx % 1 !== 0) {
        // If index is not integer, return the next index in array
        return Math.ceil(idx) - 1;
    }
    else if (len % 2 === 0) {
        // If the list has even-length, we'll return the middle of two indices
        // around quantile to indicate that we need an average value of the two
        return idx - 0.5;
    }
    else {
        // Finally, in the simple case of an integer index
        // with an odd-length list, return the index
        return idx;
    }
}

//# sourceMappingURL=quantile.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/violin/utils.js




var toBoxValue = function (values) {
    return {
        low: (0,esm/* min */.VV)(values),
        high: (0,esm/* max */.Fp)(values),
        q1: quantile_quantile(values, 0.25),
        q3: quantile_quantile(values, 0.75),
        median: quantile_quantile(values, [0.5]),
        minMax: [(0,esm/* min */.VV)(values), (0,esm/* max */.Fp)(values)],
        quantile: [quantile_quantile(values, 0.25), quantile_quantile(values, 0.75)],
    };
};
var toViolinValue = function (values, pdfOptions) {
    var pdfResults = src_default().create(values, pdfOptions);
    return {
        violinSize: pdfResults.map(function (result) { return result.y; }),
        violinY: pdfResults.map(function (result) { return result.x; }),
    };
};
var transformViolinData = function (options) {
    var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data = options.data, kde = options.kde;
    /** \u751F\u6210\u6982\u7387\u5BC6\u5EA6\u51FD\u6570\u7684\u914D\u7F6E */
    var pdfOptions = {
        min: kde.min,
        max: kde.max,
        size: kde.sampleSize,
        width: kde.width,
    };
    // \u65E0\u62C6\u5206
    if (!seriesField) {
        var group_1 = (0,esm/* groupBy */.vM)(data, xField);
        return Object.keys(group_1).map(function (x) {
            var records = group_1[x];
            var values = records.map(function (record) { return record[yField]; });
            return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ x: x }, toViolinValue(values, pdfOptions)), toBoxValue(values));
        });
    }
    // \u6709\u62C6\u5206
    var resultList = [];
    var seriesGroup = (0,esm/* groupBy */.vM)(data, seriesField);
    Object.keys(seriesGroup).forEach(function (series) {
        var group = (0,esm/* groupBy */.vM)(seriesGroup[series], xField);
        return Object.keys(group).forEach(function (key) {
            var _a;
            var records = group[key];
            var values = records.map(function (record) { return record[yField]; });
            resultList.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((_a = { x: key }, _a[seriesField] = series, _a), toViolinValue(values, pdfOptions)), toBoxValue(values)));
        });
    });
    return resultList;
};
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/violin/adaptor.js









var TOOLTIP_FIELDS = ['low', 'high', 'q1', 'q3', 'median'];
var adjustCfg = [
    {
        type: 'dodge',
        marginRatio: 1 / 32,
    },
];
/** \u5904\u7406\u6570\u636E */
function adaptor_data(params) {
    var chart = params.chart, options = params.options;
    chart.data(transformViolinData(options));
    return params;
}
/** \u5C0F\u63D0\u7434\u8F6E\u5ED3 */
function violinView(params) {
    var chart = params.chart, options = params.options;
    var seriesField = options.seriesField, color = options.color, _a = options.shape, shape = _a === void 0 ? 'violin' : _a, violinStyle = options.violinStyle, tooltip = options.tooltip, state = options.state;
    var view = chart.createView({ id: VIOLIN_VIEW_ID });
    violin_violin({
        chart: view,
        options: {
            xField: violin_constant_X_FIELD,
            yField: VIOLIN_Y_FIELD,
            seriesField: seriesField ? seriesField : violin_constant_X_FIELD,
            sizeField: VIOLIN_SIZE_FIELD,
            tooltip: (0,tslib_es6/* __assign */.pi)({ fields: TOOLTIP_FIELDS }, tooltip),
            violin: {
                style: violinStyle,
                color: color,
                shape: shape,
            },
            state: state,
        },
    });
    view.geometries[0].adjust(adjustCfg);
    return params;
}
/** \u7BB1\u7EBF */
function boxView(params) {
    var chart = params.chart, options = params.options;
    var seriesField = options.seriesField, color = options.color, tooltip = options.tooltip, box = options.box;
    // \u5982\u679C\u914D\u7F6E \`box\` \u4E3A false \uFF0C\u4E0D\u6E32\u67D3\u5185\u90E8\u7BB1\u7EBF\u56FE
    if (box === false)
        return params;
    // \u8FB9\u7F18\u7EBF
    var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
    interval_interval({
        chart: minMaxView,
        options: {
            xField: violin_constant_X_FIELD,
            yField: MIN_MAX_FIELD,
            seriesField: seriesField ? seriesField : violin_constant_X_FIELD,
            tooltip: (0,tslib_es6/* __assign */.pi)({ fields: TOOLTIP_FIELDS }, tooltip),
            state: typeof box === 'object' ? box.state : {},
            interval: {
                color: color,
                size: 1,
                style: {
                    lineWidth: 0,
                },
            },
        },
    });
    minMaxView.geometries[0].adjust(adjustCfg);
    // \u56DB\u5206\u70B9\u4F4D
    var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
    interval_interval({
        chart: quantileView,
        options: {
            xField: violin_constant_X_FIELD,
            yField: QUANTILE_FIELD,
            seriesField: seriesField ? seriesField : violin_constant_X_FIELD,
            tooltip: (0,tslib_es6/* __assign */.pi)({ fields: TOOLTIP_FIELDS }, tooltip),
            state: typeof box === 'object' ? box.state : {},
            interval: {
                color: color,
                size: 8,
                style: {
                    fillOpacity: 1,
                },
            },
        },
    });
    quantileView.geometries[0].adjust(adjustCfg);
    // \u4E2D\u4F4D\u503C
    var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
    point_point({
        chart: medianView,
        options: {
            xField: violin_constant_X_FIELD,
            yField: MEDIAN_FIELD,
            seriesField: seriesField ? seriesField : violin_constant_X_FIELD,
            tooltip: (0,tslib_es6/* __assign */.pi)({ fields: TOOLTIP_FIELDS }, tooltip),
            state: typeof box === 'object' ? box.state : {},
            point: {
                color: color,
                size: 1,
                style: {
                    fill: 'white',
                    lineWidth: 0,
                },
            },
        },
    });
    medianView.geometries[0].adjust(adjustCfg);
    // \u5173\u95ED\u8F85\u52A9 view \u7684\u8F74
    quantileView.axis(false);
    minMaxView.axis(false);
    medianView.axis(false);
    // \u5173\u95ED\u8F85\u52A9 view \u7684\u56FE\u4F8B
    medianView.legend(false);
    minMaxView.legend(false);
    quantileView.legend(false);
    return params;
}
/**
 * meta \u914D\u7F6E
 */
function violin_adaptor_meta(params) {
    var _a;
    var chart = params.chart, options = params.options;
    var meta = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
    var baseMeta = {};
    var scales = deepAssign(baseMeta, meta, (_a = {},
        _a[violin_constant_X_FIELD] = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), { 
            // fix:  dodge is not support linear attribute, please use category attribute!
            // \u5F3A\u5236 x \u8F74\u7C7B\u578B\u4E3A\u5206\u7C7B\u7C7B\u578B
            type: 'cat' }),
        _a[VIOLIN_Y_FIELD] = (0,tslib_es6/* __assign */.pi)({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)),
        _a[MIN_MAX_FIELD] = (0,tslib_es6/* __assign */.pi)({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)),
        _a[QUANTILE_FIELD] = (0,tslib_es6/* __assign */.pi)({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)),
        _a[MEDIAN_FIELD] = (0,tslib_es6/* __assign */.pi)({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)),
        _a));
    chart.scale(scales);
    return params;
}
/**
 * axis \u914D\u7F6E
 */
function violin_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis;
    var view = findViewById(chart, VIOLIN_VIEW_ID);
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        view.axis(violin_constant_X_FIELD, false);
    }
    else {
        view.axis(violin_constant_X_FIELD, xAxis);
    }
    if (yAxis === false) {
        view.axis(VIOLIN_Y_FIELD, false);
    }
    else {
        view.axis(VIOLIN_Y_FIELD, yAxis);
    }
    chart.axis(false);
    return params;
}
/**
 *
 * @param params
 * @returns
 */
function violin_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, seriesField = options.seriesField, shape = options.shape;
    if (legend === false) {
        chart.legend(false);
    }
    else {
        var legendField_1 = seriesField ? seriesField : violin_constant_X_FIELD;
        // fixme \u6682\u4E0D\u660E\u4E3A\u5565\u6709\u63CF\u8FB9
        var legendOptions = (0,esm/* omit */.CE)(legend, ['selected']);
        if (!shape || !shape.startsWith('hollow')) {
            if (!(0,esm/* get */.U2)(legendOptions, ['marker', 'style', 'lineWidth'])) {
                (0,esm/* set */.t8)(legendOptions, ['marker', 'style', 'lineWidth'], 0);
            }
        }
        chart.legend(legendField_1, legendOptions);
        // \u7279\u6B8A\u7684\u5904\u7406 fixme G2 \u5C42\u5F97\u89E3\u51B3\u8FD9\u4E2A\u95EE\u9898
        if ((0,esm/* get */.U2)(legend, 'selected')) {
            (0,esm/* each */.S6)(chart.views, function (view) { return view.legend(legendField_1, legend); });
        }
    }
    return params;
}
/**
 * annotation, apply to violin view.
 * @param params
 * @returns
 */
function violin_adaptor_annotation(params) {
    var chart = params.chart;
    var violinView = findViewById(chart, VIOLIN_VIEW_ID);
    common_annotation()((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, params), { chart: violinView }));
    return params;
}
/**
 * \u52A8\u753B
 * @param params
 */
function violin_adaptor_animation(params) {
    var chart = params.chart, options = params.options;
    var animation = options.animation;
    // \u6240\u6709\u7684 Geometry \u90FD\u4F7F\u7528\u540C\u4E00\u52A8\u753B\uFF08\u5404\u4E2A\u56FE\u5F62\u5982\u6709\u533A\u522B\uFF0C\u81EA\u884C\u8986\u76D6\uFF09
    (0,esm/* each */.S6)(chart.views, function (view) {
        addViewAnimation(view, animation);
    });
    return params;
}
/**
 * \u5C0F\u63D0\u7434\u56FE\u9002\u914D\u5668
 * @param params
 */
function violin_adaptor_adaptor(params) {
    return flow(common_theme, adaptor_data, violinView, boxView, violin_adaptor_meta, common_tooltip, violin_adaptor_axis, violin_adaptor_legend, common_interaction, violin_adaptor_annotation, violin_adaptor_animation)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/violin/index.js





var violin_Violin = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Violin, _super);
    function Violin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'violin';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Violin.getDefaultOptions = function () {
        return violin_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     */
    Violin.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        this.chart.changeData(transformViolinData(this.options));
    };
    /**
     * \u83B7\u53D6 \u5C0F\u63D0\u7434\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     */
    Violin.prototype.getDefaultOptions = function () {
        return Violin.getDefaultOptions();
    };
    /**
     * \u83B7\u53D6 \u5C0F\u63D0\u7434\u56FE \u7684\u9002\u914D\u5668
     */
    Violin.prototype.getSchemaAdaptor = function () {
        return violin_adaptor_adaptor;
    };
    return Violin;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/waterfall/constant.js
var waterfall_constant_Y_FIELD = '$$yField$$';
var DIFF_FIELD = '$$diffField$$';
var ABSOLUTE_FIELD = '$$absoluteField$$';
var IS_TOTAL = '$$isTotal$$';
/**
 * \u7011\u5E03\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var waterfall_constant_DEFAULT_OPTIONS = {
    /** default: show label */
    label: {},
    /** default: show leaderLine */
    leaderLine: {
        style: {
            lineWidth: 1,
            stroke: '#8c8c8c',
            lineDash: [4, 2],
        },
    },
    /** default: show total */
    total: {
        style: {
            fill: 'rgba(0, 0, 0, 0.25)',
        },
    },
    interactions: [{ type: 'element-active' }],
    risingFill: '#f4664a',
    fallingFill: '#30bf78',
    waterfallStyle: {
        fill: 'rgba(0, 0, 0, 0.25)',
    },
    yAxis: {
        grid: {
            line: {
                style: {
                    lineDash: [4, 2],
                },
            },
        },
    },
};
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/waterfall/shape.js




/**
 * \u83B7\u53D6\u67F1\u5B50 path
 * @param points
 */
function shape_getRectPath(points) {
    var path = [];
    for (var i = 0; i < points.length; i++) {
        var point = points[i];
        if (point) {
            var action = i === 0 ? 'M' : 'L';
            path.push([action, point.x, point.y]);
        }
    }
    var first = points[0];
    path.push(['L', first.x, first.y]);
    path.push(['z']);
    return path;
}
/**
 * \u83B7\u53D6\u586B\u5145\u5C5E\u6027
 * @param cfg \u56FE\u5F62\u7ED8\u5236\u6570\u636E
 */
function waterfall_shape_getFillAttrs(cfg) {
    return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape('interval', 'waterfall', {
    draw: function (cfg, container) {
        var customInfo = cfg.customInfo, points = cfg.points, nextPoints = cfg.nextPoints;
        var group = container.addGroup();
        // \u2460 \u7ED8\u5236\u67F1\u4F53
        var rectPath = this.parsePath(shape_getRectPath(points));
        var fillAttrs = waterfall_shape_getFillAttrs(cfg);
        group.addShape('path', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, fillAttrs), { path: rectPath }),
        });
        // \u2461 \u7ED8\u5236\u8FDE\u63A5\u7EBF
        var leaderLineCfg = (0,esm/* get */.U2)(customInfo, 'leaderLine');
        if (leaderLineCfg && nextPoints) {
            var linkPath = [
                ['M', points[2].x, points[2].y],
                ['L', nextPoints[0].x, nextPoints[0].y],
            ];
            if (points[2].y === nextPoints[1].y) {
                linkPath[1] = ['L', nextPoints[1].x, nextPoints[1].y];
            }
            linkPath = this.parsePath(linkPath);
            group.addShape('path', {
                attrs: (0,tslib_es6/* __assign */.pi)({ path: linkPath }, (leaderLineCfg.style || {})),
            });
        }
        return group;
    },
});
//# sourceMappingURL=shape.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/waterfall/utils.js




/**
 * @desc \u6570\u636E\u5904\u7406\u51FD\u6570\uFF0C\u7EDF\u4E00\u5C06\u6570\u636E\u5904\u7406\u6210[start, end]
 * @param data
 * @param xField
 * @param yField
 * @param totalLabel
 */
function processData(data, xField, yField, newYField, total) {
    var _a;
    var newData = [];
    (0,esm/* reduce */.u4)(data, function (r, d) {
        var _a;
        // \u6821\u9A8C\u6570\u636E\u5408\u6CD5\u6027
        invariant_log(LEVEL.WARN, (0,esm/* isNumber */.hj)(d[yField]), "".concat(d[yField], " is not a valid number"));
        var value = (0,esm/* isUndefined */.o8)(d[yField]) ? null : d[yField];
        newData.push((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, d), (_a = {}, _a[newYField] = [r, r + value], _a)));
        return r + value;
    }, 0);
    // \u5982\u679C\u9700\u8981\u5C55\u793A\u603B\u548C
    if (newData.length && total) {
        var sum = (0,esm/* get */.U2)(newData, [[data.length - 1], newYField, [1]]);
        newData.push((_a = {},
            _a[xField] = total.label,
            _a[yField] = sum,
            _a[newYField] = [0, sum],
            _a));
    }
    return newData;
}
/**
 * \u5904\u7406\u4E3A \u7011\u5E03\u56FE \u6570\u636E
 */
function waterfall_utils_transformData(data, xField, yField, total) {
    var processed = processData(data, xField, yField, waterfall_constant_Y_FIELD, total);
    return processed.map(function (d, dIdx) {
        var _a;
        if (!(0,esm/* isObject */.Kn)(d)) {
            return d;
        }
        return (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, d), (_a = {}, _a[ABSOLUTE_FIELD] = d[waterfall_constant_Y_FIELD][1], _a[DIFF_FIELD] = d[waterfall_constant_Y_FIELD][1] - d[waterfall_constant_Y_FIELD][0], _a[IS_TOTAL] = dIdx === data.length, _a));
    });
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/waterfall/adaptor.js









/**
 *  \u5904\u7406\u9ED8\u8BA4\u914D\u7F6E\u9879
 * @param params
 * @returns
 */
function waterfall_adaptor_defaultOptions(params) {
    var _a = params.options, locale = _a.locale, total = _a.total;
    var localeTotalLabel = getLocale(locale).get(['waterfall', 'total']);
    if (total && typeof total.label !== 'string' && localeTotalLabel) {
        // @ts-ignore
        params.options.total.label = localeTotalLabel;
    }
    return params;
}
/**
 * \u5B57\u6BB5
 * @param params
 */
function waterfall_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var data = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color = options.color, shape = options.shape, customInfo = options.customInfo;
    // \u6570\u636E\u5904\u7406
    chart.data(waterfall_utils_transformData(data, xField, yField, total));
    // \u7011\u5E03\u56FE\u81EA\u5E26\u7684 colorMapping
    var colorMapping = color ||
        function (datum) {
            if ((0,esm/* get */.U2)(datum, [IS_TOTAL])) {
                return (0,esm/* get */.U2)(total, ['style', 'fill'], '');
            }
            return (0,esm/* get */.U2)(datum, [waterfall_constant_Y_FIELD, 1]) - (0,esm/* get */.U2)(datum, [waterfall_constant_Y_FIELD, 0]) > 0 ? risingFill : fallingFill;
        };
    var p = deepAssign({}, params, {
        options: {
            xField: xField,
            yField: waterfall_constant_Y_FIELD,
            seriesField: xField,
            rawFields: [yField, DIFF_FIELD, IS_TOTAL, waterfall_constant_Y_FIELD],
            widthRatio: columnWidthRatio,
            interval: {
                style: waterfallStyle,
                // \u652F\u6301\u5916\u90E8\u81EA\u5B9A\u4E49\u5F62\u72B6
                shape: shape || 'waterfall',
                color: colorMapping,
            },
        },
    });
    var ext = interval_interval(p).ext;
    var geometry = ext.geometry;
    // \u5C06 waterfall leaderLineCfg \u4F20\u5165\u5230\u81EA\u5B9A\u4E49 shape \u4E2D
    geometry.customInfo((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, customInfo), { leaderLine: leaderLine }));
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function waterfall_adaptor_meta(params) {
    var _a, _b;
    var options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta = options.meta;
    var Y_FIELD_META = deepAssign({}, { alias: yField }, (0,esm/* get */.U2)(meta, yField));
    return flow(common_scale((_a = {},
        _a[xField] = xAxis,
        _a[yField] = yAxis,
        _a[waterfall_constant_Y_FIELD] = yAxis,
        _a), deepAssign({}, meta, (_b = {}, _b[waterfall_constant_Y_FIELD] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
/**
 * axis \u914D\u7F6E
 * @param params
 */
function waterfall_adaptor_axis(params) {
    var chart = params.chart, options = params.options;
    var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
    // \u4E3A false \u5219\u662F\u4E0D\u663E\u793A\u8F74
    if (xAxis === false) {
        chart.axis(xField, false);
    }
    else {
        chart.axis(xField, xAxis);
    }
    if (yAxis === false) {
        chart.axis(yField, false);
        chart.axis(waterfall_constant_Y_FIELD, false);
    }
    else {
        chart.axis(yField, yAxis);
        chart.axis(waterfall_constant_Y_FIELD, yAxis);
    }
    return params;
}
/**
 * legend \u914D\u7F6E todo \u6DFB\u52A0 hover \u4EA4\u4E92
 * @param params
 */
function waterfall_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale = options.locale;
    var i18n = getLocale(locale);
    if (legend === false) {
        chart.legend(false);
    }
    else {
        var items = [
            {
                name: i18n.get(['general', 'increase']),
                value: 'increase',
                marker: { symbol: 'square', style: { r: 5, fill: risingFill } },
            },
            {
                name: i18n.get(['general', 'decrease']),
                value: 'decrease',
                marker: { symbol: 'square', style: { r: 5, fill: fallingFill } },
            },
        ];
        if (total) {
            items.push({
                name: total.label || '',
                value: 'total',
                marker: {
                    symbol: 'square',
                    style: deepAssign({}, { r: 5 }, (0,esm/* get */.U2)(total, 'style')),
                },
            });
        }
        chart.legend(deepAssign({}, {
            custom: true,
            position: 'top',
            items: items,
        }, legend));
        chart.removeInteraction('legend-filter');
    }
    return params;
}
/**
 * \u6570\u636E\u6807\u7B7E
 * @param params
 */
function waterfall_adaptor_label(params) {
    var chart = params.chart, options = params.options;
    var label = options.label, labelMode = options.labelMode, xField = options.xField;
    var geometry = findGeometry(chart, 'interval');
    if (!label) {
        geometry.label(false);
    }
    else {
        var callback = label.callback, cfg = (0,tslib_es6/* __rest */._T)(label, ["callback"]);
        geometry.label({
            fields: labelMode === 'absolute' ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
            callback: callback,
            cfg: transformLabel(cfg),
        });
    }
    return params;
}
/**
 * tooltip \u914D\u7F6E
 * @param params
 */
function waterfall_adaptor_tooltip(params) {
    var chart = params.chart, options = params.options;
    var tooltip = options.tooltip, xField = options.xField, yField = options.yField;
    if (tooltip !== false) {
        chart.tooltip((0,tslib_es6/* __assign */.pi)({ showCrosshairs: false, showMarkers: false, shared: true, 
            // tooltip \u9ED8\u8BA4\u5C55\u793A y \u5B57\u6BB5\u503C
            fields: [yField] }, tooltip));
        // \u7011\u5E03\u56FE\u9ED8\u8BA4\u4EE5 yField \u4F5C\u4E3A tooltip \u5185\u5BB9
        var geometry_1 = chart.geometries[0];
        (tooltip === null || tooltip === void 0 ? void 0 : tooltip.formatter) ? geometry_1.tooltip("".concat(xField, "*").concat(yField), tooltip.formatter) : geometry_1.tooltip(yField);
    }
    else {
        chart.tooltip(false);
    }
    return params;
}
/**
 * \u7011\u5E03\u56FE\u9002\u914D\u5668
 * @param params
 */
function waterfall_adaptor_adaptor(params) {
    return flow(waterfall_adaptor_defaultOptions, common_theme, waterfall_adaptor_geometry, waterfall_adaptor_meta, waterfall_adaptor_axis, waterfall_adaptor_legend, waterfall_adaptor_tooltip, waterfall_adaptor_label, common_state, common_interaction, animation, common_annotation())(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/waterfall/index.js





/**
 * \u7011\u5E03\u56FE
 */
var Waterfall = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Waterfall, _super);
    function Waterfall() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u56FE\u8868\u7C7B\u578B */
        _this.type = 'waterfall';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u7011\u5E03\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    Waterfall.getDefaultOptions = function () {
        return waterfall_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    Waterfall.prototype.changeData = function (data) {
        var _a = this.options, xField = _a.xField, yField = _a.yField, total = _a.total;
        this.updateOption({ data: data });
        this.chart.changeData(waterfall_utils_transformData(data, xField, yField, total));
    };
    /**
     * \u83B7\u53D6 \u7011\u5E03\u56FE \u7684\u9002\u914D\u5668
     */
    Waterfall.prototype.getSchemaAdaptor = function () {
        return waterfall_adaptor_adaptor;
    };
    /**
     * \u83B7\u53D6 \u7011\u5E03\u56FE \u7684\u9ED8\u8BA4\u914D\u7F6E
     */
    Waterfall.prototype.getDefaultOptions = function () {
        return Waterfall.getDefaultOptions();
    };
    return Waterfall;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/word-cloud/constant.js


/** \u8BCD\u4E91\u56FE color \u901A\u9053\u6620\u5C04\u5B57\u6BB5 */
var WORD_CLOUD_COLOR_FIELD = 'color';
/**
 * \u8BCD\u4E91\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
 */
var word_cloud_constant_DEFAULT_OPTIONS = deepAssign({}, Plot.getDefaultOptions(), {
    timeInterval: 2000,
    legend: false,
    tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: false,
        fields: ['text', 'value', WORD_CLOUD_COLOR_FIELD],
        formatter: function (datum) {
            return { name: datum.text, value: datum.value };
        },
    },
    wordStyle: {
        fontFamily: 'Verdana',
        fontWeight: 'normal',
        padding: 1,
        fontSize: [12, 60],
        rotation: [0, 90],
        rotationSteps: 2,
        rotateRatio: 0.5,
    },
});
//# sourceMappingURL=constant.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/utils/transform/word-cloud.js

var word_cloud_DEFAULT_OPTIONS = {
    font: function () { return 'serif'; },
    padding: 1,
    size: [500, 500],
    spiral: 'archimedean',
    // timeInterval: Infinity // max execute time
    timeInterval: 3000, // max execute time
    // imageMask: '', // instance of Image, must be loaded
};
/**
 * \u6839\u636E\u5BF9\u5E94\u7684\u6570\u636E\u5BF9\u8C61\uFF0C\u8BA1\u7B97\u6BCF\u4E2A
 * \u8BCD\u8BED\u5728\u753B\u5E03\u4E2D\u7684\u6E32\u67D3\u4F4D\u7F6E\uFF0C\u5E76\u8FD4\u56DE
 * \u8BA1\u7B97\u540E\u7684\u6570\u636E\u5BF9\u8C61
 * @param words
 * @param options
 */
function wordCloud(words, options) {
    // \u6DF7\u5165\u9ED8\u8BA4\u914D\u7F6E
    options = (0,esm/* assign */.f0)({}, word_cloud_DEFAULT_OPTIONS, options);
    return word_cloud_transform(words, options);
}
/**
 * \u629B\u51FA\u6CA1\u6709\u6DF7\u5165\u9ED8\u8BA4\u914D\u7F6E\u7684\u65B9\u6CD5\uFF0C\u7528\u4E8E\u6D4B\u8BD5\u3002
 * @param words
 * @param options
 */
function word_cloud_transform(words, options) {
    // \u5E03\u5C40\u5BF9\u8C61
    var layout = tagCloud();
    ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {
        if (!(0,esm/* isNil */.UM)(options[key])) {
            layout[key](options[key]);
        }
    });
    layout.words(words);
    if (options.imageMask) {
        layout.createMask(options.imageMask);
    }
    var result = layout.start();
    var tags = result._tags;
    tags.forEach(function (tag) {
        tag.x += options.size[0] / 2;
        tag.y += options.size[1] / 2;
    });
    var _a = options.size, w = _a[0], h = _a[1];
    // \u6DFB\u52A0\u4E24\u4E2A\u53C2\u7167\u6570\u636E\uFF0C\u5206\u522B\u8868\u793A\u5DE6\u4E0A\u89D2\u548C\u53F3\u4E0B\u89D2\u3002
    // \u4E0D\u6DFB\u52A0\u7684\u8BDD\u4E0D\u4F1A\u6309\u7167\u771F\u5B9E\u7684\u5750\u6807\u6E32\u67D3\uFF0C\u800C\u662F\u4EE5
    // \u6570\u636E\u4E2D\u7684\u8FB9\u754C\u5750\u6807\u4E3A\u8FB9\u754C\u8FDB\u884C\u62C9\u4F38\uFF0C\u4EE5\u94FA\u6EE1\u753B\u5E03\u3002
    // \u8FD9\u6837\u7684\u540E\u679C\u4F1A\u5BFC\u81F4\u8BCD\u8BED\u4E4B\u95F4\u7684\u91CD\u53E0\u3002
    tags.push({
        text: '',
        value: 0,
        x: 0,
        y: 0,
        opacity: 0,
    });
    tags.push({
        text: '',
        value: 0,
        x: w,
        y: h,
        opacity: 0,
    });
    return tags;
}
var cloudRadians = Math.PI / 180, cw = (1 << 11) >> 5, ch = 1 << 11;
function cloudText(d) {
    return d.text;
}
function cloudFont() {
    return 'serif';
}
function cloudFontNormal() {
    return 'normal';
}
function cloudFontSize(d) {
    return d.value;
}
function cloudRotate() {
    return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
    return 1;
}
// Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.
function cloudSprite(contextAndRatio, d, data, di) {
    if (d.sprite)
        return;
    var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    var x = 0, y = 0, maxh = 0;
    var n = data.length;
    --di;
    while (++di < n) {
        d = data[di];
        c.save();
        c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
        var w = c.measureText(d.text + 'm').width * ratio, h = d.size << 1;
        if (d.rotate) {
            var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
            w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;
            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
        }
        else {
            w = ((w + 0x1f) >> 5) << 5;
        }
        if (h > maxh)
            maxh = h;
        if (x + w >= cw << 5) {
            x = 0;
            y += maxh;
            maxh = 0;
        }
        if (y + h >= ch)
            break;
        c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
        if (d.rotate)
            c.rotate(d.rotate * cloudRadians);
        c.fillText(d.text, 0, 0);
        if (d.padding) {
            c.lineWidth = 2 * d.padding;
            c.strokeText(d.text, 0, 0);
        }
        c.restore();
        d.width = w;
        d.height = h;
        d.xoff = x;
        d.yoff = y;
        d.x1 = w >> 1;
        d.y1 = h >> 1;
        d.x0 = -d.x1;
        d.y0 = -d.y1;
        d.hasText = true;
        x += w;
    }
    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
    while (--di >= 0) {
        d = data[di];
        if (!d.hasText)
            continue;
        var w = d.width, w32 = w >> 5;
        var h = d.y1 - d.y0;
        // Zero the buffer
        for (var i = 0; i < h * w32; i++)
            sprite[i] = 0;
        x = d.xoff;
        if (x == null)
            return;
        y = d.yoff;
        var seen = 0, seenRow = -1;
        for (var j = 0; j < h; j++) {
            for (var i = 0; i < w; i++) {
                var k = w32 * j + (i >> 5), m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
                sprite[k] |= m;
                seen |= m;
            }
            if (seen)
                seenRow = j;
            else {
                d.y0++;
                h--;
                j--;
                y++;
            }
        }
        d.y1 = d.y0 + seenRow;
        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
    }
}
// Use mask-based collision detection.
function cloudCollide(tag, board, sw) {
    sw >>= 5;
    var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;
    var x = (tag.y + tag.y0) * sw + (lx >> 5), last;
    for (var j = 0; j < h; j++) {
        last = 0;
        for (var i = 0; i <= w; i++) {
            if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
                return true;
        }
        x += sw;
    }
    return false;
}
function cloudBounds(bounds, d) {
    var b0 = bounds[0], b1 = bounds[1];
    if (d.x + d.x0 < b0.x)
        b0.x = d.x + d.x0;
    if (d.y + d.y0 < b0.y)
        b0.y = d.y + d.y0;
    if (d.x + d.x1 > b1.x)
        b1.x = d.x + d.x1;
    if (d.y + d.y1 > b1.y)
        b1.y = d.y + d.y1;
}
function collideRects(a, b) {
    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size) {
    var e = size[0] / size[1];
    return function (t) {
        return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
    };
}
function rectangularSpiral(size) {
    var dy = 4, dx = (dy * size[0]) / size[1];
    var x = 0, y = 0;
    return function (t) {
        var sign = t < 0 ? -1 : 1;
        // See triangular numbers: T_n = n * (n + 1) / 2.
        switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
            case 0:
                x += dx;
                break;
            case 1:
                y += dy;
                break;
            case 2:
                x -= dx;
                break;
            default:
                y -= dy;
                break;
        }
        return [x, y];
    };
}
// TODO reuse arrays?
function zeroArray(n) {
    var a = [];
    var i = -1;
    while (++i < n)
        a[i] = 0;
    return a;
}
function cloudCanvas() {
    return document.createElement('canvas');
}
function functor(d) {
    return (0,esm/* isFunction */.mf)(d)
        ? d
        : function () {
            return d;
        };
}
var spirals = {
    archimedean: archimedeanSpiral,
    rectangular: rectangularSpiral,
};
function tagCloud() {
    var size = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random = Math.random, words = [], timeInterval = Infinity;
    var text = cloudText;
    var fontStyle = cloudFontNormal;
    var canvas = cloudCanvas;
    var cloud = {};
    cloud.start = function () {
        var width = size[0], height = size[1];
        var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n = words.length, tags = [], data = words
            .map(function (d, i, data) {
            d.text = text.call(this, d, i, data);
            d.font = font.call(this, d, i, data);
            d.style = fontStyle.call(this, d, i, data);
            d.weight = fontWeight.call(this, d, i, data);
            d.rotate = rotate.call(this, d, i, data);
            d.size = ~~fontSize.call(this, d, i, data);
            d.padding = padding.call(this, d, i, data);
            return d;
        })
            .sort(function (a, b) {
            return b.size - a.size;
        });
        var i = -1, bounds = !cloud.board
            ? null
            : [
                {
                    x: 0,
                    y: 0,
                },
                {
                    x: width,
                    y: height,
                },
            ];
        step();
        function step() {
            var start = Date.now();
            while (Date.now() - start < timeInterval && ++i < n) {
                var d = data[i];
                d.x = (width * (random() + 0.5)) >> 1;
                d.y = (height * (random() + 0.5)) >> 1;
                cloudSprite(contextAndRatio, d, data, i);
                if (d.hasText && place(board, d, bounds)) {
                    tags.push(d);
                    if (bounds) {
                        if (!cloud.hasImage) {
                            // update bounds if image mask not set
                            cloudBounds(bounds, d);
                        }
                    }
                    else {
                        bounds = [
                            { x: d.x + d.x0, y: d.y + d.y0 },
                            { x: d.x + d.x1, y: d.y + d.y1 },
                        ];
                    }
                    // Temporary hack
                    d.x -= size[0] >> 1;
                    d.y -= size[1] >> 1;
                }
            }
            cloud._tags = tags;
            cloud._bounds = bounds;
        }
        return cloud;
    };
    function getContext(canvas) {
        canvas.width = canvas.height = 1;
        var ratio = Math.sqrt(canvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, 1, 1).data
            .length >> 2);
        canvas.width = (cw << 5) / ratio;
        canvas.height = ch / ratio;
        var context = canvas.getContext('2d', { willReadFrequently: true });
        context.fillStyle = context.strokeStyle = 'red';
        context.textAlign = 'center';
        return { context: context, ratio: ratio };
    }
    function place(board, tag, bounds) {
        // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],
        var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1;
        var dxdy, t = -dt, dx, dy;
        while ((dxdy = s((t += dt)))) {
            dx = ~~dxdy[0];
            dy = ~~dxdy[1];
            if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
                break;
            tag.x = startX + dx;
            tag.y = startY + dy;
            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
                continue;
            // TODO only check for collisions within current bounds.
            if (!bounds || !cloudCollide(tag, board, size[0])) {
                if (!bounds || collideRects(tag, bounds)) {
                    var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;
                    var last = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
                    for (var j = 0; j < h; j++) {
                        last = 0;
                        for (var i = 0; i <= w; i++) {
                            board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                        }
                        x += sw;
                    }
                    delete tag.sprite;
                    return true;
                }
            }
        }
        return false;
    }
    cloud.createMask = function (img) {
        var can = document.createElement('canvas');
        var width = size[0], height = size[1];
        // \u5F53 width \u6216 height \u4E3A 0 \u65F6\uFF0C\u8C03\u7528 cxt.getImageData \u4F1A\u62A5\u9519
        if (!width || !height) {
            return;
        }
        var w32 = width >> 5;
        var board = zeroArray((width >> 5) * height);
        can.width = width;
        can.height = height;
        var cxt = can.getContext('2d');
        cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
        var imageData = cxt.getImageData(0, 0, width, height).data;
        for (var j = 0; j < height; j++) {
            for (var i = 0; i < width; i++) {
                var k = w32 * j + (i >> 5);
                var tmp = (j * width + i) << 2;
                var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
                var m = flag ? 1 << (31 - (i % 32)) : 0;
                board[k] |= m;
            }
        }
        cloud.board = board;
        cloud.hasImage = true;
    };
    cloud.timeInterval = function (_) {
        timeInterval = _ == null ? Infinity : _;
    };
    cloud.words = function (_) {
        words = _;
    };
    cloud.size = function (_) {
        size = [+_[0], +_[1]];
    };
    cloud.font = function (_) {
        font = functor(_);
    };
    cloud.fontWeight = function (_) {
        fontWeight = functor(_);
    };
    cloud.rotate = function (_) {
        rotate = functor(_);
    };
    cloud.spiral = function (_) {
        spiral = spirals[_] || _;
    };
    cloud.fontSize = function (_) {
        fontSize = functor(_);
    };
    cloud.padding = function (_) {
        padding = functor(_);
    };
    cloud.random = function (_) {
        random = functor(_);
    };
    return cloud;
}
//# sourceMappingURL=word-cloud.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/word-cloud/utils.js





/**
 * \u7528 DataSet \u8F6C\u6362\u8BCD\u4E91\u56FE\u6570\u636E
 * @param params
 */
function utils_transform(params) {
    var rawOptions = params.options, chart = params.chart;
    var _a = chart, width = _a.width, height = _a.height, chartPadding = _a.padding, appendPadding = _a.appendPadding, ele = _a.ele;
    var data = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
    if (!data || !data.length) {
        return [];
    }
    var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding = wordStyle.padding, fontSize = wordStyle.fontSize;
    var arr = getSingleKeyValues(data, weightField);
    var range = [utils_min(arr), utils_max(arr)];
    // \u53D8\u6362\u51FA text \u548C value \u5B57\u6BB5
    var words = data.map(function (datum) { return ({
        text: datum[wordField],
        value: datum[weightField],
        color: datum[colorField],
        datum: datum,
    }); });
    var options = {
        imageMask: imageMask,
        font: fontFamily,
        fontSize: getFontSizeMapping(fontSize, range),
        fontWeight: fontWeight,
        // \u56FE\u8868\u5BBD\u9AD8\u51CF\u53BB padding \u4E4B\u540E\u7684\u5BBD\u9AD8
        size: getSize({
            width: width,
            height: height,
            padding: chartPadding,
            appendPadding: appendPadding,
            autoFit: autoFit,
            container: ele,
        }),
        padding: padding,
        timeInterval: timeInterval,
        random: random,
        spiral: spiral,
        rotate: getRotate(rawOptions),
    };
    // \u81EA\u5B9A\u4E49\u5E03\u5C40\u51FD\u6570
    if ((0,esm/* isFunction */.mf)(placementStrategy)) {
        var result = words.map(function (word, index, words) { return ((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, word), { hasText: !!word.text, font: functor(options.font)(word, index, words), weight: functor(options.fontWeight)(word, index, words), rotate: functor(options.rotate)(word, index, words), size: functor(options.fontSize)(word, index, words), style: 'normal' }), placementStrategy.call(chart, word, index, words))); });
        // \u6DFB\u52A0\u4E24\u4E2A\u53C2\u7167\u6570\u636E\uFF0C\u5206\u522B\u8868\u793A\u5DE6\u4E0A\u89D2\u548C\u53F3\u4E0B\u89D2
        result.push({
            text: '',
            value: 0,
            x: 0,
            y: 0,
            opacity: 0,
        });
        result.push({
            text: '',
            value: 0,
            x: options.size[0],
            y: options.size[1],
            opacity: 0,
        });
        return result;
    }
    // \u6570\u636E\u51C6\u5907\u5728\u5916\u90E8\u505A\uFF0CwordCloud \u5355\u7EAF\u5C31\u662F\u505A\u5E03\u5C40
    return wordCloud(words, options);
}
/**
 * \u83B7\u53D6\u6700\u7EC8\u7684\u5B9E\u9645\u7ED8\u56FE\u5C3A\u5BF8\uFF1A[width, height]
 * @param chart
 */
function getSize(options) {
    var width = options.width, height = options.height;
    var container = options.container, autoFit = options.autoFit, padding = options.padding, appendPadding = options.appendPadding;
    // \u7531\u4E8E\u8BCD\u4E91\u56FE\u6BCF\u4E2A\u8BCD\u8BED\u7684\u5750\u6807\u90FD\u662F\u5148\u901A\u8FC7 DataSet \u6839\u636E\u56FE\u8868\u5BBD\u9AD8\u8BA1\u7B97\u51FA\u6765\u7684\uFF0C
    // \u4E5F\u5C31\u662F\u8BF4\uFF0C\u5982\u679C\u4E00\u5F00\u59CB\u63D0\u4F9B\u7ED9 DataSet \u7684\u5BBD\u9AD8\u4FE1\u606F\u548C\u6700\u7EC8\u663E\u793A\u7684\u5BBD\u9AD8\u4E0D\u76F8\u540C\uFF0C
    // \u90A3\u4E48\u5C31\u4F1A\u51FA\u73B0\u5E03\u5C40\u9519\u4E71\u7684\u60C5\u51B5\uFF0C\u6240\u4EE5\u8FD9\u91CC\u5904\u7406\u7684\u76EE\u7684\u5C31\u662F\u8BA9\u4E00\u5F00\u59CB\u63D0\u4F9B\u7ED9 DataSet \u7684
    // \u5BBD\u9AD8\u4FE1\u606F\u4E0E\u6700\u7EC8\u663E\u793A\u7684\u5BBD\u9AD8\u4FE1\u606F\u76F8\u540C\uFF0C\u907F\u514D\u663E\u793A\u9519\u4E71\u3002
    if (autoFit) {
        var containerSize = getContainerSize(container);
        width = containerSize.width;
        height = containerSize.height;
    }
    // \u5BBD\u9AD8\u4E0D\u80FD\u4E3A 0\uFF0C\u5426\u5219\u4F1A\u9020\u6210\u6B7B\u5FAA\u73AF
    width = width || 400;
    height = height || 400;
    var _a = resolvePadding({ padding: padding, appendPadding: appendPadding }), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
    var result = [width - (left + right), height - (top + bottom)];
    return result;
}
/**
 * \u6839\u636E\u56FE\u8868\u7684 padding \u548C appendPadding \u8BA1\u7B97\u51FA\u56FE\u8868\u7684\u6700\u7EC8 padding
 * @param chart
 */
function resolvePadding(options) {
    var padding = normalPadding(options.padding);
    var appendPadding = normalPadding(options.appendPadding);
    var top = padding[0] + appendPadding[0];
    var right = padding[1] + appendPadding[1];
    var bottom = padding[2] + appendPadding[2];
    var left = padding[3] + appendPadding[3];
    return [top, right, bottom, left];
}
/**
 * \u5904\u7406 imageMask \u53EF\u80FD\u4E3A url \u5B57\u7B26\u4E32\u7684\u60C5\u51B5
 * @param  {HTMLImageElement | string} img
 * @return {Promise}
 */
function processImageMask(img) {
    return new Promise(function (res, rej) {
        if (img instanceof HTMLImageElement) {
            res(img);
            return;
        }
        if ((0,esm/* isString */.HD)(img)) {
            var image_1 = new Image();
            image_1.crossOrigin = 'anonymous';
            image_1.src = img;
            image_1.onload = function () {
                res(image_1);
            };
            image_1.onerror = function () {
                invariant_log(LEVEL.ERROR, false, 'image %s load failed !!!', img);
                rej();
            };
            return;
        }
        invariant_log(LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');
        rej();
    });
}
/**
 * \u628A\u7528\u6237\u63D0\u4F9B\u7684 fontSize \u503C\u8F6C\u6362\u6210\u7B26\u5408 DataSet \u8981\u6C42\u7684\u503C
 * @param options
 * @param range
 */
function getFontSizeMapping(fontSize, range) {
    if ((0,esm/* isFunction */.mf)(fontSize)) {
        return fontSize;
    }
    if ((0,esm/* isArray */.kJ)(fontSize)) {
        var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
        if (!range) {
            return function () { return (fMax_1 + fMin_1) / 2; };
        }
        var min_1 = range[0], max_1 = range[1];
        if (max_1 === min_1) {
            return function () { return (fMax_1 + fMin_1) / 2; };
        }
        return function fontSize(_a) {
            var value = _a.value;
            return ((fMax_1 - fMin_1) / (max_1 - min_1)) * (value - min_1) + fMin_1;
        };
    }
    return function () { return fontSize; };
}
function getSingleKeyValues(data, key) {
    return data
        .map(function (v) { return v[key]; })
        .filter(function (v) {
        // \u8FC7\u6EE4\u975E number
        if (typeof v === 'number' && !isNaN(v))
            return true;
        return false;
    });
}
/**
 * \u628A\u7528\u6237\u63D0\u4F9B\u7684\u5173\u4E8E\u65CB\u8F6C\u89D2\u5EA6\u7684\u5B57\u6BB5\u503C\u8F6C\u6362\u6210\u7B26\u5408 DataSet \u8981\u6C42\u7684\u503C
 * @param options
 */
function getRotate(options) {
    var _a = resolveRotate(options), rotation = _a.rotation, rotationSteps = _a.rotationSteps;
    if (!(0,esm/* isArray */.kJ)(rotation))
        return rotation;
    var min = rotation[0];
    var max = rotation[1];
    // \u7B49\u4E8E 1 \u65F6\u4E0D\u65CB\u8F6C\uFF0C\u6240\u4EE5\u628A\u6BCF\u4EFD\u5927\u5C0F\u8BBE\u4E3A 0
    var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
    return function rotate() {
        if (max === min)
            return max;
        return Math.floor(Math.random() * rotationSteps) * perSize;
    };
}
/**
 * \u786E\u4FDD\u503C\u5728\u8981\u6C42\u8303\u56F4\u5185
 * @param options
 */
function resolveRotate(options) {
    var rotationSteps = options.wordStyle.rotationSteps;
    if (rotationSteps < 1) {
        invariant_log(LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');
        rotationSteps = 1;
    }
    return {
        rotation: options.wordStyle.rotation,
        rotationSteps: rotationSteps,
    };
}
/**
 * \u4F20\u5165\u4E00\u4E2A\u5143\u7D20\u4E3A\u6570\u5B57\u7684\u6570\u7EC4\uFF0C
 * \u8FD4\u56DE\u8BE5\u6570\u7EC4\u4E2D\u503C\u6700\u5C0F\u7684\u6570\u5B57\u3002
 * @param numbers
 */
function utils_min(numbers) {
    return Math.min.apply(Math, numbers);
}
/**
 * \u4F20\u5165\u4E00\u4E2A\u5143\u7D20\u4E3A\u6570\u5B57\u7684\u6570\u7EC4\uFF0C
 * \u8FD4\u56DE\u8BE5\u6570\u7EC4\u4E2D\u503C\u6700\u5927\u7684\u6570\u5B57\u3002
 * @param numbers
 */
function utils_max(numbers) {
    return Math.max.apply(Math, numbers);
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/word-cloud/adaptor.js







/**
 * geometry \u914D\u7F6E\u5904\u7406
 * @param params
 */
function word_cloud_adaptor_geometry(params) {
    var chart = params.chart, options = params.options;
    var colorField = options.colorField, color = options.color;
    var data = utils_transform(params);
    chart.data(data);
    var p = deepAssign({}, params, {
        options: {
            xField: 'x',
            yField: 'y',
            seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
            rawFields: (0,esm/* isFunction */.mf)(color) && (0,tslib_es6/* __spreadArray */.ev)((0,tslib_es6/* __spreadArray */.ev)([], (0,esm/* get */.U2)(options, 'rawFields', []), true), ['datum'], false),
            point: {
                color: color,
                shape: 'word-cloud',
            },
        },
    });
    var ext = point_point(p).ext;
    ext.geometry.label(false);
    chart.coordinate().reflect('y');
    chart.axis(false);
    return params;
}
/**
 * meta \u914D\u7F6E
 * @param params
 */
function word_cloud_adaptor_meta(params) {
    return flow(common_scale({
        x: { nice: false },
        y: { nice: false },
    }))(params);
}
/**
 * \u8BCD\u4E91\u56FE legend \u914D\u7F6E
 * @param params
 */
function word_cloud_adaptor_legend(params) {
    var chart = params.chart, options = params.options;
    var legend = options.legend, colorField = options.colorField;
    if (legend === false) {
        chart.legend(false);
    }
    else if (colorField) {
        chart.legend(WORD_CLOUD_COLOR_FIELD, legend);
    }
    return params;
}
/**
 * \u8BCD\u4E91\u56FE\u9002\u914D\u5668
 * @param chart
 * @param options
 */
function word_cloud_adaptor_adaptor(params) {
    // flow \u7684\u65B9\u5F0F\u5904\u7406\u6240\u6709\u7684\u914D\u7F6E\u5230 G2 API
    flow(word_cloud_adaptor_geometry, word_cloud_adaptor_meta, common_tooltip, word_cloud_adaptor_legend, common_interaction, animation, common_theme, common_state)(params);
}
//# sourceMappingURL=adaptor.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/word-cloud/shapes/word-cloud.js


registerShape('point', 'word-cloud', {
    draw: function (cfg, group) {
        var cx = cfg.x;
        var cy = cfg.y;
        var shape = group.addShape('text', {
            attrs: (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, getTextAttrs(cfg)), { x: cx, y: cy }),
        });
        var rotate = cfg.data.rotate;
        if (typeof rotate === 'number') {
            Util.rotate(shape, (rotate * Math.PI) / 180);
        }
        return shape;
    },
});
function getTextAttrs(cfg) {
    return {
        fontSize: cfg.data.size,
        text: cfg.data.text,
        textAlign: 'center',
        fontFamily: cfg.data.font,
        fontWeight: cfg.data.weight,
        fill: cfg.color || cfg.defaultStyle.stroke,
        textBaseline: 'alphabetic',
    };
}
//# sourceMappingURL=word-cloud.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plots/word-cloud/index.js




// \u6CE8\u518C\u7684shape


var WordCloud = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(WordCloud, _super);
    function WordCloud() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** \u8BCD\u4E91\u56FE */
        _this.type = 'word-cloud';
        return _this;
    }
    /**
     * \u83B7\u53D6 \u8BCD\u4E91\u56FE \u9ED8\u8BA4\u914D\u7F6E\u9879
     * \u4F9B\u5916\u90E8\u4F7F\u7528
     */
    WordCloud.getDefaultOptions = function () {
        return word_cloud_constant_DEFAULT_OPTIONS;
    };
    /**
     * @override
     * @param data
     */
    WordCloud.prototype.changeData = function (data) {
        this.updateOption({ data: data });
        if (this.options.imageMask) {
            this.render();
        }
        else {
            this.chart.changeData(utils_transform({ chart: this.chart, options: this.options }));
        }
    };
    /**
     * \u83B7\u53D6\u9ED8\u8BA4\u7684 options \u914D\u7F6E\u9879
     */
    WordCloud.prototype.getDefaultOptions = function () {
        return WordCloud.getDefaultOptions();
    };
    /**
     * \u8986\u5199\u7236\u7C7B\u65B9\u6CD5\uFF0C\u8BCD\u4E91\u56FE\u9700\u8981\u52A0\u8F7D\u56FE\u7247\u8D44\u6E90\uFF0C\u6240\u4EE5\u9700\u8981\u5F02\u6B65\u6E32\u67D3
     */
    WordCloud.prototype.render = function () {
        var _this = this;
        return new Promise(function (res) {
            var imageMask = _this.options.imageMask;
            if (!imageMask) {
                // \u8C03\u7528\u7236\u7C7B\u6E32\u67D3\u51FD\u6570
                _super.prototype.render.call(_this);
                res();
                return;
            }
            var handler = function (img) {
                _this.options = (0,tslib_es6/* __assign */.pi)((0,tslib_es6/* __assign */.pi)({}, _this.options), { imageMask: img || null });
                // \u8C03\u7528\u7236\u7C7B\u6E32\u67D3\u51FD\u6570
                _super.prototype.render.call(_this);
                res();
            };
            processImageMask(imageMask).then(handler).catch(handler);
        });
    };
    /**
     * \u83B7\u53D6 \u8BCD\u4E91\u56FE \u7684\u9002\u914D\u5668
     */
    WordCloud.prototype.getSchemaAdaptor = function () {
        return word_cloud_adaptor_adaptor;
    };
    /**
     * \u8986\u5199\u7236\u7C7B\u7684\u65B9\u6CD5\uFF0C\u56E0\u4E3A\u8BCD\u4E91\u56FE\u4F7F\u7528 \u5355\u72EC\u7684\u51FD\u6570 \u8FDB\u884C\u5E03\u5C40\uFF0C\u539F\u7406\u4E0A\u6709\u4E9B\u4E0D\u4E00\u6837
     */
    WordCloud.prototype.triggerResize = function () {
        var _this = this;
        if (!this.chart.destroyed) {
            // \u5F53\u6574\u4E2A\u8BCD\u4E91\u56FE\u56FE\u8868\u7684\u5BBD\u9AD8\u4FE1\u606F\u53D1\u751F\u53D8\u5316\u65F6\uFF0C\u6BCF\u4E2A\u8BCD\u8BED\u7684\u5750\u6807
            // \u9700\u8981\u91CD\u65B0\u6267\u884C adaptor\uFF0C\u4E0D\u7136\u4F1A\u51FA\u73B0\u5E03\u5C40\u9519\u4E71\uFF0C
            // \u5982\u76F8\u90BB\u8BCD\u8BED\u91CD\u53E0\u7684\u60C5\u51B5\u3002
            this.execAdaptor();
            // \u5EF6\u8FDF\u6267\u884C\uFF0C\u6709\u5229\u4E8E\u52A8\u753B\u66F4\u6D41\u7545
            // TODO: \u5728\u591A\u6B21\u66F4\u6539\u753B\u5E03\u5C3A\u5BF8\u65F6\uFF0C\u52A8\u753B\u4F1A\u8D8A\u6765\u8D8A\u5361\u987F\uFF0C\u539F\u56E0\u672A\u77E5
            window.setTimeout(function () {
                // \u6267\u884C\u7236\u7C7B\u7684\u65B9\u6CD5
                _super.prototype.triggerResize.call(_this);
            });
        }
    };
    return WordCloud;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/plugin/index.js



/**
 * \u7ED9 G2Plot \u63D0\u4F9B\u975E\u5E38\u7B80\u5355\u7684\u5F00\u653E\u5F00\u53D1\u7684\u673A\u5236\u3002\u76EE\u7684\u662F\u80FD\u591F\u8BA9\u793E\u533A\u548C\u4E1A\u52A1\u4E0A\u81EA\u5DF1\u57FA\u4E8E G2Plot \u5F00\u53D1\u81EA\u5DF1\u7684\u5B9A\u5236\u56FE\u8868\u5E93\u3002\u4E3B\u8981\u5206\u6210\u51E0\u7C7B\u56FE\u8868\uFF1A
 * 1. \u9886\u57DF\u4E13\u4E1A\u7684\u56FE\u8868\uFF0C\u5185\u90E8\u540C\u5B66\u56E0\u4E3A\u6CA1\u6709\u573A\u666F\uFF0C\u4E0D\u4E00\u5B9A\u80FD\u505A\u7684\u5B8C\u5584\u3002
 * 2. \u5B9A\u5236\u4E1A\u52A1\u7684\u56FE\u8868\uFF0C\u4E0D\u5177\u5907\u901A\u7528\u6027
 * 3. \u8DA3\u5473\u6027\u7684\u53EF\u89C6\u5316\u7EC4\u4EF6
 * \u7136\u540E\u5B98\u65B9\u53EF\u4EE5\u6839\u636E\u793E\u533A\u7684\u60C5\u51B5\uFF0C\u53EF\u4EE5\u8FDB\u884C\u4E00\u4E9B\u5B98\u65B9\u63A8\u8350\u548C\u91C7\u7EB3\u3002
 *
 * \u5982\u679C\u4F7F\u7528\uFF1F
 *
 * \`\`\`ts
 * import { P } from '@antv/g2plot';
 * import { GeoWorldMap, GeoWorldMapOptions } from 'g2plot-geo-world-map';
 *
 * const plot = new P('container', {
 *   geoJson: '',
 *   longitude: '',
 *   latitude: '',
 * }, GeoWorldMap, defaultOptions);
 *
 * plot.render();
 * \`\`\`
 */
var P = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(P, _super);
    /**
     * \u76F8\u6BD4\u666E\u901A\u56FE\u8868\u589E\u52A0 adaptor \u53C2\u6570\u3002
     * @param container
     * @param options
     * @param adaptor
     * @param defaultOptions
     */
    function P(container, options, adaptor, defaultOptions) {
        var _this = _super.call(this, container, deepAssign({}, defaultOptions, options)) || this;
        /** \u7EDF\u4E00\u4E3A any plot */
        _this.type = 'g2-plot';
        _this.defaultOptions = defaultOptions;
        _this.adaptor = adaptor;
        return _this;
    }
    /**
     * \u5B9E\u73B0\u7236\u7C7B\u65B9\u6CD5\uFF0C\u76F4\u63A5\u4F7F\u7528\u4F20\u5165\u7684
     */
    P.prototype.getDefaultOptions = function () {
        return this.defaultOptions;
    };
    /**
     * \u5B9E\u73B0\u7236\u7C7B\u65B9\u6CD5\uFF0C\u76F4\u63A5\u4F7F\u7528\u4F20\u5165\u7684
     */
    P.prototype.getSchemaAdaptor = function () {
        return this.adaptor;
    };
    return P;
}(Plot));

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g2plot/esm/index.js
var g2plot_esm_version = '2.4.31';
// G2 \u81EA\u5B9A\u4E49\u80FD\u529B\u900F\u51FA

/** \u5F00\u653E\u4E00\u4E9B\u901A\u7528\u7684 adaptor \u901A\u9053\u65B9\u6CD5\uFF0C\u5B9E\u9A8C\u9636\u6BB5\uFF1A\u4E0D\u4FDD\u8BC1\u7A33\u5B9A\u6027 */

// \u56FD\u9645\u5316\u5904\u7406



/** \u5404\u4E2A geometry \u7684 adaptor\uFF0C\u53EF\u4EE5\u8BA9\u5F00\u53D1\u8005\u66F4\u5FEB\u7684\u6784\u9020\u56FE\u5F62 */

/** \u5168\u5C40\u53D8\u91CF */

/** G2Plot \u7684 Plot \u57FA\u7C7B */

/** \u5BF9\u4E8E\u6CA1\u6709\u5F00\u53D1\u5B8C\u6210\u7684\u56FE\u8868\uFF0C\u53EF\u4EE5\u6682\u65F6\u5148\u653E\u5230 Lab \u4E0B\u9762\uFF0C\u5148\u505A\u4F53\u9A8C\uFF0C\u7A33\u5B9A\u540E\u653E\u5230\u6839 export */

// \u9762\u79EF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [hustcc](https://github.com/hustcc)

// \u6761\u5F62\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [BBSQQ](https://github.com/BBSQQ)

// \u5BF9\u79F0\u6761\u5F62\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [arcsin1](https://github.com/arcsin1)

// \u7BB1\u7EBF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [BBSQQ](https://github.com/BBSQQ), [visiky](https://github.com/visiky)

// \u5B50\u5F39\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [arcsin1](https://github.com/arcsin1)

// \u5F26\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [MrSmallLiu](https://github.com/MrSmallLiu), [visiky](https://github.com/visiky)

// circle-packing \u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [visiky](https://github.com/visiky), [Angeli](https://github.com/Angelii)

// \u67F1\u5F62\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [zqlu](https://github.com/zqlu)

// \u6DF7\u5408\u56FE\u5F62 | author by [liuzhenying](https://github.com/liuzhenying)

// \u5206\u9762\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [visiky](https://github.com/visiky)

// \u6F0F\u6597\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49

// \u4EEA\u8868\u76D8\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [hustcc](https://github.com/hustcc)

// \u70ED\u529B\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [jiazhewang](https://github.com/jiazhewang)

// \u76F4\u65B9\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [arcsin1](https://github.com/arcsin1), [visiky](https://github.com/visiky)

// \u6298\u7EBF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [hustcc](https://github.com/hustcc)

// \u6C34\u6CE2\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [CarisL](https://github.com/CarisL), [hustcc](https://github.com/hustcc), [pearmini](https://github.com/pearmini)

// \u5DF2\u7ECF\u5E9F\u5F03\uFF0C\u66F4\u540D\u4E3A Mix

// \u997C\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [visiky](https://github.com/visiky)

// \u8FDB\u5EA6\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [connono](https://github.com/connono)

// \u96F7\u8FBE\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [visiky](https://github.com/visiky)

// \u7389\u73CF\u56FE | author by [yujs](https://github.com/yujs) | updated by [visiky](https://github.com/visiky)

// \u73AF\u5F62\u8FDB\u5EA6\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [connono](https://github.com/connono)

// \u73AB\u7470\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [zhangzhonghe](https://github.com/zhangzhonghe)

// \u6851\u57FA\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [hustcc](https://github.com/hustcc)

// \u6563\u70B9\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [lxfu1](https://github.com/lxfu1)

// K\u7EBF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [jhwong](https://github.com/jinhuiWong), [visiky](https://github.com/visiky)

// \u65ED\u65E5\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [lxfu1](https://github.com/lxfu1), [visiky](https://github.com/visiky)

// \u8FF7\u4F60\u9762\u79EF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [connono](https://github.com/connono)

// \u8FF7\u4F60\u67F1\u5F62\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [connono](https://github.com/connono)

// \u8FF7\u4F60\u6298\u7EBF\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [connono](https://github.com/connono)

// \u77E9\u5F62\u6811\u56FE

// \u97E6\u6069\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [visiky](https://github.com/visiky)

// \u5C0F\u63D0\u7434\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [YiSiWang](https://github.com/YiSiWang), [visiky](https://github.com/visiky)

// \u7011\u5E03\u56FE | author by [visiky](https://github.com/visiky)

// \u8BCD\u4E91\u56FE\u53CA\u7C7B\u578B\u5B9A\u4E49 | author by [zhangzhonghe](https://github.com/zhangzhonghe)

// \u4EE5\u4E0B\u5F00\u653E\u81EA\u5B9A\u4E49\u56FE\u8868\u5F00\u53D1\u7684\u80FD\u529B\uFF08\u76EE\u524D\u4EC5\u4EC5\u662F\u5B75\u5316\u4E2D\uFF09
/** \u6240\u6709\u5F00\u653E\u56FE\u8868\u90FD\u4F7F\u7528 G2Plot.P \u4F5C\u4E3A\u5165\u53E3\u5F00\u53D1\uFF0C\u7406\u8BBA\u4E0A\u5B98\u65B9\u7684\u6240\u6709\u56FE\u8868\u90FD\u53EF\u4EE5\u8D70 G2Plot.P \u7684\u5165\u53E3\uFF08\u6682\u65F6\u4E0D\u5904\u7406\uFF09 */

// \u7C7B\u578B\u5B9A\u4E49\u5BFC\u51FA

/** \u5F00\u53D1 adaptor \u53EF\u80FD\u4F1A\u7528\u5230\u7684\u65B9\u6CD5\u6216\u4E00\u4E9B\u5DE5\u5177\u65B9\u6CD5\uFF0C\u4E0D\u5F3A\u5236\u4F7F\u7528 */

/** \u5F00\u653E getCanvasPatterng \u65B9\u6CD5 */


/** \u900F\u51FA \u56FD\u9645\u5316 \u5DE5\u5177\u51FD\u6570\uFF0C\u4FBF\u4E8E\u4F7F\u7528 */

/** default locale register */
registerLocale('en-US', EN_US_LOCALE);
registerLocale('zh-CN', ZH_CN_LOCALE);
var adaptors = { scale: common_scale, legend: common_legend, tooltip: common_tooltip, annotation: common_annotation, interaction: common_interaction, theme: common_theme, animation: animation };
//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(73935);
var react_dom_namespaceObject = /*#__PURE__*/__webpack_require__.t(react_dom, 2);
;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/utils/render.js
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var render_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var render_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

// Let compiler not to search module usage
var fullClone = __assign({}, react_dom_namespaceObject);
var render_version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
    var mainVersion = Number((render_version || '').split('.')[0]);
    if (mainVersion >= 18) {
        (createRoot = fullClone.createRoot);
    }
}
catch (e) {
    // Do nothing;
}
function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED &&
        typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === 'object') {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
}
var MARK = '__rc_react_root__';
function modernRender(node, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node);
    container[MARK] = root;
}
function legacyRender(node, container) {
    reactRender(node, container);
}
/** @private Test usage. Not work in prod */
function _r(node, container) {
    if (false) {}
}
function render(node, container) {
    if (createRoot) {
        modernRender(node, container);
        return;
    }
    legacyRender(node, container);
}
// ========================= Unmount ==========================
function modernUnmount(container) {
    return render_awaiter(this, void 0, void 0, function () {
        return render_generator(this, function (_a) {
            // Delay to unmount to avoid React 18 sync warning
            return [2 /*return*/, Promise.resolve().then(function () {
                    var _a;
                    (_a = container[MARK]) === null || _a === void 0 ? void 0 : _a.unmount();
                    delete container[MARK];
                })];
        });
    });
}
function legacyUnmount(container) {
    unmountComponentAtNode(container);
}
/** @private Test usage. Not work in prod */
function _u(container) {
    if (false) {}
}
function unmount(container) {
    return render_awaiter(this, void 0, void 0, function () {
        return render_generator(this, function (_a) {
            if (createRoot !== undefined) {
                // Delay to unmount to avoid React 18 sync warning
                return [2 /*return*/, modernUnmount(container)];
            }
            legacyUnmount(container);
            return [2 /*return*/];
        });
    });
}

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/utils/createNode.js

var TOOLTIP_CONTAINER_MAPPING = new Map();
var createNode = function (children, type, uuid) {
    var mountPoint = document.createElement('div');
    if (type === 'tooltip') {
        mountPoint.setAttribute('data-uuid', uuid);
        if (TOOLTIP_CONTAINER_MAPPING.has(uuid)) {
            mountPoint = TOOLTIP_CONTAINER_MAPPING.get(uuid);
        }
        else {
            TOOLTIP_CONTAINER_MAPPING.set(uuid, mountPoint);
        }
        mountPoint.className = 'g2-tooltip';
    }
    render(children, mountPoint);
    return mountPoint;
};
/* harmony default export */ var utils_createNode = (createNode);

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/utils/utils.js
/* eslint-disable no-restricted-syntax */
// \u7C7B\u578B\u68C0\u6D4B
var utils_isType = function (value, type) {
    var toString = {}.toString;
    return toString.call(value) === "[object ".concat(type, "]");
};
var utils_clone = function (source) {
    if (!source) {
        return source;
    }
    var target = {};
    // eslint-disable-next-line guard-for-in
    for (var k in source) {
        target[k] = source[k];
    }
    return target;
};
var getType = function (n) {
    return Object.prototype.toString.call(n).slice(8, -1);
};
/**
 * \u6DF1\u514B\u9686
 * @param source \u8981\u6DF1\u514B\u9686\u7684\u76EE\u6807\u5BF9\u8C61
 */
var deepClone = function (source) {
    if (!source || typeof source !== 'object') {
        return source;
    }
    var target;
    if (Array.isArray(source)) {
        target = source.map(function (item) { return deepClone(item); });
    }
    else {
        target = {};
        Object.keys(source).forEach(function (key) {
            return (target[key] = deepClone(source[key]));
        });
    }
    return target;
};
/**
 * \u5B58\u5728\u65F6\u8FD4\u56DE\u8DEF\u5F84\u503C\uFF0C\u4E0D\u5B58\u5728\u65F6\u8FD4\u56DE undefined
 */
var hasPath = function (source, path) {
    var current = source;
    for (var i = 0; i < path.length; i += 1) {
        if (current === null || current === void 0 ? void 0 : current[path[i]]) {
            current = current[path[i]];
        }
        else {
            current = undefined;
            break;
        }
    }
    return current;
};
/**
 * \u5185\u90E8\u6307\u5B9A params \uFF0C\u4E0D\u8003\u8651\u590D\u6742\u60C5\u51B5
 */
var setPath = function (source, path, value) {
    if (!source) {
        return source;
    }
    var o = source;
    path.forEach(function (key, idx) {
        // \u4E0D\u662F\u6700\u540E\u4E00\u4E2A
        if (idx < path.length - 1) {
            o = o[key];
        }
        else {
            o[key] = value;
        }
    });
    return source;
};
var uuid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0;
        var v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/hooks/useChart.js
var useChart_assign = (undefined && undefined.__assign) || function () {
    useChart_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return useChart_assign.apply(this, arguments);
};
var useChart_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




function useInit(ChartClass, config) {
    var chart = (0,react.useRef)();
    var chartOptions = (0,react.useRef)();
    var container = (0,react.useRef)(null);
    var onReady = config.onReady, onEvent = config.onEvent;
    /**
     * Get data base64
     * @param {string} type A DOMString indicating the image format. The default format type is image/png.
     * @param {number} encoderOptions A Number between 0 and 1 indicating the image quality
     */
    var toDataURL = function (type, encoderOptions) {
        var _a;
        if (type === void 0) { type = 'image/png'; }
        return (_a = chart.current) === null || _a === void 0 ? void 0 : _a.chart.canvas.cfg.el.toDataURL(type, encoderOptions);
    };
    /**
     * Download Iamge
     * @param {string} name A name of image
     * @param {string} type A DOMString indicating the image format. The default format type is image/png.
     * @param {number} encoderOptions A Number between 0 and 1 indicating the image quality
     */
    var downloadImage = function (name, type, encoderOptions) {
        var _a;
        if (name === void 0) { name = 'download'; }
        if (type === void 0) { type = 'image/png'; }
        var imageName = name;
        if (name.indexOf('.') === -1) {
            imageName = "".concat(name, ".").concat(type.split('/')[1]);
        }
        var base64 = (_a = chart.current) === null || _a === void 0 ? void 0 : _a.chart.canvas.cfg.el.toDataURL(type, encoderOptions);
        var a = document.createElement('a');
        a.href = base64;
        a.download = imageName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        a = null;
        return imageName;
    };
    var reactDomToString = function (source, path, type, _uuid) {
        var statisticCustomHtml = hasPath(source, path);
        setPath(source, path, function () {
            var arg = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arg[_i] = arguments[_i];
            }
            var statisticDom = utils_isType(statisticCustomHtml, 'Function') ? statisticCustomHtml.apply(void 0, arg) : statisticCustomHtml;
            if (utils_isType(statisticDom, 'String') || utils_isType(statisticDom, 'Number') || utils_isType(statisticDom, 'HTMLDivElement')) {
                return statisticDom;
            }
            return utils_createNode(statisticDom, type, _uuid);
        });
    };
    var processConfig = function () {
        var _uuid = uuid();
        // statistic
        if (hasPath(config, ['statistic', 'content', 'customHtml'])) {
            reactDomToString(config, ['statistic', 'content', 'customHtml']);
        }
        if (hasPath(config, ['statistic', 'title', 'customHtml'])) {
            reactDomToString(config, ['statistic', 'title', 'customHtml']);
        }
        // tooltip
        if (typeof config.tooltip === 'object') {
            if (hasPath(config, ['tooltip', 'container'])) {
                reactDomToString(config, ['tooltip', 'container'], 'tooltip', _uuid);
            }
            if (hasPath(config, ['tooltip', 'customContent'])) {
                reactDomToString(config, ['tooltip', 'customContent'], 'tooltip', _uuid);
            }
        }
    };
    (0,react.useEffect)(function () {
        if (chart.current && !(0,esm/* isEqual */.Xy)(chartOptions.current, config)) {
            var changeData = false;
            if (chartOptions.current) {
                // \u4ECE options \u91CC\u9762\u53D6\u51FA data \u3001value \u3001 percent \u8FDB\u884C\u6BD4\u5BF9\uFF0C\u5224\u65AD\u662F\u5426\u4EC5\u6570\u503C\u53D1\u751F\u6539\u53D8
                var _a = chartOptions.current, currentData = _a.data, currentValue = _a.value, currentPercent = _a.percent, currentConfig = useChart_rest(_a, ["data", "value", "percent"]);
                var inputData = config.data, inputValue = config.value, inputPercent = config.percent, inputConfig = useChart_rest(config, ["data", "value", "percent"]);
                changeData = (0,esm/* isEqual */.Xy)(currentConfig, inputConfig);
            }
            chartOptions.current = deepClone(config);
            if (changeData && (0,esm/* get */.U2)(config, 'chartType') !== 'Mix') {
                var changeType_1 = 'data';
                var typeMaps = ['percent']; // \u7279\u6B8A\u7C7B\u578B\u7684\u56FE\u8868 data \u5B57\u6BB5\uFF0C\u4F8B\u5982 RingProgress
                var currentKeys_1 = Object.keys(config);
                typeMaps.forEach(function (type) {
                    if (currentKeys_1.includes(type)) {
                        changeType_1 = type;
                    }
                });
                chart.current.changeData((config === null || config === void 0 ? void 0 : config[changeType_1]) || []);
                chart.current.render();
            }
            else {
                processConfig();
                chart.current.update(config);
            }
        }
    }, [config]);
    (0,react.useEffect)(function () {
        if (!container.current) {
            return function () { return null; };
        }
        if (!chartOptions.current) {
            chartOptions.current = deepClone(config);
        }
        processConfig();
        var chartInstance = new ChartClass(container.current, useChart_assign({}, config));
        chartInstance.toDataURL = function (type, encoderOptions) {
            return toDataURL(type, encoderOptions);
        };
        chartInstance.downloadImage = function (name, type, encoderOptions) {
            return downloadImage(name, type, encoderOptions);
        };
        chartInstance.render();
        chart.current = utils_clone(chartInstance);
        if (onReady) {
            onReady(chartInstance);
        }
        var handler = function (event) {
            if (onEvent) {
                onEvent(chartInstance, event);
            }
        };
        chartInstance.on('*', handler);
        // \u7EC4\u4EF6\u9500\u6BC1\u65F6\u9500\u6BC1\u56FE\u8868
        return function () {
            if (chart.current) {
                chart.current.destroy();
                chart.current.off('*', handler);
                chart.current = undefined;
            }
        };
    }, []);
    return {
        chart: chart,
        container: container,
    };
}

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/utils/getChart.js

/**
 * \u83B7\u53D6\u6216\u8005\u7ED1\u5B9A\u56FE\u8868\u5B9E\u4F8B
 */
var getChart = function (chartRef, chart) {
    if (!chartRef) {
        return;
    }
    if ((0,esm/* isFunction */.mf)(chartRef)) {
        chartRef(chart);
    }
    else {
        chartRef.current = chart;
    }
};

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/errorBoundary/index.js
var errorBoundary_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ErrorBoundary = /** @class */ (function (_super) {
    errorBoundary_extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            hasError: false,
        };
        _this.renderError = function (e) {
            var errorTemplate = _this.props.errorTemplate;
            switch (e) {
                default:
                    if (typeof errorTemplate === 'function') {
                        return errorTemplate(e);
                    }
                    return errorTemplate ? errorTemplate : react.createElement("h5", null,
                        "\\u7EC4\\u4EF6\\u51FA\\u9519\\u4E86\\uFF0C\\u8BF7\\u6838\\u67E5\\u540E\\u91CD\\u8BD5\\uFF1A ",
                        e.message);
            }
        };
        return _this;
    }
    ErrorBoundary.getDerivedStateFromError = function (error) {
        return { hasError: true, error: error };
    };
    ErrorBoundary.getDerivedStateFromProps = function (nextProps, state) {
        if (state.children !== nextProps.children) {
            return {
                children: nextProps.children,
                hasError: false,
                error: undefined,
            };
        }
        return null;
    };
    ErrorBoundary.prototype.render = function () {
        if (this.state.hasError) {
            return this.renderError(this.state.error);
        }
        return react.createElement(react.Fragment, null, this.props.children);
    };
    return ErrorBoundary;
}(react.Component));
/* harmony default export */ var errorBoundary = (ErrorBoundary);

;// CONCATENATED MODULE: ./node_modules/react-content-loader/dist/react-content-loader.es.js


/*! *****************************************************************************\r
Copyright (c) Microsoft Corporation. All rights reserved.\r
Licensed under the Apache License, Version 2.0 (the "License"); you may not use\r
this file except in compliance with the License. You may obtain a copy of the\r
License at http://www.apache.org/licenses/LICENSE-2.0\r
\r
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r
MERCHANTABLITY OR NON-INFRINGEMENT.\r
\r
See the Apache Version 2.0 License for specific language governing permissions\r
and limitations under the License.\r
***************************************************************************** */\r
\r
var react_content_loader_es_assign = function() {\r
    react_content_loader_es_assign = Object.assign || function __assign(t) {\r
        for (var s, i = 1, n = arguments.length; i < n; i++) {\r
            s = arguments[i];\r
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r
        }\r
        return t;\r
    };\r
    return react_content_loader_es_assign.apply(this, arguments);\r
};\r
\r
function react_content_loader_es_rest(s, e) {\r
    var t = {};\r
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r
        t[p] = s[p];\r
    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r
                t[p[i]] = s[p[i]];\r
        }\r
    return t;\r
}

var uid = (function () {\r
    return Math.random()\r
        .toString(36)\r
        .substring(6);\r
});

var SVG = function (_a) {\r
    var animate = _a.animate, backgroundColor = _a.backgroundColor, backgroundOpacity = _a.backgroundOpacity, baseUrl = _a.baseUrl, children = _a.children, foregroundColor = _a.foregroundColor, foregroundOpacity = _a.foregroundOpacity, gradientRatio = _a.gradientRatio, uniqueKey = _a.uniqueKey, interval = _a.interval, rtl = _a.rtl, speed = _a.speed, style = _a.style, title = _a.title, props = react_content_loader_es_rest(_a, ["animate", "backgroundColor", "backgroundOpacity", "baseUrl", "children", "foregroundColor", "foregroundOpacity", "gradientRatio", "uniqueKey", "interval", "rtl", "speed", "style", "title"]);\r
    var fixedId = uniqueKey || uid();\r
    var idClip = fixedId + "-diff";\r
    var idGradient = fixedId + "-animated-diff";\r
    var idAria = fixedId + "-aria";\r
    var rtlStyle = rtl ? { transform: 'scaleX(-1)' } : null;\r
    var keyTimes = "0; " + interval + "; 1";\r
    var dur = speed + "s";\r
    return ((0,react.createElement)("svg", react_content_loader_es_assign({ "aria-labelledby": idAria, role: "img", style: react_content_loader_es_assign(react_content_loader_es_assign({}, style), rtlStyle) }, props),\r
        title ? (0,react.createElement)("title", { id: idAria }, title) : null,\r
        (0,react.createElement)("rect", { role: "presentation", x: "0", y: "0", width: "100%", height: "100%", clipPath: "url(" + baseUrl + "#" + idClip + ")", style: { fill: "url(" + baseUrl + "#" + idGradient + ")" } }),\r
        (0,react.createElement)("defs", { role: "presentation" },\r
            (0,react.createElement)("clipPath", { id: idClip }, children),\r
            (0,react.createElement)("linearGradient", { id: idGradient },\r
                (0,react.createElement)("stop", { offset: "0%", stopColor: backgroundColor, stopOpacity: backgroundOpacity }, animate && ((0,react.createElement)("animate", { attributeName: "offset", values: -gradientRatio + "; " + -gradientRatio + "; 1", keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" }))),\r
                (0,react.createElement)("stop", { offset: "50%", stopColor: foregroundColor, stopOpacity: foregroundOpacity }, animate && ((0,react.createElement)("animate", { attributeName: "offset", values: -gradientRatio / 2 + "; " + -gradientRatio / 2 + "; " + (1 +\r
                        gradientRatio / 2), keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" }))),\r
                (0,react.createElement)("stop", { offset: "100%", stopColor: backgroundColor, stopOpacity: backgroundOpacity }, animate && ((0,react.createElement)("animate", { attributeName: "offset", values: "0; 0; " + (1 + gradientRatio), keyTimes: keyTimes, dur: dur, repeatCount: "indefinite" })))))));\r
};\r
SVG.defaultProps = {\r
    animate: true,\r
    backgroundColor: '#f5f6f7',\r
    backgroundOpacity: 1,\r
    baseUrl: '',\r
    foregroundColor: '#eee',\r
    foregroundOpacity: 1,\r
    gradientRatio: 2,\r
    id: null,\r
    interval: 0.25,\r
    rtl: false,\r
    speed: 1.2,\r
    style: {},\r
    title: 'Loading...',\r
};

var ContentLoader = function (props) {\r
    return props.children ? (0,react.createElement)(SVG, react_content_loader_es_assign({}, props)) : (0,react.createElement)(ReactContentLoaderFacebook, react_content_loader_es_assign({}, props));\r
};

var ReactContentLoaderFacebook = function (props) { return ((0,react.createElement)(ContentLoader, react_content_loader_es_assign({ viewBox: "0 0 476 124" }, props),\r
    (0,react.createElement)("rect", { x: "48", y: "8", width: "88", height: "6", rx: "3" }),\r
    (0,react.createElement)("rect", { x: "48", y: "26", width: "52", height: "6", rx: "3" }),\r
    (0,react.createElement)("rect", { x: "0", y: "56", width: "410", height: "6", rx: "3" }),\r
    (0,react.createElement)("rect", { x: "0", y: "72", width: "380", height: "6", rx: "3" }),\r
    (0,react.createElement)("rect", { x: "0", y: "88", width: "178", height: "6", rx: "3" }),\r
    (0,react.createElement)("circle", { cx: "20", cy: "20", r: "20" }))); };

var ReactContentLoaderInstagram = function (props) { return (createElement(ContentLoader, react_content_loader_es_assign({ viewBox: "0 0 400 460" }, props),\r
    createElement("circle", { cx: "31", cy: "31", r: "15" }),\r
    createElement("rect", { x: "58", y: "18", rx: "2", ry: "2", width: "140", height: "10" }),\r
    createElement("rect", { x: "58", y: "34", rx: "2", ry: "2", width: "140", height: "10" }),\r
    createElement("rect", { x: "0", y: "60", rx: "2", ry: "2", width: "400", height: "400" }))); };

var ReactContentLoaderCode = function (props) { return (createElement(ContentLoader, react_content_loader_es_assign({ viewBox: "0 0 340 84" }, props),\r
    createElement("rect", { x: "0", y: "0", width: "67", height: "11", rx: "3" }),\r
    createElement("rect", { x: "76", y: "0", width: "140", height: "11", rx: "3" }),\r
    createElement("rect", { x: "127", y: "48", width: "53", height: "11", rx: "3" }),\r
    createElement("rect", { x: "187", y: "48", width: "72", height: "11", rx: "3" }),\r
    createElement("rect", { x: "18", y: "48", width: "100", height: "11", rx: "3" }),\r
    createElement("rect", { x: "0", y: "71", width: "37", height: "11", rx: "3" }),\r
    createElement("rect", { x: "18", y: "23", width: "140", height: "11", rx: "3" }),\r
    createElement("rect", { x: "166", y: "23", width: "173", height: "11", rx: "3" }))); };

var ReactContentLoaderListStyle = function (props) { return (createElement(ContentLoader, react_content_loader_es_assign({ viewBox: "0 0 400 110" }, props),\r
    createElement("rect", { x: "0", y: "0", rx: "3", ry: "3", width: "250", height: "10" }),\r
    createElement("rect", { x: "20", y: "20", rx: "3", ry: "3", width: "220", height: "10" }),\r
    createElement("rect", { x: "20", y: "40", rx: "3", ry: "3", width: "170", height: "10" }),\r
    createElement("rect", { x: "0", y: "60", rx: "3", ry: "3", width: "250", height: "10" }),\r
    createElement("rect", { x: "20", y: "80", rx: "3", ry: "3", width: "200", height: "10" }),\r
    createElement("rect", { x: "20", y: "100", rx: "3", ry: "3", width: "80", height: "10" }))); };

var ReactContentLoaderBulletList = function (props) { return (createElement(ContentLoader, react_content_loader_es_assign({ viewBox: "0 0 245 125" }, props),\r
    createElement("circle", { cx: "10", cy: "20", r: "8" }),\r
    createElement("rect", { x: "25", y: "15", rx: "5", ry: "5", width: "220", height: "10" }),\r
    createElement("circle", { cx: "10", cy: "50", r: "8" }),\r
    createElement("rect", { x: "25", y: "45", rx: "5", ry: "5", width: "220", height: "10" }),\r
    createElement("circle", { cx: "10", cy: "80", r: "8" }),\r
    createElement("rect", { x: "25", y: "75", rx: "5", ry: "5", width: "220", height: "10" }),\r
    createElement("circle", { cx: "10", cy: "110", r: "8" }),\r
    createElement("rect", { x: "25", y: "105", rx: "5", ry: "5", width: "220", height: "10" }))); };

/* harmony default export */ var react_content_loader_es = (ContentLoader);

//# sourceMappingURL=react-content-loader.es.js.map

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/utils/createLoading.js


var ChartLoading = function (_a) {
    var loadingTemplate = _a.loadingTemplate, _b = _a.theme, theme = _b === void 0 ? 'light' : _b;
    var renderLoading = function () {
        if (loadingTemplate) {
            return loadingTemplate;
        }
        return (react.createElement(react_content_loader_es, { viewBox: "0 0 400 180", width: 200, height: 90, speed: 1, backgroundColor: theme === 'dark' ? '#262626' : '#D9D9D9' },
            react.createElement("rect", { x: "20", y: "5", rx: "0", ry: "0", width: "1", height: "170" }),
            react.createElement("rect", { x: "20", y: "175", rx: "0", ry: "0", width: "360", height: "1" }),
            react.createElement("rect", { x: "40", y: "75", rx: "0", ry: "0", width: "35", height: "100" }),
            react.createElement("rect", { x: "80", y: "125", rx: "0", ry: "0", width: "35", height: "50" }),
            react.createElement("rect", { x: "120", y: "105", rx: "0", ry: "0", width: "35", height: "70" }),
            react.createElement("rect", { x: "160", y: "35", rx: "0", ry: "0", width: "35", height: "140" }),
            react.createElement("rect", { x: "200", y: "55", rx: "0", ry: "0", width: "35", height: "120" }),
            react.createElement("rect", { x: "240", y: "15", rx: "0", ry: "0", width: "35", height: "160" }),
            react.createElement("rect", { x: "280", y: "135", rx: "0", ry: "0", width: "35", height: "40" }),
            react.createElement("rect", { x: "320", y: "85", rx: "0", ry: "0", width: "35", height: "90" })));
    };
    return (react.createElement("div", { className: "charts-loading-container", style: {
            position: 'absolute',
            width: '100%',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            left: 0,
            top: 0,
            zIndex: 99,
            backgroundColor: theme === 'dark' ? 'rgb(20, 20, 20)' : 'rgb(255, 255, 255)',
        } }, renderLoading()));
};
/* harmony default export */ var createLoading = (ChartLoading);

;// CONCATENATED MODULE: ./node_modules/@ant-design/plots/es/components/line/index.js
var line_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






var LineChart = (0,react.forwardRef)(function (props, ref) {
    var chartRef = props.chartRef, _a = props.style, style = _a === void 0 ? {
        height: 'inherit',
    } : _a, className = props.className, loading = props.loading, loadingTemplate = props.loadingTemplate, errorTemplate = props.errorTemplate, rest = line_rest(props, ["chartRef", "style", "className", "loading", "loadingTemplate", "errorTemplate"]);
    var _b = useInit(plots_line_Line, rest), chart = _b.chart, container = _b.container;
    (0,react.useEffect)(function () {
        getChart(chartRef, chart.current);
    }, [chart.current]);
    (0,react.useImperativeHandle)(ref, function () { return ({
        getChart: function () { return chart.current; },
    }); });
    return (react.createElement(errorBoundary, { errorTemplate: errorTemplate },
        loading && react.createElement(createLoading, { loadingTemplate: loadingTemplate, theme: props.theme }),
        react.createElement("div", { className: className, style: style, ref: container })));
});
/* harmony default export */ var components_line = (LineChart);


//# sourceURL=webpack:///./node_modules/@ant-design/plots/es/components/line/index.js_+_693_modules?`)},90494:function(__unused_webpack_module,__webpack_exports__){"use strict";eval(`var WILDCARD = '*';
/* event-emitter */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._events = {};
    }
    /**
     * \u76D1\u542C\u4E00\u4E2A\u4E8B\u4EF6
     * @param evt
     * @param callback
     * @param once
     */
    EventEmitter.prototype.on = function (evt, callback, once) {
        if (!this._events[evt]) {
            this._events[evt] = [];
        }
        this._events[evt].push({
            callback: callback,
            once: !!once,
        });
        return this;
    };
    /**
     * \u76D1\u542C\u4E00\u4E2A\u4E8B\u4EF6\u4E00\u6B21
     * @param evt
     * @param callback
     */
    EventEmitter.prototype.once = function (evt, callback) {
        return this.on(evt, callback, true);
    };
    /**
     * \u89E6\u53D1\u4E00\u4E2A\u4E8B\u4EF6
     * @param evt
     * @param args
     */
    EventEmitter.prototype.emit = function (evt) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var events = this._events[evt] || [];
        var wildcardEvents = this._events[WILDCARD] || [];
        // \u5B9E\u9645\u7684\u5904\u7406 emit \u65B9\u6CD5
        var doEmit = function (es) {
            var length = es.length;
            for (var i = 0; i < length; i++) {
                if (!es[i]) {
                    continue;
                }
                var _a = es[i], callback = _a.callback, once = _a.once;
                if (once) {
                    es.splice(i, 1);
                    if (es.length === 0) {
                        delete _this._events[evt];
                    }
                    length--;
                    i--;
                }
                callback.apply(_this, args);
            }
        };
        doEmit(events);
        doEmit(wildcardEvents);
    };
    /**
     * \u53D6\u6D88\u76D1\u542C\u4E00\u4E2A\u4E8B\u4EF6\uFF0C\u6216\u8005\u4E00\u4E2Achannel
     * @param evt
     * @param callback
     */
    EventEmitter.prototype.off = function (evt, callback) {
        if (!evt) {
            // evt \u4E3A\u7A7A\u5168\u90E8\u6E05\u9664
            this._events = {};
        }
        else {
            if (!callback) {
                // evt \u5B58\u5728\uFF0Ccallback \u4E3A\u7A7A\uFF0C\u6E05\u9664\u4E8B\u4EF6\u6240\u6709\u65B9\u6CD5
                delete this._events[evt];
            }
            else {
                // evt \u5B58\u5728\uFF0Ccallback \u5B58\u5728\uFF0C\u6E05\u9664\u5339\u914D\u7684
                var events = this._events[evt] || [];
                var length_1 = events.length;
                for (var i = 0; i < length_1; i++) {
                    if (events[i].callback === callback) {
                        events.splice(i, 1);
                        length_1--;
                        i--;
                    }
                }
                if (events.length === 0) {
                    delete this._events[evt];
                }
            }
        }
        return this;
    };
    /* \u5F53\u524D\u6240\u6709\u7684\u4E8B\u4EF6 */
    EventEmitter.prototype.getEvents = function () {
        return this._events;
    };
    return EventEmitter;
}());
/* harmony default export */ __webpack_exports__["Z"] = (EventEmitter);
//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/event-emitter/esm/index.js?`)},2667:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97582);
/* harmony import */ var _antv_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90494);
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77341);



var Base = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT)(Base, _super);
    function Base(cfg) {
        var _this = _super.call(this) || this;
        /**
         * \u662F\u5426\u88AB\u9500\u6BC1
         * @type {boolean}
         */
        _this.destroyed = false;
        var defaultCfg = _this.getDefaultCfg();
        _this.cfg = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .mix */ .CD)(defaultCfg, cfg);
        return _this;
    }
    /**
     * @protected
     * \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     * @returns {object} \u9ED8\u8BA4\u7684\u914D\u7F6E\u9879
     */
    Base.prototype.getDefaultCfg = function () {
        return {};
    };
    // \u5B9E\u73B0\u63A5\u53E3\u7684\u65B9\u6CD5
    Base.prototype.get = function (name) {
        return this.cfg[name];
    };
    // \u5B9E\u73B0\u63A5\u53E3\u7684\u65B9\u6CD5
    Base.prototype.set = function (name, value) {
        this.cfg[name] = value;
    };
    // \u5B9E\u73B0\u63A5\u53E3\u7684\u65B9\u6CD5
    Base.prototype.destroy = function () {
        this.cfg = {
            destroyed: true,
        };
        this.off();
        this.destroyed = true;
    };
    return Base;
}(_antv_event_emitter__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z));
/* harmony default export */ __webpack_exports__["Z"] = (Base);
//# sourceMappingURL=base.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/base.js?`)},58906:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ canvas; }
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(97582);
// EXTERNAL MODULE: ./node_modules/detect-browser/es/index.js
var es = __webpack_require__(43631);
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/abstract/container.js
var container = __webpack_require__(37153);
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/util/util.js
var util = __webpack_require__(77341);
// EXTERNAL MODULE: ./node_modules/@antv/util/esm/index.js + 104 modules
var esm = __webpack_require__(45098);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-timer/src/timer.js
var timer_frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++timer_frame; // Pretend we\u2019ve set an alarm, if we haven\u2019t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --timer_frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  timer_frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    timer_frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (timer_frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    timer_frame = 1, setFrame(wake);
  }
}

// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(52677);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-color/src/define.js
/* harmony default export */ function src_define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-color/src/color.js

function Color() {}
var _darker = 0.7;

var _brighter = 1 / _darker;

var reI = "\\\\s*([+-]?\\\\d+)\\\\s*",
  reN = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*",
  reP = "\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*",
  reHex = /^#([0-9a-f]{3,8})$/,
  reRgbInteger = new RegExp("^rgb\\\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\\\)$")),
  reRgbPercent = new RegExp("^rgb\\\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\\\)$")),
  reRgbaInteger = new RegExp("^rgba\\\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\\\)$")),
  reRgbaPercent = new RegExp("^rgba\\\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\\\)$")),
  reHslPercent = new RegExp("^hsl\\\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\\\)$")),
  reHslaPercent = new RegExp("^hsla\\\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\\\)$"));
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
src_define(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function color_rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
src_define(Rgb, color_rgb, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  clamp: function clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
}
function rgb_formatHex8() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
}
function rgb_formatRgb() {
  var a = clampa(this.opacity);
  return "".concat(a === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a === 1 ? ")" : ", ".concat(a, ")"));
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
    g = o.g / 255,
    b = o.b / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    h = NaN,
    s = max - min,
    l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
src_define(Hsl, hsl, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
      s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
      l = this.l,
      m2 = l + (l < 0.5 ? l : 1 - l) * s,
      m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp: function clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = clampa(this.opacity);
    return "".concat(a === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a === 1 ? ")" : ", ".concat(a, ")"));
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
    t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
/* harmony default export */ function src_basis(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
      v1 = values[i],
      v2 = values[i + 1],
      v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
      v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/basisClosed.js

/* harmony default export */ function basisClosed(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
      v0 = values[(i + n - 1) % n],
      v1 = values[i % n],
      v2 = values[(i + 1) % n],
      v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/constant.js
/* harmony default export */ var src_constant = (function (x) {
  return function () {
    return x;
  };
});
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/color.js

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : src_constant(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : src_constant(isNaN(a) ? b : a);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/rgb.js




/* harmony default export */ var rgb = ((function rgbGamma(y) {
  var color = gamma(y);
  function rgb(start, end) {
    var r = color((start = color_rgb(start)).r, (end = color_rgb(end)).r),
      g = color(start.g, end.g),
      b = color(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb.gamma = rgbGamma;
  return rgb;
})(1));
function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
      r = new Array(n),
      g = new Array(n),
      b = new Array(n),
      i,
      color;
    for (i = 0; i < n; ++i) {
      color = color_rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}
var rgbBasis = rgbSpline(src_basis);
var rgbBasisClosed = rgbSpline(basisClosed);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/numberArray.js
/* harmony default export */ function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
    c = b.slice(),
    i;
  return function (t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/array.js


/* harmony default export */ function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0,
    na = a ? Math.min(nb, a.length) : 0,
    x = new Array(na),
    c = new Array(nb),
    i;
  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function (t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/date.js
/* harmony default export */ function date(a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/number.js
/* harmony default export */ function number(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/object.js


/* harmony default export */ function object(a, b) {
  var i = {},
    c = {},
    k;
  if (a === null || helpers_typeof(a) !== "object") a = {};
  if (b === null || helpers_typeof(b) !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function (t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/string.js

var reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,
  reB = new RegExp(reA.source, "g");
function zero(b) {
  return function () {
    return b;
  };
}
function one(b) {
  return function (t) {
    return b(t) + "";
  };
}
/* harmony default export */ function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
    // scan index for next number in b
    am,
    // current match in a
    bm,
    // current match in b
    bs,
    // string preceding current number in b, if any
    i = -1,
    // index in s
    s = [],
    // string constants and placeholders
    q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: number(am, bm)
      });
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  });
}
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/node_modules/d3-interpolate/src/value.js










/* harmony default export */ function value(a, b) {
  var t = helpers_typeof(b),
    c;
  return b == null || t === "boolean" ? src_constant(b) : (t === "number" ? number : t === "string" ? (c = color(b)) ? (b = c, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : number)(a, b);
}
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/animate/register.js + 12 modules
var register = __webpack_require__(93924);
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/util/path.js
var path = __webpack_require__(47575);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function (prop) { return ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(prop); };
var isGradientColor = function (val) { return /^[r,R,L,l]{1}[\\s]*\\(/.test(val); };
//# sourceMappingURL=color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/animate/timeline.js


 // \u76EE\u524D\u6574\u4F53\u52A8\u753B\u53EA\u9700\u8981\u6570\u503C\u548C\u6570\u7EC4\u7684\u5DEE\u503C\u8BA1\u7B97



var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
/**
 * \u4F7F\u7528 ratio \u8FDB\u884C\u63D2\u503C\u8BA1\u7B97\u6765\u66F4\u65B0\u5C5E\u6027
 * @param {IElement}  shape    \u5143\u7D20
 * @param {Animation} animation \u52A8\u753B
 * @param {number}    ratio    \u6BD4\u4F8B
 * @return {boolean}  \u52A8\u753B\u662F\u5426\u6267\u884C\u5B8C\u6210
 */
function _update(shape, animation, ratio) {
    var cProps = {}; // \u6B64\u523B\u5C5E\u6027
    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
    if (shape.destroyed) {
        return;
    }
    var interf; //  \u5DEE\u503C\u51FD\u6570
    for (var k in toAttrs) {
        if (!(0,esm/* isEqual */.Xy)(fromAttrs[k], toAttrs[k])) {
            if (k === 'path') {
                var toPath = toAttrs[k];
                var fromPath = fromAttrs[k];
                if (toPath.length > fromPath.length) {
                    toPath = path.parsePathString(toAttrs[k]); // \u7EC8\u70B9\u72B6\u6001
                    fromPath = path.parsePathString(fromAttrs[k]); // \u8D77\u59CB\u72B6\u6001
                    fromPath = path.fillPathByDiff(fromPath, toPath);
                    fromPath = path.formatPath(fromPath, toPath);
                    animation.fromAttrs.path = fromPath;
                    animation.toAttrs.path = toPath;
                }
                else if (!animation.pathFormatted) {
                    toPath = path.parsePathString(toAttrs[k]);
                    fromPath = path.parsePathString(fromAttrs[k]);
                    fromPath = path.formatPath(fromPath, toPath);
                    animation.fromAttrs.path = fromPath;
                    animation.toAttrs.path = toPath;
                    animation.pathFormatted = true;
                }
                cProps[k] = [];
                for (var i = 0; i < toPath.length; i++) {
                    var toPathPoint = toPath[i];
                    var fromPathPoint = fromPath[i];
                    var cPathPoint = [];
                    for (var j = 0; j < toPathPoint.length; j++) {
                        if ((0,esm/* isNumber */.hj)(toPathPoint[j]) && fromPathPoint && (0,esm/* isNumber */.hj)(fromPathPoint[j])) {
                            interf = value(fromPathPoint[j], toPathPoint[j]);
                            cPathPoint.push(interf(ratio));
                        }
                        else {
                            cPathPoint.push(toPathPoint[j]);
                        }
                    }
                    cProps[k].push(cPathPoint);
                }
            }
            else if (k === 'matrix') {
                /*
                 \u5BF9\u77E9\u9635\u8FDB\u884C\u63D2\u503C\u65F6\uFF0C\u9700\u8981\u4FDD\u8BC1\u77E9\u9635\u4E0D\u4E3A\u7A7A\uFF0C\u4E3A\u7A7A\u5219\u4F7F\u7528\u5355\u4F4D\u77E9\u9635
                 TODO: \u4E8C\u7EF4\u548C\u4E09\u7EF4\u573A\u666F\u4E0B\u5355\u4F4D\u77E9\u9635\u4E0D\u540C\uFF0C\u4E4B\u540E WebGL \u7248\u9700\u8981\u505A\u8FDB\u4E00\u6B65\u5904\u7406
                 */
                var matrixFn = array(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
                var currentMatrix = matrixFn(ratio);
                cProps[k] = currentMatrix;
            }
            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
                cProps[k] = toAttrs[k];
            }
            else if (!(0,esm/* isFunction */.mf)(toAttrs[k])) {
                // \u975E\u51FD\u6570\u7C7B\u578B\u7684\u503C\u624D\u80FD\u505A\u63D2\u503C
                interf = value(fromAttrs[k], toAttrs[k]);
                cProps[k] = interf(ratio);
            }
        }
    }
    shape.attr(cProps);
}
/**
 * \u6839\u636E\u81EA\u5B9A\u4E49\u5E27\u52A8\u753B\u51FD\u6570 onFrame \u6765\u66F4\u65B0\u5C5E\u6027
 * @param {IElement}  shape    \u5143\u7D20
 * @param {Animation} animation \u52A8\u753B
 * @param {number}    elapsed  \u52A8\u753B\u6267\u884C\u65F6\u95F4(\u6BEB\u79D2)
 * @return {boolean}  \u52A8\u753B\u662F\u5426\u6267\u884C\u5B8C\u6210
 */
function update(shape, animation, elapsed) {
    var startTime = animation.startTime, delay = animation.delay;
    // \u5982\u679C\u8FD8\u6CA1\u6709\u5F00\u59CB\u6267\u884C\u6216\u6682\u505C\uFF0C\u5148\u4E0D\u66F4\u65B0
    if (elapsed < startTime + delay || animation._paused) {
        return false;
    }
    var ratio;
    var duration = animation.duration;
    var easing = animation.easing;
    var easeFn = (0,register/* getEasing */._)(easing);
    // \u5DF2\u6267\u884C\u65F6\u95F4
    elapsed = elapsed - startTime - animation.delay;
    if (animation.repeat) {
        // \u5982\u679C\u52A8\u753B\u91CD\u590D\u6267\u884C\uFF0C\u5219 elapsed > duration\uFF0C\u8BA1\u7B97 ratio \u65F6\u9700\u53D6\u6A21
        ratio = (elapsed % duration) / duration;
        ratio = easeFn(ratio);
    }
    else {
        ratio = elapsed / duration;
        if (ratio < 1) {
            // \u52A8\u753B\u672A\u6267\u884C\u5B8C
            ratio = easeFn(ratio);
        }
        else {
            // \u52A8\u753B\u5DF2\u6267\u884C\u5B8C
            if (animation.onFrame) {
                shape.attr(animation.onFrame(1));
            }
            else {
                shape.attr(animation.toAttrs);
            }
            return true;
        }
    }
    if (animation.onFrame) {
        var attrs = animation.onFrame(ratio);
        shape.attr(attrs);
    }
    else {
        _update(shape, animation, ratio);
    }
    return false;
}
var Timeline = /** @class */ (function () {
    /**
     * \u65F6\u95F4\u8F74\u6784\u9020\u51FD\u6570\uFF0C\u4F9D\u8D56\u4E8E\u753B\u5E03
     * @param {}
     */
    function Timeline(canvas) {
        /**
         * \u6267\u884C\u52A8\u753B\u7684\u5143\u7D20\u5217\u8868
         * @type {IElement[]}
         */
        this.animators = [];
        /**
         * \u5F53\u524D\u65F6\u95F4
         * @type {number}
         */
        this.current = 0;
        /**
         * \u5B9A\u65F6\u5668
         * @type {d3Timer.Timer}
         */
        this.timer = null;
        this.canvas = canvas;
    }
    /**
     * \u521D\u59CB\u5316\u5B9A\u65F6\u5668
     */
    Timeline.prototype.initTimer = function () {
        var _this = this;
        var isFinished = false;
        var shape;
        var animations;
        var animation;
        this.timer = timer(function (elapsed) {
            _this.current = elapsed;
            if (_this.animators.length > 0) {
                for (var i = _this.animators.length - 1; i >= 0; i--) {
                    shape = _this.animators[i];
                    if (shape.destroyed) {
                        // \u5982\u679C\u5DF2\u7ECF\u88AB\u9500\u6BC1\uFF0C\u76F4\u63A5\u79FB\u51FA\u961F\u5217
                        _this.removeAnimator(i);
                        continue;
                    }
                    if (!shape.isAnimatePaused()) {
                        animations = shape.get('animations');
                        for (var j = animations.length - 1; j >= 0; j--) {
                            animation = animations[j];
                            isFinished = update(shape, animation, elapsed);
                            if (isFinished) {
                                animations.splice(j, 1);
                                isFinished = false;
                                if (animation.callback) {
                                    animation.callback();
                                }
                            }
                        }
                    }
                    if (animations.length === 0) {
                        _this.removeAnimator(i);
                    }
                }
                var autoDraw = _this.canvas.get('autoDraw');
                // \u975E\u81EA\u52A8\u6E32\u67D3\u6A21\u5F0F\u4E0B\uFF0C\u624B\u52A8\u8C03\u7528 canvas.draw() \u91CD\u65B0\u6E32\u67D3
                if (!autoDraw) {
                    _this.canvas.draw();
                }
            }
        });
    };
    /**
     * \u589E\u52A0\u52A8\u753B\u5143\u7D20
     */
    Timeline.prototype.addAnimator = function (shape) {
        this.animators.push(shape);
    };
    /**
     * \u79FB\u9664\u52A8\u753B\u5143\u7D20
     */
    Timeline.prototype.removeAnimator = function (index) {
        this.animators.splice(index, 1);
    };
    /**
     * \u662F\u5426\u6709\u52A8\u753B\u5728\u6267\u884C
     */
    Timeline.prototype.isAnimating = function () {
        return !!this.animators.length;
    };
    /**
     * \u505C\u6B62\u5B9A\u65F6\u5668
     */
    Timeline.prototype.stop = function () {
        if (this.timer) {
            this.timer.stop();
        }
    };
    /**
     * \u505C\u6B62\u65F6\u95F4\u8F74\u4E0A\u6240\u6709\u5143\u7D20\u7684\u52A8\u753B\uFF0C\u5E76\u7F6E\u7A7A\u52A8\u753B\u5143\u7D20\u5217\u8868
     * @param {boolean} toEnd \u662F\u5426\u5230\u52A8\u753B\u7684\u6700\u7EC8\u72B6\u6001\uFF0C\u7528\u6765\u900F\u4F20\u7ED9\u52A8\u753B\u5143\u7D20\u7684 stopAnimate \u65B9\u6CD5
     */
    Timeline.prototype.stopAllAnimations = function (toEnd) {
        if (toEnd === void 0) { toEnd = true; }
        this.animators.forEach(function (animator) {
            animator.stopAnimate(toEnd);
        });
        this.animators = [];
        this.canvas.draw();
    };
    /**
     * \u83B7\u53D6\u5F53\u524D\u65F6\u95F4
     */
    Timeline.prototype.getTime = function () {
        return this.current;
    };
    return Timeline;
}());
/* harmony default export */ var animate_timeline = (Timeline);
//# sourceMappingURL=timeline.js.map
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/event/graph-event.js
var graph_event = __webpack_require__(89473);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/event/event-contoller.js
/**
 * @fileoverview \u4E8B\u4EF6\u5904\u7406\u5668
 * @author dxq613@gmail.com
 */


var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var DELEGATION_SPLIT = ':';
var EVENTS = [
    'mousedown',
    'mouseup',
    'dblclick',
    'mouseout',
    'mouseover',
    'mousemove',
    'mouseleave',
    'mouseenter',
    'touchstart',
    'touchmove',
    'touchend',
    'dragenter',
    'dragover',
    'dragleave',
    'drop',
    'contextmenu',
    'mousewheel',
];
// \u662F\u5426\u6709\u59D4\u6258\u4E8B\u4EF6\u76D1\u542C
function hasDelegation(events, type) {
    for (var key in events) {
        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {
            return true;
        }
    }
    return false;
}
// \u89E6\u53D1\u76EE\u6807\u4E8B\u4EF6\uFF0C\u76EE\u6807\u53EA\u80FD\u662F shape \u6216 canvas
function emitTargetEvent(target, type, eventObj) {
    eventObj.name = type;
    eventObj.target = target;
    eventObj.currentTarget = target;
    eventObj.delegateTarget = target;
    target.emit(type, eventObj);
}
// \u4E8B\u4EF6\u5192\u6CE1, enter \u548C leave \u9700\u8981\u5BF9 fromShape \u548C toShape \u8FDB\u884C\u5224\u540C
function bubbleEvent(container, type, eventObj) {
    if (eventObj.bubbles) {
        var relativeShape = void 0;
        var isOverEvent = false;
        if (type === 'mouseenter') {
            relativeShape = eventObj.fromShape;
            isOverEvent = true;
        }
        else if (type === 'mouseleave') {
            isOverEvent = true;
            relativeShape = eventObj.toShape;
        }
        // canvas \u4E0A\u7684 mouseenter\uFF0C mouseleave \u4E8B\u4EF6\uFF0C\u4EC5\u5F53\u8FDB\u5165\u6216\u8005\u79FB\u51FA canvas \u65F6\u89E6\u53D1
        if (container.isCanvas() && isOverEvent) {
            return;
        }
        // \u5982\u679C\u76F8\u5173\u56FE\u5F62\u540C\u5F53\u524D\u56FE\u5F62\u5728\u540C\u4E00\u4E2A\u5BB9\u5668\u5185\uFF0C\u4E0D\u89E6\u53D1\u4E8B\u4EF6
        if (relativeShape && (0,util/* isParent */.UY)(container, relativeShape)) {
            // \u963B\u6B62\u7EE7\u7EED\u5411\u4E0A\u5192\u6CE1
            eventObj.bubbles = false;
            return;
        }
        // \u4E8B\u4EF6\u540D\u79F0\u53EF\u80FD\u5728\u59D4\u6258\u8FC7\u7A0B\u4E2D\u88AB\u4FEE\u6539\uFF0C\u56E0\u6B64\u4E8B\u4EF6\u5192\u6CE1\u65F6\u9700\u8981\u91CD\u65B0\u8BBE\u7F6E\u4E8B\u4EF6\u540D\u79F0
        eventObj.name = type;
        eventObj.currentTarget = container;
        eventObj.delegateTarget = container;
        container.emit(type, eventObj);
    }
}
var EventController = /** @class */ (function () {
    function EventController(cfg) {
        var _this = this;
        // \u6B63\u5728\u88AB\u62D6\u62FD\u7684\u56FE\u5F62
        this.draggingShape = null;
        this.dragging = false;
        // \u5F53\u524D\u9F20\u6807/touch\u6240\u5728\u4F4D\u7F6E\u7684\u56FE\u5F62
        this.currentShape = null;
        this.mousedownShape = null;
        this.mousedownPoint = null;
        // \u7EDF\u4E00\u5904\u7406\u6240\u6709\u7684\u56DE\u8C03
        this._eventCallback = function (ev) {
            var type = ev.type;
            _this._triggerEvent(type, ev);
        };
        // \u5728 document \u5904\u7406\u62D6\u62FD\u5230\u753B\u5E03\u5916\u7684\u4E8B\u4EF6\uFF0C\u5904\u7406\u4ECE\u56FE\u5F62\u4E0A\u79FB\u9664\u753B\u5E03\u672A\u88AB\u6355\u6349\u7684\u95EE\u9898
        this._onDocumentMove = function (ev) {
            var canvas = _this.canvas;
            var el = canvas.get('el');
            if (el !== ev.target) {
                // \u4E0D\u5728 canvas \u4E0A\u79FB\u52A8
                if (_this.dragging || _this.currentShape) {
                    var pointInfo = _this._getPointInfo(ev);
                    // \u8FD8\u5728\u62D6\u62FD\u8FC7\u7A0B\u4E2D
                    if (_this.dragging) {
                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);
                    }
                    // \u8BF4\u660E\u4ECE\u67D0\u4E2A\u56FE\u5F62\u76F4\u63A5\u79FB\u52A8\u5230\u4E86\u753B\u5E03\u5916\u9762\uFF0C
                    // \u4FEE\u590D\u4E86 mouseleave \u7684 bug \u540E\u4E0D\u518D\u51FA\u73B0\u8FD9\u79CD\u60C5\u51B5
                    // if (this.currentShape) {
                    //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);
                    //   this.currentShape = null;
                    // }
                }
            }
        };
        // \u5728 document \u4E0A\u5904\u7406\u62D6\u62FD\u5230\u5916\u9762\uFF0C\u91CA\u653E\u9F20\u6807\u65F6\u89E6\u53D1 dragend
        this._onDocumentMouseUp = function (ev) {
            var canvas = _this.canvas;
            var el = canvas.get('el');
            if (el !== ev.target) {
                // \u4E0D\u5728 canvas \u4E0A\u79FB\u52A8
                if (_this.dragging) {
                    var pointInfo = _this._getPointInfo(ev);
                    if (_this.draggingShape) {
                        // \u5982\u679C\u5B58\u5728\u62D6\u62FD\u7684\u56FE\u5F62\uFF0C\u5219\u4E5F\u89E6\u53D1 drop \u4E8B\u4EF6
                        _this._emitEvent('drop', ev, pointInfo, null);
                    }
                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);
                    _this._afterDrag(_this.draggingShape, pointInfo, ev);
                }
            }
        };
        this.canvas = cfg.canvas;
    }
    EventController.prototype.init = function () {
        this._bindEvents();
    };
    // \u6CE8\u518C\u4E8B\u4EF6
    EventController.prototype._bindEvents = function () {
        var _this = this;
        var el = this.canvas.get('el');
        (0,util/* each */.S6)(EVENTS, function (eventName) {
            el.addEventListener(eventName, _this._eventCallback);
        });
        if (document) {
            // \u5904\u7406\u79FB\u52A8\u5230\u5916\u9762\u6CA1\u6709\u89E6\u53D1 shape mouse leave \u7684\u4E8B\u4EF6
            // \u5904\u7406\u62D6\u62FD\u5230\u5916\u90E8\u7684\u95EE\u9898
            document.addEventListener('mousemove', this._onDocumentMove);
            // \u5904\u7406\u62D6\u62FD\u8FC7\u7A0B\u4E2D\u5728\u5916\u90E8\u91CA\u653E\u9F20\u6807\u7684\u95EE\u9898
            document.addEventListener('mouseup', this._onDocumentMouseUp);
        }
    };
    // \u6E05\u7406\u4E8B\u4EF6
    EventController.prototype._clearEvents = function () {
        var _this = this;
        var el = this.canvas.get('el');
        (0,util/* each */.S6)(EVENTS, function (eventName) {
            el.removeEventListener(eventName, _this._eventCallback);
        });
        if (document) {
            document.removeEventListener('mousemove', this._onDocumentMove);
            document.removeEventListener('mouseup', this._onDocumentMouseUp);
        }
    };
    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {
        var eventObj = new graph_event/* default */.Z(type, event);
        eventObj.fromShape = fromShape;
        eventObj.toShape = toShape;
        eventObj.x = point.x;
        eventObj.y = point.y;
        eventObj.clientX = point.clientX;
        eventObj.clientY = point.clientY;
        eventObj.propagationPath.push(target);
        // \u4E8B\u4EF6\u7684x,y\u5E94\u8BE5\u662F\u57FA\u4E8E\u753B\u5E03\u5DE6\u4E0A\u89D2\u7684\uFF0C\u4E0Ecanvas\u7684matrix\u65E0\u5173
        return eventObj;
    };
    // \u6839\u636E\u70B9\u83B7\u53D6\u56FE\u5F62\uFF0C\u63D0\u53D6\u6210\u72EC\u7ACB\u65B9\u6CD5\uFF0C\u4FBF\u4E8E\u540E\u7EED\u4F18\u5316
    EventController.prototype._getShape = function (point, ev) {
        return this.canvas.getShape(point.x, point.y, ev);
    };
    // \u83B7\u53D6\u4E8B\u4EF6\u7684\u5F53\u524D\u70B9\u7684\u4FE1\u606F
    EventController.prototype._getPointInfo = function (ev) {
        var canvas = this.canvas;
        var clientPoint = canvas.getClientByEvent(ev);
        var point = canvas.getPointByEvent(ev);
        return {
            x: point.x,
            y: point.y,
            clientX: clientPoint.x,
            clientY: clientPoint.y,
        };
    };
    // \u89E6\u53D1\u4E8B\u4EF6
    EventController.prototype._triggerEvent = function (type, ev) {
        var pointInfo = this._getPointInfo(ev);
        // \u6BCF\u6B21\u90FD\u83B7\u53D6\u56FE\u5F62\u6709\u4E00\u5B9A\u6210\u672C\uFF0C\u540E\u671F\u53EF\u4EE5\u8003\u8651\u8FDB\u884C\u7F13\u5B58\u7B56\u7565
        var shape = this._getShape(pointInfo, ev);
        var method = this["_on" + type];
        var leaveCanvas = false;
        if (method) {
            method.call(this, pointInfo, shape, ev);
        }
        else {
            var preShape = this.currentShape;
            // \u5982\u679C\u8FDB\u5165\u3001\u79FB\u51FA\u753B\u5E03\u65F6\u5B58\u5728\u56FE\u5F62\uFF0C\u5219\u8981\u5206\u522B\u89E6\u53D1\u4E8B\u4EF6
            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {
                this._emitEvent(type, ev, pointInfo, null, null, shape); // \u5148\u8FDB\u5165\u753B\u5E03
                if (shape) {
                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // \u518D\u89E6\u53D1\u56FE\u5F62\u7684\u4E8B\u4EF6
                }
                if (type === 'mouseenter' && this.draggingShape) {
                    // \u5982\u679C\u6B63\u5728\u62D6\u62FD\u56FE\u5F62, \u5219\u89E6\u53D1 dragleave
                    this._emitEvent('dragenter', ev, pointInfo, null);
                }
            }
            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {
                leaveCanvas = true;
                if (preShape) {
                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // \u5148\u89E6\u53D1\u56FE\u5F62\u7684\u4E8B\u4EF6
                }
                this._emitEvent(type, ev, pointInfo, null, preShape, null); // \u518D\u89E6\u53D1\u79BB\u5F00\u753B\u5E03\u4E8B\u4EF6
                if (type === 'mouseleave' && this.draggingShape) {
                    this._emitEvent('dragleave', ev, pointInfo, null);
                }
            }
            else {
                this._emitEvent(type, ev, pointInfo, shape, null, null); // \u4E00\u822C\u4E8B\u4EF6\u4E2D\u4E0D\u9700\u8981\u8003\u8651 from, to
            }
        }
        if (!leaveCanvas) {
            this.currentShape = shape;
        }
        // \u5F53\u9F20\u6807\u4ECE\u753B\u5E03\u79FB\u52A8\u5230 shape \u6216\u8005\u4ECE preShape \u79FB\u52A8\u5230 shape \u65F6\uFF0C\u5E94\u7528 shape \u4E0A\u7684\u9F20\u6807\u6837\u5F0F
        if (shape && !shape.get('destroyed')) {
            var canvas = this.canvas;
            var el = canvas.get('el');
            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');
        }
    };
    // \u8BB0\u5F55\u4E0B\u70B9\u51FB\u7684\u4F4D\u7F6E\u3001\u56FE\u5F62\uFF0C\u4FBF\u4E8E\u62D6\u62FD\u4E8B\u4EF6\u3001click \u4E8B\u4EF6\u7684\u5224\u5B9A
    EventController.prototype._onmousedown = function (pointInfo, shape, event) {
        // \u53EA\u6709\u9F20\u6807\u5DE6\u952E\u7684 mousedown \u4E8B\u4EF6\u624D\u4F1A\u8BBE\u7F6E mousedownShape \u7B49\u5C5E\u6027\uFF0C\u907F\u514D\u9F20\u6807\u53F3\u952E\u7684 mousedown \u4E8B\u4EF6\u5F15\u8D77\u5176\u4ED6\u4E8B\u4EF6\u53D1\u751F
        if (event.button === LEFT_BTN_CODE) {
            this.mousedownShape = shape;
            this.mousedownPoint = pointInfo;
            this.mousedownTimeStamp = event.timeStamp;
        }
        this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown \u4E0D\u8003\u8651fromShape, toShape
    };
    // mouseleave \u548C mouseenter \u90FD\u662F\u6210\u5BF9\u5B58\u5728\u7684
    // mouseenter \u548C mouseover \u540C\u65F6\u89E6\u53D1
    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {
        var el = this.canvas.get('el');
        if (fromShape !== toShape) {
            if (fromShape) {
                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);
                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);
                // \u5F53\u9F20\u6807\u4ECE fromShape \u79FB\u52A8\u5230\u753B\u5E03\u4E0A\u65F6\uFF0C\u91CD\u7F6E\u9F20\u6807\u6837\u5F0F
                if (!toShape || toShape.get('destroyed')) {
                    el.style.cursor = this.canvas.get('cursor');
                }
            }
            if (toShape) {
                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);
                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);
            }
        }
    };
    // dragover \u4E0D\u7B49\u540C\u4E8E mouseover\uFF0C\u800C\u7B49\u540C\u4E8E mousemove
    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {
        if (toShape) {
            if (toShape !== fromShape) {
                if (fromShape) {
                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);
                }
                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);
            }
            if (!isCanvasEmit) {
                this._emitEvent('dragover', event, pointInfo, toShape);
            }
        }
        else if (fromShape) {
            // TODO: \u6B64\u5904\u5224\u65AD\u6709\u95EE\u9898\uFF0C\u5F53 drag \u56FE\u5F62\u65F6\uFF0C\u4E5F\u4F1A\u89E6\u53D1\u4E00\u6B21 dragleave \u4E8B\u4EF6\uFF0C\u56E0\u4E3A\u6B64\u65F6 toShape \u4E3A null\uFF0C\u8FD9\u4E0D\u662F\u6240\u671F\u671B\u7684
            // \u7ECF\u8FC7\u7A7A\u767D\u533A\u57DF
            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);
        }
        if (isCanvasEmit) {
            this._emitEvent('dragover', event, pointInfo, toShape);
        }
    };
    // drag \u5B8C\u6210\u540E\uFF0C\u9700\u8981\u505A\u4E00\u4E9B\u6E05\u7406\u5DE5\u4F5C
    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {
        if (draggingShape) {
            draggingShape.set('capture', true); // \u6062\u590D\u53EF\u4EE5\u62FE\u53D6
            this.draggingShape = null;
        }
        this.dragging = false;
        // drag \u5B8C\u6210\u540E\uFF0C\u6709\u53EF\u80FD draggingShape \u5DF2\u7ECF\u79FB\u52A8\u5230\u4E86\u5F53\u524D\u4F4D\u7F6E\uFF0C\u6240\u4EE5\u4E0D\u80FD\u76F4\u63A5\u53D6\u5F53\u524D\u56FE\u5F62
        var shape = this._getShape(pointInfo, event);
        // \u62D6\u62FD\u5B8C\u6210\u540E\uFF0C\u8FDB\u884C enter\uFF0Cleave \u7684\u5224\u5B9A
        if (shape !== draggingShape) {
            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
        }
        this.currentShape = shape; // \u66F4\u65B0\u5F53\u524D shape\uFF0C\u5982\u679C\u4E0D\u5904\u7406\u5F53\u524D\u56FE\u5F62\u7684 mouseleave \u4E8B\u4EF6\u53EF\u80FD\u4F1A\u51FA\u95EE\u9898
    };
    // \u6309\u952E\u62AC\u8D77\u65F6\uFF0C\u4F1A\u7EC8\u6B62\u62D6\u62FD\u3001\u89E6\u53D1\u70B9\u51FB
    EventController.prototype._onmouseup = function (pointInfo, shape, event) {
        // eevent.button === 0 \u8868\u793A\u9F20\u6807\u5DE6\u952E\u4E8B\u4EF6\uFF0C\u6B64\u5904\u52A0\u4E0A\u5224\u65AD\u4E3B\u8981\u662F\u4E3A\u4E86\u907F\u514D\u53F3\u952E\u9F20\u6807\u4F1A\u89E6\u53D1 mouseup \u548C click \u4E8B\u4EF6
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
        if (event.button === LEFT_BTN_CODE) {
            var draggingShape = this.draggingShape;
            if (this.dragging) {
                // \u5B58\u5728\u53EF\u4EE5\u62D6\u62FD\u7684\u56FE\u5F62\uFF0C\u540C\u65F6\u62D6\u62FD\u5230\u5176\u4ED6\u56FE\u5F62\u4E0A\u65F6\u89E6\u53D1 drag \u4E8B\u4EF6
                if (draggingShape) {
                    this._emitEvent('drop', event, pointInfo, shape);
                }
                this._emitEvent('dragend', event, pointInfo, draggingShape);
                this._afterDrag(draggingShape, pointInfo, event);
            }
            else {
                this._emitEvent('mouseup', event, pointInfo, shape); // \u5148\u89E6\u53D1 mouseup \u518D\u89E6\u53D1 click
                if (shape === this.mousedownShape) {
                    this._emitEvent('click', event, pointInfo, shape);
                }
                this.mousedownShape = null;
                this.mousedownPoint = null;
            }
        }
    };
    // \u5F53\u89E6\u53D1\u6D4F\u89C8\u5668\u7684 dragover \u4E8B\u4EF6\u65F6\uFF0C\u4E0D\u4F1A\u518D\u89E6\u53D1 mousemove \uFF0C\u6240\u4EE5\u8FD9\u65F6\u5019\u7684 dragenter, dragleave \u4E8B\u4EF6\u9700\u8981\u91CD\u65B0\u5904\u7406
    EventController.prototype._ondragover = function (pointInfo, shape, event) {
        event.preventDefault(); // \u5982\u679C\u4E0D\u5BF9 dragover \u8FDB\u884C preventDefault\uFF0C\u5219\u4E0D\u4F1A\u5728 canvas \u4E0A\u89E6\u53D1 drop \u4E8B\u4EF6
        var preShape = this.currentShape;
        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    // \u5927\u91CF\u7684\u56FE\u5F62\u4E8B\u4EF6\uFF0C\u90FD\u901A\u8FC7 mousemove \u6A21\u62DF
    EventController.prototype._onmousemove = function (pointInfo, shape, event) {
        var canvas = this.canvas;
        var preShape = this.currentShape;
        var draggingShape = this.draggingShape;
        // \u6B63\u5728\u62D6\u62FD\u65F6
        if (this.dragging) {
            // \u6B63\u5728\u62D6\u62FD\u4E2D
            if (draggingShape) {
                // \u5982\u679C\u62D6\u62FD\u4E86 shape \u4F1A\u89E6\u53D1 dragenter, dragleave, dragover \u548C drag \u4E8B\u4EF6
                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
            }
            // \u5982\u679C\u5B58\u5728 draggingShape \u5219\u4F1A\u5728 draggingShape \u4E0A\u89E6\u53D1 drag \u4E8B\u4EF6\uFF0C\u5192\u6CE1\u5230 canvas \u4E0A
            // \u5426\u5219\u5728 canvas \u4E0A\u89E6\u53D1 drag \u4E8B\u4EF6
            this._emitEvent('drag', event, pointInfo, draggingShape);
        }
        else {
            var mousedownPoint = this.mousedownPoint;
            if (mousedownPoint) {
                // \u5F53\u9F20\u6807\u70B9\u51FB\u4E0B\u53BB\uFF0C\u540C\u65F6\u79FB\u52A8\u65F6\uFF0C\u8FDB\u884C drag \u5224\u5B9A
                var mousedownShape = this.mousedownShape;
                var now = event.timeStamp;
                var timeWindow = now - this.mousedownTimeStamp;
                var dx = mousedownPoint.clientX - pointInfo.clientX;
                var dy = mousedownPoint.clientY - pointInfo.clientY;
                var dist = dx * dx + dy * dy;
                if (timeWindow > 120 || dist > CLICK_OFFSET) {
                    if (mousedownShape && mousedownShape.get('draggable')) {
                        // \u8BBE\u7F6E\u4E86 draggable \u7684 shape \u624D\u80FD\u89E6\u53D1 drag \u76F8\u5173\u7684\u4E8B\u4EF6
                        draggingShape = this.mousedownShape; // \u62D6\u52A8\u9F20\u6807\u70B9\u4E0B\u65F6\u7684 shape
                        draggingShape.set('capture', false); // \u7981\u6B62\u7EE7\u7EED\u62FE\u53D6\uFF0C\u5426\u5219\u65E0\u6CD5\u8FDB\u884C dragover,dragenter,dragleave,drop\u7684\u5224\u5B9A
                        this.draggingShape = draggingShape;
                        this.dragging = true;
                        this._emitEvent('dragstart', event, pointInfo, draggingShape);
                        // \u6E05\u7406\u6309\u4E0B\u9F20\u6807\u65F6\u7F13\u5B58\u7684\u503C
                        this.mousedownShape = null;
                        this.mousedownPoint = null;
                    }
                    else if (!mousedownShape && canvas.get('draggable')) {
                        // \u8BBE\u7F6E\u4E86 draggable \u7684 canvas \u624D\u80FD\u89E6\u53D1 drag \u76F8\u5173\u7684\u4E8B\u4EF6
                        this.dragging = true;
                        this._emitEvent('dragstart', event, pointInfo, null);
                        // \u6E05\u7406\u6309\u4E0B\u9F20\u6807\u65F6\u7F13\u5B58\u7684\u503C
                        this.mousedownShape = null;
                        this.mousedownPoint = null;
                    }
                    else {
                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
                        this._emitEvent('mousemove', event, pointInfo, shape);
                    }
                }
                else {
                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);
                    this._emitEvent('mousemove', event, pointInfo, shape);
                }
            }
            else {
                // \u6CA1\u6709\u6309\u952E\u6309\u4E0B\u65F6\uFF0C\u5219\u76F4\u63A5\u89E6\u53D1 mouse over \u76F8\u5173\u7684\u5404\u79CD\u4E8B\u4EF6
                this._emitMouseoverEvents(event, pointInfo, preShape, shape);
                // \u59CB\u7EC8\u89E6\u53D1\u79FB\u52A8
                this._emitEvent('mousemove', event, pointInfo, shape);
            }
        }
    };
    // \u89E6\u53D1\u4E8B\u4EF6
    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {
        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
        // \u5B58\u5728 shape \u89E6\u53D1\uFF0C\u5219\u8FDB\u884C\u5192\u6CE1\u5904\u7406
        if (shape) {
            eventObj.shape = shape;
            // \u89E6\u53D1 shape \u4E0A\u7684\u4E8B\u4EF6
            emitTargetEvent(shape, type, eventObj);
            var parent_1 = shape.getParent();
            // \u6267\u884C\u5192\u6CE1
            while (parent_1) {
                // \u59D4\u6258\u4E8B\u4EF6\u8981\u5148\u89E6\u53D1
                parent_1.emitDelegation(type, eventObj);
                // \u4E8B\u4EF6\u5192\u6CE1\u505C\u6B62\uFF0C\u4E0D\u80FD\u59A8\u788D\u59D4\u6258\u4E8B\u4EF6
                if (!eventObj.propagationStopped) {
                    bubbleEvent(parent_1, type, eventObj);
                }
                eventObj.propagationPath.push(parent_1);
                parent_1 = parent_1.getParent();
            }
        }
        else {
            // \u5982\u679C\u6CA1\u6709 shape \u76F4\u63A5\u5728 canvas \u4E0A\u89E6\u53D1
            var canvas = this.canvas;
            // \u76F4\u63A5\u89E6\u53D1 canvas \u4E0A\u7684\u4E8B\u4EF6
            emitTargetEvent(canvas, type, eventObj);
        }
    };
    EventController.prototype.destroy = function () {
        // \u6E05\u7406\u4E8B\u4EF6
        this._clearEvents();
        // \u6E05\u7406\u7F13\u5B58\u7684\u5BF9\u8C61
        this.canvas = null;
        this.currentShape = null;
        this.draggingShape = null;
        this.mousedownPoint = null;
        this.mousedownShape = null;
        this.mousedownTimeStamp = null;
    };
    return EventController;
}());
/* harmony default export */ var event_contoller = (EventController);
//# sourceMappingURL=event-contoller.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/abstract/canvas.js






var PX_SUFFIX = 'px';
var browser = (0,es/* detect */.qY)();
var isFirefox = browser && browser.name === 'firefox';
var Canvas = /** @class */ (function (_super) {
    (0,tslib_es6/* __extends */.ZT)(Canvas, _super);
    function Canvas(cfg) {
        var _this = _super.call(this, cfg) || this;
        _this.initContainer();
        _this.initDom();
        _this.initEvents();
        _this.initTimeline();
        return _this;
    }
    Canvas.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        // set default cursor style for canvas
        cfg['cursor'] = 'default';
        // CSS transform \u76EE\u524D\u5C1A\u672A\u7ECF\u8FC7\u957F\u65F6\u95F4\u9A8C\u8BC1\uFF0C\u4E3A\u4E86\u907F\u514D\u5F71\u54CD\u4E0A\u5C42\u4E1A\u52A1\uFF0C\u9ED8\u8BA4\u5173\u95ED\uFF0C\u4E0A\u5C42\u6309\u9700\u5F00\u542F
        cfg['supportCSSTransform'] = false;
        return cfg;
    };
    /**
     * @protected
     * \u521D\u59CB\u5316\u5BB9\u5668
     */
    Canvas.prototype.initContainer = function () {
        var container = this.get('container');
        if ((0,util/* isString */.HD)(container)) {
            container = document.getElementById(container);
            this.set('container', container);
        }
    };
    /**
     * @protected
     * \u521D\u59CB\u5316 DOM
     */
    Canvas.prototype.initDom = function () {
        var el = this.createDom();
        this.set('el', el);
        // \u9644\u52A0\u5230\u5BB9\u5668
        var container = this.get('container');
        container.appendChild(el);
        // \u8BBE\u7F6E\u521D\u59CB\u5BBD\u5EA6
        this.setDOMSize(this.get('width'), this.get('height'));
    };
    /**
     * @protected
     * \u521D\u59CB\u5316\u7ED1\u5B9A\u7684\u4E8B\u4EF6
     */
    Canvas.prototype.initEvents = function () {
        var eventController = new event_contoller({
            canvas: this,
        });
        eventController.init();
        this.set('eventController', eventController);
    };
    /**
     * @protected
     * \u521D\u59CB\u5316\u65F6\u95F4\u8F74
     */
    Canvas.prototype.initTimeline = function () {
        var timeline = new animate_timeline(this);
        this.set('timeline', timeline);
    };
    /**
     * @protected
     * \u4FEE\u6539\u753B\u5E03\u5BF9\u5E94\u7684 DOM \u7684\u5927\u5C0F
     * @param {number} width  \u5BBD\u5EA6
     * @param {number} height \u9AD8\u5EA6
     */
    Canvas.prototype.setDOMSize = function (width, height) {
        var el = this.get('el');
        if (util/* isBrowser */.jU) {
            el.style.width = width + PX_SUFFIX;
            el.style.height = height + PX_SUFFIX;
        }
    };
    // \u5B9E\u73B0\u63A5\u53E3
    Canvas.prototype.changeSize = function (width, height) {
        this.setDOMSize(width, height);
        this.set('width', width);
        this.set('height', height);
        this.onCanvasChange('changeSize');
    };
    /**
     * \u83B7\u53D6\u5F53\u524D\u7684\u6E32\u67D3\u5F15\u64CE
     * @return {Renderer} \u8FD4\u56DE\u5F53\u524D\u7684\u6E32\u67D3\u5F15\u64CE
     */
    Canvas.prototype.getRenderer = function () {
        return this.get('renderer');
    };
    /**
     * \u83B7\u53D6\u753B\u5E03\u7684 cursor \u6837\u5F0F
     * @return {Cursor}
     */
    Canvas.prototype.getCursor = function () {
        return this.get('cursor');
    };
    /**
     * \u8BBE\u7F6E\u753B\u5E03\u7684 cursor \u6837\u5F0F
     * @param {Cursor} cursor  cursor \u6837\u5F0F
     */
    Canvas.prototype.setCursor = function (cursor) {
        this.set('cursor', cursor);
        var el = this.get('el');
        if (util/* isBrowser */.jU && el) {
            // \u76F4\u63A5\u8BBE\u7F6E\u6837\u5F0F\uFF0C\u4E0D\u7B49\u5F85\u9F20\u6807\u79FB\u52A8\u65F6\u518D\u8BBE\u7F6E
            el.style.cursor = cursor;
        }
    };
    // \u5B9E\u73B0\u63A5\u53E3
    Canvas.prototype.getPointByEvent = function (ev) {
        var supportCSSTransform = this.get('supportCSSTransform');
        if (supportCSSTransform) {
            // For Firefox <= 38
            if (isFirefox && !(0,util/* isNil */.kK)(ev.layerX) && ev.layerX !== ev.offsetX) {
                return {
                    x: ev.layerX,
                    y: ev.layerY,
                };
            }
            if (!(0,util/* isNil */.kK)(ev.offsetX)) {
                // For IE6+, Firefox >= 39, Chrome, Safari, Opera
                return {
                    x: ev.offsetX,
                    y: ev.offsetY,
                };
            }
        }
        // should calculate by self for other cases, like Safari in ios
        // TODO: support CSS transform
        var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;
        return this.getPointByClient(clientX, clientY);
    };
    // \u83B7\u53D6 touch \u4E8B\u4EF6\u7684 clientX \u548C clientY \u9700\u8981\u5355\u72EC\u5904\u7406
    Canvas.prototype.getClientByEvent = function (ev) {
        var clientInfo = ev;
        if (ev.touches) {
            if (ev.type === 'touchend') {
                clientInfo = ev.changedTouches[0];
            }
            else {
                clientInfo = ev.touches[0];
            }
        }
        return {
            x: clientInfo.clientX,
            y: clientInfo.clientY,
        };
    };
    // \u5B9E\u73B0\u63A5\u53E3
    Canvas.prototype.getPointByClient = function (clientX, clientY) {
        var el = this.get('el');
        var bbox = el.getBoundingClientRect();
        return {
            x: clientX - bbox.left,
            y: clientY - bbox.top,
        };
    };
    // \u5B9E\u73B0\u63A5\u53E3
    Canvas.prototype.getClientByPoint = function (x, y) {
        var el = this.get('el');
        var bbox = el.getBoundingClientRect();
        return {
            x: x + bbox.left,
            y: y + bbox.top,
        };
    };
    // \u5B9E\u73B0\u63A5\u53E3
    Canvas.prototype.draw = function () { };
    /**
     * @protected
     * \u9500\u6BC1 DOM \u5BB9\u5668
     */
    Canvas.prototype.removeDom = function () {
        var el = this.get('el');
        el.parentNode.removeChild(el);
    };
    /**
     * @protected
     * \u6E05\u7406\u6240\u6709\u7684\u4E8B\u4EF6
     */
    Canvas.prototype.clearEvents = function () {
        var eventController = this.get('eventController');
        eventController.destroy();
    };
    Canvas.prototype.isCanvas = function () {
        return true;
    };
    Canvas.prototype.getParent = function () {
        return null;
    };
    Canvas.prototype.destroy = function () {
        var timeline = this.get('timeline');
        if (this.get('destroyed')) {
            return;
        }
        this.clear();
        // \u540C\u521D\u59CB\u5316\u65F6\u76F8\u53CD\u987A\u5E8F\u8C03\u7528
        if (timeline) {
            // \u753B\u5E03\u9500\u6BC1\u65F6\u81EA\u52A8\u505C\u6B62\u52A8\u753B
            timeline.stop();
        }
        this.clearEvents();
        this.removeDom();
        _super.prototype.destroy.call(this);
    };
    return Canvas;
}(container/* default */.Z));
/* harmony default export */ var canvas = (Canvas);
//# sourceMappingURL=canvas.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/canvas.js_+_18_modules?`)},37153:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97582);
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29881);
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77341);



var SHAPE_MAP = {};
var INDEX = '_INDEX';
/**
 * \u8BBE\u7F6E canvas
 * @param {IElement} element \u5143\u7D20
 * @param {ICanvas}  canvas  \u753B\u5E03
 */
function setCanvas(element, canvas) {
    element.set('canvas', canvas);
    if (element.isGroup()) {
        var children = element.get('children');
        if (children.length) {
            children.forEach(function (child) {
                setCanvas(child, canvas);
            });
        }
    }
}
/**
 * \u8BBE\u7F6E timeline
 * @param {IElement} element  \u5143\u7D20
 * @param {Timeline} timeline \u65F6\u95F4\u8F74
 */
function setTimeline(element, timeline) {
    element.set('timeline', timeline);
    if (element.isGroup()) {
        var children = element.get('children');
        if (children.length) {
            children.forEach(function (child) {
                setTimeline(child, timeline);
            });
        }
    }
}
function contains(container, element) {
    var children = container.getChildren();
    return children.indexOf(element) >= 0;
}
function removeChild(container, element, destroy) {
    if (destroy === void 0) { destroy = true; }
    // \u4E0D\u518D\u8C03\u7528 element.remove() \u65B9\u6CD5\uFF0C\u4F1A\u51FA\u73B0\u5FAA\u73AF\u8C03\u7528
    if (destroy) {
        element.destroy();
    }
    else {
        element.set('parent', null);
        element.set('canvas', null);
    }
    (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .removeFromArray */ .As)(container.getChildren(), element);
}
function getComparer(compare) {
    return function (left, right) {
        var result = compare(left, right);
        return result === 0 ? left[INDEX] - right[INDEX] : result;
    };
}
var Container = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT)(Container, _super);
    function Container() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Container.prototype.isCanvas = function () {
        return false;
    };
    // \u6839\u636E\u5B50\u8282\u70B9\u786E\u5B9A BBox
    Container.prototype.getBBox = function () {
        // \u6240\u6709\u7684\u503C\u53EF\u80FD\u5728\u753B\u5E03\u7684\u53EF\u89C6\u533A\u5916
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        // \u5C06\u53EF\u89C1\u5143\u7D20\u3001\u56FE\u5F62\u4EE5\u53CA\u4E0D\u4E3A\u7A7A\u7684\u56FE\u5F62\u5206\u7EC4\u7B5B\u9009\u51FA\u6765\uFF0C\u7528\u4E8E\u5305\u56F4\u76D2\u5408\u5E76
        var children = this.getChildren().filter(function (child) {
            return child.get('visible') && (!child.isGroup() || (child.isGroup() && child.getChildren().length > 0));
        });
        if (children.length > 0) {
            (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (child) {
                var _a = child.getBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;
                if (childMinX < minX) {
                    minX = childMinX;
                }
                if (childMaxX > maxX) {
                    maxX = childMaxX;
                }
                if (childMinY < minY) {
                    minY = childMinY;
                }
                if (childMaxY > maxY) {
                    maxY = childMaxY;
                }
            });
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var box = {
            x: minX,
            y: minY,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };
        return box;
    };
    // \u83B7\u53D6\u753B\u5E03\u7684\u5305\u56F4\u76D2
    Container.prototype.getCanvasBBox = function () {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        // \u5C06\u53EF\u89C1\u5143\u7D20\u3001\u56FE\u5F62\u4EE5\u53CA\u4E0D\u4E3A\u7A7A\u7684\u56FE\u5F62\u5206\u7EC4\u7B5B\u9009\u51FA\u6765\uFF0C\u7528\u4E8E\u5305\u56F4\u76D2\u5408\u5E76
        var children = this.getChildren().filter(function (child) {
            return child.get('visible') && (!child.isGroup() || (child.isGroup() && child.getChildren().length > 0));
        });
        if (children.length > 0) {
            (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (child) {
                var _a = child.getCanvasBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;
                if (childMinX < minX) {
                    minX = childMinX;
                }
                if (childMaxX > maxX) {
                    maxX = childMaxX;
                }
                if (childMinY < minY) {
                    minY = childMinY;
                }
                if (childMaxY > maxY) {
                    maxY = childMaxY;
                }
            });
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var box = {
            x: minX,
            y: minY,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };
        return box;
    };
    Container.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        cfg['children'] = [];
        return cfg;
    };
    Container.prototype.onAttrChange = function (name, value, originValue) {
        _super.prototype.onAttrChange.call(this, name, value, originValue);
        if (name === 'matrix') {
            var totalMatrix = this.getTotalMatrix();
            this._applyChildrenMarix(totalMatrix);
        }
    };
    // \u4E0D\u4F46\u5E94\u7528\u5230\u81EA\u5DF1\u8EAB\u4E0A\u8FD8\u8981\u5E94\u7528\u4E8E\u5B50\u5143\u7D20
    Container.prototype.applyMatrix = function (matrix) {
        var preTotalMatrix = this.getTotalMatrix();
        _super.prototype.applyMatrix.call(this, matrix);
        var totalMatrix = this.getTotalMatrix();
        // totalMatrix \u6CA1\u6709\u53D1\u751F\u53D8\u5316\u65F6\uFF0C\u8FD9\u91CC\u4EC5\u8003\u8651\u4E24\u8005\u90FD\u4E3A null \u65F6
        // \u4E0D\u7EE7\u7EED\u5411\u4E0B\u4F20\u9012\u77E9\u9635
        if (totalMatrix === preTotalMatrix) {
            return;
        }
        this._applyChildrenMarix(totalMatrix);
    };
    // \u5728\u5B50\u5143\u7D20\u4E0A\u8BBE\u7F6E\u77E9\u9635
    Container.prototype._applyChildrenMarix = function (totalMatrix) {
        var children = this.getChildren();
        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (child) {
            child.applyMatrix(totalMatrix);
        });
    };
    // \u517C\u5BB9\u8001\u7248\u672C\u7684\u63A5\u53E3
    Container.prototype.addShape = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var type = args[0];
        var cfg = args[1];
        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Kn)(type)) {
            cfg = type;
        }
        else {
            cfg['type'] = type;
        }
        var shapeType = SHAPE_MAP[cfg.type];
        if (!shapeType) {
            shapeType = (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .upperFirst */ .jC)(cfg.type);
            SHAPE_MAP[cfg.type] = shapeType;
        }
        var ShapeBase = this.getShapeBase();
        var shape = new ShapeBase[shapeType](cfg);
        this.add(shape);
        return shape;
    };
    Container.prototype.addGroup = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var groupClass = args[0], cfg = args[1];
        var group;
        if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .mf)(groupClass)) {
            if (cfg) {
                group = new groupClass(cfg);
            }
            else {
                group = new groupClass({
                    // canvas,
                    parent: this,
                });
            }
        }
        else {
            var tmpCfg = groupClass || {};
            var TmpGroupClass = this.getGroupBase();
            group = new TmpGroupClass(tmpCfg);
        }
        this.add(group);
        return group;
    };
    Container.prototype.getCanvas = function () {
        var canvas;
        if (this.isCanvas()) {
            canvas = this;
        }
        else {
            canvas = this.get('canvas');
        }
        return canvas;
    };
    Container.prototype.getShape = function (x, y, ev) {
        // \u5982\u679C\u4E0D\u652F\u6301\u62FE\u53D6\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE
        if (!(0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .isAllowCapture */ .pP)(this)) {
            return null;
        }
        var children = this.getChildren();
        var shape;
        // \u5982\u679C\u5BB9\u5668\u662F group
        if (!this.isCanvas()) {
            var v = [x, y, 1];
            // \u5C06 x, y \u8F6C\u6362\u6210\u5BF9\u5E94\u4E8E group \u7684\u5C40\u90E8\u5750\u6807
            v = this.invertFromMatrix(v);
            if (!this.isClipped(v[0], v[1])) {
                shape = this._findShape(children, v[0], v[1], ev);
            }
        }
        else {
            shape = this._findShape(children, x, y, ev);
        }
        return shape;
    };
    Container.prototype._findShape = function (children, x, y, ev) {
        var shape = null;
        for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            if ((0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .isAllowCapture */ .pP)(child)) {
                if (child.isGroup()) {
                    shape = child.getShape(x, y, ev);
                }
                else if (child.isHit(x, y)) {
                    shape = child;
                }
            }
            if (shape) {
                break;
            }
        }
        return shape;
    };
    Container.prototype.add = function (element) {
        var canvas = this.getCanvas();
        var children = this.getChildren();
        var timeline = this.get('timeline');
        var preParent = element.getParent();
        if (preParent) {
            removeChild(preParent, element, false);
        }
        element.set('parent', this);
        if (canvas) {
            setCanvas(element, canvas);
        }
        if (timeline) {
            setTimeline(element, timeline);
        }
        children.push(element);
        element.onCanvasChange('add');
        this._applyElementMatrix(element);
    };
    // \u5C06\u5F53\u524D\u5BB9\u5668\u7684\u77E9\u9635\u5E94\u7528\u5230\u5B50\u5143\u7D20
    Container.prototype._applyElementMatrix = function (element) {
        var totalMatrix = this.getTotalMatrix();
        // \u6DFB\u52A0\u56FE\u5F62\u6216\u8005\u5206\u7EC4\u65F6\uFF0C\u9700\u8981\u628A\u5F53\u524D\u56FE\u5143\u7684\u77E9\u9635\u8BBE\u7F6E\u8FDB\u53BB
        if (totalMatrix) {
            element.applyMatrix(totalMatrix);
        }
    };
    Container.prototype.getChildren = function () {
        return this.get('children');
    };
    Container.prototype.sort = function () {
        var children = this.getChildren();
        // \u7A33\u5B9A\u6392\u5E8F
        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (child, index) {
            child[INDEX] = index;
            return child;
        });
        children.sort(getComparer(function (obj1, obj2) {
            return obj1.get('zIndex') - obj2.get('zIndex');
        }));
        this.onCanvasChange('sort');
    };
    Container.prototype.clear = function () {
        this.set('clearing', true);
        if (this.destroyed) {
            return;
        }
        var children = this.getChildren();
        for (var i = children.length - 1; i >= 0; i--) {
            children[i].destroy(); // \u9500\u6BC1\u5B50\u5143\u7D20
        }
        this.set('children', []);
        this.onCanvasChange('clear');
        this.set('clearing', false);
    };
    Container.prototype.destroy = function () {
        if (this.get('destroyed')) {
            return;
        }
        this.clear();
        _super.prototype.destroy.call(this);
    };
    /**
     * \u83B7\u53D6\u7B2C\u4E00\u4E2A\u5B50\u5143\u7D20
     * @return {IElement} \u7B2C\u4E00\u4E2A\u5143\u7D20
     */
    Container.prototype.getFirst = function () {
        return this.getChildByIndex(0);
    };
    /**
     * \u83B7\u53D6\u6700\u540E\u4E00\u4E2A\u5B50\u5143\u7D20
     * @return {IElement} \u5143\u7D20
     */
    Container.prototype.getLast = function () {
        var children = this.getChildren();
        return this.getChildByIndex(children.length - 1);
    };
    /**
     * \u6839\u636E\u7D22\u5F15\u83B7\u53D6\u5B50\u5143\u7D20
     * @return {IElement} \u7B2C\u4E00\u4E2A\u5143\u7D20
     */
    Container.prototype.getChildByIndex = function (index) {
        var children = this.getChildren();
        return children[index];
    };
    /**
     * \u5B50\u5143\u7D20\u7684\u6570\u91CF
     * @return {number} \u5B50\u5143\u7D20\u6570\u91CF
     */
    Container.prototype.getCount = function () {
        var children = this.getChildren();
        return children.length;
    };
    /**
     * \u662F\u5426\u5305\u542B\u5BF9\u5E94\u5143\u7D20
     * @param {IElement} element \u5143\u7D20
     * @return {boolean}
     */
    Container.prototype.contain = function (element) {
        var children = this.getChildren();
        return children.indexOf(element) > -1;
    };
    /**
     * \u79FB\u9664\u5BF9\u5E94\u5B50\u5143\u7D20
     * @param {IElement} element \u5B50\u5143\u7D20
     * @param {boolean} destroy \u662F\u5426\u9500\u6BC1\u5B50\u5143\u7D20\uFF0C\u9ED8\u8BA4\u4E3A true
     */
    Container.prototype.removeChild = function (element, destroy) {
        if (destroy === void 0) { destroy = true; }
        if (this.contain(element)) {
            element.remove(destroy);
        }
    };
    /**
     * \u67E5\u627E\u6240\u6709\u5339\u914D\u7684\u5143\u7D20
     * @param  {ElementFilterFn}   fn  \u5339\u914D\u51FD\u6570
     * @return {IElement[]} \u5143\u7D20\u6570\u7EC4
     */
    Container.prototype.findAll = function (fn) {
        var rst = [];
        var children = this.getChildren();
        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (element) {
            if (fn(element)) {
                rst.push(element);
            }
            if (element.isGroup()) {
                rst = rst.concat(element.findAll(fn));
            }
        });
        return rst;
    };
    /**
     * \u67E5\u627E\u5143\u7D20\uFF0C\u627E\u5230\u7B2C\u4E00\u4E2A\u8FD4\u56DE
     * @param  {ElementFilterFn} fn    \u5339\u914D\u51FD\u6570
     * @return {IElement|null} \u5143\u7D20\uFF0C\u53EF\u4EE5\u4E3A\u7A7A
     */
    Container.prototype.find = function (fn) {
        var rst = null;
        var children = this.getChildren();
        (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .each */ .S6)(children, function (element) {
            if (fn(element)) {
                rst = element;
            }
            else if (element.isGroup()) {
                rst = element.find(fn);
            }
            if (rst) {
                return false;
            }
        });
        return rst;
    };
    /**
     * \u6839\u636E ID \u67E5\u627E\u5143\u7D20
     * @param {string} id \u5143\u7D20 id
     * @return {IElement|null} \u5143\u7D20
     */
    Container.prototype.findById = function (id) {
        return this.find(function (element) {
            return element.get('id') === id;
        });
    };
    /**
     * \u8BE5\u65B9\u6CD5\u5373\u5C06\u5E9F\u5F03\uFF0C\u4E0D\u5EFA\u8BAE\u4F7F\u7528
     * \u6839\u636E className \u67E5\u627E\u5143\u7D20
     * TODO: \u8BE5\u65B9\u5F0F\u5B9A\u4E49\u6682\u65F6\u53EA\u7ED9 G6 3.3 \u4EE5\u540E\u7684\u7248\u672C\u4F7F\u7528\uFF0C\u5F85 G6 \u4E2D\u7684 findByClassName \u65B9\u6CD5\u79FB\u9664\u540E\uFF0CG \u4E5F\u9700\u8981\u540C\u6B65\u79FB\u9664
     * @param {string} className \u5143\u7D20 className
     * @return {IElement | null} \u5143\u7D20
     */
    Container.prototype.findByClassName = function (className) {
        return this.find(function (element) {
            return element.get('className') === className;
        });
    };
    /**
     * \u6839\u636E name \u67E5\u627E\u5143\u7D20\u5217\u8868
     * @param {string}      name \u5143\u7D20\u540D\u79F0
     * @return {IElement[]} \u5143\u7D20
     */
    Container.prototype.findAllByName = function (name) {
        return this.findAll(function (element) {
            return element.get('name') === name;
        });
    };
    return Container;
}(_element__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z));
/* harmony default export */ __webpack_exports__["Z"] = (Container);
//# sourceMappingURL=container.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/container.js?`)},29881:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97582);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45098);
/* harmony import */ var _antv_matrix_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31506);
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77341);
/* harmony import */ var _util_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(41482);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2667);






var transform = _antv_matrix_util__WEBPACK_IMPORTED_MODULE_3__/* .transform */ .vs;
var MATRIX = 'matrix';
var CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type'];
// \u53EF\u4EE5\u5728 toAttrs \u4E2D\u8BBE\u7F6E\uFF0C\u4F46\u4E0D\u5C5E\u4E8E\u7ED8\u56FE\u5C5E\u6027\u7684\u5B57\u6BB5
var RESERVED_PORPS = ['repeat'];
var DELEGATION_SPLIT = ':';
var WILDCARD = '*';
// \u9700\u8981\u8003\u8651\u6570\u7EC4\u5D4C\u5957\u6570\u7EC4\u7684\u573A\u666F
// \u6570\u7EC4\u5D4C\u5957\u5BF9\u8C61\u7684\u573A\u666F\u4E0D\u8003\u8651
function _cloneArrayAttr(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(arr[i])) {
            result.push([].concat(arr[i]));
        }
        else {
            result.push(arr[i]);
        }
    }
    return result;
}
function getFormatFromAttrs(toAttrs, shape) {
    var fromAttrs = {};
    var attrs = shape.attrs;
    for (var k in toAttrs) {
        fromAttrs[k] = attrs[k];
    }
    return fromAttrs;
}
function getFormatToAttrs(props, shape) {
    var toAttrs = {};
    var attrs = shape.attr();
    (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(props, function (v, k) {
        if (RESERVED_PORPS.indexOf(k) === -1 && !(0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isEqual */ .Xy)(attrs[k], v)) {
            toAttrs[k] = v;
        }
    });
    return toAttrs;
}
function checkExistedAttrs(animations, animation) {
    if (animation.onFrame) {
        return animations;
    }
    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(animations, function (item) {
        // \u540E\u4E00\u4E2A\u52A8\u753B\u5F00\u59CB\u6267\u884C\u7684\u65F6\u95F4 < \u524D\u4E00\u4E2A\u52A8\u753B\u7684\u7ED3\u675F\u65F6\u95F4 && \u540E\u4E00\u4E2A\u52A8\u753B\u7684\u6267\u884C\u65F6\u95F4 > \u524D\u4E00\u4E2A\u52A8\u753B\u7684\u5EF6\u8FDF
        if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
            (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(animation.toAttrs, function (v, k) {
                if (hasOwnProperty.call(item.toAttrs, k)) {
                    delete item.toAttrs[k];
                    delete item.fromAttrs[k];
                }
            });
        }
    });
    return animations;
}
var Element = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_4__/* .__extends */ .ZT)(Element, _super);
    function Element(cfg) {
        var _this = _super.call(this, cfg) || this;
        /**
         * @protected
         * \u56FE\u5F62\u5C5E\u6027
         * @type {ShapeAttrs}
         */
        _this.attrs = {};
        var attrs = _this.getDefaultAttrs();
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .mix */ .CD)(attrs, cfg.attrs);
        _this.attrs = attrs;
        _this.initAttrs(attrs);
        _this.initAnimate(); // \u521D\u59CB\u5316\u52A8\u753B
        return _this;
    }
    // override
    Element.prototype.getDefaultCfg = function () {
        return {
            visible: true,
            capture: true,
            zIndex: 0,
        };
    };
    /**
     * @protected
     * \u83B7\u53D6\u9ED8\u8BA4\u7684\u5C5E\u76F8
     */
    Element.prototype.getDefaultAttrs = function () {
        return {
            matrix: this.getDefaultMatrix(),
            opacity: 1,
        };
    };
    /**
     * @protected
     * \u4E00\u4E9B\u65B9\u6CD5\u8C03\u7528\u4F1A\u5F15\u8D77\u753B\u5E03\u53D8\u5316
     * @param {ChangeType} changeType \u6539\u53D8\u7684\u7C7B\u578B
     */
    Element.prototype.onCanvasChange = function (changeType) { };
    /**
     * @protected
     * \u521D\u59CB\u5316\u5C5E\u6027\uFF0C\u6709\u4E9B\u5C5E\u6027\u9700\u8981\u52A0\u5DE5
     * @param {object} attrs \u5C5E\u6027\u503C
     */
    Element.prototype.initAttrs = function (attrs) { };
    /**
     * @protected
     * \u521D\u59CB\u5316\u52A8\u753B
     */
    Element.prototype.initAnimate = function () {
        this.set('animable', true);
        this.set('animating', false);
    };
    Element.prototype.isGroup = function () {
        return false;
    };
    Element.prototype.getParent = function () {
        return this.get('parent');
    };
    Element.prototype.getCanvas = function () {
        return this.get('canvas');
    };
    Element.prototype.attr = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0], value = args[1];
        if (!name)
            return this.attrs;
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Kn)(name)) {
            for (var k in name) {
                this.setAttr(k, name[k]);
            }
            this.afterAttrsChange(name);
            return this;
        }
        if (args.length === 2) {
            this.setAttr(name, value);
            this.afterAttrsChange((_a = {},
                _a[name] = value,
                _a));
            return this;
        }
        return this.attrs[name];
    };
    // \u662F\u5426\u88AB\u88C1\u526A\uFF0C\u88AB\u88C1\u526A\u5219\u4E0D\u663E\u793A\uFF0C\u4E0D\u53C2\u4E0E\u62FE\u53D6
    Element.prototype.isClipped = function (refX, refY) {
        var clip = this.getClip();
        return clip && !clip.isHit(refX, refY);
    };
    /**
     * \u5185\u90E8\u8BBE\u7F6E\u5C5E\u6027\u503C\u7684\u63A5\u53E3
     * @param {string} name \u5C5E\u6027\u540D
     * @param {any} value \u5C5E\u6027\u503C
     */
    Element.prototype.setAttr = function (name, value) {
        var originValue = this.attrs[name];
        if (originValue !== value) {
            this.attrs[name] = value;
            this.onAttrChange(name, value, originValue);
        }
    };
    /**
     * @protected
     * \u5C5E\u6027\u503C\u53D1\u751F\u6539\u53D8
     * @param {string} name \u5C5E\u6027\u540D
     * @param {any} value \u5C5E\u6027\u503C
     * @param {any} originValue \u5C5E\u6027\u503C
     */
    Element.prototype.onAttrChange = function (name, value, originValue) {
        if (name === 'matrix') {
            this.set('totalMatrix', null);
        }
    };
    /**
     * \u5C5E\u6027\u66F4\u6539\u540E\u9700\u8981\u505A\u7684\u4E8B\u60C5
     * @protected
     */
    Element.prototype.afterAttrsChange = function (targetAttrs) {
        if (this.cfg.isClipShape) {
            var applyTo = this.cfg.applyTo;
            if (applyTo) {
                applyTo.onCanvasChange('clip');
            }
        }
        else {
            this.onCanvasChange('attr');
        }
    };
    Element.prototype.show = function () {
        // \u4E0D\u662F\u9AD8\u9891\u64CD\u4F5C\u76F4\u63A5\u4F7F\u7528 set
        this.set('visible', true);
        this.onCanvasChange('show');
        return this;
    };
    Element.prototype.hide = function () {
        // \u4E0D\u662F\u9AD8\u9891\u64CD\u4F5C\u76F4\u63A5\u4F7F\u7528 set
        this.set('visible', false);
        this.onCanvasChange('hide');
        return this;
    };
    Element.prototype.setZIndex = function (zIndex) {
        this.set('zIndex', zIndex);
        var parent = this.getParent();
        if (parent) {
            // \u6539\u53D8 zIndex \u4E0D\u5E94\u8BE5\u7ACB\u5373\u89E6\u53D1\u6E32\u67D3 (\u8C03\u7528 onCanvasChange('zIndex'))\uFF0C\u9700\u8981\u7ECF\u8FC7 sort \u518D\u89E6\u53D1
            parent.sort();
        }
        return this;
    };
    Element.prototype.toFront = function () {
        var parent = this.getParent();
        if (!parent) {
            return;
        }
        var children = parent.getChildren();
        var el = this.get('el');
        var index = children.indexOf(this);
        children.splice(index, 1);
        children.push(this);
        this.onCanvasChange('zIndex');
    };
    Element.prototype.toBack = function () {
        var parent = this.getParent();
        if (!parent) {
            return;
        }
        var children = parent.getChildren();
        var el = this.get('el');
        var index = children.indexOf(this);
        children.splice(index, 1);
        children.unshift(this);
        this.onCanvasChange('zIndex');
    };
    Element.prototype.remove = function (destroy) {
        if (destroy === void 0) { destroy = true; }
        var parent = this.getParent();
        if (parent) {
            (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .removeFromArray */ .As)(parent.getChildren(), this);
            if (!parent.get('clearing')) {
                // \u5982\u679C\u7236\u5143\u7D20\u6B63\u5728\u6E05\u7406\uFF0C\u5F53\u524D\u5143\u7D20\u4E0D\u89E6\u53D1 remove
                this.onCanvasChange('remove');
            }
        }
        else {
            this.onCanvasChange('remove');
        }
        if (destroy) {
            this.destroy();
        }
    };
    Element.prototype.resetMatrix = function () {
        this.attr(MATRIX, this.getDefaultMatrix());
        this.onCanvasChange('matrix');
    };
    Element.prototype.getMatrix = function () {
        return this.attr(MATRIX);
    };
    Element.prototype.setMatrix = function (m) {
        this.attr(MATRIX, m);
        this.onCanvasChange('matrix');
    };
    // \u83B7\u53D6\u603B\u7684 matrix
    Element.prototype.getTotalMatrix = function () {
        var totalMatrix = this.cfg.totalMatrix;
        if (!totalMatrix) {
            var currentMatrix = this.attr('matrix');
            var parentMatrix = this.cfg.parentMatrix;
            if (parentMatrix && currentMatrix) {
                totalMatrix = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_5__/* .multiplyMatrix */ .xq)(parentMatrix, currentMatrix);
            }
            else {
                totalMatrix = currentMatrix || parentMatrix;
            }
            this.set('totalMatrix', totalMatrix);
        }
        return totalMatrix;
    };
    // \u4E0A\u5C42\u5206\u7EC4\u8BBE\u7F6E matrix
    Element.prototype.applyMatrix = function (matrix) {
        var currentMatrix = this.attr('matrix');
        var totalMatrix = null;
        if (matrix && currentMatrix) {
            totalMatrix = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_5__/* .multiplyMatrix */ .xq)(matrix, currentMatrix);
        }
        else {
            totalMatrix = currentMatrix || matrix;
        }
        this.set('totalMatrix', totalMatrix);
        this.set('parentMatrix', matrix);
    };
    /**
     * @protected
     * \u83B7\u53D6\u9ED8\u8BA4\u7684\u77E9\u9635
     * @returns {number[]|null} \u9ED8\u8BA4\u7684\u77E9\u9635
     */
    Element.prototype.getDefaultMatrix = function () {
        return null;
    };
    // \u5C06\u5411\u91CF\u5E94\u7528\u8BBE\u7F6E\u7684\u77E9\u9635
    Element.prototype.applyToMatrix = function (v) {
        var matrix = this.attr('matrix');
        if (matrix) {
            return (0,_util_matrix__WEBPACK_IMPORTED_MODULE_5__/* .multiplyVec2 */ .rG)(matrix, v);
        }
        return v;
    };
    // \u6839\u636E\u8BBE\u7F6E\u7684\u77E9\u9635\uFF0C\u5C06\u5411\u91CF\u8F6C\u6362\u76F8\u5BF9\u4E8E\u56FE\u5F62/\u5206\u7EC4\u7684\u4F4D\u7F6E
    Element.prototype.invertFromMatrix = function (v) {
        var matrix = this.attr('matrix');
        if (matrix) {
            var invertMatrix = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_5__/* .invert */ .U_)(matrix);
            if (invertMatrix) {
                return (0,_util_matrix__WEBPACK_IMPORTED_MODULE_5__/* .multiplyVec2 */ .rG)(invertMatrix, v);
            }
        }
        return v;
    };
    // \u8BBE\u7F6E clip
    Element.prototype.setClip = function (clipCfg) {
        var canvas = this.getCanvas();
        // \u5E94\u8BE5\u53EA\u8BBE\u7F6E\u5F53\u524D\u5143\u7D20\u7684 clip\uFF0C\u4E0D\u5E94\u8BE5\u53BB\u4FEE\u6539 clip \u672C\u8EAB\uFF0C\u65B9\u4FBF clip \u88AB\u590D\u7528
        // TODO: setClip \u7684\u4F20\u53C2\u65E2 shape \u914D\u7F6E\uFF0C\u4E5F\u652F\u6301 shape \u5BF9\u8C61
        // const preShape = this.get('clipShape');
        // if (preShape) {
        //   // \u5C06\u4E4B\u524D\u7684 clipShape \u9500\u6BC1
        //   preShape.destroy();
        // }
        var clipShape = null;
        // \u5982\u679C\u914D\u7F6E\u9879\u4E3A null\uFF0C\u5219\u4E0D\u79FB\u9664 clipShape
        if (clipCfg) {
            var ShapeBase = this.getShapeBase();
            var shapeType = (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .upperFirst */ .jC)(clipCfg.type);
            var Cons = ShapeBase[shapeType];
            if (Cons) {
                clipShape = new Cons({
                    type: clipCfg.type,
                    isClipShape: true,
                    applyTo: this,
                    attrs: clipCfg.attrs,
                    canvas: canvas,
                });
            }
        }
        this.set('clipShape', clipShape);
        this.onCanvasChange('clip');
        return clipShape;
    };
    Element.prototype.getClip = function () {
        // \u9AD8\u9891\u7387\u8C03\u7528\u7684\u5730\u65B9\u76F4\u63A5\u4F7F\u7528 this.cfg.xxx
        var clipShape = this.cfg.clipShape;
        // \u672A\u8BBE\u7F6E\u65F6\u8FD4\u56DE Null\uFF0C\u4FDD\u8BC1\u4E00\u81F4\u6027
        if (!clipShape) {
            return null;
        }
        return clipShape;
    };
    Element.prototype.clone = function () {
        var _this = this;
        var originAttrs = this.attrs;
        var attrs = {};
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(originAttrs, function (i, k) {
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(originAttrs[k])) {
                attrs[k] = _cloneArrayAttr(originAttrs[k]);
            }
            else {
                attrs[k] = originAttrs[k];
            }
        });
        var cons = this.constructor;
        // @ts-ignore
        var clone = new cons({ attrs: attrs });
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(CLONE_CFGS, function (cfgName) {
            clone.set(cfgName, _this.get(cfgName));
        });
        return clone;
    };
    Element.prototype.destroy = function () {
        var destroyed = this.destroyed;
        if (destroyed) {
            return;
        }
        this.attrs = {};
        _super.prototype.destroy.call(this);
        // this.onCanvasChange('destroy');
    };
    /**
     * \u662F\u5426\u5904\u4E8E\u52A8\u753B\u6682\u505C\u72B6\u6001
     * @return {boolean} \u662F\u5426\u5904\u4E8E\u52A8\u753B\u6682\u505C\u72B6\u6001
     */
    Element.prototype.isAnimatePaused = function () {
        return this.get('_pause').isPaused;
    };
    /**
     * \u6267\u884C\u52A8\u753B\uFF0C\u652F\u6301\u591A\u79CD\u51FD\u6570\u7B7E\u540D
     * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)
     * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)
     * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)
     * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)
     * \u5404\u4E2A\u53C2\u6570\u7684\u542B\u4E49\u4E3A:
     *   toAttrs  \u52A8\u753B\u6700\u7EC8\u72B6\u6001
     *   onFrame  \u81EA\u5B9A\u4E49\u5E27\u52A8\u753B\u51FD\u6570
     *   duration \u52A8\u753B\u6267\u884C\u65F6\u95F4
     *   easing   \u52A8\u753B\u7F13\u52A8\u6548\u679C
     *   callback \u52A8\u753B\u6267\u884C\u540E\u7684\u56DE\u8C03
     *   delay    \u52A8\u753B\u5EF6\u8FDF\u65F6\u95F4
     */
    Element.prototype.animate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.get('timeline') && !this.get('canvas')) {
            return;
        }
        this.set('animating', true);
        var timeline = this.get('timeline');
        if (!timeline) {
            timeline = this.get('canvas').get('timeline');
            this.set('timeline', timeline);
        }
        var animations = this.get('animations') || [];
        // \u521D\u59CB\u5316 tick
        if (!timeline.timer) {
            timeline.initTimer();
        }
        var toAttrs = args[0], duration = args[1], _a = args[2], easing = _a === void 0 ? 'easeLinear' : _a, _b = args[3], callback = _b === void 0 ? _antv_util__WEBPACK_IMPORTED_MODULE_0__/* .noop */ .ZT : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
        var onFrame;
        var repeat;
        var pauseCallback;
        var resumeCallback;
        var animateCfg;
        // \u7B2C\u4E8C\u4E2A\u53C2\u6570\uFF0C\u65E2\u53EF\u4EE5\u662F\u52A8\u753B\u6700\u7EC8\u72B6\u6001 toAttrs\uFF0C\u4E5F\u53EF\u4EE5\u662F\u81EA\u5B9A\u4E49\u5E27\u52A8\u753B\u51FD\u6570 onFrame
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .mf)(toAttrs)) {
            onFrame = toAttrs;
            toAttrs = {};
        }
        else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Kn)(toAttrs) && toAttrs.onFrame) {
            // \u517C\u5BB9 3.0 \u4E2D\u7684\u5199\u6CD5\uFF0ConFrame \u548C repeat \u53EF\u5728 toAttrs \u4E2D\u8BBE\u7F6E
            onFrame = toAttrs.onFrame;
            repeat = toAttrs.repeat;
        }
        // \u7B2C\u4E8C\u4E2A\u53C2\u6570\uFF0C\u65E2\u53EF\u4EE5\u662F\u6267\u884C\u65F6\u95F4 duration\uFF0C\u4E5F\u53EF\u4EE5\u662F\u52A8\u753B\u53C2\u6570 animateCfg
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Kn)(duration)) {
            animateCfg = duration;
            duration = animateCfg.duration;
            easing = animateCfg.easing || 'easeLinear';
            delay = animateCfg.delay || 0;
            // animateCfg \u4E2D\u7684\u8BBE\u7F6E\u4F18\u5148\u7EA7\u66F4\u9AD8
            repeat = animateCfg.repeat || repeat || false;
            callback = animateCfg.callback || _antv_util__WEBPACK_IMPORTED_MODULE_0__/* .noop */ .ZT;
            pauseCallback = animateCfg.pauseCallback || _antv_util__WEBPACK_IMPORTED_MODULE_0__/* .noop */ .ZT;
            resumeCallback = animateCfg.resumeCallback || _antv_util__WEBPACK_IMPORTED_MODULE_0__/* .noop */ .ZT;
        }
        else {
            // \u7B2C\u56DB\u4E2A\u53C2\u6570\uFF0C\u65E2\u53EF\u4EE5\u662F\u56DE\u8C03\u51FD\u6570 callback\uFF0C\u4E5F\u53EF\u4EE5\u662F\u5EF6\u8FDF\u65F6\u95F4 delay
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isNumber */ .hj)(callback)) {
                delay = callback;
                callback = null;
            }
            // \u7B2C\u4E09\u4E2A\u53C2\u6570\uFF0C\u65E2\u53EF\u4EE5\u662F\u7F13\u52A8\u53C2\u6570 easing\uFF0C\u4E5F\u53EF\u4EE5\u662F\u56DE\u8C03\u51FD\u6570 callback
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .mf)(easing)) {
                callback = easing;
                easing = 'easeLinear';
            }
            else {
                easing = easing || 'easeLinear';
            }
        }
        var formatToAttrs = getFormatToAttrs(toAttrs, this);
        var animation = {
            fromAttrs: getFormatFromAttrs(formatToAttrs, this),
            toAttrs: formatToAttrs,
            duration: duration,
            easing: easing,
            repeat: repeat,
            callback: callback,
            pauseCallback: pauseCallback,
            resumeCallback: resumeCallback,
            delay: delay,
            startTime: timeline.getTime(),
            id: (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .uniqueId */ .EL)(),
            onFrame: onFrame,
            pathFormatted: false,
        };
        // \u5982\u679C\u52A8\u753B\u5143\u7D20\u961F\u5217\u4E2D\u5DF2\u7ECF\u6709\u8FD9\u4E2A\u56FE\u5F62\u4E86
        if (animations.length > 0) {
            // \u5148\u68C0\u67E5\u662F\u5426\u9700\u8981\u5408\u5E76\u5C5E\u6027\u3002\u82E5\u6709\u76F8\u540C\u7684\u52A8\u753B\uFF0C\u5C06\u8BE5\u5C5E\u6027\u4ECE\u524D\u4E00\u4E2A\u52A8\u753B\u4E2D\u5220\u9664,\u76F4\u63A5\u7528\u540E\u4E00\u4E2A\u52A8\u753B\u4E2D
            animations = checkExistedAttrs(animations, animation);
        }
        else {
            // \u5426\u5219\u5C06\u56FE\u5F62\u6DFB\u52A0\u5230\u52A8\u753B\u5143\u7D20\u961F\u5217
            timeline.addAnimator(this);
        }
        animations.push(animation);
        this.set('animations', animations);
        this.set('_pause', { isPaused: false });
    };
    /**
     * \u505C\u6B62\u52A8\u753B
     * @param {boolean} toEnd \u662F\u5426\u5230\u52A8\u753B\u7684\u6700\u7EC8\u72B6\u6001
     */
    Element.prototype.stopAnimate = function (toEnd) {
        var _this = this;
        if (toEnd === void 0) { toEnd = true; }
        var animations = this.get('animations');
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(animations, function (animation) {
            // \u5C06\u52A8\u753B\u6267\u884C\u5230\u6700\u540E\u4E00\u5E27
            if (toEnd) {
                if (animation.onFrame) {
                    _this.attr(animation.onFrame(1));
                }
                else {
                    _this.attr(animation.toAttrs);
                }
            }
            if (animation.callback) {
                // \u52A8\u753B\u505C\u6B62\u65F6\u7684\u56DE\u8C03
                animation.callback();
            }
        });
        this.set('animating', false);
        this.set('animations', []);
    };
    /**
     * \u6682\u505C\u52A8\u753B
     */
    Element.prototype.pauseAnimate = function () {
        var timeline = this.get('timeline');
        var animations = this.get('animations');
        var pauseTime = timeline.getTime();
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(animations, function (animation) {
            animation._paused = true;
            animation._pauseTime = pauseTime;
            if (animation.pauseCallback) {
                // \u52A8\u753B\u6682\u505C\u65F6\u7684\u56DE\u8C03
                animation.pauseCallback();
            }
        });
        // \u8BB0\u5F55\u4E0B\u662F\u5728\u4EC0\u4E48\u65F6\u5019\u6682\u505C\u7684
        this.set('_pause', {
            isPaused: true,
            pauseTime: pauseTime,
        });
        return this;
    };
    /**
     * \u6062\u590D\u52A8\u753B
     */
    Element.prototype.resumeAnimate = function () {
        var timeline = this.get('timeline');
        var current = timeline.getTime();
        var animations = this.get('animations');
        var pauseTime = this.get('_pause').pauseTime;
        // \u4E4B\u540E\u66F4\u65B0\u5C5E\u6027\u9700\u8981\u8BA1\u7B97\u52A8\u753B\u5DF2\u7ECF\u6267\u884C\u7684\u65F6\u957F\uFF0C\u5982\u679C\u6682\u505C\u4E86\uFF0C\u5C31\u628A\u521D\u59CB\u65F6\u95F4\u8C03\u540E
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(animations, function (animation) {
            animation.startTime = animation.startTime + (current - pauseTime);
            animation._paused = false;
            animation._pauseTime = null;
            if (animation.resumeCallback) {
                animation.resumeCallback();
            }
        });
        this.set('_pause', {
            isPaused: false,
        });
        this.set('animations', animations);
        return this;
    };
    /**
     * \u89E6\u53D1\u59D4\u6258\u4E8B\u4EF6
     * @param  {string}     type \u4E8B\u4EF6\u7C7B\u578B
     * @param  {GraphEvent} eventObj \u4E8B\u4EF6\u5BF9\u8C61
     */
    Element.prototype.emitDelegation = function (type, eventObj) {
        var _this = this;
        var paths = eventObj.propagationPath;
        var events = this.getEvents();
        var relativeShape;
        if (type === 'mouseenter') {
            relativeShape = eventObj.fromShape;
        }
        else if (type === 'mouseleave') {
            relativeShape = eventObj.toShape;
        }
        var _loop_1 = function (i) {
            var element = paths[i];
            // \u6682\u5B9A\u8DDF name \u7ED1\u5B9A
            var name_1 = element.get('name');
            if (name_1) {
                // \u7B2C\u4E00\u4E2A mouseenter \u548C mouseleave \u7684\u505C\u6B62\u5373\u53EF\uFF0C\u56E0\u4E3A\u540E\u9762\u7684\u90FD\u662F\u524D\u9762\u7684 Parent
                if (
                // \u53EA\u6709 element \u662F Group \u6216\u8005 Canvas \u7684\u65F6\u5019\uFF0C\u624D\u9700\u8981\u5224\u65AD isParent
                (element.isGroup() || (element.isCanvas && element.isCanvas())) &&
                    relativeShape &&
                    (0,_util_util__WEBPACK_IMPORTED_MODULE_1__/* .isParent */ .UY)(element, relativeShape)) {
                    return "break";
                }
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(name_1)) {
                    (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(name_1, function (subName) {
                        _this.emitDelegateEvent(element, subName, eventObj);
                    });
                }
                else {
                    this_1.emitDelegateEvent(element, name_1, eventObj);
                }
            }
        };
        var this_1 = this;
        // \u81F3\u5C11\u6709\u4E00\u4E2A\u5BF9\u8C61\uFF0C\u4E14\u7B2C\u4E00\u4E2A\u5BF9\u8C61\u4E3A shape
        for (var i = 0; i < paths.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    };
    Element.prototype.emitDelegateEvent = function (element, name, eventObj) {
        var events = this.getEvents();
        // \u4E8B\u4EF6\u59D4\u6258\u7684\u5F62\u5F0F name:type
        var eventName = name + DELEGATION_SPLIT + eventObj.type;
        if (events[eventName] || events[WILDCARD]) {
            // \u5BF9\u4E8E\u901A\u914D\u7B26 *\uFF0C\u4E8B\u4EF6\u540D\u79F0 = \u59D4\u6258\u4E8B\u4EF6\u540D\u79F0
            eventObj.name = eventName;
            eventObj.currentTarget = element;
            eventObj.delegateTarget = this;
            // \u5C06\u59D4\u6258\u4E8B\u4EF6\u7684\u76D1\u542C\u5BF9\u8C61 delegateObject \u6302\u8F7D\u5230\u4E8B\u4EF6\u5BF9\u8C61\u4E0A
            eventObj.delegateObject = element.get('delegateObject');
            this.emit(eventName, eventObj);
        }
    };
    /**
     * \u79FB\u52A8\u5143\u7D20
     * @param {number} translateX \u6C34\u5E73\u79FB\u52A8\u8DDD\u79BB
     * @param {number} translateY \u5782\u76F4\u79FB\u52A8\u8DDD\u79BB
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.translate = function (translateX, translateY) {
        if (translateX === void 0) { translateX = 0; }
        if (translateY === void 0) { translateY = 0; }
        var matrix = this.getMatrix();
        var newMatrix = transform(matrix, [['t', translateX, translateY]]);
        this.setMatrix(newMatrix);
        return this;
    };
    /**
     * \u79FB\u52A8\u5143\u7D20\u5230\u76EE\u6807\u4F4D\u7F6E
     * @param {number} targetX \u76EE\u6807\u4F4D\u7F6E\u7684\u6C34\u5E73\u5750\u6807
     * @param {number} targetX \u76EE\u6807\u4F4D\u7F6E\u7684\u5782\u76F4\u5750\u6807
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.move = function (targetX, targetY) {
        var x = this.attr('x') || 0;
        var y = this.attr('y') || 0;
        this.translate(targetX - x, targetY - y);
        return this;
    };
    /**
     * \u79FB\u52A8\u5143\u7D20\u5230\u76EE\u6807\u4F4D\u7F6E\uFF0C\u7B49\u4EF7\u4E8E move \u65B9\u6CD5\u3002\u7531\u4E8E moveTo \u7684\u8BED\u4E49\u6027\u66F4\u5F3A\uFF0C\u56E0\u6B64\u5728\u6587\u6863\u4E2D\u63A8\u8350\u4F7F\u7528 moveTo \u65B9\u6CD5
     * @param {number} targetX \u76EE\u6807\u4F4D\u7F6E\u7684 x \u8F74\u5750\u6807
     * @param {number} targetY \u76EE\u6807\u4F4D\u7F6E\u7684 y \u8F74\u5750\u6807
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.moveTo = function (targetX, targetY) {
        return this.move(targetX, targetY);
    };
    /**
     * \u7F29\u653E\u5143\u7D20
     * @param {number} ratioX \u6C34\u5E73\u7F29\u653E\u6BD4\u4F8B
     * @param {number} ratioY \u5782\u76F4\u7F29\u653E\u6BD4\u4F8B
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.scale = function (ratioX, ratioY) {
        var matrix = this.getMatrix();
        var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);
        this.setMatrix(newMatrix);
        return this;
    };
    /**
     * \u4EE5\u753B\u5E03\u5DE6\u4E0A\u89D2 (0, 0) \u4E3A\u4E2D\u5FC3\u65CB\u8F6C\u5143\u7D20
     * @param {number} radian \u65CB\u8F6C\u89D2\u5EA6(\u5F27\u5EA6\u503C)
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.rotate = function (radian) {
        var matrix = this.getMatrix();
        var newMatrix = transform(matrix, [['r', radian]]);
        this.setMatrix(newMatrix);
        return this;
    };
    /**
     * \u4EE5\u8D77\u59CB\u70B9\u4E3A\u4E2D\u5FC3\u65CB\u8F6C\u5143\u7D20
     * @param {number} radian \u65CB\u8F6C\u89D2\u5EA6(\u5F27\u5EA6\u503C)
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.rotateAtStart = function (rotate) {
        var _a = this.attr(), x = _a.x, y = _a.y;
        var matrix = this.getMatrix();
        var newMatrix = transform(matrix, [
            ['t', -x, -y],
            ['r', rotate],
            ['t', x, y],
        ]);
        this.setMatrix(newMatrix);
        return this;
    };
    /**
     * \u4EE5\u4EFB\u610F\u70B9 (x, y) \u4E3A\u4E2D\u5FC3\u65CB\u8F6C\u5143\u7D20
     * @param {number} radian \u65CB\u8F6C\u89D2\u5EA6(\u5F27\u5EA6\u503C)
     * @return {IElement} \u5143\u7D20
     */
    Element.prototype.rotateAtPoint = function (x, y, rotate) {
        var matrix = this.getMatrix();
        var newMatrix = transform(matrix, [
            ['t', -x, -y],
            ['r', rotate],
            ['t', x, y],
        ]);
        this.setMatrix(newMatrix);
        return this;
    };
    return Element;
}(_base__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z));
/* harmony default export */ __webpack_exports__["Z"] = (Element);
//# sourceMappingURL=element.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/element.js?`)},31841:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97582);
/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37153);


var AbstractGroup = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .ZT)(AbstractGroup, _super);
    function AbstractGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup.prototype.isGroup = function () {
        return true;
    };
    AbstractGroup.prototype.isEntityGroup = function () {
        return false;
    };
    AbstractGroup.prototype.clone = function () {
        var clone = _super.prototype.clone.call(this);
        // \u83B7\u53D6\u6784\u9020\u51FD\u6570
        var children = this.getChildren();
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            clone.add(child.clone());
        }
        return clone;
    };
    return AbstractGroup;
}(_container__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z));
/* harmony default export */ __webpack_exports__["Z"] = (AbstractGroup);
//# sourceMappingURL=group.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/group.js?`)},15032:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97582);
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29881);
/* harmony import */ var _util_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41482);



var AbstractShape = /** @class */ (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .ZT)(AbstractShape, _super);
    function AbstractShape(cfg) {
        return _super.call(this, cfg) || this;
    }
    // \u662F\u5426\u5728\u5305\u56F4\u76D2\u5185
    AbstractShape.prototype._isInBBox = function (refX, refY) {
        var bbox = this.getBBox();
        return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    /**
     * \u5C5E\u6027\u66F4\u6539\u540E\u9700\u8981\u505A\u7684\u4E8B\u60C5
     * @protected
     * @param {ShapeAttrs} targetAttrs \u6E32\u67D3\u7684\u56FE\u50CF\u5C5E\u6027
     */
    AbstractShape.prototype.afterAttrsChange = function (targetAttrs) {
        _super.prototype.afterAttrsChange.call(this, targetAttrs);
        this.clearCacheBBox();
    };
    // \u8BA1\u7B97\u5305\u56F4\u76D2\u65F6\uFF0C\u9700\u8981\u7F13\u5B58\uFF0C\u8FD9\u662F\u4E00\u4E2A\u9AD8\u9891\u7684\u64CD\u4F5C
    AbstractShape.prototype.getBBox = function () {
        var bbox = this.cfg.bbox;
        if (!bbox) {
            bbox = this.calculateBBox();
            this.set('bbox', bbox);
        }
        return bbox;
    };
    // \u8BA1\u7B97\u76F8\u5BF9\u4E8E\u753B\u5E03\u7684\u5305\u56F4\u76D2
    AbstractShape.prototype.getCanvasBBox = function () {
        var canvasBBox = this.cfg.canvasBBox;
        if (!canvasBBox) {
            canvasBBox = this.calculateCanvasBBox();
            this.set('canvasBBox', canvasBBox);
        }
        return canvasBBox;
    };
    AbstractShape.prototype.applyMatrix = function (matrix) {
        _super.prototype.applyMatrix.call(this, matrix);
        // \u6E05\u7406\u6389\u7F13\u5B58\u7684\u5305\u56F4\u76D2
        this.set('canvasBBox', null);
    };
    /**
     * \u8BA1\u7B97\u76F8\u5BF9\u4E8E\u753B\u5E03\u7684\u5305\u56F4\u76D2\uFF0C\u9ED8\u8BA4\u7B49\u540C\u4E8E bbox
     * @return {BBox} \u5305\u56F4\u76D2
     */
    AbstractShape.prototype.calculateCanvasBBox = function () {
        var bbox = this.getBBox();
        var totalMatrix = this.getTotalMatrix();
        var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
        if (totalMatrix) {
            var topLeft = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_2__/* .multiplyVec2 */ .rG)(totalMatrix, [bbox.minX, bbox.minY]);
            var topRight = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_2__/* .multiplyVec2 */ .rG)(totalMatrix, [bbox.maxX, bbox.minY]);
            var bottomLeft = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_2__/* .multiplyVec2 */ .rG)(totalMatrix, [bbox.minX, bbox.maxY]);
            var bottomRight = (0,_util_matrix__WEBPACK_IMPORTED_MODULE_2__/* .multiplyVec2 */ .rG)(totalMatrix, [bbox.maxX, bbox.maxY]);
            minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
            maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
            minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
            maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        }
        var attrs = this.attrs;
        // \u5982\u679C\u5B58\u5728 shadow \u5219\u8BA1\u7B97 shadow
        if (attrs.shadowColor) {
            var _a = attrs.shadowBlur, shadowBlur = _a === void 0 ? 0 : _a, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
            var shadowLeft = minX - shadowBlur + shadowOffsetX;
            var shadowRight = maxX + shadowBlur + shadowOffsetX;
            var shadowTop = minY - shadowBlur + shadowOffsetY;
            var shadowBottom = maxY + shadowBlur + shadowOffsetY;
            minX = Math.min(minX, shadowLeft);
            maxX = Math.max(maxX, shadowRight);
            minY = Math.min(minY, shadowTop);
            maxY = Math.max(maxY, shadowBottom);
        }
        return {
            x: minX,
            y: minY,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };
    };
    /**
     * @protected
     * \u6E05\u7406\u7F13\u5B58\u7684 bbox
     */
    AbstractShape.prototype.clearCacheBBox = function () {
        this.set('bbox', null);
        this.set('canvasBBox', null);
    };
    // \u5B9E\u73B0\u63A5\u53E3
    AbstractShape.prototype.isClipShape = function () {
        return this.get('isClipShape');
    };
    /**
     * @protected
     * \u4E0D\u540C\u7684\u56FE\u5F62\u81EA\u5DF1\u5B9E\u73B0\u662F\u5426\u5728\u56FE\u5F62\u5185\u90E8\u7684\u903B\u8F91\uFF0C\u8981\u5224\u65AD\u8FB9\u548C\u586B\u5145\u533A\u57DF
     * @param  {number}  refX \u76F8\u5BF9\u4E8E\u56FE\u5F62\u7684\u5750\u6807 x
     * @param  {number}  refY \u76F8\u5BF9\u4E8E\u56FE\u5F62\u7684\u5750\u6807 Y
     * @return {boolean} \u70B9\u662F\u5426\u5728\u56FE\u5F62\u5185\u90E8
     */
    AbstractShape.prototype.isInShape = function (refX, refY) {
        return false;
    };
    /**
     * \u662F\u5426\u4EC5\u4EC5\u4F7F\u7528 BBox \u68C0\u6D4B\u5C31\u53EF\u4EE5\u5224\u5B9A\u62FE\u53D6\u5230\u56FE\u5F62
     * \u9ED8\u8BA4\u662F false\uFF0C\u4F46\u662F\u6709\u4E9B\u56FE\u5F62\u4F8B\u5982 image\u3001marker \u7B49\u90FD\u53EF\u76F4\u63A5\u4F7F\u7528 BBox \u7684\u68C0\u6D4B\u800C\u4E0D\u9700\u8981\u4F7F\u7528\u56FE\u5F62\u62FE\u53D6
     * @return {Boolean} \u4EC5\u4EC5\u4F7F\u7528 BBox \u8FDB\u884C\u62FE\u53D6
     */
    AbstractShape.prototype.isOnlyHitBox = function () {
        return false;
    };
    // \u4E0D\u540C\u7684 Shape \u5404\u81EA\u5B9E\u73B0
    AbstractShape.prototype.isHit = function (x, y) {
        var startArrowShape = this.get('startArrowShape');
        var endArrowShape = this.get('endArrowShape');
        var vec = [x, y, 1];
        vec = this.invertFromMatrix(vec);
        var refX = vec[0], refY = vec[1];
        var inBBox = this._isInBBox(refX, refY);
        // \u8DF3\u8FC7\u56FE\u5F62\u7684\u62FE\u53D6\uFF0C\u5728\u67D0\u4E9B\u56FE\u5F62\u4E2D\u53EF\u4EE5\u7701\u7565\u4E00\u500D\u7684\u68C0\u6D4B\u6210\u672C
        if (this.isOnlyHitBox()) {
            return inBBox;
        }
        // \u88AB\u88C1\u51CF\u6389\u7684\u548C\u4E0D\u5728\u5305\u56F4\u76D2\u5185\u7684\u4E0D\u8FDB\u884C\u8BA1\u7B97
        if (inBBox && !this.isClipped(refX, refY)) {
            // \u5BF9\u56FE\u5F62\u8FDB\u884C\u62FE\u53D6\u5224\u65AD
            if (this.isInShape(refX, refY)) {
                return true;
            }
            // \u5BF9\u8D77\u59CB\u7BAD\u5934\u8FDB\u884C\u62FE\u53D6\u5224\u65AD
            if (startArrowShape && startArrowShape.isHit(refX, refY)) {
                return true;
            }
            // \u5BF9\u7ED3\u675F\u7BAD\u5934\u8FDB\u884C\u62FE\u53D6\u5224\u65AD
            if (endArrowShape && endArrowShape.isHit(refX, refY)) {
                return true;
            }
        }
        return false;
    };
    return AbstractShape;
}(_element__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z));
/* harmony default export */ __webpack_exports__["Z"] = (AbstractShape);
//# sourceMappingURL=shape.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/abstract/shape.js?`)},93924:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "_": function() { return /* binding */ getEasing; },
  "C": function() { return /* binding */ registerEasing; }
});

// NAMESPACE OBJECT: ./node_modules/d3-ease/src/index.js
var src_namespaceObject = {};
__webpack_require__.r(src_namespaceObject);
__webpack_require__.d(src_namespaceObject, {
  "easeBack": function() { return backInOut; },
  "easeBackIn": function() { return backIn; },
  "easeBackInOut": function() { return backInOut; },
  "easeBackOut": function() { return backOut; },
  "easeBounce": function() { return bounceOut; },
  "easeBounceIn": function() { return bounceIn; },
  "easeBounceInOut": function() { return bounceInOut; },
  "easeBounceOut": function() { return bounceOut; },
  "easeCircle": function() { return circleInOut; },
  "easeCircleIn": function() { return circleIn; },
  "easeCircleInOut": function() { return circleInOut; },
  "easeCircleOut": function() { return circleOut; },
  "easeCubic": function() { return cubicInOut; },
  "easeCubicIn": function() { return cubicIn; },
  "easeCubicInOut": function() { return cubicInOut; },
  "easeCubicOut": function() { return cubicOut; },
  "easeElastic": function() { return elasticOut; },
  "easeElasticIn": function() { return elasticIn; },
  "easeElasticInOut": function() { return elasticInOut; },
  "easeElasticOut": function() { return elasticOut; },
  "easeExp": function() { return expInOut; },
  "easeExpIn": function() { return expIn; },
  "easeExpInOut": function() { return expInOut; },
  "easeExpOut": function() { return expOut; },
  "easeLinear": function() { return linear; },
  "easePoly": function() { return polyInOut; },
  "easePolyIn": function() { return polyIn; },
  "easePolyInOut": function() { return polyInOut; },
  "easePolyOut": function() { return polyOut; },
  "easeQuad": function() { return quadInOut; },
  "easeQuadIn": function() { return quadIn; },
  "easeQuadInOut": function() { return quadInOut; },
  "easeQuadOut": function() { return quadOut; },
  "easeSin": function() { return sinInOut; },
  "easeSinIn": function() { return sinIn; },
  "easeSinInOut": function() { return sinInOut; },
  "easeSinOut": function() { return sinOut; }
});

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/linear.js
function linear(t) {
  return +t;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/poly.js
var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/sin.js
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/math.js
// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/exp.js


function expIn(t) {
  return tpmt(1 - +t);
}

function expOut(t) {
  return 1 - tpmt(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/back.js
var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/elastic.js


var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * tpmt(-(--t)) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * tpmt(-t) * Math.sin((s - t) / p)
        : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

;// CONCATENATED MODULE: ./node_modules/d3-ease/src/index.js




















;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/animate/register.js

var EASING_MAP = {};
/**
 * \u6839\u636E\u540D\u79F0\u83B7\u53D6\u5BF9\u5E94\u7684\u52A8\u753B\u7F13\u52A8\u51FD\u6570
 * @param type \u52A8\u753B\u7F13\u52A8\u51FD\u6570\u540D\u79F0
 */
function getEasing(type) {
    // \u9ED8\u8BA4\u4ECE d3-ease \u4E2D\u83B7\u53D6
    return EASING_MAP[type.toLowerCase()] || src_namespaceObject[type];
}
/**
 * \u6CE8\u518C\u52A8\u753B\u7F13\u52A8\u51FD\u6570
 * @param type \u52A8\u753B\u7F13\u52A8\u51FD\u6570\u540D\u79F0
 * @param easeFn \u52A8\u753B\u7F13\u52A8\u51FD\u6570
 */
function registerEasing(type, easeFn) {
    EASING_MAP[type.toLowerCase()] = easeFn;
}
//# sourceMappingURL=register.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/animate/register.js_+_12_modules?`)},46556:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "b": function() { return /* reexport */ getMethod; },
  "W": function() { return /* reexport */ register; }
});

;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/register.js
var cache = new Map();
/**
 * \u6CE8\u518C\u8BA1\u7B97\u5305\u56F4\u76D2\u7684\u7B97\u6CD5
 * @param type \u65B9\u6CD5\u540D
 * @param method \u65B9\u6CD5
 */
function register(type, method) {
    cache.set(type, method);
}
/**
 * \u83B7\u53D6\u8BA1\u7B97\u5305\u56F4\u76D2\u7684\u7B97\u6CD5
 * @param type \u65B9\u6CD5\u540D
 */
function getMethod(type) {
    return cache.get(type);
}
//# sourceMappingURL=register.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/rect.js
/* harmony default export */ function rect(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
    return {
        x: x,
        y: y,
        width: width,
        height: height,
    };
}
//# sourceMappingURL=rect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/circle.js
/* harmony default export */ function circle(shape) {
    var _a = shape.attr(), x = _a.x, y = _a.y, r = _a.r;
    return {
        x: x - r,
        y: y - r,
        width: r * 2,
        height: r * 2,
    };
}
//# sourceMappingURL=circle.js.map
// EXTERNAL MODULE: ./node_modules/@antv/g-math/esm/index.js + 10 modules
var esm = __webpack_require__(32793);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/util.js
// \u5408\u5E76\u5305\u56F4\u76D2
function mergeBBox(bbox1, bbox2) {
    if (!bbox1 || !bbox2) {
        return bbox1 || bbox2;
    }
    return {
        minX: Math.min(bbox1.minX, bbox2.minX),
        minY: Math.min(bbox1.minY, bbox2.minY),
        maxX: Math.max(bbox1.maxX, bbox2.maxX),
        maxY: Math.max(bbox1.maxY, bbox2.maxY),
    };
}
// \u5408\u5E76\u7BAD\u5934\u7684\u5305\u56F4\u76D2
function mergeArrowBBox(shape, bbox) {
    var startArrowShape = shape.get('startArrowShape');
    var endArrowShape = shape.get('endArrowShape');
    var startArrowBBox = null;
    var endArrowBBox = null;
    if (startArrowShape) {
        startArrowBBox = startArrowShape.getCanvasBBox();
        bbox = mergeBBox(bbox, startArrowBBox);
    }
    if (endArrowShape) {
        endArrowBBox = endArrowShape.getCanvasBBox();
        bbox = mergeBBox(bbox, endArrowBBox);
    }
    return bbox;
}
//# sourceMappingURL=util.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/polyline.js


/* harmony default export */ function polyline(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
        var point = points[i];
        xArr.push(point[0]);
        yArr.push(point[1]);
    }
    var _a = esm/* Util.getBBoxByArray */.Zr.getBBoxByArray(xArr, yArr), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    var bbox = {
        minX: x,
        minY: y,
        maxX: x + width,
        maxY: y + height,
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
        x: bbox.minX,
        y: bbox.minY,
        width: bbox.maxX - bbox.minX,
        height: bbox.maxY - bbox.minY,
    };
}
//# sourceMappingURL=polyline.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/polygon.js

/* harmony default export */ function polygon(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
        var point = points[i];
        xArr.push(point[0]);
        yArr.push(point[1]);
    }
    return esm/* Util.getBBoxByArray */.Zr.getBBoxByArray(xArr, yArr);
}
//# sourceMappingURL=polygon.js.map
// EXTERNAL MODULE: ./node_modules/@antv/g-base/esm/util/text.js
var util_text = __webpack_require__(8723);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/text.js

/* harmony default export */ function bbox_text(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
    var font = attrs.font;
    if (!font) {
        // \u5982\u679C\u672A\u7EC4\u88C5 font
        font = (0,util_text/* assembleFont */.$O)(attrs);
    }
    var width = (0,util_text/* getTextWidth */.mY)(text, font);
    var bbox;
    if (!width) {
        // \u5982\u679Cwidth\u4E0D\u5B58\u5728\uFF0C\u56DB\u70B9\u5171\u5176\u5B9E\u70B9
        bbox = {
            x: x,
            y: y,
            width: 0,
            height: 0,
        };
    }
    else {
        var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
        var height = (0,util_text/* getTextHeight */.FE)(text, fontSize, lineHeight); // attrs.height
        // \u9ED8\u8BA4\u5DE6\u53F3\u5BF9\u9F50\uFF1Aleft, \u9ED8\u8BA4\u4E0A\u4E0B\u5BF9\u9F50 bottom
        var point = {
            x: x,
            y: y - height,
        };
        if (textAlign) {
            if (textAlign === 'end' || textAlign === 'right') {
                point.x -= width;
            }
            else if (textAlign === 'center') {
                point.x -= width / 2;
            }
        }
        if (textBaseline) {
            if (textBaseline === 'top') {
                point.y += height;
            }
            else if (textBaseline === 'middle') {
                point.y += height / 2;
            }
        }
        bbox = {
            x: point.x,
            y: point.y,
            width: width,
            height: height,
        };
    }
    return bbox;
}
//# sourceMappingURL=text.js.map
// EXTERNAL MODULE: ./node_modules/@antv/path-util/esm/index.js + 14 modules
var path_util_esm = __webpack_require__(59665);
// EXTERNAL MODULE: ./node_modules/@antv/util/esm/index.js + 104 modules
var util_esm = __webpack_require__(45098);
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/path.js




function getPathBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
        var box = void 0;
        switch (segment.command) {
            case 'Q':
                box = esm/* Quad.box */.lD.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
                break;
            case 'C':
                box = esm/* Cubic.box */.Ll.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
                break;
            case 'A':
                var arcParams = segment.arcParams;
                box = esm/* Arc.box */.wN.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
                break;
            default:
                xArr.push(currentPoint[0]);
                yArr.push(currentPoint[1]);
                break;
        }
        if (box) {
            segment.box = box;
            xArr.push(box.x, box.x + box.width);
            yArr.push(box.y, box.y + box.height);
        }
        if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {
            segmentsWithAngle.push(segment);
        }
    }
    // bbox calculation should ignore NaN for path attribute
    // ref: https://github.com/antvis/g/issues/210
    // ref: https://github.com/antvis/G2/issues/3109
    xArr = xArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });
    yArr = yArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });
    var minX = (0,util_esm/* min */.VV)(xArr);
    var minY = (0,util_esm/* min */.VV)(yArr);
    var maxX = (0,util_esm/* max */.Fp)(xArr);
    var maxY = (0,util_esm/* max */.Fp)(yArr);
    if (segmentsWithAngle.length === 0) {
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
        var segment = segmentsWithAngle[i];
        var currentPoint = segment.currentPoint;
        var extra = void 0;
        if (currentPoint[0] === minX) {
            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
            minX = minX - extra.xExtra;
        }
        else if (currentPoint[0] === maxX) {
            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
            maxX = maxX + extra.xExtra;
        }
        if (currentPoint[1] === minY) {
            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
            minY = minY - extra.yExtra;
        }
        else if (currentPoint[1] === maxY) {
            extra = getExtraFromSegmentWithAngle(segment, lineWidth);
            maxY = maxY + extra.yExtra;
        }
    }
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    // \u4EE5 currentPoint \u4E3A\u9876\u70B9\u7684\u5939\u89D2
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    // \u5939\u89D2\u4E3A\u7A7A\u3001 0 \u6216 PI \u65F6\uFF0C\u4E0D\u9700\u8981\u8BA1\u7B97\u5939\u89D2\u5904\u7684\u989D\u5916\u5BBD\u5EA6
    // \u6CE8\u610F: \u7531\u4E8E\u8BA1\u7B97\u7CBE\u5EA6\u95EE\u9898\uFF0C\u5939\u89D2\u4E3A 0 \u7684\u60C5\u51B5\u8BA1\u7B97\u51FA\u6765\u7684\u89D2\u5EA6\u53EF\u80FD\u662F\u4E00\u4E2A\u5F88\u5C0F\u7684\u503C\uFF0C\u8FD8\u9700\u8981\u5224\u65AD\u5176\u4E0E 0 \u662F\u5426\u8FD1\u4F3C\u76F8\u7B49
    if (!currentAngle || Math.sin(currentAngle) === 0 || (0,util_esm/* isNumberEqual */.vQ)(currentAngle, 0)) {
        return {
            xExtra: 0,
            yExtra: 0,
        };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    // \u5C06\u5939\u89D2\u8F6C\u4E3A\u9510\u89D2
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    // \u8FD9\u91CC\u4E0D\u8003\u8651\u5728\u6C34\u5E73\u548C\u5782\u76F4\u65B9\u5411\u7684\u6295\u5F71\uFF0C\u76F4\u63A5\u4F7F\u7528\u6700\u5927\u5DEE\u503C
    // \u7531\u4E8E\u4E0A\u5C42\u7EDF\u4E00\u52A0\u51CF\u4E86\u4E8C\u5206\u4E4B\u4E00\u7EBF\u5BBD\uFF0C\u8FD9\u91CC\u9700\u8981\u8FDB\u884C\u5F25\u8865
    var extra = {
        // \u6C34\u5E73\u65B9\u5411\u6295\u5F71
        xExtra: Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
        // \u5782\u76F4\u65B9\u5411\u6295\u5F71
        yExtra: Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    };
    return extra;
}
/* harmony default export */ function path(shape) {
    var attrs = shape.attr();
    var path = attrs.path, stroke = attrs.stroke;
    var lineWidth = stroke ? attrs.lineWidth : 0; // \u53EA\u6709\u6709 stroke \u65F6\uFF0ClineWidth \u624D\u751F\u6548
    var segments = shape.get('segments') || (0,path_util_esm/* path2Segments */.zx)(path);
    var _a = getPathBox(segments, lineWidth), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    var bbox = {
        minX: x,
        minY: y,
        maxX: x + width,
        maxY: y + height,
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
        x: bbox.minX,
        y: bbox.minY,
        width: bbox.maxX - bbox.minX,
        height: bbox.maxY - bbox.minY,
    };
}
//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/line.js

/* harmony default export */ function line(shape) {
    var attrs = shape.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var bbox = {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY,
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
        x: bbox.minX,
        y: bbox.minY,
        width: bbox.maxX - bbox.minX,
        height: bbox.maxY - bbox.minY,
    };
}
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/ellipse.js
/* harmony default export */ function ellipse(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
    return {
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2,
    };
}
//# sourceMappingURL=ellipse.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-base/esm/bbox/index.js









register('rect', rect);
register('image', rect); // image \u4F7F\u7528 rect \u7684\u5305\u56F4\u76D2\u8BA1\u7B97
register('circle', circle);
register('marker', circle); // marker \u4F7F\u7528 circle \u7684\u8BA1\u7B97\u65B9\u6848
register('polyline', polyline);
register('polygon', polygon);
register('text', bbox_text);
register('path', path);
register('line', line);
register('ellipse', ellipse);

//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/bbox/index.js_+_10_modules?`)},89473:function(__unused_webpack_module,__webpack_exports__){"use strict";eval(`var GraphEvent = /** @class */ (function () {
    function GraphEvent(type, event) {
        /**
         * \u662F\u5426\u5141\u8BB8\u5192\u6CE1
         * @type {boolean}
         */
        this.bubbles = true;
        /**
         * \u89E6\u53D1\u5BF9\u8C61
         * @type {object}
         */
        this.target = null;
        /**
         * \u76D1\u542C\u5BF9\u8C61
         * @type {object}
         */
        this.currentTarget = null;
        /**
         * \u59D4\u6258\u5BF9\u8C61
         * @type {object}
         */
        this.delegateTarget = null;
        /**
         * \u59D4\u6258\u4E8B\u4EF6\u76D1\u542C\u5BF9\u8C61\u7684\u4EE3\u7406\u5BF9\u8C61\uFF0C\u5373 ev.delegateObject = ev.currentTarget.get('delegateObject')
         * @type {object}
         */
        this.delegateObject = null;
        /**
         * \u662F\u5426\u963B\u6B62\u4E86\u539F\u751F\u4E8B\u4EF6
         * @type {boolean}
         */
        this.defaultPrevented = false;
        /**
         * \u662F\u5426\u963B\u6B62\u4F20\u64AD\uFF08\u5411\u4E0A\u5192\u6CE1\uFF09
         * @type {boolean}
         */
        this.propagationStopped = false;
        /**
         * \u89E6\u53D1\u4E8B\u4EF6\u7684\u56FE\u5F62
         * @type {IShape}
         */
        this.shape = null;
        /**
         * \u5F00\u59CB\u89E6\u53D1\u4E8B\u4EF6\u7684\u56FE\u5F62
         * @type {IShape}
         */
        this.fromShape = null;
        /**
         * \u4E8B\u4EF6\u7ED3\u675F\u65F6\u7684\u89E6\u53D1\u56FE\u5F62
         * @type {IShape}
         */
        this.toShape = null;
        // \u89E6\u53D1\u4E8B\u4EF6\u7684\u8DEF\u5F84
        this.propagationPath = [];
        this.type = type;
        this.name = type;
        this.originalEvent = event;
        this.timeStamp = event.timeStamp;
    }
    /**
     * \u963B\u6B62\u6D4F\u89C8\u5668\u9ED8\u8BA4\u7684\u884C\u4E3A
     */
    GraphEvent.prototype.preventDefault = function () {
        this.defaultPrevented = true;
        if (this.originalEvent.preventDefault) {
            this.originalEvent.preventDefault();
        }
    };
    /**
     * \u963B\u6B62\u5192\u6CE1
     */
    GraphEvent.prototype.stopPropagation = function () {
        this.propagationStopped = true;
    };
    GraphEvent.prototype.toString = function () {
        var type = this.type;
        return "[Event (type=" + type + ")]";
    };
    GraphEvent.prototype.save = function () { };
    GraphEvent.prototype.restore = function () { };
    return GraphEvent;
}());
/* harmony default export */ __webpack_exports__["Z"] = (GraphEvent);
//# sourceMappingURL=graph-event.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/event/graph-event.js?`)},98190:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractCanvas": function() { return /* reexport safe */ _abstract_canvas__WEBPACK_IMPORTED_MODULE_5__.Z; },
/* harmony export */   "AbstractGroup": function() { return /* reexport safe */ _abstract_group__WEBPACK_IMPORTED_MODULE_6__.Z; },
/* harmony export */   "AbstractShape": function() { return /* reexport safe */ _abstract_shape__WEBPACK_IMPORTED_MODULE_7__.Z; },
/* harmony export */   "Base": function() { return /* reexport safe */ _abstract_base__WEBPACK_IMPORTED_MODULE_4__.Z; },
/* harmony export */   "Event": function() { return /* reexport safe */ _event_graph_event__WEBPACK_IMPORTED_MODULE_3__.Z; },
/* harmony export */   "PathUtil": function() { return /* reexport module object */ _util_path__WEBPACK_IMPORTED_MODULE_0__; },
/* harmony export */   "assembleFont": function() { return /* reexport safe */ _util_text__WEBPACK_IMPORTED_MODULE_9__.$O; },
/* harmony export */   "getBBoxMethod": function() { return /* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_8__.b; },
/* harmony export */   "getOffScreenContext": function() { return /* reexport safe */ _util_offscreen__WEBPACK_IMPORTED_MODULE_12__.L; },
/* harmony export */   "getTextHeight": function() { return /* reexport safe */ _util_text__WEBPACK_IMPORTED_MODULE_9__.FE; },
/* harmony export */   "invert": function() { return /* reexport safe */ _util_matrix__WEBPACK_IMPORTED_MODULE_11__.U_; },
/* harmony export */   "isAllowCapture": function() { return /* reexport safe */ _util_util__WEBPACK_IMPORTED_MODULE_10__.pP; },
/* harmony export */   "multiplyVec2": function() { return /* reexport safe */ _util_matrix__WEBPACK_IMPORTED_MODULE_11__.rG; },
/* harmony export */   "registerBBox": function() { return /* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_8__.W; },
/* harmony export */   "registerEasing": function() { return /* reexport safe */ _animate_register__WEBPACK_IMPORTED_MODULE_13__.C; },
/* harmony export */   "version": function() { return /* binding */ version; }
/* harmony export */ });
/* harmony import */ var _util_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47575);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_1__) if(["default","Event","Base","AbstractCanvas","AbstractGroup","AbstractShape","PathUtil","getBBoxMethod","registerBBox","getTextHeight","assembleFont","isAllowCapture","multiplyVec2","invert","getOffScreenContext","registerEasing","version"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _types__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19641);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_interfaces__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _interfaces__WEBPACK_IMPORTED_MODULE_2__) if(["default","Event","Base","AbstractCanvas","AbstractGroup","AbstractShape","PathUtil","getBBoxMethod","registerBBox","getTextHeight","assembleFont","isAllowCapture","multiplyVec2","invert","getOffScreenContext","registerEasing","version"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _interfaces__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _event_graph_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89473);
/* harmony import */ var _abstract_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2667);
/* harmony import */ var _abstract_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58906);
/* harmony import */ var _abstract_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(31841);
/* harmony import */ var _abstract_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(15032);
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(46556);
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8723);
/* harmony import */ var _util_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(77341);
/* harmony import */ var _util_matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(41482);
/* harmony import */ var _util_offscreen__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(67052);
/* harmony import */ var _animate_register__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(93924);
/**
 * @fileoverview G \u7684\u57FA\u7840\u63A5\u53E3\u5B9A\u4E49\u548C\u6240\u6709\u7684\u62BD\u8C61\u7C7B
 * @author dxq613@gmail.com
 */















var version = '0.5.11';
//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/index.js?`)},19641:function(){eval(`//# sourceMappingURL=interfaces.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/interfaces.js?`)},52:function(){eval(`//# sourceMappingURL=types.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/types.js?`)},41482:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U_": function() { return /* binding */ invert; },
/* harmony export */   "rG": function() { return /* binding */ multiplyVec2; },
/* harmony export */   "xq": function() { return /* binding */ multiplyMatrix; }
/* harmony export */ });
/**
 * @fileoverview \u77E9\u9635\u8FD0\u7B97\uFF0C\u672C\u6765\u662F\u8981\u5F15\u5165 gl-matrix, \u4F46\u662F\u8003\u8651\u5230 g-mobile \u5BF9\u5927\u5C0F\u6709\u9650\u5236\uFF0C\u540C\u65F6 g-webgl \u4F7F\u7528\u7684 matrix \u4E0D\u4E00\u81F4
 * \u6240\u4EE5\uFF0C\u8FD9\u91CC\u4EC5\u5B9E\u73B0 2D \u51E0\u4E2A\u8FD0\u7B97\uFF0C\u4E0A\u5C42\u81EA\u5DF1\u5F15\u5165 gl-matrix
 * @author dxq613@gmail.com
 */
/**
 * 3\u9636\u77E9\u9635\u76F8\u4E58
 * @param {number[]} a \u77E9\u96351
 * @param {number[]} b \u77E9\u96352
 */
function multiplyMatrix(a, b) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b00 = b[0];
    var b01 = b[1];
    var b02 = b[2];
    var b10 = b[3];
    var b11 = b[4];
    var b12 = b[5];
    var b20 = b[6];
    var b21 = b[7];
    var b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
}
/**
 * 3\u9636\u77E9\u9635\u540C2\u9636\u5411\u91CF\u76F8\u4E58
 * @param {number[]} m \u77E9\u9635
 * @param {number[]} v \u4E8C\u9636\u5411\u91CF
 */
function multiplyVec2(m, v) {
    var out = [];
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
/**
 * \u77E9\u9635\u7684\u9006
 * @param {number[]} a \u77E9\u9635
 */
function invert(a) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    // Calculate the determinant
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
        return null;
    }
    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
}
//# sourceMappingURL=matrix.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/util/matrix.js?`)},67052:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": function() { return /* binding */ getOffScreenContext; }
/* harmony export */ });
// \u5168\u5C40\u8BBE\u7F6E\u4E00\u4E2A\u552F\u4E00\u79BB\u5C4F\u7684 ctx\uFF0C\u7528\u4E8E\u8BA1\u7B97 isPointInPath
var offScreenCtx = null;
function getOffScreenContext() {
    if (!offScreenCtx) {
        var canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        offScreenCtx = canvas.getContext('2d');
    }
    return offScreenCtx;
}
//# sourceMappingURL=offscreen.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/util/offscreen.js?`)},47575:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "catmullRomToBezier": function() { return /* binding */ catmullRomToBezier; },
/* harmony export */   "fillPath": function() { return /* binding */ fillPath; },
/* harmony export */   "fillPathByDiff": function() { return /* binding */ fillPathByDiff; },
/* harmony export */   "formatPath": function() { return /* binding */ formatPath; },
/* harmony export */   "intersection": function() { return /* binding */ intersection; },
/* harmony export */   "parsePathArray": function() { return /* binding */ parsePathArray; },
/* harmony export */   "parsePathString": function() { return /* binding */ parsePathString; },
/* harmony export */   "pathToAbsolute": function() { return /* binding */ pathToAbsolute; },
/* harmony export */   "pathToCurve": function() { return /* binding */ pathToCurve; },
/* harmony export */   "rectPath": function() { return /* binding */ rectPath; }
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45098);

var SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", 'ig');
var PATH_VALUES = new RegExp("(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", 'ig');
// Parse given path string into an array of arrays of path segments
var parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(pathString)) {
        return pathString;
    }
    var paramCounts = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0,
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND, function (a, b, c) {
        var params = [];
        var name = b.toLowerCase();
        c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
        });
        if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
        }
        if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
        }
        if (name === 'r') {
            data.push([b].concat(params));
        }
        else {
            while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        }
        return pathString;
    });
    return data;
};
// http://schepers.cc/getting-to-the-point
var catmullRomToBezier = function (crp, z) {
    var d = [];
    // @ts-ignore
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
        var p = [
            {
                x: +crp[i - 2],
                y: +crp[i - 1],
            },
            {
                x: +crp[i],
                y: +crp[i + 1],
            },
            {
                x: +crp[i + 2],
                y: +crp[i + 3],
            },
            {
                x: +crp[i + 4],
                y: +crp[i + 5],
            },
        ];
        if (z) {
            if (!i) {
                p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1],
                };
            }
            else if (iLen - 4 === i) {
                p[3] = {
                    x: +crp[0],
                    y: +crp[1],
                };
            }
            else if (iLen - 2 === i) {
                p[2] = {
                    x: +crp[0],
                    y: +crp[1],
                };
                p[3] = {
                    x: +crp[2],
                    y: +crp[3],
                };
            }
        }
        else {
            if (iLen - 4 === i) {
                p[3] = p[2];
            }
            else if (!i) {
                p[0] = {
                    x: +crp[i],
                    y: +crp[i + 1],
                };
            }
        }
        d.push([
            'C',
            (-p[0].x + 6 * p[1].x + p[2].x) / 6,
            (-p[0].y + 6 * p[1].y + p[2].y) / 6,
            (p[1].x + 6 * p[2].x - p[3].x) / 6,
            (p[1].y + 6 * p[2].y - p[3].y) / 6,
            p[2].x,
            p[2].y,
        ]);
    }
    return d;
};
var ellipsePath = function (x, y, rx, ry, a) {
    var res = [];
    if (a === null && ry === null) {
        ry = rx;
    }
    x = +x;
    y = +y;
    rx = +rx;
    ry = +ry;
    if (a !== null) {
        var rad = Math.PI / 180;
        var x1 = x + rx * Math.cos(-ry * rad);
        var x2 = x + rx * Math.cos(-a * rad);
        var y1 = y + rx * Math.sin(-ry * rad);
        var y2 = y + rx * Math.sin(-a * rad);
        res = [
            ['M', x1, y1],
            ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2],
        ];
    }
    else {
        res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
    }
    return res;
};
var pathToAbsolute = function (pathArray) {
    pathArray = parsePathString(pathArray);
    if (!pathArray || !pathArray.length) {
        return [['M', 0, 0]];
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    if (pathArray[0][0] === 'M') {
        x = +pathArray[0][1];
        y = +pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[0] = ['M', x, y];
    }
    var crz = pathArray.length === 3 &&
        pathArray[0][0] === 'M' &&
        pathArray[1][0].toUpperCase() === 'R' &&
        pathArray[2][0].toUpperCase() === 'Z';
    for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
        res.push((r = []));
        pa = pathArray[i];
        pa0 = pa[0];
        if (pa0 !== pa0.toUpperCase()) {
            r[0] = pa0.toUpperCase();
            switch (r[0]) {
                case 'A':
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +pa[6] + x;
                    r[7] = +pa[7] + y;
                    break;
                case 'V':
                    r[1] = +pa[1] + y;
                    break;
                case 'H':
                    r[1] = +pa[1] + x;
                    break;
                case 'R':
                    dots = [x, y].concat(pa.slice(1));
                    for (var j = 2, jj = dots.length; j < jj; j++) {
                        dots[j] = +dots[j] + x;
                        dots[++j] = +dots[j] + y;
                    }
                    res.pop();
                    res = res.concat(catmullRomToBezier(dots, crz));
                    break;
                case 'O':
                    res.pop();
                    dots = ellipsePath(x, y, pa[1], pa[2]);
                    dots.push(dots[0]);
                    res = res.concat(dots);
                    break;
                case 'U':
                    res.pop();
                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                    r = ['U'].concat(res[res.length - 1].slice(-2));
                    break;
                case 'M':
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                    break; // for lint
                default:
                    for (var j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +pa[j] + (j % 2 ? x : y);
                    }
            }
        }
        else if (pa0 === 'R') {
            dots = [x, y].concat(pa.slice(1));
            res.pop();
            res = res.concat(catmullRomToBezier(dots, crz));
            r = ['R'].concat(pa.slice(-2));
        }
        else if (pa0 === 'O') {
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
        }
        else if (pa0 === 'U') {
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ['U'].concat(res[res.length - 1].slice(-2));
        }
        else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
                r[k] = pa[k];
            }
        }
        pa0 = pa0.toUpperCase();
        if (pa0 !== 'O') {
            switch (r[0]) {
                case 'Z':
                    x = +mx;
                    y = +my;
                    break;
                case 'H':
                    x = r[1];
                    break;
                case 'V':
                    y = r[1];
                    break;
                case 'M':
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                    break; // for lint
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
    }
    return res;
};
var l2c = function (x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
};
var q2c = function (x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3;
    var _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    if (rx === ry) {
        rx += 1;
    }
    var _120 = (Math.PI * 120) / 180;
    var rad = (Math.PI / 180) * (+angle || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    var rotate = function (x, y, rad) {
        var X = x * Math.cos(rad) - y * Math.sin(rad);
        var Y = x * Math.sin(rad) + y * Math.cos(rad);
        return {
            x: X,
            y: Y,
        };
    };
    if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate(x2, y2, -rad);
        x2 = xy.x;
        y2 = xy.y;
        if (x1 === x2 && y1 === y2) {
            // \u82E5\u5F27\u7684\u8D77\u59CB\u70B9\u548C\u7EC8\u70B9\u91CD\u53E0\u5219\u9519\u5F00\u4E00\u70B9
            x2 += 1;
            y2 += 1;
        }
        // const cos = Math.cos(Math.PI / 180 * angle);
        // const sin = Math.sin(Math.PI / 180 * angle);
        var x = (x1 - x2) / 2;
        var y = (y1 - y2) / 2;
        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
        if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
        }
        var rx2 = rx * rx;
        var ry2 = ry * ry;
        var k = (large_arc_flag === sweep_flag ? -1 : 1) *
            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
        cx = (k * rx * y) / ry + (x1 + x2) / 2;
        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
        // @ts-ignore
        f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
        // @ts-ignore
        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        f1 < 0 && (f1 = Math.PI * 2 + f1);
        f2 < 0 && (f2 = Math.PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
            f1 = f1 - Math.PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
            f2 = f2 - Math.PI * 2;
        }
    }
    else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > _120) {
        var f2old = f2;
        var x2old = x2;
        var y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2);
        y2 = cy + ry * Math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c2 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = (4 / 3) * rx * t;
    var hy = (4 / 3) * ry * t;
    var m1 = [x1, y1];
    var m2 = [x1 + hx * s1, y1 - hy * c1];
    var m3 = [x2 + hx * s2, y2 - hy * c2];
    var m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    res = [m2, m3, m4].concat(res).join().split(',');
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
    }
    return newres;
};
var pathToCurve = function (path, path2) {
    var p = pathToAbsolute(path);
    var p2 = path2 && pathToAbsolute(path2);
    var attrs = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null,
    };
    var attrs2 = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null,
    };
    var pcoms1 = []; // path commands of original path p
    var pcoms2 = []; // path commands of original path p2
    var pfirst = ''; // temporary holder for original path command
    var pcom = ''; // holder for previous path command of original path
    var ii;
    var processPath = function (path, d, pcom) {
        var nx;
        var ny;
        if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        !(path[0] in
            {
                T: 1,
                Q: 1,
            }) && (d.qx = d.qy = null);
        switch (path[0]) {
            case 'M':
                d.X = path[1];
                d.Y = path[2];
                break;
            case 'A':
                path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                break;
            case 'S':
                if (pcom === 'C' || pcom === 'S') {
                    // In "S" case we have to take into account, if the previous command is C/S.
                    nx = d.x * 2 - d.bx; // And reflect the previous
                    ny = d.y * 2 - d.by; // command's control point relative to the current point.
                }
                else {
                    // or some else or nothing
                    nx = d.x;
                    ny = d.y;
                }
                path = ['C', nx, ny].concat(path.slice(1));
                break;
            case 'T':
                if (pcom === 'Q' || pcom === 'T') {
                    // In "T" case we have to take into account, if the previous command is Q/T.
                    d.qx = d.x * 2 - d.qx; // And make a reflection similar
                    d.qy = d.y * 2 - d.qy; // to case "S".
                }
                else {
                    // or something else or nothing
                    d.qx = d.x;
                    d.qy = d.y;
                }
                path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                break;
            case 'Q':
                d.qx = path[1];
                d.qy = path[2];
                path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                break;
            case 'L':
                path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
                break;
            case 'H':
                path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
                break;
            case 'V':
                path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
                break;
            case 'Z':
                path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
                break;
            default:
                break;
        }
        return path;
    };
    var fixArc = function (pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];
            while (pi.length) {
                pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved
                p2 && (pcoms2[i] = 'A'); // the same as above
                pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = Math.max(p.length, (p2 && p2.length) || 0);
        }
    };
    var fixM = function (path1, path2, a1, a2, i) {
        if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
            path2.splice(i, 0, ['M', a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = Math.max(p.length, (p2 && p2.length) || 0);
        }
    };
    ii = Math.max(p.length, (p2 && p2.length) || 0);
    for (var i = 0; i < ii; i++) {
        p[i] && (pfirst = p[i][0]); // save current path command
        if (pfirst !== 'C') {
            // C is not saved yet, because it may be result of conversion
            pcoms1[i] = pfirst; // Save current path command
            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
        }
        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
        if (pcoms1[i] !== 'A' && pfirst === 'C')
            pcoms1[i] = 'C'; // A is the only command
        // which may produce multiple C:s
        // so we have to make sure that C is also C in original path
        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
        if (p2) {
            // the same procedures is done to p2
            p2[i] && (pfirst = p2[i][0]);
            if (pfirst !== 'C') {
                pcoms2[i] = pfirst;
                i && (pcom = pcoms2[i - 1]);
            }
            p2[i] = processPath(p2[i], attrs2, pcom);
            if (pcoms2[i] !== 'A' && pfirst === 'C') {
                pcoms2[i] = 'C';
            }
            fixArc(p2, i);
        }
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i];
        var seg2 = p2 && p2[i];
        var seglen = seg.length;
        var seg2len = p2 && seg2.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
    }
    return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function (path) {
    return path.join(',').replace(p2s, '$1');
};
var base3 = function (t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function (x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z === null) {
        z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [
        -0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816,
    ];
    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    var sum = 0;
    for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2;
        var xbase = base3(ct, x1, x2, x3, x4);
        var ybase = base3(ct, y1, y2, y3, y4);
        var comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
};
var curveDim = function (x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [];
    var bounds = [[], []];
    var a;
    var b;
    var c;
    var t;
    for (var i = 0; i < 2; ++i) {
        if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
        }
        else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
        }
        if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
                continue;
            }
            t = -c / b;
            if (t > 0 && t < 1) {
                tvalues.push(t);
            }
            continue;
        }
        var b2ac = b * b - 4 * c * a;
        var sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
            continue;
        }
        var t1 = (-b + sqrtb2ac) / (2 * a);
        if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
        }
        var t2 = (-b - sqrtb2ac) / (2 * a);
        if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
        }
    }
    var j = tvalues.length;
    var jlen = j;
    var mt;
    while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
        bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
        min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1]),
        },
        max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1]),
        },
    };
};
var intersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    if (Math.max(x1, x2) < Math.min(x3, x4) ||
        Math.min(x1, x2) > Math.max(x3, x4) ||
        Math.max(y1, y2) < Math.min(y3, y4) ||
        Math.min(y1, y2) > Math.max(y3, y4)) {
        return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
        return;
    }
    var px = nx / denominator;
    var py = ny / denominator;
    var px2 = +px.toFixed(2);
    var py2 = +py.toFixed(2);
    if (px2 < +Math.min(x1, x2).toFixed(2) ||
        px2 > +Math.max(x1, x2).toFixed(2) ||
        px2 < +Math.min(x3, x4).toFixed(2) ||
        px2 > +Math.max(x3, x4).toFixed(2) ||
        py2 < +Math.min(y1, y2).toFixed(2) ||
        py2 > +Math.max(y1, y2).toFixed(2) ||
        py2 < +Math.min(y3, y4).toFixed(2) ||
        py2 > +Math.max(y3, y4).toFixed(2)) {
        return;
    }
    return {
        x: px,
        y: py,
    };
};
var isPointInsideBBox = function (bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function (x, y, w, h, r) {
    if (r) {
        return [
            ['M', +x + +r, y],
            ['l', w - r * 2, 0],
            ['a', r, r, 0, 0, 1, r, r],
            ['l', 0, h - r * 2],
            ['a', r, r, 0, 0, 1, -r, r],
            ['l', r * 2 - w, 0],
            ['a', r, r, 0, 0, 1, -r, -r],
            ['l', 0, r * 2 - h],
            ['a', r, r, 0, 0, 1, r, -r],
            ['z'],
        ];
    }
    var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
    // @ts-ignore
    res.parsePathArray = parsePathArray;
    return res;
};
var box = function (x, y, width, height) {
    if (x === null) {
        x = y = width = height = 0;
    }
    if (y === null) {
        y = x.y;
        width = x.width;
        height = x.height;
        x = x.x;
    }
    return {
        x: x,
        y: y,
        width: width,
        w: width,
        height: height,
        h: height,
        x2: x + width,
        y2: y + height,
        cx: x + width / 2,
        cy: y + height / 2,
        r1: Math.min(width, height) / 2,
        r2: Math.max(width, height) / 2,
        r0: Math.sqrt(width * width + height * height) / 2,
        path: rectPath(x, y, width, height),
        vb: [x, y, width, height].join(' '),
    };
};
var isBBoxIntersect = function (bbox1, bbox2) {
    bbox1 = box(bbox1);
    bbox2 = box(bbox2);
    return (isPointInsideBBox(bbox2, bbox1.x, bbox1.y) ||
        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) ||
        isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) ||
        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) ||
        isPointInsideBBox(bbox1, bbox2.x, bbox2.y) ||
        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) ||
        isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) ||
        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) ||
        (((bbox1.x < bbox2.x2 && bbox1.x > bbox2.x) || (bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)) &&
            ((bbox1.y < bbox2.y2 && bbox1.y > bbox2.y) || (bbox2.y < bbox1.y2 && bbox2.y > bbox1.y))));
};
var bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(p1x)) {
        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    var t13 = Math.pow(t1, 3);
    var t12 = Math.pow(t1, 2);
    var t2 = t * t;
    var t3 = t2 * t;
    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
    var ax = t1 * p1x + t * c1x;
    var ay = t1 * p1y + t * c1y;
    var cx = t1 * c2x + t * p2x;
    var cy = t1 * c2y + t * p2y;
    var alpha = 90 - (Math.atan2(mx - nx, my - ny) * 180) / Math.PI;
    // (mx > nx || my < ny) && (alpha += 180);
    return {
        x: x,
        y: y,
        m: {
            x: mx,
            y: my,
        },
        n: {
            x: nx,
            y: ny,
        },
        start: {
            x: ax,
            y: ay,
        },
        end: {
            x: cx,
            y: cy,
        },
        alpha: alpha,
    };
};
var interHelper = function (bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1);
    var bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1);
    var l2 = bezlen.apply(0, bez2);
    var n1 = ~~(l1 / 8);
    var n2 = ~~(l2 / 8);
    var dots1 = [];
    var dots2 = [];
    var xy = {};
    var res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
        dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1,
        });
    }
    for (var i = 0; i < n2 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
        dots2.push({
            x: d.x,
            y: d.y,
            t: i / n2,
        });
    }
    for (var i = 0; i < n1; i++) {
        for (var j = 0; j < n2; j++) {
            var di = dots1[i];
            var di1 = dots1[i + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                    continue;
                }
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                    if (justCount) {
                        // @ts-ignore
                        res += 1;
                    }
                    else {
                        // @ts-ignore
                        res.push({
                            x: is.x,
                            y: is.y,
                            t1: t1,
                            t2: t2,
                        });
                    }
                }
            }
        }
    }
    return res;
};
var interPathHelper = function (path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);
    var x1;
    var y1;
    var x2;
    var y2;
    var x1m;
    var y1m;
    var x2m;
    var y2m;
    var bez1;
    var bez2;
    var res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
        var pi = path1[i];
        if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
        }
        else {
            if (pi[0] === 'C') {
                bez1 = [x1, y1].concat(pi.slice(1));
                x1 = bez1[6];
                y1 = bez1[7];
            }
            else {
                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                x1 = x1m;
                y1 = y1m;
            }
            for (var j = 0, jj = path2.length; j < jj; j++) {
                var pj = path2[j];
                if (pj[0] === 'M') {
                    x2 = x2m = pj[1];
                    y2 = y2m = pj[2];
                }
                else {
                    if (pj[0] === 'C') {
                        bez2 = [x2, y2].concat(pj.slice(1));
                        x2 = bez2[6];
                        y2 = bez2[7];
                    }
                    else {
                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                        x2 = x2m;
                        y2 = y2m;
                    }
                    var intr = interHelper(bez1, bez2, justCount);
                    if (justCount) {
                        // @ts-ignore
                        res += intr;
                    }
                    else {
                        // @ts-ignore
                        for (var k = 0, kk = intr.length; k < kk; k++) {
                            intr[k].segment1 = i;
                            intr[k].segment2 = j;
                            intr[k].bez1 = bez1;
                            intr[k].bez2 = bez2;
                        }
                        // @ts-ignore
                        res = res.concat(intr);
                    }
                }
            }
        }
    }
    return res;
};
var intersection = function (path1, path2) {
    return interPathHelper(path1, path2);
};
function decasteljau(points, t) {
    var left = [];
    var right = [];
    function recurse(points, t) {
        if (points.length === 1) {
            left.push(points[0]);
            right.push(points[0]);
        }
        else {
            var middlePoints = [];
            for (var i = 0; i < points.length - 1; i++) {
                if (i === 0) {
                    left.push(points[0]);
                }
                if (i === points.length - 2) {
                    right.push(points[i + 1]);
                }
                middlePoints[i] = [
                    (1 - t) * points[i][0] + t * points[i + 1][0],
                    (1 - t) * points[i][1] + t * points[i + 1][1],
                ];
            }
            recurse(middlePoints, t);
        }
    }
    if (points.length) {
        recurse(points, t);
    }
    return { left: left, right: right.reverse() };
}
function splitCurve(start, end, count) {
    var points = [[start[1], start[2]]];
    count = count || 2;
    var segments = [];
    if (end[0] === 'A') {
        points.push(end[6]);
        points.push(end[7]);
    }
    else if (end[0] === 'C') {
        points.push([end[1], end[2]]);
        points.push([end[3], end[4]]);
        points.push([end[5], end[6]]);
    }
    else if (end[0] === 'S' || end[0] === 'Q') {
        points.push([end[1], end[2]]);
        points.push([end[3], end[4]]);
    }
    else {
        points.push([end[1], end[2]]);
    }
    var leftSegments = points;
    var t = 1 / count;
    for (var i = 0; i < count - 1; i++) {
        var rt = t / (1 - t * i);
        var split = decasteljau(leftSegments, rt);
        segments.push(split.left);
        leftSegments = split.right;
    }
    segments.push(leftSegments);
    var result = segments.map(function (segment) {
        var cmd = [];
        if (segment.length === 4) {
            cmd.push('C');
            cmd = cmd.concat(segment[2]);
        }
        if (segment.length >= 3) {
            if (segment.length === 3) {
                cmd.push('Q');
            }
            cmd = cmd.concat(segment[1]);
        }
        if (segment.length === 2) {
            cmd.push('L');
        }
        cmd = cmd.concat(segment[segment.length - 1]);
        return cmd;
    });
    return result;
}
var splitSegment = function (start, end, count) {
    if (count === 1) {
        return [[].concat(start)];
    }
    var segments = [];
    if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
        segments = segments.concat(splitCurve(start, end, count));
    }
    else {
        var temp = [].concat(start);
        if (temp[0] === 'M') {
            temp[0] = 'L';
        }
        for (var i = 0; i <= count - 1; i++) {
            segments.push(temp);
        }
    }
    return segments;
};
var fillPath = function (source, target) {
    if (source.length === 1) {
        return source;
    }
    var sourceLen = source.length - 1;
    var targetLen = target.length - 1;
    var ratio = sourceLen / targetLen;
    var segmentsToFill = [];
    if (source.length === 1 && source[0][0] === 'M') {
        for (var i = 0; i < targetLen - sourceLen; i++) {
            source.push(source[0]);
        }
        return source;
    }
    for (var i = 0; i < targetLen; i++) {
        var index = Math.floor(ratio * i);
        segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
    }
    var filled = segmentsToFill.reduce(function (filled, count, i) {
        if (i === sourceLen) {
            return filled.concat(source[sourceLen]);
        }
        return filled.concat(splitSegment(source[i], source[i + 1], count));
    }, []);
    filled.unshift(source[0]);
    if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
        filled.push('Z');
    }
    return filled;
};
var isEqual = function (obj1, obj2) {
    if (obj1.length !== obj2.length) {
        return false;
    }
    var result = true;
    (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(obj1, function (item, i) {
        if (item !== obj2[i]) {
            result = false;
            return false;
        }
    });
    return result;
};
function getMinDiff(del, add, modify) {
    var type = null;
    var min = modify;
    if (add < min) {
        min = add;
        type = 'add';
    }
    if (del < min) {
        min = del;
        type = 'del';
    }
    return {
        type: type,
        min: min,
    };
}
/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * \u8BA1\u7B97\u4E24\u6761path\u7684\u7F16\u8F91\u8DDD\u79BB
 */
var levenshteinDistance = function (source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment;
    var targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
        return null;
    }
    var dist = [];
    for (var i = 0; i <= sourceLen; i++) {
        dist[i] = [];
        dist[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
        dist[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
        sourceSegment = source[i - 1];
        for (var j = 1; j <= targetLen; j++) {
            targetSegment = target[j - 1];
            if (isEqual(sourceSegment, targetSegment)) {
                temp = 0;
            }
            else {
                temp = 1;
            }
            var del = dist[i - 1][j].min + 1;
            var add = dist[i][j - 1].min + 1;
            var modify = dist[i - 1][j - 1].min + temp;
            dist[i][j] = getMinDiff(del, add, modify);
        }
    }
    return dist;
};
var fillPathByDiff = function (source, target) {
    var diffMatrix = levenshteinDistance(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    // \u5982\u679Csource\u548Ctarget\u4E0D\u662F\u5B8C\u5168\u4E0D\u76F8\u7B49
    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
        // \u83B7\u53D6\u4ECEsource\u5230target\u6240\u9700\u6539\u52A8
        for (var i = 1; i <= sourceLen; i++) {
            var min = diffMatrix[i][i].min;
            minPos = i;
            for (var j = index; j <= targetLen; j++) {
                if (diffMatrix[i][j].min < min) {
                    min = diffMatrix[i][j].min;
                    minPos = j;
                }
            }
            index = minPos;
            if (diffMatrix[i][index].type) {
                changes.push({ index: i - 1, type: diffMatrix[i][index].type });
            }
        }
        // \u5BF9source\u8FDB\u884C\u589E\u5220path
        for (var i = changes.length - 1; i >= 0; i--) {
            index = changes[i].index;
            if (changes[i].type === 'add') {
                source.splice(index, 0, [].concat(source[index]));
            }
            else {
                source.splice(index, 1);
            }
        }
    }
    // source\u5C3E\u90E8\u8865\u9F50
    sourceLen = source.length;
    var diff = targetLen - sourceLen;
    if (sourceLen < targetLen) {
        for (var i = 0; i < diff; i++) {
            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
                source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
            }
            else {
                source.push(source[sourceLen - 1]);
            }
            sourceLen += 1;
        }
    }
    return source;
};
// \u5C06\u4E24\u4E2A\u70B9\u5747\u5206\u6210count\u4E2A\u70B9
function _splitPoints(points, former, count) {
    var result = [].concat(points);
    var index;
    var t = 1 / (count + 1);
    var formerEnd = _getSegmentPoints(former)[0];
    for (var i = 1; i <= count; i++) {
        t *= i;
        index = Math.floor(points.length * t);
        if (index === 0) {
            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
        }
        else {
            result.splice(index, 0, [
                formerEnd[0] * t + points[index][0] * (1 - t),
                formerEnd[1] * t + points[index][1] * (1 - t),
            ]);
        }
    }
    return result;
}
/*
 * \u62BD\u53D6pathSegment\u4E2D\u7684\u5173\u952E\u70B9
 * M,L,A,Q,H,V\u4E00\u4E2A\u7AEF\u70B9
 * Q, S\u62BD\u53D6\u4E00\u4E2A\u7AEF\u70B9\uFF0C\u4E00\u4E2A\u63A7\u5236\u70B9
 * C\u62BD\u53D6\u4E00\u4E2A\u7AEF\u70B9\uFF0C\u4E24\u4E2A\u63A7\u5236\u70B9
 */
function _getSegmentPoints(segment) {
    var points = [];
    switch (segment[0]) {
        case 'M':
            points.push([segment[1], segment[2]]);
            break;
        case 'L':
            points.push([segment[1], segment[2]]);
            break;
        case 'A':
            points.push([segment[6], segment[7]]);
            break;
        case 'Q':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;
        case 'T':
            points.push([segment[1], segment[2]]);
            break;
        case 'C':
            points.push([segment[5], segment[6]]);
            points.push([segment[1], segment[2]]);
            points.push([segment[3], segment[4]]);
            break;
        case 'S':
            points.push([segment[3], segment[4]]);
            points.push([segment[1], segment[2]]);
            break;
        case 'H':
            points.push([segment[1], segment[1]]);
            break;
        case 'V':
            points.push([segment[1], segment[1]]);
            break;
        default:
    }
    return points;
}
var formatPath = function (fromPath, toPath) {
    if (fromPath.length <= 1) {
        return fromPath;
    }
    var points;
    for (var i = 0; i < toPath.length; i++) {
        if (fromPath[i][0] !== toPath[i][0]) {
            // \u83B7\u53D6fromPath\u7684pathSegment\u7684\u7AEF\u70B9\uFF0C\u6839\u636EtoPath\u7684\u6307\u4EE4\u5BF9\u5176\u6539\u9020
            points = _getSegmentPoints(fromPath[i]);
            switch (toPath[i][0]) {
                case 'M':
                    fromPath[i] = ['M'].concat(points[0]);
                    break;
                case 'L':
                    fromPath[i] = ['L'].concat(points[0]);
                    break;
                case 'A':
                    fromPath[i] = [].concat(toPath[i]);
                    fromPath[i][6] = points[0][0];
                    fromPath[i][7] = points[0][1];
                    break;
                case 'Q':
                    if (points.length < 2) {
                        if (i > 0) {
                            points = _splitPoints(points, fromPath[i - 1], 1);
                        }
                        else {
                            fromPath[i] = toPath[i];
                            break;
                        }
                    }
                    fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
                        return arr.concat(i);
                    }, []));
                    break;
                case 'T':
                    fromPath[i] = ['T'].concat(points[0]);
                    break;
                case 'C':
                    if (points.length < 3) {
                        if (i > 0) {
                            points = _splitPoints(points, fromPath[i - 1], 2);
                        }
                        else {
                            fromPath[i] = toPath[i];
                            break;
                        }
                    }
                    fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
                        return arr.concat(i);
                    }, []));
                    break;
                case 'S':
                    if (points.length < 2) {
                        if (i > 0) {
                            points = _splitPoints(points, fromPath[i - 1], 1);
                        }
                        else {
                            fromPath[i] = toPath[i];
                            break;
                        }
                    }
                    fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
                        return arr.concat(i);
                    }, []));
                    break;
                default:
                    fromPath[i] = toPath[i];
            }
        }
    }
    return fromPath;
};

//# sourceMappingURL=path.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/util/path.js?`)},8723:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$O": function() { return /* binding */ assembleFont; },
/* harmony export */   "FE": function() { return /* binding */ getTextHeight; },
/* harmony export */   "mY": function() { return /* binding */ getTextWidth; }
/* harmony export */ });
/* unused harmony export getLineSpaceing */
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77341);
/* harmony import */ var _offscreen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67052);


/**
 * \u83B7\u53D6\u6587\u672C\u7684\u9AD8\u5EA6
 * @param text \u6587\u672C
 * @param fontSize \u5B57\u4F53\u5927\u5C0F
 * @param lineHeight \u884C\u9AD8\uFF0C\u53EF\u4EE5\u4E3A\u7A7A
 */
function getTextHeight(text, fontSize, lineHeight) {
    var lineCount = 1;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(text)) {
        lineCount = text.split('\\n').length;
    }
    if (lineCount > 1) {
        var spaceingY = getLineSpaceing(fontSize, lineHeight);
        return fontSize * lineCount + spaceingY * (lineCount - 1);
    }
    return fontSize;
}
/**
 * \u83B7\u53D6\u884C\u95F4\u8DDD\u5982\u679C\u6587\u672C\u591A\u884C\uFF0C\u9700\u8981\u83B7\u53D6\u6587\u672C\u95F4\u8DDD
 * @param fontSize \u5B57\u4F53\u5927\u5C0F
 * @param lineHeight \u884C\u9AD8
 */
function getLineSpaceing(fontSize, lineHeight) {
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
/**
 * \u5B57\u4F53\u5BBD\u5EA6
 * @param text \u6587\u672C
 * @param font \u5B57\u4F53
 */
function getTextWidth(text, font) {
    var context = (0,_offscreen__WEBPACK_IMPORTED_MODULE_1__/* .getOffScreenContext */ .L)(); // \u83B7\u53D6\u79BB\u5C4F\u7684 ctx \u8FDB\u884C\u8BA1\u7B97
    var width = 0;
    // null \u6216\u8005 undefined \u65F6\uFF0C\u5BBD\u5EA6\u4E3A 0
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__/* .isNil */ .kK)(text) || text === '') {
        return width;
    }
    context.save();
    context.font = font;
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__/* .isString */ .HD)(text) && text.includes('\\n')) {
        var textArr = text.split('\\n');
        (0,_util__WEBPACK_IMPORTED_MODULE_0__/* .each */ .S6)(textArr, function (subText) {
            var measureWidth = context.measureText(subText).width;
            if (width < measureWidth) {
                width = measureWidth;
            }
        });
    }
    else {
        width = context.measureText(text).width;
    }
    context.restore();
    return width;
}
function assembleFont(attrs) {
    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
    return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ').trim();
}
//# sourceMappingURL=text.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/util/text.js?`)},77341:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "As": function() { return /* binding */ removeFromArray; },
/* harmony export */   "CD": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.CD; },
/* harmony export */   "HD": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.HD; },
/* harmony export */   "Kn": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.Kn; },
/* harmony export */   "S6": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.S6; },
/* harmony export */   "UY": function() { return /* binding */ isParent; },
/* harmony export */   "jC": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.jC; },
/* harmony export */   "jU": function() { return /* binding */ isBrowser; },
/* harmony export */   "kK": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.UM; },
/* harmony export */   "mf": function() { return /* reexport safe */ _antv_util__WEBPACK_IMPORTED_MODULE_0__.mf; },
/* harmony export */   "pP": function() { return /* binding */ isAllowCapture; }
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45098);
function removeFromArray(arr, obj) {
    var index = arr.indexOf(obj);
    if (index !== -1) {
        arr.splice(index, 1);
    }
}
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

// \u662F\u5426\u5143\u7D20\u7684\u7236\u5BB9\u5668
function isParent(container, shape) {
    // \u6240\u6709 shape \u90FD\u662F canvas \u7684\u5B50\u5143\u7D20
    if (container.isCanvas()) {
        return true;
    }
    var parent = shape.getParent();
    var isParent = false;
    while (parent) {
        if (parent === container) {
            isParent = true;
            break;
        }
        parent = parent.getParent();
    }
    return isParent;
}
function isAllowCapture(element) {
    // @ts-ignore
    return element.cfg.visible && element.cfg.capture;
}
//# sourceMappingURL=util.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-base/esm/util/util.js?`)},32793:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "wN": function() { return /* reexport */ arc; },
  "Ll": function() { return /* reexport */ cubic; },
  "x1": function() { return /* reexport */ line; },
  "aH": function() { return /* reexport */ polyline; },
  "lD": function() { return /* reexport */ quadratic; },
  "Zr": function() { return /* reexport */ util_namespaceObject; }
});

// UNUSED EXPORTS: Polygon

// NAMESPACE OBJECT: ./node_modules/@antv/g-math/esm/util.js
var util_namespaceObject = {};
__webpack_require__.r(util_namespaceObject);
__webpack_require__.d(util_namespaceObject, {
  "distance": function() { return distance; },
  "getBBoxByArray": function() { return getBBoxByArray; },
  "getBBoxRange": function() { return getBBoxRange; },
  "isNumberEqual": function() { return isNumberEqual; },
  "piMod": function() { return piMod; }
});

// EXTERNAL MODULE: ./node_modules/@antv/util/esm/index.js + 104 modules
var esm = __webpack_require__(45098);
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/util.js

/**
 * \u4E24\u70B9\u4E4B\u95F4\u7684\u8DDD\u79BB
 * @param {number} x1 \u8D77\u59CB\u70B9 x
 * @param {number} y1 \u8D77\u59CB\u70B9 y
 * @param {number} x2 \u7ED3\u675F\u70B9 x
 * @param {number} y2 \u7ED3\u675F\u70B9 y
 * @return {number} \u8DDD\u79BB
 */
function distance(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual(v1, v2) {
    return Math.abs(v1 - v2) < 0.001;
}
function getBBoxByArray(xArr, yArr) {
    var minX = (0,esm/* min */.VV)(xArr);
    var minY = (0,esm/* min */.VV)(yArr);
    var maxX = (0,esm/* max */.Fp)(xArr);
    var maxY = (0,esm/* max */.Fp)(yArr);
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY,
    };
}
function getBBoxRange(x1, y1, x2, y2) {
    return {
        minX: (0,esm/* min */.VV)([x1, x2]),
        maxX: (0,esm/* max */.Fp)([x1, x2]),
        minY: (0,esm/* min */.VV)([y1, y2]),
        maxY: (0,esm/* max */.Fp)([y1, y2]),
    };
}
function piMod(angle) {
    return (angle + Math.PI * 2) % (Math.PI * 2);
}
//# sourceMappingURL=util.js.map
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js
var vec2 = __webpack_require__(31437);
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/line.js


/* harmony default export */ var line = ({
    /**
     * \u8BA1\u7B97\u7EBF\u6BB5\u7684\u5305\u56F4\u76D2
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @return {object} \u5305\u56F4\u76D2\u5BF9\u8C61
     */
    box: function (x1, y1, x2, y2) {
        return getBBoxByArray([x1, x2], [y1, y2]);
    },
    /**
     * \u7EBF\u6BB5\u7684\u957F\u5EA6
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @return {number} \u8DDD\u79BB
     */
    length: function (x1, y1, x2, y2) {
        return distance(x1, y1, x2, y2);
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u70B9
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @param {number} t \u6307\u5B9A\u6BD4\u4F8B
     * @return {object} \u5305\u542B x, y \u7684\u70B9
     */
    pointAt: function (x1, y1, x2, y2, t) {
        return {
            x: (1 - t) * x1 + t * x2,
            y: (1 - t) * y1 + t * y2,
        };
    },
    /**
     * \u70B9\u5230\u7EBF\u6BB5\u7684\u8DDD\u79BB
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @param {number} x  \u6D4B\u8BD5\u70B9 x
     * @param {number} y  \u6D4B\u8BD5\u70B9 y
     * @return {number} \u8DDD\u79BB
     */
    pointDistance: function (x1, y1, x2, y2, x, y) {
        // \u6295\u5F71\u8DDD\u79BB x1, y1 \u7684\u5411\u91CF\uFF0C\u5047\u8BBE p, p1, p2 \u4E09\u4E2A\u70B9\uFF0C\u6295\u5F71\u70B9\u4E3A a
        // p1a = p1p.p1p2/|p1p2| * (p1p \u7684\u5355\u4F4D\u5411\u91CF)
        var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
        if (cross < 0) {
            return distance(x1, y1, x, y);
        }
        var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        if (cross > lengthSquare) {
            return distance(x2, y2, x, y);
        }
        return this.pointToLine(x1, y1, x2, y2, x, y);
    },
    /**
     * \u70B9\u5230\u76F4\u7EBF\u7684\u8DDD\u79BB\uFF0C\u800C\u4E0D\u662F\u70B9\u5230\u7EBF\u6BB5\u7684\u8DDD\u79BB
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @param {number} x  \u6D4B\u8BD5\u70B9 x
     * @param {number} y  \u6D4B\u8BD5\u70B9 y
     * @return {number} \u8DDD\u79BB
     */
    pointToLine: function (x1, y1, x2, y2, x, y) {
        var d = [x2 - x1, y2 - y1];
        // \u5982\u679C\u7AEF\u70B9\u76F8\u7B49\uFF0C\u5219\u5224\u5B9A\u70B9\u5230\u70B9\u7684\u8DDD\u79BB
        if (vec2/* exactEquals */.I6(d, [0, 0])) {
            return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
        }
        var u = [-d[1], d[0]];
        vec2/* normalize */.Fv(u, u);
        var a = [x - x1, y - y1];
        return Math.abs(vec2/* dot */.AK(a, u));
    },
    /**
     * \u7EBF\u6BB5\u7684\u89D2\u5EA6
     * @param {number} x1 \u8D77\u59CB\u70B9 x
     * @param {number} y1 \u8D77\u59CB\u70B9 y
     * @param {number} x2 \u7ED3\u675F\u70B9 x
     * @param {number} y2 \u7ED3\u675F\u70B9 y
     * @return {number} \u5BFC\u6570
     */
    tangentAngle: function (x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1);
    },
});
//# sourceMappingURL=line.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/bezier.js

var EPSILON = 0.0001;
/**
 * \u4F7F\u7528\u725B\u987F\u5207\u5272\u6CD5\u6C42\u6700\u8FD1\u7684\u70B9
 * @param {number[]} xArr      \u70B9\u7684 x \u6570\u7EC4
 * @param {number[]} yArr      \u70B9\u7684 y \u6570\u7EC4
 * @param {number}   x         \u6307\u5B9A\u7684\u70B9 x
 * @param {number}   y         \u6307\u5B9A\u7684\u70B9 y
 * @param {Function} tCallback \u5DEE\u503C\u51FD\u6570
 */
function nearestPoint(xArr, yArr, x, y, tCallback, length) {
    var t;
    var d = Infinity;
    var v0 = [x, y];
    var segNum = 20;
    if (length && length > 200) {
        segNum = length / 10;
    }
    var increaseRate = 1 / segNum;
    var interval = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
        var _t = i * increaseRate;
        var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    // \u63D0\u524D\u7EC8\u6B62
    if (t === 0) {
        return {
            x: xArr[0],
            y: yArr[0],
        };
    }
    if (t === 1) {
        var count = xArr.length;
        return {
            x: xArr[count - 1],
            y: yArr[count - 1],
        };
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON) {
            break;
        }
        var prev = t - interval;
        var next = t + interval;
        var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
        var d1 = distance(v0[0], v0[1], v1[0], v1[1]);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
            var d2 = distance(v0[0], v0[1], v2[0], v2[1]);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    return {
        x: tCallback.apply(null, xArr.concat([t])),
        y: tCallback.apply(null, yArr.concat([t])),
    };
}
// \u8FD1\u4F3C\u6C42\u89E3 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2
function snapLength(xArr, yArr) {
    var totalLength = 0;
    var count = xArr.length;
    for (var i = 0; i < count; i++) {
        var x = xArr[i];
        var y = yArr[i];
        var nextX = xArr[(i + 1) % count];
        var nextY = yArr[(i + 1) % count];
        totalLength += distance(x, y, nextX, nextY);
    }
    return totalLength / 2;
}
//# sourceMappingURL=bezier.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/quadratic.js



// \u5DEE\u503C\u516C\u5F0F
function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
// \u6C42\u6781\u503C
function extrema(p0, p1, p2) {
    var a = p0 + p2 - 2 * p1;
    if (isNumberEqual(a, 0)) {
        return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
        return [rst];
    }
    return [];
}
function derivativeAt(p0, p1, p2, t) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
// \u5206\u5272\u8D1D\u585E\u5C14\u66F2\u7EBF
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
    // \u5212\u5206\u70B9
    var xt = quadraticAt(x1, x2, x3, t);
    var yt = quadraticAt(y1, y2, y3, t);
    // \u5206\u5272\u7684\u7B2C\u4E00\u6761\u66F2\u7EBF\u7684\u63A7\u5236\u70B9
    var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);
    // \u5206\u5272\u7684\u7B2C\u4E8C\u6761\u66F2\u7EBF\u7684\u63A7\u5236\u70B9
    var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);
    return [
        [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
        [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],
    ];
}
// \u4F7F\u7528\u8FED\u4EE3\u6CD5\u53D6\u8D1D\u585E\u5C14\u66F2\u7EBF\u7684\u957F\u5EA6
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
    if (iterationCount === 0) {
        return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;
    }
    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
    var left = quadratics[0];
    var right = quadratics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
/* harmony default export */ var quadratic = ({
    box: function (x1, y1, x2, y2, x3, y3) {
        var xExtrema = extrema(x1, x2, x3)[0];
        var yExtrema = extrema(y1, y2, y3)[0];
        // \u63A7\u5236\u70B9\u4E0D\u52A0\u5165 box \u7684\u8BA1\u7B97
        var xArr = [x1, x3];
        var yArr = [y1, y3];
        if (xExtrema !== undefined) {
            xArr.push(quadraticAt(x1, x2, x3, xExtrema));
        }
        if (yExtrema !== undefined) {
            yArr.push(quadraticAt(y1, y2, y3, yExtrema));
        }
        return getBBoxByArray(xArr, yArr);
    },
    length: function (x1, y1, x2, y2, x3, y3) {
        return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
    },
    nearestPoint: function (x1, y1, x2, y2, x3, y3, x0, y0) {
        return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
    },
    pointDistance: function (x1, y1, x2, y2, x3, y3, x0, y0) {
        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
        return distance(point.x, point.y, x0, y0);
    },
    interpolationAt: quadraticAt,
    pointAt: function (x1, y1, x2, y2, x3, y3, t) {
        return {
            x: quadraticAt(x1, x2, x3, t),
            y: quadraticAt(y1, y2, y3, t),
        };
    },
    divide: function (x1, y1, x2, y2, x3, y3, t) {
        return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
    },
    tangentAngle: function (x1, y1, x2, y2, x3, y3, t) {
        var dx = derivativeAt(x1, x2, x3, t);
        var dy = derivativeAt(y1, y2, y3, t);
        var angle = Math.atan2(dy, dx);
        return piMod(angle);
    },
});
//# sourceMappingURL=quadratic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/cubic.js



function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t; // t * t * t \u7684\u6027\u80FD\u5927\u6982\u662F Math.pow(t, 3) \u7684\u4E09\u500D
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function cubic_derivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function cubic_extrema(p0, p1, p2, p3) {
    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual(a, 0)) {
        if (!isNumberEqual(b, 0)) {
            t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                extremas.push(t1);
            }
        }
    }
    else {
        var disc = b * b - 4 * a * c;
        if (isNumberEqual(disc, 0)) {
            extremas.push(-b / (2 * a));
        }
        else if (disc > 0) {
            discSqrt = Math.sqrt(disc);
            t1 = (-b + discSqrt) / (2 * a);
            t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                extremas.push(t1);
            }
            if (t2 >= 0 && t2 <= 1) {
                extremas.push(t2);
            }
        }
    }
    return extremas;
}
// \u5206\u5272\u8D1D\u585E\u5C14\u66F2\u7EBF
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    // \u5212\u5206\u70B9
    var xt = cubicAt(x1, x2, x3, x4, t);
    var yt = cubicAt(y1, y2, y3, y4, t);
    // \u8BA1\u7B97\u4E24\u70B9\u4E4B\u95F4\u7684\u5DEE\u503C\u70B9
    var c1 = line.pointAt(x1, y1, x2, y2, t);
    var c2 = line.pointAt(x2, y2, x3, y3, t);
    var c3 = line.pointAt(x3, y3, x4, y4, t);
    var c12 = line.pointAt(c1.x, c1.y, c2.x, c2.y, t);
    var c23 = line.pointAt(c2.x, c2.y, c3.x, c3.y, t);
    return [
        [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
        [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],
    ];
}
// \u4F7F\u7528\u8FED\u4EE3\u6CD5\u53D6\u8D1D\u585E\u5C14\u66F2\u7EBF\u7684\u957F\u5EA6\uFF0C\u4E8C\u9636\u548C\u4E09\u9636\u5206\u5F00\u5199\uFF0C\u66F4\u6E05\u6670\u548C\u4FBF\u4E8E\u8C03\u8BD5
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
    if (iterationCount === 0) {
        return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
    }
    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
    var left = cubics[0];
    var right = cubics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
/* harmony default export */ var cubic = ({
    extrema: cubic_extrema,
    box: function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var xArr = [x1, x4];
        var yArr = [y1, y4];
        var xExtrema = cubic_extrema(x1, x2, x3, x4);
        var yExtrema = cubic_extrema(y1, y2, y3, y4);
        for (var i = 0; i < xExtrema.length; i++) {
            xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));
        }
        for (var i = 0; i < yExtrema.length; i++) {
            yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));
        }
        return getBBoxByArray(xArr, yArr);
    },
    length: function (x1, y1, x2, y2, x3, y3, x4, y4) {
        // \u8FED\u4EE3\u4E09\u6B21\uFF0C\u5212\u5206\u6210 8 \u6BB5\u6C42\u957F\u5EA6
        return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
    },
    nearestPoint: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
        return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);
    },
    pointDistance: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
        return distance(point.x, point.y, x0, y0);
    },
    interpolationAt: cubicAt,
    pointAt: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {
        return {
            x: cubicAt(x1, x2, x3, x4, t),
            y: cubicAt(y1, y2, y3, y4, t),
        };
    },
    divide: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {
        return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
    },
    tangentAngle: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {
        var dx = cubic_derivativeAt(x1, x2, x3, x4, t);
        var dy = cubic_derivativeAt(y1, y2, y3, y4, t);
        return piMod(Math.atan2(dy, dx));
    },
});
//# sourceMappingURL=cubic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/ellipse.js
/**
 * @fileoverview \u692D\u5706\u7684\u4E00\u4E9B\u8BA1\u7B97\uFF0C
 *  - \u5468\u957F\u8BA1\u7B97\u53C2\u8003\uFF1Ahttps://www.mathsisfun.com/geometry/ellipse-perimeter.html
 *  - \u8DDD\u79BB\u8BA1\u7B97\u53C2\u8003\uFF1Ahttps://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/
 * @author dxq613@gmail.com
 */

function copysign(v1, v2) {
    var absv = Math.abs(v1);
    return v2 > 0 ? absv : absv * -1;
}
/* harmony default export */ var ellipse = ({
    /**
     * \u5305\u56F4\u76D2\u8BA1\u7B97
     * @param {number} x  \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y  \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @return {object} \u5305\u56F4\u76D2
     */
    box: function (x, y, rx, ry) {
        return {
            x: x - rx,
            y: y - ry,
            width: rx * 2,
            height: ry * 2,
        };
    },
    /**
     * \u8BA1\u7B97\u5468\u957F\uFF0C\u4F7F\u7528\u8FD1\u4F3C\u6CD5
     * @param {number} x  \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y  \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @return {number} \u692D\u5706\u5468\u957F
     */
    length: function (x, y, rx, ry) {
        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
    },
    /**
     * \u8DDD\u79BB\u692D\u5706\u6700\u8FD1\u7684\u70B9
     * @param {number} x  \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y  \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @param {number} x0  \u6307\u5B9A\u7684\u70B9 x
     * @param {number} y0  \u6307\u5B9A\u7684\u70B9 y
     * @return {object} \u692D\u5706\u4E0A\u8DDD\u79BB\u6307\u5B9A\u70B9\u6700\u8FD1\u7684\u70B9
     */
    nearestPoint: function (x, y, rx, ry, x0, y0) {
        var a = rx;
        var b = ry;
        // \u5047\u5982\u692D\u5706\u534A\u5F84\u4E3A0\u5219\u8FD4\u56DE\u5706\u5FC3
        if (a === 0 || b === 0) {
            return {
                x: x,
                y: y,
            };
        }
        // \u8F6C\u6362\u6210 0\uFF0C 0 \u4E3A\u4E2D\u5FC3\u7684\u692D\u5706\u8BA1\u7B97
        var relativeX = x0 - x;
        var relativeY = y0 - y;
        var px = Math.abs(relativeX);
        var py = Math.abs(relativeY);
        var squareA = a * a;
        var squareB = b * b;
        // const angle0 = Math.atan2(relativeY, relativeX);
        var t = Math.PI / 4;
        var nearestX; // \u692D\u5706\u4E0A\u7684\u4EFB\u4E00\u70B9
        var nearestY;
        // \u8FED\u4EE3 4 \u6B21
        for (var i = 0; i < 4; i++) {
            nearestX = a * Math.cos(t);
            nearestY = b * Math.sin(t);
            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;
            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;
            var rx1 = nearestX - ex;
            var ry1 = nearestY - ey;
            var qx = px - ex;
            var qy = py - ey;
            var r = Math.hypot(ry1, rx1);
            var q = Math.hypot(qy, qx);
            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
            t += delta_t;
            t = Math.min(Math.PI / 2, Math.max(0, t));
        }
        return {
            x: x + copysign(nearestX, relativeX),
            y: y + copysign(nearestY, relativeY),
        };
    },
    /**
     * \u70B9\u5230\u692D\u5706\u6700\u8FD1\u7684\u8DDD\u79BB
     * @param {number} x  \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y  \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @param {number} x0  \u6307\u5B9A\u7684\u70B9 x
     * @param {number} y0  \u6307\u5B9A\u7684\u70B9 y
     * @return {number} \u70B9\u5230\u692D\u5706\u7684\u8DDD\u79BB
     */
    pointDistance: function (x, y, rx, ry, x0, y0) {
        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);
        return distance(nearestPoint.x, nearestPoint.y, x0, y0);
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u70B9
     * @param {number} x \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @param {number} t \u6307\u5B9A\u6BD4\u4F8B\uFF0Cx\u8F74\u65B9\u5411\u4E3A 0
     * @return {object} \u70B9
     */
    pointAt: function (x, y, rx, ry, t) {
        var angle = 2 * Math.PI * t; // \u6309\u7167\u89D2\u5EA6\u8FDB\u884C\u8BA1\u7B97\uFF0C\u800C\u4E0D\u6309\u7167\u5468\u957F\u8BA1\u7B97
        return {
            x: x + rx * Math.cos(angle),
            y: y + ry * Math.sin(angle),
        };
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u8BA1\u7B97\u5207\u7EBF\u89D2\u5EA6
     * @param {number} x \u692D\u5706\u4E2D\u5FC3 x
     * @param {number} y \u692D\u5706\u4E2D\u5FC3 y
     * @param {number} rx \u692D\u5706 x \u65B9\u5411\u534A\u5F84
     * @param {number} ry \u692D\u5706 y \u65B9\u5411\u534A\u5F84
     * @param {number} t \u6307\u5B9A\u6BD4\u4F8B 0 - 1 \u4E4B\u95F4\uFF0Cx\u8F74\u65B9\u5411\u4E3A 0\u3002\u5728 0-1 \u8303\u56F4\u4E4B\u5916\u662F\u5FAA\u73AF\u8FD8\u662F\u8FD4\u56DE null\uFF0C\u8FD8\u9700\u8981\u8C03\u6574
     * @return {number} \u89D2\u5EA6\uFF0C\u5728 0 - 2PI \u4E4B\u95F4
     */
    tangentAngle: function (x, y, rx, ry, t) {
        var angle = 2 * Math.PI * t; // \u6309\u7167\u89D2\u5EA6\u8FDB\u884C\u8BA1\u7B97\uFF0C\u800C\u4E0D\u6309\u7167\u5468\u957F\u8BA1\u7B97
        // \u76F4\u63A5\u4F7F\u7528 x,y \u7684\u5BFC\u6570\u8BA1\u7B97\uFF0C x' = -rx * sin(t); y' = ry * cos(t);
        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));
        // \u4E5F\u53EF\u4EE5\u4F7F\u7528\u6307\u5B9A\u70B9\u7684\u5207\u7EBF\u65B9\u7A0B\u8BA1\u7B97\uFF0C\u6210\u672C\u6709\u4E9B\u9AD8
        // const point = this.pointAt(0, 0, rx, ry, t); // \u692D\u5706\u7684\u5207\u7EBF\u540C\u692D\u5706\u7684\u4E2D\u5FC3\u4E0D\u76F8\u5173
        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));
        // if (angle >= 0 && angle <= Math.PI) {
        //   tangentAngle += Math.PI;
        // }
        return piMod(tangentAngle);
    },
});
//# sourceMappingURL=ellipse.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/arc.js


// \u504F\u5BFC\u6570 x
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);
}
// \u504F\u5BFC\u6570 y
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);
}
// x \u7684\u6781\u503C
function xExtrema(rx, ry, xRotation) {
    return Math.atan((-ry / rx) * Math.tan(xRotation));
}
// y \u7684\u6781\u503C
function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
}
// \u6839\u636E\u89D2\u5EA6\u6C42 x \u5750\u6807
function xAt(cx, cy, rx, ry, xRotation, angle) {
    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;
}
// \u6839\u636E\u89D2\u5EA6\u6C42 y \u5750\u6807
function yAt(cx, cy, rx, ry, xRotation, angle) {
    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;
}
// \u83B7\u53D6\u70B9\u5728\u692D\u5706\u4E0A\u7684\u89D2\u5EA6
function getAngle(rx, ry, x0, y0) {
    var angle = Math.atan2(y0 * rx, x0 * ry);
    // \u8F6C\u6362\u5230 0 - 2PI \u5185
    return (angle + Math.PI * 2) % (Math.PI * 2);
}
// \u6839\u636E\u89D2\u5EA6\u83B7\u53D6\uFF0Cx,y
function getPoint(rx, ry, angle) {
    return {
        x: rx * Math.cos(angle),
        y: ry * Math.sin(angle),
    };
}
// \u65CB\u8F6C
function rotate(x, y, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return [x * cos - y * sin, x * sin + y * cos];
}
/* harmony default export */ var arc = ({
    /**
     * \u8BA1\u7B97\u5305\u56F4\u76D2
     * @param {number} cx         \u5706\u5FC3 x
     * @param {number} cy         \u5706\u5FC3 y
     * @param {number} rx         x \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} ry         y \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} xRotation  \u65CB\u8F6C\u89D2\u5EA6
     * @param {number} startAngle \u8D77\u59CB\u89D2\u5EA6
     * @param {number} endAngle   \u7ED3\u675F\u89D2\u5EA6
     * @return {object} \u5305\u56F4\u76D2\u5BF9\u8C61
     */
    box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {
        var xDim = xExtrema(rx, ry, xRotation);
        var minX = Infinity;
        var maxX = -Infinity;
        var xs = [startAngle, endAngle];
        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
            var xAngle = xDim + i;
            if (startAngle < endAngle) {
                if (startAngle < xAngle && xAngle < endAngle) {
                    xs.push(xAngle);
                }
            }
            else {
                if (endAngle < xAngle && xAngle < startAngle) {
                    xs.push(xAngle);
                }
            }
        }
        for (var i = 0; i < xs.length; i++) {
            var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
            if (x < minX) {
                minX = x;
            }
            if (x > maxX) {
                maxX = x;
            }
        }
        var yDim = yExtrema(rx, ry, xRotation);
        var minY = Infinity;
        var maxY = -Infinity;
        var ys = [startAngle, endAngle];
        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
            var yAngle = yDim + i;
            if (startAngle < endAngle) {
                if (startAngle < yAngle && yAngle < endAngle) {
                    ys.push(yAngle);
                }
            }
            else {
                if (endAngle < yAngle && yAngle < startAngle) {
                    ys.push(yAngle);
                }
            }
        }
        for (var i = 0; i < ys.length; i++) {
            var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
            if (y < minY) {
                minY = y;
            }
            if (y > maxY) {
                maxY = y;
            }
        }
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    },
    /**
     * \u83B7\u53D6\u5706\u5F27\u7684\u957F\u5EA6\uFF0C\u8BA1\u7B97\u5706\u5F27\u957F\u5EA6\u65F6\u4E0D\u8003\u8651\u65CB\u8F6C\u89D2\u5EA6\uFF0C
     * \u4EC5\u8DDF rx, ry, startAngle, endAngle \u76F8\u5173
     * @param {number} cx         \u5706\u5FC3 x
     * @param {number} cy         \u5706\u5FC3 y
     * @param {number} rx         x \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} ry         y \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} xRotation  \u65CB\u8F6C\u89D2\u5EA6
     * @param {number} startAngle \u8D77\u59CB\u89D2\u5EA6
     * @param {number} endAngle   \u7ED3\u675F\u89D2\u5EA6
     */
    length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) { },
    /**
     * \u83B7\u53D6\u6307\u5B9A\u70B9\u5230\u5706\u5F27\u7684\u6700\u8FD1\u8DDD\u79BB\u7684\u70B9
     * @param {number} cx         \u5706\u5FC3 x
     * @param {number} cy         \u5706\u5FC3 y
     * @param {number} rx         x \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} ry         y \u8F74\u65B9\u5411\u7684\u534A\u5F84
     * @param {number} xRotation  \u65CB\u8F6C\u89D2\u5EA6
     * @param {number} startAngle \u8D77\u59CB\u89D2\u5EA6
     * @param {number} endAngle   \u7ED3\u675F\u89D2\u5EA6
     * @param {number} x0         \u6307\u5B9A\u70B9\u7684 x
     * @param {number} y0         \u6307\u5B9A\u70B9\u7684 y
     * @return {object} \u5230\u6307\u5B9A\u70B9\u6700\u8FD1\u8DDD\u79BB\u7684\u70B9
     */
    nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
        // \u5C06\u6700\u8FD1\u8DDD\u79BB\u95EE\u9898\u8F6C\u6362\u6210\u5230\u692D\u5706\u4E2D\u5FC3 0,0 \u6CA1\u6709\u65CB\u8F6C\u7684\u692D\u5706\u95EE\u9898
        var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);
        var x1 = relativeVector[0], y1 = relativeVector[1];
        // \u8BA1\u7B97\u70B9\u5230\u692D\u5706\u7684\u6700\u8FD1\u7684\u70B9
        var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);
        // \u83B7\u53D6\u70B9\u5728\u692D\u5706\u4E0A\u7684\u89D2\u5EA6
        var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);
        // \u70B9\u6CA1\u6709\u5728\u5706\u5F27\u4E0A
        if (angle < startAngle) {
            // \u5C0F\u4E8E\u8D77\u59CB\u5706\u5F27
            relativePoint = getPoint(rx, ry, startAngle);
        }
        else if (angle > endAngle) {
            // \u5927\u4E8E\u7ED3\u675F\u5706\u5F27
            relativePoint = getPoint(rx, ry, endAngle);
        }
        // \u65CB\u8F6C\u5230 xRotation \u7684\u89D2\u5EA6
        var vector = rotate(relativePoint.x, relativePoint.y, xRotation);
        return {
            x: vector[0] + cx,
            y: vector[1] + cy,
        };
    },
    pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
        var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);
        return distance(nearestPoint.x, nearestPoint.y, x0, y0);
    },
    pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
        var angle = (endAngle - startAngle) * t + startAngle;
        return {
            x: xAt(cx, cy, rx, ry, xRotation, angle),
            y: yAt(cx, cy, rx, ry, xRotation, angle),
        };
    },
    tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
        var angle = (endAngle - startAngle) * t + startAngle;
        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
        return piMod(Math.atan2(dy, dx));
    },
});
//# sourceMappingURL=arc.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/segments.js


function analyzePoints(points) {
    // \u8BA1\u7B97\u6BCF\u6BB5\u7684\u957F\u5EA6\u548C\u603B\u7684\u957F\u5EA6
    var totalLength = 0;
    var segments = [];
    for (var i = 0; i < points.length - 1; i++) {
        var from = points[i];
        var to = points[i + 1];
        var length_1 = distance(from[0], from[1], to[0], to[1]);
        var seg = {
            from: from,
            to: to,
            length: length_1,
        };
        segments.push(seg);
        totalLength += length_1;
    }
    return { segments: segments, totalLength: totalLength };
}
function lengthOfSegment(points) {
    if (points.length < 2) {
        return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
        var from = points[i];
        var to = points[i + 1];
        totalLength += distance(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
}
/**
 * \u6309\u7167\u6BD4\u4F8B\u5728\u6570\u636E\u7247\u6BB5\u4E2D\u83B7\u53D6\u70B9
 * @param {array} points \u70B9\u7684\u96C6\u5408
 * @param {number} t \u767E\u5206\u6BD4 0-1
 * @return {object} \u70B9\u7684\u5750\u6807
 */
function pointAtSegments(points, t) {
    // \u8FB9\u754C\u5224\u65AD
    if (t > 1 || t < 0 || points.length < 2) {
        return null;
    }
    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
    // \u591A\u4E2A\u70B9\u6709\u53EF\u80FD\u91CD\u5408
    if (totalLength === 0) {
        return {
            x: points[0][0],
            y: points[0][1],
        };
    }
    // \u8BA1\u7B97\u6BD4\u4F8B
    var startRatio = 0;
    var point = null;
    for (var i = 0; i < segments.length; i++) {
        var seg = segments[i];
        var from = seg.from, to = seg.to;
        var currentRatio = seg.length / totalLength;
        if (t >= startRatio && t <= startRatio + currentRatio) {
            var localRatio = (t - startRatio) / currentRatio;
            point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);
            break;
        }
        startRatio += currentRatio;
    }
    return point;
}
/**
 * \u6309\u7167\u6BD4\u4F8B\u5728\u6570\u636E\u7247\u6BB5\u4E2D\u83B7\u53D6\u5207\u7EBF\u7684\u89D2\u5EA6
 * @param {array} points \u70B9\u7684\u96C6\u5408
 * @param {number} t \u767E\u5206\u6BD4 0-1
 */
function angleAtSegments(points, t) {
    // \u8FB9\u754C\u5224\u65AD
    if (t > 1 || t < 0 || points.length < 2) {
        return 0;
    }
    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
    // \u8BA1\u7B97\u6BD4\u4F8B
    var startRatio = 0;
    var angle = 0;
    for (var i = 0; i < segments.length; i++) {
        var seg = segments[i];
        var from = seg.from, to = seg.to;
        var currentRatio = seg.length / totalLength;
        if (t >= startRatio && t <= startRatio + currentRatio) {
            angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
            break;
        }
        startRatio += currentRatio;
    }
    return angle;
}
function distanceAtSegment(points, x, y) {
    var minDistance = Infinity;
    for (var i = 0; i < points.length - 1; i++) {
        var point = points[i];
        var nextPoint = points[i + 1];
        var distance_1 = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
        if (distance_1 < minDistance) {
            minDistance = distance_1;
        }
    }
    return minDistance;
}
//# sourceMappingURL=segments.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/polyline.js


/* harmony default export */ var polyline = ({
    /**
     * \u8BA1\u7B97\u591A\u6298\u7EBF\u7684\u5305\u56F4\u76D2
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @return {object} \u5305\u56F4\u76D2
     */
    box: function (points) {
        var xArr = [];
        var yArr = [];
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            xArr.push(point[0]);
            yArr.push(point[1]);
        }
        return getBBoxByArray(xArr, yArr);
    },
    /**
     * \u8BA1\u7B97\u591A\u6298\u7EBF\u7684\u957F\u5EA6
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @return {object} \u591A\u6761\u8FB9\u7684\u957F\u5EA6
     */
    length: function (points) {
        return lengthOfSegment(points);
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u591A\u6298\u7EBF\u7684\u70B9
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} t \u5728\u591A\u6298\u7EBF\u7684\u957F\u5EA6\u4E0A\u7684\u6BD4\u4F8B
     * @return {object} \u6839\u636E\u6BD4\u4F8B\u503C\u8BA1\u7B97\u51FA\u6765\u7684\u70B9
     */
    pointAt: function (points, t) {
        return pointAtSegments(points, t);
    },
    /**
     * \u6307\u5B9A\u70B9\u5230\u591A\u6298\u7EBF\u7684\u8DDD\u79BB
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} x \u6307\u5B9A\u70B9\u7684 x
     * @param {number} y \u6307\u5B9A\u70B9\u7684 y
     * @return {number} \u70B9\u5230\u591A\u6298\u7EBF\u7684\u8DDD\u79BB
     */
    pointDistance: function (points, x, y) {
        return distanceAtSegment(points, x, y);
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u591A\u6298\u7EBF\u7684\u5207\u7EBF\u89D2\u5EA6
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} t \u5728\u591A\u6298\u7EBF\u7684\u957F\u5EA6\u4E0A\u7684\u6BD4\u4F8B
     * @return {object} \u6839\u636E\u6BD4\u4F8B\u503C\u8BA1\u7B97\u51FA\u6765\u7684\u89D2\u5EA6
     */
    tangentAngle: function (points, t) {
        return angleAtSegments(points, t);
    },
});
//# sourceMappingURL=polyline.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/polygon.js


function getAllPoints(points) {
    var tmp = points.slice(0);
    if (points.length) {
        tmp.push(points[0]);
    }
    return tmp;
}
/* harmony default export */ var polygon = ({
    /**
     * \u8BA1\u7B97\u591A\u8FB9\u5F62\u7684\u5305\u56F4\u76D2
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @return {object} \u5305\u56F4\u76D2
     */
    box: function (points) {
        return polyline.box(points);
    },
    /**
     * \u8BA1\u7B97\u591A\u8FB9\u5F62\u7684\u957F\u5EA6
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @return {object} \u591A\u8FB9\u5F62\u8FB9\u7684\u957F\u5EA6
     */
    length: function (points) {
        return lengthOfSegment(getAllPoints(points));
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u591A\u8FB9\u5F62\u7684\u70B9
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} t \u5728\u591A\u8FB9\u5F62\u7684\u957F\u5EA6\u4E0A\u7684\u6BD4\u4F8B
     * @return {object} \u6839\u636E\u6BD4\u4F8B\u503C\u8BA1\u7B97\u51FA\u6765\u7684\u70B9
     */
    pointAt: function (points, t) {
        return pointAtSegments(getAllPoints(points), t);
    },
    /**
     * \u6307\u5B9A\u70B9\u5230\u591A\u8FB9\u5F62\u7684\u8DDD\u79BB
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} x \u6307\u5B9A\u70B9\u7684 x
     * @param {number} y \u6307\u5B9A\u70B9\u7684 y
     * @return {number} \u70B9\u5230\u591A\u8FB9\u5F62\u7684\u8DDD\u79BB
     */
    pointDistance: function (points, x, y) {
        return distanceAtSegment(getAllPoints(points), x, y);
    },
    /**
     * \u6839\u636E\u6BD4\u4F8B\u83B7\u53D6\u591A\u8FB9\u5F62\u7684\u5207\u7EBF\u89D2\u5EA6
     * @param {array} points \u70B9\u7684\u96C6\u5408 [x,y] \u7684\u5F62\u5F0F
     * @param {number} t \u5728\u591A\u8FB9\u5F62\u7684\u957F\u5EA6\u4E0A\u7684\u6BD4\u4F8B
     * @return {object} \u6839\u636E\u6BD4\u4F8B\u503C\u8BA1\u7B97\u51FA\u6765\u7684\u89D2\u5EA6
     */
    tangentAngle: function (points, t) {
        return angleAtSegments(getAllPoints(points), t);
    },
});
//# sourceMappingURL=polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/g-math/esm/index.js








//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/g-math/esm/index.js_+_10_modules?`)},31506:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dg": function() { return /* binding */ angleTo; },
/* harmony export */   "lh": function() { return /* binding */ leftScale; },
/* harmony export */   "m$": function() { return /* binding */ leftTranslate; },
/* harmony export */   "vs": function() { return /* binding */ transform; },
/* harmony export */   "zu": function() { return /* binding */ leftRotate; }
/* harmony export */ });
/* unused harmony exports direction, vertical */
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35600);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31437);
/**
 * @description \u6269\u5C55\u65B9\u6CD5\uFF0C\u63D0\u4F9B gl-matrix \u4E3A\u63D0\u4F9B\u7684\u65B9\u6CD5
 * */

function leftTranslate(out, a, v) {
    var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .fromTranslation */ .vc(transMat, v);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .multiply */ .Jp(out, transMat, a);
}
function leftRotate(out, a, rad) {
    var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .fromRotation */ .Us(rotateMat, rad);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .multiply */ .Jp(out, rotateMat, a);
}
function leftScale(out, a, v) {
    var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .fromScaling */ .xJ(scaleMat, v);
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .multiply */ .Jp(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__/* .multiply */ .Jp(out, a1, a);
}
/**
 * \u6839\u636E actions \u6765\u505A transform
 * @param m
 * @param actions
 */
function transform(m, actions) {
    var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
    for (var i = 0, len = actions.length; i < len; i++) {
        var action = actions[i];
        switch (action[0]) {
            case 't':
                leftTranslate(matrix, matrix, [action[1], action[2]]);
                break;
            case 's':
                leftScale(matrix, matrix, [action[1], action[2]]);
                break;
            case 'r':
                leftRotate(matrix, matrix, action[1]);
                break;
            case 'm':
                leftMultiply(matrix, matrix, action[1]);
                break;
            default:
                break;
        }
    }
    return matrix;
}
/**
 * \u5411\u91CF v1 \u5230 \u5411\u91CF v2 \u5939\u89D2\u7684\u65B9\u5411
 * @param  {Array} v1 \u5411\u91CF
 * @param  {Array} v2 \u5411\u91CF
 * @return {Boolean} >= 0 \u987A\u65F6\u9488 < 0 \u9006\u65F6\u9488
 */
function direction(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
}
/**
 * \u4E8C\u7EF4\u5411\u91CF v1 \u5230 v2 \u7684\u5939\u89D2
 * @param v1
 * @param v2
 * @param direct
 */
function angleTo(v1, v2, direct) {
    var ang = gl_matrix__WEBPACK_IMPORTED_MODULE_1__/* .angle */ .EU(v1, v2);
    var angleLargeThanPI = direction(v1, v2) >= 0;
    if (direct) {
        if (angleLargeThanPI) {
            return Math.PI * 2 - ang;
        }
        return ang;
    }
    if (angleLargeThanPI) {
        return ang;
    }
    return Math.PI * 2 - ang;
}
/**
 * \u8BA1\u7B97\u4E8C\u7EF4\u5411\u91CF\u7684\u5782\u76F4\u5411\u91CF
 * @param out
 * @param v
 * @param flag
 */
function vertical(out, v, flag) {
    if (flag) {
        out[0] = v[1];
        out[1] = -1 * v[0];
    }
    else {
        out[0] = -1 * v[1];
        out[1] = v[0];
    }
    return out;
}
//# sourceMappingURL=ext.js.map

//# sourceURL=webpack:///./node_modules/@antv/matrix-util/esm/ext.js?`)},59665:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "e9": function() { return /* reexport */ catmull_rom_2_bezier; },
  "Wq": function() { return /* reexport */ isPolygonsIntersect; },
  "tr": function() { return /* reexport */ parsePathString; },
  "wb": function() { return /* reexport */ pathToAbsolute; },
  "zx": function() { return /* reexport */ getSegments; }
});

// UNUSED EXPORTS: fillPath, fillPathByDiff, formatPath, getArcParams, getLineIntersect, isPointInPolygon, parsePath, parsePathArray, path2Curve, pathIntersection, reactPath

// EXTERNAL MODULE: ./node_modules/@antv/util/esm/index.js + 104 modules
var esm = __webpack_require__(45098);
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/parse-path.js

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\\s\\,]+/ig;
function parsePath(p) {
    var path = p || [];
    if ((0,esm/* isArray */.kJ)(path)) {
        return path;
    }
    if ((0,esm/* isString */.HD)(path)) {
        path = path.match(regexTags);
        (0,esm/* each */.S6)(path, function (item, index) {
            // @ts-ignore
            item = item.match(regexDot);
            if (item[0].length > 1) {
                var tag = item[0].charAt(0);
                // @ts-ignore
                item.splice(1, 0, item[0].substr(1));
                // @ts-ignore
                item[0] = tag;
            }
            // @ts-ignore
            (0,esm/* each */.S6)(item, function (sub, i) {
                if (!isNaN(sub)) {
                    // @ts-ignore
                    item[i] = +sub;
                }
            });
            // @ts-ignore
            path[index] = item;
        });
        return path;
    }
}
/* harmony default export */ var parse_path = (parsePath);
//# sourceMappingURL=parse-path.js.map
// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js
var vec2 = __webpack_require__(31437);
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js

function smoothBezier(points, smooth, isLoop, constraint) {
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min;
    var max;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
        min = constraint[0], max = constraint[1];
        for (var i = 0, l = points.length; i < l; i += 1) {
            var point = points[i];
            min = vec2/* min */.VV([0, 0], min, point);
            max = vec2/* max */.Fp([0, 0], max, point);
        }
    }
    for (var i = 0, len = points.length; i < len; i += 1) {
        var point = points[i];
        if (i === 0 && !isLoop) {
            cp0 = point;
        }
        else if (i === len - 1 && !isLoop) {
            cp1 = point;
            cps.push(cp0);
            cps.push(cp1);
        }
        else {
            var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
            prevPoint = points[prevIdx];
            nextPoint = points[isLoop ? (i + 1) % len : i + 1];
            var v = [0, 0];
            v = vec2/* sub */.lu(v, nextPoint, prevPoint);
            v = vec2/* scale */.bA(v, v, smooth);
            var d0 = vec2/* distance */.TE(point, prevPoint);
            var d1 = vec2/* distance */.TE(point, nextPoint);
            var sum = d0 + d1;
            if (sum !== 0) {
                d0 /= sum;
                d1 /= sum;
            }
            var v1 = vec2/* scale */.bA([0, 0], v, -d0);
            var v2 = vec2/* scale */.bA([0, 0], v, d1);
            cp1 = vec2/* add */.IH([0, 0], point, v1);
            nextCp0 = vec2/* add */.IH([0, 0], point, v2);
            // \u4E0B\u4E00\u4E2A\u63A7\u5236\u70B9\u5FC5\u987B\u5728\u8FD9\u4E2A\u70B9\u548C\u4E0B\u4E00\u4E2A\u70B9\u4E4B\u95F4
            nextCp0 = vec2/* min */.VV([0, 0], nextCp0, vec2/* max */.Fp([0, 0], nextPoint, point));
            nextCp0 = vec2/* max */.Fp([0, 0], nextCp0, vec2/* min */.VV([0, 0], nextPoint, point));
            // \u91CD\u65B0\u8BA1\u7B97 cp1 \u7684\u503C
            v1 = vec2/* sub */.lu([0, 0], nextCp0, point);
            v1 = vec2/* scale */.bA([0, 0], v1, -d0 / d1);
            cp1 = vec2/* add */.IH([0, 0], point, v1);
            // \u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\u5FC5\u987B\u8981\u5728\u4E0A\u4E00\u4E2A\u70B9\u548C\u8FD9\u4E00\u4E2A\u70B9\u4E4B\u95F4
            cp1 = vec2/* min */.VV([0, 0], cp1, vec2/* max */.Fp([0, 0], prevPoint, point));
            cp1 = vec2/* max */.Fp([0, 0], cp1, vec2/* min */.VV([0, 0], prevPoint, point));
            // \u91CD\u65B0\u8BA1\u7B97 nextCp0 \u7684\u503C
            v2 = vec2/* sub */.lu([0, 0], point, cp1);
            v2 = vec2/* scale */.bA([0, 0], v2, d1 / d0);
            nextCp0 = vec2/* add */.IH([0, 0], point, v2);
            if (hasConstraint) {
                cp1 = vec2/* max */.Fp([0, 0], cp1, min);
                cp1 = vec2/* min */.VV([0, 0], cp1, max);
                nextCp0 = vec2/* max */.Fp([0, 0], nextCp0, min);
                nextCp0 = vec2/* min */.VV([0, 0], nextCp0, max);
            }
            cps.push(cp0);
            cps.push(cp1);
            cp0 = nextCp0;
        }
    }
    if (isLoop) {
        cps.push(cps.shift());
    }
    return cps;
}
/**
 * create bezier spline from catmull rom spline
 * @param {Array} crp Catmull Rom Points
 * @param {boolean} z Spline is loop
 * @param {Array} constraint Constraint
 */
function catmullRom2Bezier(crp, z, constraint) {
    if (z === void 0) { z = false; }
    if (constraint === void 0) { constraint = [
        [0, 0],
        [1, 1],
    ]; }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
        pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p;
    for (var i = 0; i < len - 1; i += 1) {
        cp1 = controlPointList[i * 2];
        cp2 = controlPointList[i * 2 + 1];
        p = pointList[i + 1];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    if (isLoop) {
        cp1 = controlPointList[len];
        cp2 = controlPointList[len + 1];
        p = pointList[0];
        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    return d1;
}
/* harmony default export */ var catmull_rom_2_bezier = (catmullRom2Bezier);
//# sourceMappingURL=catmull-rom-2-bezier.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/fill-path-by-diff.js

function getMinDiff(del, add, modify) {
    var type = null;
    var min = modify;
    if (add < min) {
        min = add;
        type = 'add';
    }
    if (del < min) {
        min = del;
        type = 'del';
    }
    return {
        type: type,
        min: min,
    };
}
/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * \u8BA1\u7B97\u4E24\u6761path\u7684\u7F16\u8F91\u8DDD\u79BB
 */
var levenshteinDistance = function (source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment, targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
        return null;
    }
    var dist = [];
    for (var i = 0; i <= sourceLen; i++) {
        dist[i] = [];
        dist[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
        dist[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
        sourceSegment = source[i - 1];
        for (var j = 1; j <= targetLen; j++) {
            targetSegment = target[j - 1];
            if (isEqual(sourceSegment, targetSegment)) {
                temp = 0;
            }
            else {
                temp = 1;
            }
            var del = dist[i - 1][j].min + 1;
            var add = dist[i][j - 1].min + 1;
            var modify = dist[i - 1][j - 1].min + temp;
            dist[i][j] = getMinDiff(del, add, modify);
        }
    }
    return dist;
};
function fillPathByDiff(source, target) {
    var diffMatrix = levenshteinDistance(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    // \u5982\u679Csource\u548Ctarget\u4E0D\u662F\u5B8C\u5168\u4E0D\u76F8\u7B49
    // @ts-ignore
    if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
        // \u83B7\u53D6\u4ECEsource\u5230target\u6240\u9700\u6539\u52A8
        for (var i = 1; i <= sourceLen; i++) {
            var min = diffMatrix[i][i].min;
            minPos = i;
            for (var j = index; j <= targetLen; j++) {
                if (diffMatrix[i][j].min < min) {
                    min = diffMatrix[i][j].min;
                    minPos = j;
                }
            }
            index = minPos;
            if (diffMatrix[i][index].type) {
                changes.push({ index: i - 1, type: diffMatrix[i][index].type });
            }
        }
        // \u5BF9source\u8FDB\u884C\u589E\u5220path
        for (var i = changes.length - 1; i >= 0; i--) {
            index = changes[i].index;
            if (changes[i].type === 'add') {
                // @ts-ignore
                source.splice(index, 0, [].concat(source[index]));
            }
            else {
                // @ts-ignore
                source.splice(index, 1);
            }
        }
    }
    // source\u5C3E\u90E8\u8865\u9F50
    sourceLen = source.length;
    if (sourceLen < targetLen) {
        for (var i = 0; i < (targetLen - sourceLen); i++) {
            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
                // @ts-ignore
                source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
            }
            else {
                // @ts-ignore
                source.push(source[sourceLen - 1]);
            }
        }
    }
    return source;
}
//# sourceMappingURL=fill-path-by-diff.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/parse-path-string.js

var SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');
// Parses given path string into an array of arrays of path segments
function parsePathString(pathString) {
    if (!pathString) {
        return null;
    }
    if ((0,esm/* isArray */.kJ)(pathString)) {
        return pathString;
    }
    var paramCounts = {
        a: 7,
        c: 6,
        o: 2,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        u: 3,
        z: 0,
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND, function (a, b, c) {
        var params = [];
        var name = b.toLowerCase();
        c.replace(PATH_VALUES, function (a, b) {
            b && params.push(+b);
        });
        if (name === 'm' && params.length > 2) {
            data.push([b].concat(params.splice(0, 2)));
            name = 'l';
            b = b === 'm' ? 'l' : 'L';
        }
        if (name === 'o' && params.length === 1) {
            data.push([b, params[0]]);
        }
        if (name === 'r') {
            data.push([b].concat(params));
        }
        else {
            while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        }
        return '';
    });
    return data;
}
//# sourceMappingURL=parse-path-string.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/path-2-absolute.js

var REGEX_MD = /[a-z]/;
function toSymmetry(p, c) {
    return [
        c[0] + (c[0] - p[0]),
        c[1] + (c[1] - p[1]),
    ];
}
function pathToAbsolute(pathString) {
    var pathArray = parsePathString(pathString);
    if (!pathArray || !pathArray.length) {
        return [
            ['M', 0, 0],
        ];
    }
    var needProcess = false; // \u5982\u679C\u5B58\u5728\u5C0F\u5199\u7684\u547D\u4EE4\u6216\u8005 V,H,T,S \u5219\u9700\u8981\u5904\u7406
    for (var i = 0; i < pathArray.length; i++) {
        var cmd = pathArray[i][0];
        // \u5982\u679C\u5B58\u5728\u76F8\u5BF9\u4F4D\u7F6E\u7684\u547D\u4EE4\uFF0C\u5219\u4E2D\u65AD\u8FD4\u56DE
        if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {
            needProcess = true;
            break;
        }
    }
    // \u5982\u679C\u4E0D\u5B58\u5728\u76F8\u5BF9\u547D\u4EE4\uFF0C\u5219\u76F4\u63A5\u8FD4\u56DE
    // \u5982\u679C\u5728\u4E1A\u52A1\u4E0A\u90FD\u5199\u7EDD\u5BF9\u8DEF\u5F84\uFF0C\u8FD9\u79CD\u65B9\u5F0F\u6700\u5FEB\uFF0C\u4EC5\u505A\u4E86\u4E00\u6B21\u68C0\u6D4B
    if (!needProcess) {
        return pathArray;
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    var first = pathArray[0];
    if (first[0] === 'M' || first[0] === 'm') {
        x = +first[1];
        y = +first[2];
        mx = x;
        my = y;
        start++;
        res[0] = ['M', x, y];
    }
    for (var i = start, ii = pathArray.length; i < ii; i++) {
        var pa = pathArray[i];
        var preParams = res[i - 1]; // \u53D6\u524D\u4E00\u4E2A\u5DF2\u7ECF\u5904\u7406\u540E\u7684\u8282\u70B9\uFF0C\u5426\u5219\u4F1A\u51FA\u73B0\u95EE\u9898
        var r = [];
        var cmd = pa[0];
        var upCmd = cmd.toUpperCase();
        if (cmd !== upCmd) {
            r[0] = upCmd;
            switch (upCmd) {
                case 'A':
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +pa[6] + x;
                    r[7] = +pa[7] + y;
                    break;
                case 'V':
                    r[1] = +pa[1] + y;
                    break;
                case 'H':
                    r[1] = +pa[1] + x;
                    break;
                case 'M':
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                    r[1] = mx;
                    r[2] = my;
                    break; // for lint
                default:
                    for (var j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +pa[j] + ((j % 2) ? x : y);
                    }
            }
        }
        else { // \u5982\u679C\u672C\u6765\u5DF2\u7ECF\u5927\u5199\uFF0C\u5219\u4E0D\u5904\u7406
            r = pathArray[i];
        }
        // \u9700\u8981\u5728\u5916\u9762\u7EDF\u4E00\u505A\uFF0C\u540C\u65F6\u5904\u7406 V,H,S,T \u7B49\u7279\u6B8A\u6307\u4EE4
        switch (upCmd) {
            case 'Z':
                x = +mx;
                y = +my;
                break;
            case 'H':
                x = r[1];
                r = ['L', x, y];
                break;
            case 'V':
                y = r[1];
                r = ['L', x, y];
                break;
            case 'T':
                x = r[1];
                y = r[2];
                // \u4EE5 x, y \u4E3A\u4E2D\u5FC3\u7684\uFF0C\u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\u7684\u5BF9\u79F0\u70B9
                // \u9700\u8981\u5047\u8BBE\u4E0A\u4E00\u4E2A\u8282\u70B9\u7684\u547D\u4EE4\u4E3A Q
                var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
                r = ['Q', symetricT[0], symetricT[1], x, y];
                break;
            case 'S':
                x = r[r.length - 2];
                y = r[r.length - 1];
                // \u4EE5 x,y \u4E3A\u4E2D\u5FC3\uFF0C\u53D6\u4E0A\u4E00\u4E2A\u63A7\u5236\u70B9\uFF0C
                // \u9700\u8981\u5047\u8BBE\u4E0A\u4E00\u4E2A\u7EBF\u6BB5\u4E3A C \u6216\u8005 S
                var length_1 = preParams.length;
                var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
                r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break; // for lint
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
        }
        res.push(r);
    }
    return res;
}
//# sourceMappingURL=path-2-absolute.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;
var mapToEllipse = function (_a, rx, ry, cosphi, sinphi, centerx, centery) {
    var x = _a.x, y = _a.y;
    x *= rx;
    y *= ry;
    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;
    return {
        x: xp + centerx,
        y: yp + centery
    };
};
var approxUnitArc = function (ang1, ang2) {
    // If 90 degree circular arc, use a constant
    // as derived from http://spencermortensen.com/articles/bezier-circle
    var a = ang2 === 1.5707963267948966
        ? 0.551915024494
        : ang2 === -1.5707963267948966
            ? -0.551915024494
            : 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);
    return [
        {
            x: x1 - y1 * a,
            y: y1 + x1 * a
        },
        {
            x: x2 + y2 * a,
            y: y2 - x2 * a
        },
        {
            x: x2,
            y: y2
        }
    ];
};
var vectorAngle = function (ux, uy, vx, vy) {
    var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
    var dot = ux * vx + uy * vy;
    if (dot > 1) {
        dot = 1;
    }
    if (dot < -1) {
        dot = -1;
    }
    return sign * Math.acos(dot);
};
var getArcCenter = function (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq);
    if (radicant < 0) {
        radicant = 0;
    }
    radicant /= (rxsq * pypsq) + (rysq * pxpsq);
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
};
var arcToBezier = function (_a) {
    var px = _a.px, py = _a.py, cx = _a.cx, cy = _a.cy, rx = _a.rx, ry = _a.ry, _b = _a.xAxisRotation, xAxisRotation = _b === void 0 ? 0 : _b, _c = _a.largeArcFlag, largeArcFlag = _c === void 0 ? 0 : _c, _d = _a.sweepFlag, sweepFlag = _d === void 0 ? 0 : _d;
    var curves = [];
    if (rx === 0 || ry === 0) {
        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) +
        Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    var _e = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), centerx = _e[0], centery = _e[1], ang1 = _e[2], ang2 = _e[3];
    // If 'ang2' == 90.0000000001, then \`ratio\` will evaluate to
    // 1.0000000001. This causes \`segments\` to be greater than one, which is an
    // unecessary split, and adds extra points to the bezier curve. To alleviate
    // this issue, we round to 1.0 when the ratio is close to 1.0.
    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1.0 - ratio) < 0.0000001) {
        ratio = 1.0;
    }
    var segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    for (var i = 0; i < segments; i++) {
        curves.push(approxUnitArc(ang1, ang2));
        ang1 += ang2;
    }
    return curves.map(function (curve) {
        var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _a.x, y1 = _a.y;
        var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _b.x, y2 = _b.y;
        var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _c.x, y = _c.y;
        return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
    });
};
function arc_2_cubic_arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2) {
    var curves = arcToBezier({
        px: x1,
        py: y1,
        cx: x2,
        cy: y2,
        rx: rx,
        ry: ry,
        xAxisRotation: angle,
        largeArcFlag: LAF,
        sweepFlag: SF,
    });
    return curves.reduce(function (prev, cur) {
        var x1 = cur.x1, y1 = cur.y1, x2 = cur.x2, y2 = cur.y2, x = cur.x, y = cur.y;
        prev.push(x1, y1, x2, y2, x, y);
        return prev;
    }, []);
}
//# sourceMappingURL=arc-2-cubic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/process/segment-2-cubic.js



function segment_2_cubic_segmentToCubic(segment, params) {
    if ('TQ'.indexOf(segment[0]) < 0) {
        params.qx = null;
        params.qy = null;
    }
    var _a = segment.slice(1), s1 = _a[0], s2 = _a[1];
    switch (segment[0]) {
        case 'M':
            params.x = s1;
            params.y = s2;
            return segment;
        case 'A':
            return ['C'].concat(arcToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));
        case 'Q':
            params.qx = s1;
            params.qy = s2;
            return ['C'].concat(quadToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));
        case 'L':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, segment[1], segment[2]));
        case 'H':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, segment[1], params.y1));
        case 'V':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, params.x1, segment[1]));
        case 'Z':
            // @ts-ignore
            return ['C'].concat(lineToCubic(params.x1, params.y1, params.x, params.y));
        default:
    }
    return segment;
}
//# sourceMappingURL=segment-2-cubic.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/path-2-curve.js


function pathToCurve(path, needZCommandIndexes) {
    if (needZCommandIndexes === void 0) { needZCommandIndexes = false; }
    var pathArray = path2Absolute(path);
    var params = {
        x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null,
    };
    var allPathCommands = [];
    var pathCommand = '';
    var ii = pathArray.length;
    var segment;
    var seglen;
    var zCommandIndexes = [];
    for (var i = 0; i < ii; i += 1) {
        if (pathArray[i])
            pathCommand = pathArray[i][0];
        allPathCommands[i] = pathCommand;
        pathArray[i] = segmentToCubic(pathArray[i], params);
        fixArc(pathArray, allPathCommands, i);
        ii = pathArray.length; // solves curveArrays ending in Z
        // keep Z command account for lineJoin
        // @see https://github.com/antvis/util/issues/68
        if (pathCommand === 'Z') {
            zCommandIndexes.push(i);
        }
        segment = pathArray[i];
        seglen = segment.length;
        params.x1 = +segment[seglen - 2];
        params.y1 = +segment[seglen - 1];
        params.x2 = +(segment[seglen - 4]) || params.x1;
        params.y2 = +(segment[seglen - 3]) || params.y1;
    }
    if (needZCommandIndexes) {
        return [pathArray, zCommandIndexes];
    }
    else {
        return pathArray;
    }
}
function fixArc(pathArray, allPathCommands, i) {
    if (pathArray[i].length > 7) {
        pathArray[i].shift();
        var pi = pathArray[i];
        // const ni = i + 1;
        var ni = i;
        while (pi.length) {
            // if created multiple C:s, their original seg is saved
            allPathCommands[i] = 'A';
            // @ts-ignore
            pathArray.splice(ni += 1, 0, ['C'].concat(pi.splice(0, 6)));
        }
        pathArray.splice(i, 1);
    }
}
//# sourceMappingURL=path-2-curve.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/path-intersection.js



var base3 = function (t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function (x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z === null) {
        z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    var sum = 0;
    for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2;
        var xbase = base3(ct, x1, x2, x3, x4);
        var ybase = base3(ct, y1, y2, y3, y4);
        var comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
};
var curveDim = function (x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [];
    var bounds = [
        [],
        [],
    ];
    var a;
    var b;
    var c;
    var t;
    for (var i = 0; i < 2; ++i) {
        if (i === 0) {
            b = 6 * x0 - 12 * x1 + 6 * x2;
            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
            c = 3 * x1 - 3 * x0;
        }
        else {
            b = 6 * y0 - 12 * y1 + 6 * y2;
            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c = 3 * y1 - 3 * y0;
        }
        if (Math.abs(a) < 1e-12) {
            if (Math.abs(b) < 1e-12) {
                continue;
            }
            t = -c / b;
            if (t > 0 && t < 1) {
                tvalues.push(t);
            }
            continue;
        }
        var b2ac = b * b - 4 * c * a;
        var sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
            continue;
        }
        var t1 = (-b + sqrtb2ac) / (2 * a);
        if (t1 > 0 && t1 < 1) {
            tvalues.push(t1);
        }
        var t2 = (-b - sqrtb2ac) / (2 * a);
        if (t2 > 0 && t2 < 1) {
            tvalues.push(t2);
        }
    }
    var j = tvalues.length;
    var jlen = j;
    var mt;
    while (j--) {
        t = tvalues[j];
        mt = 1 - t;
        bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
        bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
        min: {
            x: Math.min.apply(0, bounds[0]),
            y: Math.min.apply(0, bounds[1]),
        },
        max: {
            x: Math.max.apply(0, bounds[0]),
            y: Math.max.apply(0, bounds[1]),
        },
    };
};
var intersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    if (Math.max(x1, x2) < Math.min(x3, x4) ||
        Math.min(x1, x2) > Math.max(x3, x4) ||
        Math.max(y1, y2) < Math.min(y3, y4) ||
        Math.min(y1, y2) > Math.max(y3, y4)) {
        return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
        return;
    }
    var px = nx / denominator;
    var py = ny / denominator;
    var px2 = +px.toFixed(2);
    var py2 = +py.toFixed(2);
    if (px2 < +Math.min(x1, x2).toFixed(2) ||
        px2 > +Math.max(x1, x2).toFixed(2) ||
        px2 < +Math.min(x3, x4).toFixed(2) ||
        px2 > +Math.max(x3, x4).toFixed(2) ||
        py2 < +Math.min(y1, y2).toFixed(2) ||
        py2 > +Math.max(y1, y2).toFixed(2) ||
        py2 < +Math.min(y3, y4).toFixed(2) ||
        py2 > +Math.max(y3, y4).toFixed(2)) {
        return;
    }
    return {
        x: px,
        y: py,
    };
};
var isPointInsideBBox = function (bbox, x, y) {
    return x >= bbox.x &&
        x <= bbox.x + bbox.width &&
        y >= bbox.y &&
        y <= bbox.y + bbox.height;
};
var box = function (x, y, width, height) {
    if (x === null) {
        x = y = width = height = 0;
    }
    if (y === null) {
        y = x.y;
        width = x.width;
        height = x.height;
        x = x.x;
    }
    return {
        x: x,
        y: y,
        width: width,
        w: width,
        height: height,
        h: height,
        x2: x + width,
        y2: y + height,
        cx: x + width / 2,
        cy: y + height / 2,
        r1: Math.min(width, height) / 2,
        r2: Math.max(width, height) / 2,
        r0: Math.sqrt(width * width + height * height) / 2,
        path: rectPath(x, y, width, height),
        vb: [x, y, width, height].join(' '),
    };
};
var isBBoxIntersect = function (bbox1, bbox2) {
    // @ts-ignore
    bbox1 = box(bbox1);
    // @ts-ignore
    bbox2 = box(bbox2);
    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!isArray(p1x)) {
        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    var t13 = Math.pow(t1, 3);
    var t12 = Math.pow(t1, 2);
    var t2 = t * t;
    var t3 = t2 * t;
    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
    var ax = t1 * p1x + t * c1x;
    var ay = t1 * p1y + t * c1y;
    var cx = t1 * c2x + t * p2x;
    var cy = t1 * c2y + t * p2y;
    var alpha = (90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI);
    // (mx > nx || my < ny) && (alpha += 180);
    return {
        x: x,
        y: y,
        m: {
            x: mx,
            y: my,
        },
        n: {
            x: nx,
            y: ny,
        },
        start: {
            x: ax,
            y: ay,
        },
        end: {
            x: cx,
            y: cy,
        },
        alpha: alpha,
    };
};
var interHelper = function (bez1, bez2, justCount) {
    // @ts-ignore
    var bbox1 = bezierBBox(bez1);
    // @ts-ignore
    var bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1);
    var l2 = bezlen.apply(0, bez2);
    var n1 = ~~(l1 / 8);
    var n2 = ~~(l2 / 8);
    var dots1 = [];
    var dots2 = [];
    var xy = {};
    var res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
        dots1.push({
            x: d.x,
            y: d.y,
            t: i / n1,
        });
    }
    for (var i = 0; i < n2 + 1; i++) {
        var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
        dots2.push({
            x: d.x,
            y: d.y,
            t: i / n2,
        });
    }
    for (var i = 0; i < n1; i++) {
        for (var j = 0; j < n2; j++) {
            var di = dots1[i];
            var di1 = dots1[i + 1];
            var dj = dots2[j];
            var dj1 = dots2[j + 1];
            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
                    continue;
                }
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                    if (justCount) {
                        // @ts-ignore
                        res++;
                    }
                    else {
                        // @ts-ignore
                        res.push({
                            x: is.x,
                            y: is.y,
                            t1: t1,
                            t2: t2,
                        });
                    }
                }
            }
        }
    }
    return res;
};
var interPathHelper = function (path1, path2, justCount) {
    // @ts-ignore
    path1 = path2Curve(path1);
    // @ts-ignore
    path2 = path2Curve(path2);
    var x1;
    var y1;
    var x2;
    var y2;
    var x1m;
    var y1m;
    var x2m;
    var y2m;
    var bez1;
    var bez2;
    var res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
        var pi = path1[i];
        if (pi[0] === 'M') {
            x1 = x1m = pi[1];
            y1 = y1m = pi[2];
        }
        else {
            if (pi[0] === 'C') {
                bez1 = [x1, y1].concat(pi.slice(1));
                x1 = bez1[6];
                y1 = bez1[7];
            }
            else {
                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                x1 = x1m;
                y1 = y1m;
            }
            for (var j = 0, jj = path2.length; j < jj; j++) {
                var pj = path2[j];
                if (pj[0] === 'M') {
                    x2 = x2m = pj[1];
                    y2 = y2m = pj[2];
                }
                else {
                    if (pj[0] === 'C') {
                        bez2 = [x2, y2].concat(pj.slice(1));
                        x2 = bez2[6];
                        y2 = bez2[7];
                    }
                    else {
                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                        x2 = x2m;
                        y2 = y2m;
                    }
                    var intr = interHelper(bez1, bez2, justCount);
                    if (justCount) {
                        // @ts-ignore
                        res += intr;
                    }
                    else {
                        // @ts-ignore
                        for (var k = 0, kk = intr.length; k < kk; k++) {
                            intr[k].segment1 = i;
                            intr[k].segment2 = j;
                            intr[k].bez1 = bez1;
                            intr[k].bez2 = bez2;
                        }
                        // @ts-ignore
                        res = res.concat(intr);
                    }
                }
            }
        }
    }
    return res;
};
function pathIntersection(path1, path2) {
    // @ts-ignore
    return interPathHelper(path1, path2);
}
//# sourceMappingURL=path-intersection.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/get-arc-params.js

// \u5411\u91CF\u957F\u5EA6
function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
// u.v/|u||v|\uFF0C\u8BA1\u7B97\u5939\u89D2\u7684\u4F59\u5F26\u503C
function vRatio(u, v) {
    // \u5F53\u5B58\u5728\u4E00\u4E2A\u5411\u91CF\u7684\u957F\u5EA6\u4E3A 0 \u65F6\uFF0C\u5939\u89D2\u4E5F\u4E3A 0\uFF0C\u5373\u5939\u89D2\u7684\u4F59\u5F26\u503C\u4E3A 1
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
// \u5411\u91CF\u89D2\u5EA6
function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
/**
 * \u5224\u65AD\u4E24\u4E2A\u70B9\u662F\u5426\u91CD\u5408\uFF0C\u70B9\u5750\u6807\u7684\u683C\u5F0F\u4E3A [x, y]
 * @param {Array} point1 \u7B2C\u4E00\u4E2A\u70B9
 * @param {Array} point2 \u7B2C\u4E8C\u4E2A\u70B9
 */
function isSamePoint(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
}
// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y
function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = (0,esm/* mod */.wQ)((0,esm/* toRadian */.c$)(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    // \u5F27\u5F62\u8D77\u70B9\u5750\u6807
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    // \u5F27\u5F62\u7EC8\u70B9\u5750\u6807
    var x2 = params[6];
    var y2 = params[7];
    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;
    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;
    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
        f *= -1;
    }
    if (isNaN(f)) {
        f = 0;
    }
    // \u65CB\u8F6C\u524D\u7684\u8D77\u70B9\u5750\u6807\uFF0C\u4E14\u5F53\u957F\u534A\u8F74\u548C\u77ED\u534A\u8F74\u7684\u957F\u5EA6\u4E3A 0 \u65F6\uFF0C\u5750\u6807\u6309 (0, 0) \u5904\u7406
    var cxp = ry ? (f * rx * yp) / ry : 0;
    var cyp = rx ? (f * -ry * xp) / rx : 0;
    // \u692D\u5706\u5706\u5FC3\u5750\u6807
    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    // \u8D77\u59CB\u70B9\u7684\u5355\u4F4D\u5411\u91CF
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    // \u7EC8\u6B62\u70B9\u7684\u5355\u4F4D\u5411\u91CF
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    // \u8BA1\u7B97\u8D77\u59CB\u70B9\u548C\u5706\u5FC3\u7684\u8FDE\u7EBF\uFF0C\u4E0E x \u8F74\u6B63\u65B9\u5411\u7684\u5939\u89D2
    var theta = vAngle([1, 0], u);
    // \u8BA1\u7B97\u5706\u5F27\u8D77\u59CB\u70B9\u548C\u7EC8\u6B62\u70B9\u4E0E\u692D\u5706\u5706\u5FC3\u8FDE\u7EBF\u7684\u5939\u89D2
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
        dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
        dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * Math.PI;
    }
    return {
        cx: cx,
        cy: cy,
        // \u5F27\u5F62\u7684\u8D77\u70B9\u548C\u7EC8\u70B9\u76F8\u540C\u65F6\uFF0C\u957F\u8F74\u548C\u77ED\u8F74\u7684\u957F\u5EA6\u6309 0 \u5904\u7406
        rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
        ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
        startAngle: theta,
        endAngle: theta + dTheta,
        xRotation: xRotation,
        arcFlag: arcFlag,
        sweepFlag: sweepFlag,
    };
}
//# sourceMappingURL=get-arc-params.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/path-2-segments.js



// \u70B9\u5BF9\u79F0
function path_2_segments_toSymmetry(point, center) {
    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
function getSegments(path) {
    path = parse_path(path);
    var segments = [];
    var currentPoint = null; // \u5F53\u524D\u56FE\u5F62
    var nextParams = null; // \u4E0B\u4E00\u8282\u70B9\u7684 path \u53C2\u6570
    var startMovePoint = null; // \u5F00\u59CB M \u7684\u70B9\uFF0C\u53EF\u80FD\u4F1A\u6709\u591A\u4E2A
    var lastStartMovePointIndex = 0; // \u6700\u8FD1\u4E00\u4E2A\u5F00\u59CB\u70B9 M \u7684\u7D22\u5F15
    var count = path.length;
    for (var i = 0; i < count; i++) {
        var params = path[i];
        nextParams = path[i + 1];
        var command = params[0];
        // \u6570\u5B66\u5B9A\u4E49\u4E0A\u7684\u53C2\u6570\uFF0C\u4FBF\u4E8E\u540E\u9762\u7684\u8BA1\u7B97
        var segment = {
            command: command,
            prePoint: currentPoint,
            params: params,
            startTangent: null,
            endTangent: null,
        };
        switch (command) {
            case 'M':
                startMovePoint = [params[1], params[2]];
                lastStartMovePointIndex = i;
                break;
            case 'A':
                var arcParams = getArcParams(currentPoint, params);
                segment['arcParams'] = arcParams;
                break;
            default:
                break;
        }
        if (command === 'Z') {
            // \u6709\u4E86 Z \u540E\uFF0C\u5F53\u524D\u8282\u70B9\u4ECE\u5F00\u59CB M \u7684\u70B9\u5F00\u59CB
            currentPoint = startMovePoint;
            // \u5982\u679C\u5F53\u524D\u70B9\u7684\u547D\u4EE4\u4E3A Z\uFF0C\u76F8\u5F53\u4E8E\u5F53\u524D\u70B9\u4E3A\u6700\u8FD1\u4E00\u4E2A M \u70B9\uFF0C\u5219\u4E0B\u4E00\u4E2A\u70B9\u76F4\u63A5\u6307\u5411\u6700\u8FD1\u4E00\u4E2A M \u70B9\u7684\u4E0B\u4E00\u4E2A\u70B9
            nextParams = path[lastStartMovePointIndex + 1];
        }
        else {
            var len = params.length;
            currentPoint = [params[len - 2], params[len - 1]];
        }
        if (nextParams && nextParams[0] === 'Z') {
            // \u5982\u679C\u4E0B\u4E00\u4E2A\u70B9\u7684\u547D\u4EE4\u4E3A Z\uFF0C\u5219\u4E0B\u4E00\u4E2A\u70B9\u76F4\u63A5\u6307\u5411\u6700\u8FD1\u4E00\u4E2A M \u70B9
            nextParams = path[lastStartMovePointIndex];
            if (segments[lastStartMovePointIndex]) {
                // \u5982\u679C\u4E0B\u4E00\u4E2A\u70B9\u7684\u547D\u4EE4\u4E3A Z\uFF0C\u5219\u6700\u8FD1\u4E00\u4E2A M \u70B9\u7684\u524D\u4E00\u4E2A\u70B9\u4E3A\u5F53\u524D\u70B9
                segments[lastStartMovePointIndex].prePoint = currentPoint;
            }
        }
        segment['currentPoint'] = currentPoint;
        // \u5982\u679C\u5F53\u524D\u70B9\u4E0E\u6700\u8FD1\u4E00\u4E2A M \u70B9\u76F8\u540C\uFF0C\u5219\u6700\u8FD1\u4E00\u4E2A M \u70B9\u7684\u524D\u4E00\u4E2A\u70B9\u4E3A\u5F53\u524D\u70B9\u7684\u524D\u4E00\u4E2A\u70B9
        if (segments[lastStartMovePointIndex] &&
            isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
            segments[lastStartMovePointIndex].prePoint = segment.prePoint;
        }
        var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
        segment['nextPoint'] = nextPoint;
        // Add startTangent and endTangent
        var prePoint = segment.prePoint;
        if (['L', 'H', 'V'].includes(command)) {
            segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
            segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
        else if (command === 'Q') {
            // \u4E8C\u6B21\u8D1D\u585E\u5C14\u66F2\u7EBF\u53EA\u6709\u4E00\u4E2A\u63A7\u5236\u70B9
            var cp = [params[1], params[2]];
            // \u4E8C\u6B21\u8D1D\u585E\u5C14\u66F2\u7EBF\u7684\u7EC8\u70B9\u4E3A currentPoint
            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
        }
        else if (command === 'T') {
            var preSegment = segments[i - 1];
            var cp = path_2_segments_toSymmetry(preSegment.currentPoint, prePoint);
            if (preSegment.command === 'Q') {
                segment.command = 'Q';
                segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
                segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
            }
            else {
                segment.command = 'TL';
                segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
                segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
            }
        }
        else if (command === 'C') {
            // \u4E09\u6B21\u8D1D\u585E\u5C14\u66F2\u7EBF\u6709\u4E24\u4E2A\u63A7\u5236\u70B9
            var cp1 = [params[1], params[2]];
            var cp2 = [params[3], params[4]];
            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
            // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]
            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
                segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
            }
            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
                segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
            }
        }
        else if (command === 'S') {
            var preSegment = segments[i - 1];
            var cp1 = path_2_segments_toSymmetry(preSegment.currentPoint, prePoint);
            var cp2 = [params[1], params[2]];
            if (preSegment.command === 'C') {
                segment.command = 'C'; // \u5C06 S \u547D\u4EE4\u53D8\u6362\u4E3A C \u547D\u4EE4
                segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
            }
            else {
                segment.command = 'SQ'; // \u5C06 S \u547D\u4EE4\u53D8\u6362\u4E3A SQ \u547D\u4EE4
                segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
            }
        }
        else if (command === 'A') {
            var d = 0.001;
            var _a = segment['arcParams'] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;
            if (sweepFlag === 0) {
                d *= -1;
            }
            var dx1 = rx * Math.cos(startAngle - d) + cx;
            var dy1 = ry * Math.sin(startAngle - d) + cy;
            segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
            var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
            var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
            segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
        }
        segments.push(segment);
    }
    return segments;
}
//# sourceMappingURL=path-2-segments.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/point-in-polygon.js
/**
 * @fileoverview \u5224\u65AD\u70B9\u662F\u5426\u5728\u591A\u8FB9\u5F62\u5185
 * @author dxq613@gmail.com
 */
// \u591A\u8FB9\u5F62\u7684\u5C04\u7EBF\u68C0\u6D4B\uFF0C\u53C2\u8003\uFF1Ahttps://blog.csdn.net/WilliamSun0122/article/details/77994526
var tolerance = 1e-6;
// \u4E09\u6001\u51FD\u6570\uFF0C\u5224\u65AD\u4E24\u4E2Adouble\u5728eps\u7CBE\u5EA6\u4E0B\u7684\u5927\u5C0F\u5173\u7CFB
function dcmp(x) {
    if (Math.abs(x) < tolerance) {
        return 0;
    }
    return x < 0 ? -1 : 1;
}
// \u5224\u65AD\u70B9Q\u662F\u5426\u5728p1\u548Cp2\u7684\u7EBF\u6BB5\u4E0A
function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&
        Math.min(p1[0], p2[0]) <= q[0] &&
        q[0] <= Math.max(p1[0], p2[0]) &&
        Math.min(p1[1], p2[1]) <= q[1] &&
        q[1] <= Math.max(p1[1], p2[1])) {
        return true;
    }
    return false;
}
// \u5224\u65AD\u70B9P\u5728\u591A\u8FB9\u5F62\u5185-\u5C04\u7EBF\u6CD5
function isInPolygon(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
        // svg \u4E2D\u70B9\u5C0F\u4E8E 3 \u4E2A\u65F6\uFF0C\u4E0D\u663E\u793A\uFF0C\u4E5F\u65E0\u6CD5\u88AB\u62FE\u53D6
        return false;
    }
    for (var i = 0; i < n; i++) {
        var p1 = points[i];
        var p2 = points[(i + 1) % n];
        if (onSegment(p1, p2, [x, y])) {
            // \u70B9\u5728\u591A\u8FB9\u5F62\u4E00\u6761\u8FB9\u4E0A
            return true;
        }
        // \u524D\u4E00\u4E2A\u5224\u65ADmin(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
        // \u540E\u4E00\u4E2A\u5224\u65AD\u88AB\u6D4B\u70B9 \u5728 \u5C04\u7EBF\u4E0E\u8FB9\u4EA4\u70B9 \u7684\u5DE6\u8FB9
        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&
            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {
            isHit = !isHit;
        }
    }
    return isHit;
}
//# sourceMappingURL=point-in-polygon.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/get-line-intersect.js
var isBetween = function (value, min, max) { return value >= min && value <= max; };
function getLineIntersect(p0, p1, p2, p3) {
    var tolerance = 0.001;
    var E = {
        x: p2.x - p0.x,
        y: p2.y - p0.y,
    };
    var D0 = {
        x: p1.x - p0.x,
        y: p1.y - p0.y,
    };
    var D1 = {
        x: p3.x - p2.x,
        y: p3.y - p2.y,
    };
    var kross = D0.x * D1.y - D0.y * D1.x;
    var sqrKross = kross * kross;
    var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
    var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
    var point = null;
    if (sqrKross > tolerance * sqrLen0 * sqrLen1) {
        var s = (E.x * D1.y - E.y * D1.x) / kross;
        var t = (E.x * D0.y - E.y * D0.x) / kross;
        if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
            point = {
                x: p0.x + s * D0.x,
                y: p0.y + s * D0.y,
            };
        }
    }
    return point;
}
;
//# sourceMappingURL=get-line-intersect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/is-polygons-intersect.js



function parseToLines(points) {
    var lines = [];
    var count = points.length;
    for (var i = 0; i < count - 1; i++) {
        var point = points[i];
        var next = points[i + 1];
        lines.push({
            from: {
                x: point[0],
                y: point[1]
            },
            to: {
                x: next[0],
                y: next[1]
            }
        });
    }
    if (lines.length > 1) {
        var first = points[0];
        var last = points[count - 1];
        lines.push({
            from: {
                x: last[0],
                y: last[1]
            },
            to: {
                x: first[0],
                y: first[1]
            }
        });
    }
    return lines;
}
function lineIntersectPolygon(lines, line) {
    var isIntersect = false;
    (0,esm/* each */.S6)(lines, function (l) {
        if (getLineIntersect(l.from, l.to, line.from, line.to)) {
            isIntersect = true;
            return false;
        }
    });
    return isIntersect;
}
function getBBox(points) {
    var xArr = points.map(function (p) { return p[0]; });
    var yArr = points.map(function (p) { return p[1]; });
    return {
        minX: Math.min.apply(null, xArr),
        maxX: Math.max.apply(null, xArr),
        minY: Math.min.apply(null, yArr),
        maxY: Math.max.apply(null, yArr)
    };
}
function intersectBBox(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
    // \u7A7A\u6570\u7EC4\uFF0C\u6216\u8005\u4E00\u4E2A\u70B9\u8FD4\u56DE false
    if (points1.length < 2 || points2.length < 2) {
        return false;
    }
    var bbox1 = getBBox(points1);
    var bbox2 = getBBox(points2);
    // \u5224\u5B9A\u5305\u56F4\u76D2\u662F\u5426\u76F8\u4EA4\uFF0C\u6BD4\u5224\u5B9A\u70B9\u662F\u5426\u5728\u591A\u8FB9\u5F62\u5185\u8981\u5FEB\u7684\u591A\uFF0C\u53EF\u4EE5\u7B5B\u9009\u6389\u5927\u591A\u6570\u60C5\u51B5
    if (!intersectBBox(bbox1, bbox2)) {
        return false;
    }
    var isIn = false;
    // \u5224\u5B9A\u70B9\u662F\u5426\u5728\u591A\u8FB9\u5F62\u5185\u90E8\uFF0C\u4E00\u65E6\u6709\u4E00\u4E2A\u70B9\u5728\u53E6\u4E00\u4E2A\u591A\u8FB9\u5F62\u5185\uFF0C\u5219\u8FD4\u56DE
    (0,esm/* each */.S6)(points2, function (point) {
        if (isInPolygon(points1, point[0], point[1])) {
            isIn = true;
            return false;
        }
    });
    if (isIn) {
        return true;
    }
    // \u4E24\u4E2A\u591A\u8FB9\u5F62\u90FD\u9700\u8981\u5224\u5B9A
    (0,esm/* each */.S6)(points1, function (point) {
        if (isInPolygon(points2, point[0], point[1])) {
            isIn = true;
            return false;
        }
    });
    if (isIn) {
        return true;
    }
    var lines1 = parseToLines(points1);
    var lines2 = parseToLines(points2);
    var isIntersect = false;
    (0,esm/* each */.S6)(lines2, function (line) {
        if (lineIntersectPolygon(lines1, line)) {
            isIntersect = true;
            return false;
        }
    });
    return isIntersect;
}
//# sourceMappingURL=is-polygons-intersect.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/path-util/esm/index.js
















//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/path-util/esm/index.js_+_14_modules?`)},45098:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Ct": function() { return /* reexport */ cache; },
  "f0": function() { return /* reexport */ mix_mix; },
  "uZ": function() { return /* reexport */ esm_clamp; },
  "VS": function() { return /* reexport */ cancelAnimationFrame; },
  "d9": function() { return /* reexport */ esm_clone; },
  "FX": function() { return /* reexport */ esm_contains; },
  "Ds": function() { return /* reexport */ esm_debounce; },
  "b$": function() { return /* reexport */ deep_mix; },
  "e5": function() { return /* reexport */ esm_difference; },
  "S6": function() { return /* reexport */ esm_each; },
  "yW": function() { return /* reexport */ esm_every; },
  "hX": function() { return /* reexport */ esm_filter; },
  "sE": function() { return /* reexport */ esm_find; },
  "cx": function() { return /* reexport */ find_index; },
  "Wx": function() { return /* reexport */ first_value; },
  "ri": function() { return /* reexport */ fixed_base; },
  "xH": function() { return /* reexport */ esm_flatten; },
  "U5": function() { return /* reexport */ for_in; },
  "U2": function() { return /* reexport */ get; },
  "Lo": function() { return /* reexport */ get_ellipsis_text; },
  "rx": function() { return /* reexport */ get_range; },
  "ru": function() { return /* reexport */ group; },
  "vM": function() { return /* reexport */ group_by; },
  "Ms": function() { return /* reexport */ groupToMap; },
  "wH": function() { return /* reexport */ has_key; },
  "YM": function() { return /* reexport */ head; },
  "q9": function() { return /* reexport */ esm_contains; },
  "cq": function() { return /* reexport */ index_of; },
  "kJ": function() { return /* reexport */ is_array; },
  "jn": function() { return /* reexport */ is_boolean; },
  "J_": function() { return /* reexport */ is_date; },
  "kK": function() { return /* reexport */ is_element; },
  "xb": function() { return /* reexport */ is_empty; },
  "Xy": function() { return /* reexport */ is_equal; },
  "mf": function() { return /* reexport */ is_function; },
  "BD": function() { return /* reexport */ is_match; },
  "UM": function() { return /* reexport */ is_nil; },
  "Ft": function() { return /* reexport */ is_null; },
  "hj": function() { return /* reexport */ is_number; },
  "vQ": function() { return /* reexport */ isNumberEqual; },
  "Kn": function() { return /* reexport */ is_object; },
  "PO": function() { return /* reexport */ is_plain_object; },
  "HD": function() { return /* reexport */ is_string; },
  "P9": function() { return /* reexport */ is_type; },
  "o8": function() { return /* reexport */ is_undefined; },
  "XP": function() { return /* reexport */ esm_keys; },
  "Z$": function() { return /* reexport */ last; },
  "vl": function() { return /* reexport */ lower_case; },
  "UI": function() { return /* reexport */ esm_map; },
  "Q8": function() { return /* reexport */ map_values; },
  "Fp": function() { return /* reexport */ esm_max; },
  "UT": function() { return /* reexport */ max_by; },
  "HP": function() { return /* reexport */ memoize; },
  "VV": function() { return /* reexport */ esm_min; },
  "F": function() { return /* reexport */ min_by; },
  "CD": function() { return /* reexport */ mix_mix; },
  "wQ": function() { return /* reexport */ esm_mod; },
  "ZT": function() { return /* reexport */ noop; },
  "CE": function() { return /* reexport */ omit; },
  "ei": function() { return /* reexport */ pick; },
  "u4": function() { return /* reexport */ esm_reduce; },
  "Od": function() { return /* reexport */ esm_remove; },
  "U7": function() { return /* reexport */ requestAnimationFrame; },
  "t8": function() { return /* reexport */ set; },
  "dp": function() { return /* reexport */ size; },
  "G": function() { return /* reexport */ esm_some; },
  "MR": function() { return /* reexport */ sort_by; },
  "ng": function() { return /* reexport */ esm_substitute; },
  "P2": function() { return /* reexport */ throttle; },
  "qo": function() { return /* reexport */ to_array; },
  "c$": function() { return /* reexport */ to_radian; },
  "BB": function() { return /* reexport */ to_string; },
  "jj": function() { return /* reexport */ uniq; },
  "EL": function() { return /* reexport */ unique_id; },
  "jC": function() { return /* reexport */ upper_first; },
  "VO": function() { return /* reexport */ esm_values; },
  "I": function() { return /* reexport */ values_of_key; }
});

// UNUSED EXPORTS: augment, endsWith, extend, flattenDeep, getType, getWrapBehavior, has, hasValue, identity, isArguments, isArrayLike, isDecimal, isEqualWith, isError, isEven, isFinite, isInteger, isNegative, isObjectLike, isOdd, isPositive, isPrototype, isRegExp, lowerFirst, measureTextWidth, number2color, parseRadius, pull, pullAt, startsWith, toDegree, toInteger, union, upperCase, wrapBehavior

;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-array-like.js
var isArrayLike = function (value) {
    /**
     * isArrayLike([1, 2, 3]) => true
     * isArrayLike(document.body.children) => true
     * isArrayLike('abc') => true
     * isArrayLike(Function) => false
     */
    return value !== null && typeof value !== 'function' && isFinite(value.length);
};
/* harmony default export */ var is_array_like = (isArrayLike);
//# sourceMappingURL=is-array-like.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/contains.js

var contains_contains = function (arr, value) {
    if (!is_array_like(arr)) {
        return false;
    }
    return arr.indexOf(value) > -1;
};
/* harmony default export */ var esm_contains = (contains_contains);
//# sourceMappingURL=contains.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/filter.js

var filter = function (arr, func) {
    if (!is_array_like(arr)) {
        return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
        var value = arr[index];
        if (func(value, index)) {
            result.push(value);
        }
    }
    return result;
};
/* harmony default export */ var esm_filter = (filter);
//# sourceMappingURL=filter.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/difference.js


/**
 * Flattens \`array\` a single level deep.
 *
 * @param {Array} arr The array to inspect.
 * @param {Array} values The values to exclude.
 * @return {Array} Returns the new array of filtered values.
 * @example
 * difference([2, 1], [2, 3]);  // => [1]
 */
var difference = function (arr, values) {
    if (values === void 0) { values = []; }
    return esm_filter(arr, function (value) { return !esm_contains(values, value); });
};
/* harmony default export */ var esm_difference = (difference);
//# sourceMappingURL=difference.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-type.js
var is_type_toString = {}.toString;
var is_type_isType = function (value, type) { return is_type_toString.call(value) === '[object ' + type + ']'; };
/* harmony default export */ var is_type = (is_type_isType);
//# sourceMappingURL=is-type.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-function.js
/**
 * \u662F\u5426\u4E3A\u51FD\u6570
 * @param  {*} fn \u5BF9\u8C61
 * @return {Boolean}  \u662F\u5426\u51FD\u6570
 */

/* harmony default export */ var is_function = (function (value) {
    return is_type(value, 'Function');
});
//# sourceMappingURL=is-function.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-nil.js
// isFinite,
var isNil = function (value) {
    /**
     * isNil(null) => true
     * isNil() => true
     */
    return value === null || value === undefined;
};
/* harmony default export */ var is_nil = (isNil);
//# sourceMappingURL=is-nil.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-array.js

/* harmony default export */ var is_array = (function (value) {
    return Array.isArray ?
        Array.isArray(value) :
        is_type(value, 'Array');
});
//# sourceMappingURL=is-array.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-object.js
/* harmony default export */ var is_object = (function (value) {
    /**
     * isObject({}) => true
     * isObject([1, 2, 3]) => true
     * isObject(Function) => true
     * isObject(null) => false
     */
    var type = typeof value;
    return value !== null && type === 'object' || type === 'function';
});
//# sourceMappingURL=is-object.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/each.js


function each(elements, func) {
    if (!elements) {
        return;
    }
    var rst;
    if (is_array(elements)) {
        for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);
            if (rst === false) {
                break;
            }
        }
    }
    else if (is_object(elements)) {
        for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
                rst = func(elements[k], k);
                if (rst === false) {
                    break;
                }
            }
        }
    }
}
/* harmony default export */ var esm_each = (each);
//# sourceMappingURL=each.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/keys.js


var keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {
    var result = [];
    esm_each(obj, function (value, key) {
        if (!(is_function(obj) && key === 'prototype')) {
            result.push(key);
        }
    });
    return result;
};
/* harmony default export */ var esm_keys = (keys);
//# sourceMappingURL=keys.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-match.js


function isMatch(obj, attrs) {
    var _keys = esm_keys(attrs);
    var length = _keys.length;
    if (is_nil(obj))
        return !length;
    for (var i = 0; i < length; i += 1) {
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) {
            return false;
        }
    }
    return true;
}
/* harmony default export */ var is_match = (isMatch);
//# sourceMappingURL=is-match.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-object-like.js
var isObjectLike = function (value) {
    /**
     * isObjectLike({}) => true
     * isObjectLike([1, 2, 3]) => true
     * isObjectLike(Function) => false
     * isObjectLike(null) => false
     */
    return typeof value === 'object' && value !== null;
};
/* harmony default export */ var is_object_like = (isObjectLike);
//# sourceMappingURL=is-object-like.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-plain-object.js


var isPlainObject = function (value) {
    /**
     * isObjectLike(new Foo) => false
     * isObjectLike([1, 2, 3]) => false
     * isObjectLike({ x: 0, y: 0 }) => true
     * isObjectLike(Object.create(null)) => true
     */
    if (!is_object_like(value) || !is_type(value, 'Object')) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
};
/* harmony default export */ var is_plain_object = (isPlainObject);
//# sourceMappingURL=is-plain-object.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/find.js




function find(arr, predicate) {
    if (!is_array(arr))
        return null;
    var _predicate;
    if (is_function(predicate)) {
        _predicate = predicate;
    }
    if (is_plain_object(predicate)) {
        _predicate = function (a) { return is_match(a, predicate); };
    }
    if (_predicate) {
        for (var i = 0; i < arr.length; i += 1) {
            if (_predicate(arr[i])) {
                return arr[i];
            }
        }
    }
    return null;
}
/* harmony default export */ var esm_find = (find);
//# sourceMappingURL=find.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/find-index.js
function findIndex(arr, predicate, fromIndex) {
    if (fromIndex === void 0) { fromIndex = 0; }
    for (var i = fromIndex; i < arr.length; i++) {
        if (predicate(arr[i], i)) {
            // \u627E\u5230\u7EC8\u6B62\u5FAA\u73AF
            return i;
        }
    }
    return -1;
}
/* harmony default export */ var find_index = (findIndex);
//# sourceMappingURL=find-index.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/first-value.js


var firstValue = function (data, name) {
    var rst = null;
    for (var i = 0; i < data.length; i++) {
        var obj = data[i];
        var value = obj[name];
        if (!is_nil(value)) {
            if (is_array(value)) {
                rst = value[0]; // todo \u8FD9\u91CC\u662F\u5426\u5E94\u8BE5\u4F7F\u7528\u9012\u5F52\uFF0C\u8C03\u7528 firstValue @\u7EDD\u4E91
            }
            else {
                rst = value;
            }
            break;
        }
    }
    return rst;
};
/* harmony default export */ var first_value = (firstValue);
//# sourceMappingURL=first-value.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/flatten.js

/**
 * Flattens \`array\` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
 */
var flatten = function (arr) {
    if (!is_array(arr)) {
        return [];
    }
    var rst = [];
    for (var i = 0; i < arr.length; i++) {
        rst = rst.concat(arr[i]);
    }
    return rst;
};
/* harmony default export */ var esm_flatten = (flatten);
//# sourceMappingURL=flatten.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/flatten-deep.js

/**
 * Flattens \`array\` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @param {Array} result The array to return.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
 */
var flattenDeep = function (arr, result) {
    if (result === void 0) { result = []; }
    if (!isArray(arr)) {
        result.push(arr);
    }
    else {
        for (var i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], result);
        }
    }
    return result;
};
/* harmony default export */ var flatten_deep = ((/* unused pure expression or super */ null && (flattenDeep)));
//# sourceMappingURL=flatten-deep.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/max.js

/**
 * @param {Array} arr The array to iterate over.
 * @return {*} Returns the maximum value.
 * @example
 *
 * max([1, 2]);
 * // => 2
 *
 * max([]);
 * // => undefined
 *
 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
 *
 * max(data);
 * // => 1250010
 * // Math.max(...data) will encounter "Maximum call stack size exceeded" error
 */
/* harmony default export */ var esm_max = (function (arr) {
    if (!is_array(arr)) {
        return undefined;
    }
    return arr.reduce(function (prev, curr) {
        return Math.max(prev, curr);
    }, arr[0]);
});
//# sourceMappingURL=max.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/min.js

/**
 * @param {Array} arr The array to iterate over.
 * @return {*} Returns the minimum value.
 * @example
 *
 * min([1, 2]);
 * // => 1
 *
 * min([]);
 * // => undefined
 *
 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
 *
 * min(data);
 * // => 1250010
 * // Math.min(...data) will encounter "Maximum call stack size exceeded" error
 */
/* harmony default export */ var esm_min = (function (arr) {
    if (!is_array(arr)) {
        return undefined;
    }
    return arr.reduce(function (prev, curr) {
        return Math.min(prev, curr);
    }, arr[0]);
});
//# sourceMappingURL=min.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/get-range.js



var getRange = function (values) {
    // \u5B58\u5728 NaN \u65F6\uFF0Cmin,max \u5224\u5B9A\u4F1A\u51FA\u95EE\u9898
    var filterValues = values.filter(function (v) { return !isNaN(v); });
    if (!filterValues.length) {
        // \u5982\u679C\u6CA1\u6709\u6570\u503C\u5219\u76F4\u63A5\u8FD4\u56DE0
        return {
            min: 0,
            max: 0,
        };
    }
    if (is_array(values[0])) {
        var tmp = [];
        for (var i = 0; i < values.length; i++) {
            tmp = tmp.concat(values[i]);
        }
        filterValues = tmp;
    }
    var max = esm_max(filterValues);
    var min = esm_min(filterValues);
    return {
        min: min,
        max: max,
    };
};
/* harmony default export */ var get_range = (getRange);
//# sourceMappingURL=get-range.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;
var pull = function (arr) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var fromIndex = -1;
        while ((fromIndex = indexOf.call(arr, value)) > -1) {
            splice.call(arr, fromIndex, 1);
        }
    }
    return arr;
};
/* harmony default export */ var esm_pull = ((/* unused pure expression or super */ null && (pull)));
//# sourceMappingURL=pull.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/pull-at.js

var pull_at_splice = Array.prototype.splice;
var pullAt = function pullAt(arr, indexes) {
    if (!is_array_like(arr)) {
        return [];
    }
    var length = arr ? indexes.length : 0;
    var last = length - 1;
    while (length--) {
        var previous = void 0;
        var index = indexes[length];
        if (length === last || index !== previous) {
            previous = index;
            pull_at_splice.call(arr, index, 1);
        }
    }
    return arr;
};
/* harmony default export */ var pull_at = (pullAt);
//# sourceMappingURL=pull-at.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/reduce.js



var reduce = function (arr, fn, init) {
    if (!is_array(arr) && !is_plain_object(arr)) {
        return arr;
    }
    var result = init;
    esm_each(arr, function (data, i) {
        result = fn(result, data, i);
    });
    return result;
};
/* harmony default export */ var esm_reduce = (reduce);
//# sourceMappingURL=reduce.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/remove.js


var remove = function (arr, predicate) {
    /**
     * const arr = [1, 2, 3, 4]
     * const evens = remove(arr, n => n % 2 == 0)
     * console.log(arr) // => [1, 3]
     * console.log(evens) // => [2, 4]
     */
    var result = [];
    if (!is_array_like(arr)) {
        return result;
    }
    var i = -1;
    var indexes = [];
    var length = arr.length;
    while (++i < length) {
        var value = arr[i];
        if (predicate(value, i, arr)) {
            result.push(value);
            indexes.push(i);
        }
    }
    pull_at(arr, indexes);
    return result;
};
/* harmony default export */ var esm_remove = (remove);
//# sourceMappingURL=remove.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-string.js

/* harmony default export */ var is_string = (function (str) {
    return is_type(str, 'String');
});
//# sourceMappingURL=is-string.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/sort-by.js



function sortBy(arr, key) {
    var comparer;
    if (is_function(key)) {
        comparer = function (a, b) { return key(a) - key(b); };
    }
    else {
        var keys_1 = [];
        if (is_string(key)) {
            keys_1.push(key);
        }
        else if (is_array(key)) {
            keys_1 = key;
        }
        comparer = function (a, b) {
            for (var i = 0; i < keys_1.length; i += 1) {
                var prop = keys_1[i];
                if (a[prop] > b[prop]) {
                    return 1;
                }
                if (a[prop] < b[prop]) {
                    return -1;
                }
            }
            return 0;
        };
    }
    arr.sort(comparer);
    return arr;
}
/* harmony default export */ var sort_by = (sortBy);
//# sourceMappingURL=sort-by.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache) {
    if (cache === void 0) { cache = new Map(); }
    var r = [];
    if (Array.isArray(arr)) {
        for (var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            // \u52A0\u4E00\u4E2A cache\uFF0C\u63D0\u5347\u6027\u80FD
            if (!cache.has(item)) {
                r.push(item);
                cache.set(item, true);
            }
        }
    }
    return r;
}
//# sourceMappingURL=uniq.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/values-of-key.js


/* harmony default export */ var values_of_key = (function (data, name) {
    var rst = [];
    var tmpMap = {};
    for (var i = 0; i < data.length; i++) {
        var obj = data[i];
        var value = obj[name];
        if (!is_nil(value)) {
            // flatten
            if (!is_array(value)) {
                value = [value];
            }
            for (var j = 0; j < value.length; j++) {
                var val = value[j];
                // unique
                if (!tmpMap[val]) {
                    rst.push(val);
                    tmpMap[val] = true;
                }
            }
        }
    }
    return rst;
});
//# sourceMappingURL=values-of-key.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/head.js

function head(o) {
    if (is_array_like(o)) {
        return o[0];
    }
    return undefined;
}
//# sourceMappingURL=head.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/last.js

function last(o) {
    if (is_array_like(o)) {
        var arr = o;
        return arr[arr.length - 1];
    }
    return undefined;
}
//# sourceMappingURL=last.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/starts-with.js


function startsWith(arr, e) {
    return (isArray(arr) || isString(arr)) ? arr[0] === e : false;
}
/* harmony default export */ var starts_with = ((/* unused pure expression or super */ null && (startsWith)));
//# sourceMappingURL=starts-with.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/ends-with.js


function endsWith(arr, e) {
    return (isArray(arr) || isString(arr)) ? arr[arr.length - 1] === e : false;
}
/* harmony default export */ var ends_with = ((/* unused pure expression or super */ null && (endsWith)));
//# sourceMappingURL=ends-with.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/every.js
/**
 * \u53EA\u8981\u6709\u4E00\u4E2A\u4E0D\u6EE1\u8DB3\u6761\u4EF6\u5C31\u8FD4\u56DE false
 * @param arr
 * @param func
 */
var every = function (arr, func) {
    for (var i = 0; i < arr.length; i++) {
        if (!func(arr[i], i))
            return false;
    }
    return true;
};
/* harmony default export */ var esm_every = (every);
//# sourceMappingURL=every.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/some.js
/**
 * \u53EA\u8981\u6709\u4E00\u4E2A\u6EE1\u8DB3\u6761\u4EF6\u5C31\u8FD4\u56DE true
 * @param arr
 * @param func
 */
var some = function (arr, func) {
    for (var i = 0; i < arr.length; i++) {
        if (func(arr[i], i))
            return true;
    }
    return false;
};
/* harmony default export */ var esm_some = (some);
//# sourceMappingURL=some.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/group-by.js


var group_by_hasOwnProperty = Object.prototype.hasOwnProperty;
function groupBy(data, condition) {
    if (!condition || !is_array(data)) {
        return {};
    }
    var result = {};
    // \u517C\u5BB9\u65B9\u6CD5\u548C \u5B57\u7B26\u4E32\u7684\u5199\u6CD5
    var predicate = is_function(condition) ? condition : function (item) { return item[condition]; };
    var key;
    for (var i = 0; i < data.length; i++) {
        var item = data[i];
        key = predicate(item);
        if (group_by_hasOwnProperty.call(result, key)) {
            result[key].push(item);
        }
        else {
            result[key] = [item];
        }
    }
    return result;
}
/* harmony default export */ var group_by = (groupBy);
//# sourceMappingURL=group-by.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/group-to-map.js



/**
 * \u5C06\u6570\u636E\u5206\u7EC4\u6210 map
 * @param data
 * @param condition
 */
function groupToMap(data, condition) {
    if (!condition) {
        return {
            0: data,
        };
    }
    if (!is_function(condition)) {
        // \u5982\u679C\u662F\u5B57\u7B26\u4E32\uFF0C\u5219\u6309\u7167 a*b \u98CE\u683C\u6210\u6570\u7EC4
        var paramscondition_1 = is_array(condition) ? condition : condition.replace(/\\s+/g, '').split('*');
        condition = function (row) {
            var unique = '_'; // \u907F\u514D\u51FA\u73B0\u6570\u5B57\u4F5C\u4E3AKey\u7684\u60C5\u51B5\uFF0C\u4F1A\u8FDB\u884C\u6309\u7167\u6570\u5B57\u7684\u6392\u5E8F
            // \u6839\u636E\u5B57\u6BB5\u5217\u8868\u7684\u503C\uFF0C\u62FC\u63A5\u6210 key
            for (var i = 0, l = paramscondition_1.length; i < l; i++) {
                unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
            }
            return unique;
        };
    }
    return group_by(data, condition);
}
//# sourceMappingURL=group-to-map.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/group.js

/* harmony default export */ var group = (function (data, condition) {
    if (!condition) {
        // \u6CA1\u6709\u6761\u4EF6\uFF0C\u5219\u81EA\u8EAB\u6539\u6210\u6570\u7EC4
        return [data];
    }
    var groups = groupToMap(data, condition);
    var array = [];
    for (var i in groups) {
        array.push(groups[i]);
    }
    return array;
});
//# sourceMappingURL=group.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/number2color.js
var numColorCache = {};
function numberToColor(num) {
    // \u589E\u52A0\u7F13\u5B58
    var color = numColorCache[num];
    if (!color) {
        var str = num.toString(16);
        for (var i = str.length; i < 6; i++) {
            str = '0' + str;
        }
        color = '#' + str;
        numColorCache[num] = color;
    }
    return color;
}
/* harmony default export */ var number2color = ((/* unused pure expression or super */ null && (numberToColor)));
//# sourceMappingURL=number2color.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/parse-radius.js

function parseRadius(radius) {
    var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
    if (isArray(radius)) {
        if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
        }
        else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
        }
        else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
        }
        else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
        }
    }
    else {
        r1 = r2 = r3 = r4 = radius;
    }
    return {
        r1: r1,
        r2: r2,
        r3: r3,
        r4: r4
    };
}
/* harmony default export */ var parse_radius = ((/* unused pure expression or super */ null && (parseRadius)));
//# sourceMappingURL=parse-radius.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/clamp.js
var clamp = function (a, min, max) {
    if (a < min) {
        return min;
    }
    else if (a > max) {
        return max;
    }
    return a;
};
/* harmony default export */ var esm_clamp = (clamp);
//# sourceMappingURL=clamp.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/fixed-base.js
var fixedBase = function (v, base) {
    var str = base.toString();
    var index = str.indexOf('.');
    if (index === -1) {
        return Math.round(v);
    }
    var length = str.substr(index + 1).length;
    if (length > 20) {
        length = 20;
    }
    return parseFloat(v.toFixed(length));
};
/* harmony default export */ var fixed_base = (fixedBase);
//# sourceMappingURL=fixed-base.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-number.js
/**
 * \u5224\u65AD\u662F\u5426\u6570\u5B57
 * @return {Boolean} \u662F\u5426\u6570\u5B57
 */

var is_number_isNumber = function (value) {
    return is_type(value, 'Number');
};
/* harmony default export */ var is_number = (is_number_isNumber);
//# sourceMappingURL=is-number.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-decimal.js

var isDecimal = function (num) {
    return isNumber(num) && num % 1 !== 0;
};
/* harmony default export */ var is_decimal = ((/* unused pure expression or super */ null && (isDecimal)));
//# sourceMappingURL=is-decimal.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-even.js

var isEven = function (num) {
    return isNumber(num) && num % 2 === 0;
};
/* harmony default export */ var is_even = ((/* unused pure expression or super */ null && (isEven)));
//# sourceMappingURL=is-even.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-integer.js

var isInteger = Number.isInteger ? Number.isInteger : function (num) {
    return is_number(num) && num % 1 === 0;
};
/* harmony default export */ var is_integer = ((/* unused pure expression or super */ null && (isInteger)));
//# sourceMappingURL=is-integer.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-negative.js

var isNegative = function (num) {
    return isNumber(num) && num < 0;
};
/* harmony default export */ var is_negative = ((/* unused pure expression or super */ null && (isNegative)));
//# sourceMappingURL=is-negative.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-number-equal.js
var PRECISION = 0.00001; // numbers less than this is considered as 0
function isNumberEqual(a, b, precision) {
    if (precision === void 0) { precision = PRECISION; }
    return Math.abs((a - b)) < precision;
}
;
//# sourceMappingURL=is-number-equal.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-odd.js

var isOdd = function (num) {
    return isNumber(num) && num % 2 !== 0;
};
/* harmony default export */ var is_odd = ((/* unused pure expression or super */ null && (isOdd)));
//# sourceMappingURL=is-odd.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-positive.js

var isPositive = function (num) {
    return isNumber(num) && num > 0;
};
/* harmony default export */ var is_positive = ((/* unused pure expression or super */ null && (isPositive)));
//# sourceMappingURL=is-positive.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/max-by.js


/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
/* harmony default export */ var max_by = (function (arr, fn) {
    if (!is_array(arr)) {
        return undefined;
    }
    var maxItem;
    var max = -Infinity;
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var v = is_function(fn) ? fn(item) : item[fn];
        if (v > max) {
            maxItem = item;
            max = v;
        }
    }
    return maxItem;
});
//# sourceMappingURL=max-by.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/min-by.js


/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * minBy(objects, 'n');
 * // => { 'n': 1 }
 */
/* harmony default export */ var min_by = (function (arr, fn) {
    if (!is_array(arr)) {
        return undefined;
    }
    var minItem;
    var min = Infinity;
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        var v = is_function(fn) ? fn(item) : item[fn];
        if (v < min) {
            minItem = item;
            min = v;
        }
    }
    return minItem;
});
//# sourceMappingURL=min-by.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/mod.js
var mod = function (n, m) {
    return ((n % m) + m) % m;
};
/* harmony default export */ var esm_mod = (mod);
//# sourceMappingURL=mod.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;
var toDegree = function (radian) {
    return DEGREE * radian;
};
/* harmony default export */ var to_degree = ((/* unused pure expression or super */ null && (toDegree)));
//# sourceMappingURL=to-degree.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/to-integer.js
/* harmony default export */ var to_integer = (parseInt);
//# sourceMappingURL=to-integer.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;
var toRadian = function (degree) {
    return RADIAN * degree;
};
/* harmony default export */ var to_radian = (toRadian);
//# sourceMappingURL=to-radian.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/for-in.js

/* harmony default export */ var for_in = (esm_each);
//# sourceMappingURL=for-in.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/has.js
/* harmony default export */ var has = (function (obj, key) { return obj.hasOwnProperty(key); });
//# sourceMappingURL=has.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/has-key.js

/* harmony default export */ var has_key = (has);
//# sourceMappingURL=has-key.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/values.js


// @ts-ignore
var values_values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {
    var result = [];
    esm_each(obj, function (value, key) {
        if (!(is_function(obj) && key === 'prototype')) {
            result.push(value);
        }
    });
    return result;
};
/* harmony default export */ var esm_values = (values_values);
//# sourceMappingURL=values.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/has-value.js


/* harmony default export */ var has_value = (function (obj, value) { return contains(values(obj), value); });
//# sourceMappingURL=has-value.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/to-string.js

/* harmony default export */ var to_string = (function (value) {
    if (is_nil(value))
        return '';
    return value.toString();
});
//# sourceMappingURL=to-string.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/lower-case.js

var lowerCase = function (str) {
    return to_string(str).toLowerCase();
};
/* harmony default export */ var lower_case = (lowerCase);
//# sourceMappingURL=lower-case.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/substitute.js
function substitute(str, o) {
    if (!str || !o) {
        return str;
    }
    return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {
        if (match.charAt(0) === '\\\\') {
            return match.slice(1);
        }
        return (o[name] === undefined) ? '' : o[name];
    });
}
/* harmony default export */ var esm_substitute = (substitute);
//# sourceMappingURL=substitute.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/upper-first.js

var upperFirst = function (value) {
    var str = to_string(value);
    return str.charAt(0).toUpperCase() + str.substring(1);
};
/* harmony default export */ var upper_first = (upperFirst);
//# sourceMappingURL=upper-first.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/get-type.js
var get_type_toString = {}.toString;
var getType = function (value) {
    return get_type_toString.call(value).replace(/^\\[object /, '').replace(/]$/, '');
};
/* harmony default export */ var get_type = (getType);
//# sourceMappingURL=get-type.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-arguments.js
/**
 * \u662F\u5426\u662F\u53C2\u6570\u7C7B\u578B
 *
 * @param {Object} value \u6D4B\u8BD5\u7684\u503C
 * @return {Boolean}
 */

var isArguments = function (value) {
    return isType(value, 'Arguments');
};
/* harmony default export */ var is_arguments = ((/* unused pure expression or super */ null && (isArguments)));
//# sourceMappingURL=is-arguments.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-boolean.js
/**
 * \u662F\u5426\u662F\u5E03\u5C14\u7C7B\u578B
 *
 * @param {Object} value \u6D4B\u8BD5\u7684\u503C
 * @return {Boolean}
 */

var isBoolean = function (value) {
    return is_type(value, 'Boolean');
};
/* harmony default export */ var is_boolean = (isBoolean);
//# sourceMappingURL=is-boolean.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-date.js

var isDate = function (value) {
    return is_type(value, 'Date');
};
/* harmony default export */ var is_date = (isDate);
//# sourceMappingURL=is-date.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-error.js
/**
 * \u662F\u5426\u662F\u53C2\u6570\u7C7B\u578B
 *
 * @param {Object} value \u6D4B\u8BD5\u7684\u503C
 * @return {Boolean}
 */

var isError = function (value) {
    return isType(value, 'Error');
};
/* harmony default export */ var is_error = ((/* unused pure expression or super */ null && (isError)));
//# sourceMappingURL=is-error.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-finite.js
/**
 * \u5224\u65AD\u662F\u5426\u4E3A\u6709\u9650\u6570
 * @return {Boolean}
 */

/* harmony default export */ function is_finite(value) {
    return isNumber(value) && isFinite(value);
}
//# sourceMappingURL=is-finite.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-null.js
var isNull = function (value) {
    return value === null;
};
/* harmony default export */ var is_null = (isNull);
//# sourceMappingURL=is-null.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-prototype.js
var objectProto = Object.prototype;
var isPrototype = function (value) {
    var Ctor = value && value.constructor;
    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;
    return value === proto;
};
/* harmony default export */ var is_prototype = (isPrototype);
//# sourceMappingURL=is-prototype.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-reg-exp.js

var isRegExp = function (str) {
    return isType(str, 'RegExp');
};
/* harmony default export */ var is_reg_exp = ((/* unused pure expression or super */ null && (isRegExp)));
//# sourceMappingURL=is-reg-exp.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-undefined.js
var isUndefined = function (value) {
    return value === undefined;
};
/* harmony default export */ var is_undefined = (isUndefined);
//# sourceMappingURL=is-undefined.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-element.js
/**
 * \u5224\u65AD\u662F\u5426HTML\u5143\u7D20
 * @return {Boolean} \u662F\u5426HTML\u5143\u7D20
 */
var isElement = function (o) {
    return o instanceof Element || o instanceof HTMLDocument;
};
/* harmony default export */ var is_element = (isElement);
//# sourceMappingURL=is-element.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame(fn) {
    var method = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        // @ts-ignore
        window.mozRequestAnimationFrame ||
        // @ts-ignore
        window.msRequestAnimationFrame ||
        function (f) {
            return setTimeout(f, 16);
        };
    return method(fn);
}
;
//# sourceMappingURL=request-animation-frame.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame(handler) {
    var method = window.cancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        // @ts-ignore
        window.mozCancelAnimationFrame ||
        // @ts-ignore
        window.msCancelAnimationFrame ||
        clearTimeout;
    method(handler);
}
;
//# sourceMappingURL=clear-animation-frame.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/augment.js


var augment = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var c = args[0];
    for (var i = 1; i < args.length; i++) {
        var obj = args[i];
        if (isFunction(obj)) {
            obj = obj.prototype;
        }
        mix(c.prototype, obj);
    }
};
/* harmony default export */ var esm_augment = ((/* unused pure expression or super */ null && (augment)));
//# sourceMappingURL=augment.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/clone.js

var clone = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    var rst;
    if (is_array(obj)) {
        rst = [];
        for (var i = 0, l = obj.length; i < l; i++) {
            if (typeof obj[i] === 'object' && obj[i] != null) {
                rst[i] = clone(obj[i]);
            }
            else {
                rst[i] = obj[i];
            }
        }
    }
    else {
        rst = {};
        for (var k in obj) {
            if (typeof obj[k] === 'object' && obj[k] != null) {
                rst[k] = clone(obj[k]);
            }
            else {
                rst[k] = obj[k];
            }
        }
    }
    return rst;
};
/* harmony default export */ var esm_clone = (clone);
//# sourceMappingURL=clone.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
    var timeout;
    return function () {
        var context = this, args = arguments;
        var later = function () {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
}
/* harmony default export */ var esm_debounce = (debounce);
//# sourceMappingURL=debounce.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/memoize.js

/**
 * _.memoize(calColor);
 * _.memoize(calColor, (...args) => args[0]);
 * @param f
 * @param resolver
 */
/* harmony default export */ var memoize = (function (f, resolver) {
    if (!is_function(f)) {
        throw new TypeError('Expected a function');
    }
    var memoized = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // \u4F7F\u7528\u65B9\u6CD5\u6784\u9020 key\uFF0C\u5982\u679C\u4E0D\u5B58\u5728 resolver\uFF0C\u5219\u76F4\u63A5\u53D6\u7B2C\u4E00\u4E2A\u53C2\u6570\u4F5C\u4E3A key
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = f.apply(this, args);
        // \u7F13\u5B58\u8D77\u6765
        cache.set(key, result);
        return result;
    };
    memoized.cache = new Map();
    return memoized;
});
//# sourceMappingURL=memoize.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/deep-mix.js


var MAX_MIX_LEVEL = 5;
function _deepMix(dist, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
        if (src.hasOwnProperty(key)) {
            var value = src[key];
            if (value !== null && is_plain_object(value)) {
                if (!is_plain_object(dist[key])) {
                    dist[key] = {};
                }
                if (level < maxLevel) {
                    _deepMix(dist[key], value, level + 1, maxLevel);
                }
                else {
                    dist[key] = src[key];
                }
            }
            else if (is_array(value)) {
                dist[key] = [];
                dist[key] = dist[key].concat(value);
            }
            else if (value !== undefined) {
                dist[key] = value;
            }
        }
    }
}
// todo \u91CD\u5199
var deepMix = function (rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
        _deepMix(rst, args[i]);
    }
    return rst;
};
/* harmony default export */ var deep_mix = (deepMix);
//# sourceMappingURL=deep-mix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/extend.js


var extend = function (subclass, superclass, overrides, staticOverrides) {
    // \u5982\u679C\u53EA\u63D0\u4F9B\u7236\u7C7B\u6784\u9020\u51FD\u6570\uFF0C\u5219\u81EA\u52A8\u751F\u6210\u5B50\u7C7B\u6784\u9020\u51FD\u6570
    if (!isFunction(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function () { };
    }
    var create = Object.create ?
        function (proto, c) {
            return Object.create(proto, {
                constructor: {
                    value: c
                }
            });
        } :
        function (proto, c) {
            function Tmp() { }
            Tmp.prototype = proto;
            var o = new Tmp();
            o.constructor = c;
            return o;
        };
    var superObj = create(superclass.prototype, subclass); // new superclass(),//\u5B9E\u4F8B\u5316\u7236\u7C7B\u4F5C\u4E3A\u5B50\u7C7B\u7684prototype
    subclass.prototype = mix(superObj, subclass.prototype); // \u6307\u5B9A\u5B50\u7C7B\u7684prototype
    subclass.superclass = create(superclass.prototype, superclass);
    mix(superObj, overrides);
    mix(subclass, staticOverrides);
    return subclass;
};
/* harmony default export */ var esm_extend = ((/* unused pure expression or super */ null && (extend)));
//# sourceMappingURL=extend.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/index-of.js

var index_of_indexOf = function (arr, obj) {
    if (!is_array_like(arr)) {
        return -1;
    }
    var m = Array.prototype.indexOf;
    if (m) {
        return m.call(arr, obj);
    }
    var index = -1;
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === obj) {
            index = i;
            break;
        }
    }
    return index;
};
/* harmony default export */ var index_of = (index_of_indexOf);
//# sourceMappingURL=index-of.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-empty.js




var is_empty_hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmpty(value) {
    /**
     * isEmpty(null) => true
     * isEmpty() => true
     * isEmpty(true) => true
     * isEmpty(1) => true
     * isEmpty([1, 2, 3]) => false
     * isEmpty('abc') => false
     * isEmpty({ a: 1 }) => false
     */
    if (is_nil(value)) {
        return true;
    }
    if (is_array_like(value)) {
        return !value.length;
    }
    var type = get_type(value);
    if (type === 'Map' || type === 'Set') {
        return !value.size;
    }
    if (is_prototype(value)) {
        return !Object.keys(value).length;
    }
    for (var key in value) {
        if (is_empty_hasOwnProperty.call(value, key)) {
            return false;
        }
    }
    return true;
}
/* harmony default export */ var is_empty = (isEmpty);
//# sourceMappingURL=is-empty.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-equal.js



var is_equal_isEqual = function (value, other) {
    if (value === other) {
        return true;
    }
    if (!value || !other) {
        return false;
    }
    if (is_string(value) || is_string(other)) {
        return false;
    }
    if (is_array_like(value) || is_array_like(other)) {
        if (value.length !== other.length) {
            return false;
        }
        var rst = true;
        for (var i = 0; i < value.length; i++) {
            rst = is_equal_isEqual(value[i], other[i]);
            if (!rst) {
                break;
            }
        }
        return rst;
    }
    if (is_object_like(value) || is_object_like(other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
            return false;
        }
        var rst = true;
        for (var i = 0; i < valueKeys.length; i++) {
            rst = is_equal_isEqual(value[valueKeys[i]], other[valueKeys[i]]);
            if (!rst) {
                break;
            }
        }
        return rst;
    }
    return false;
};
/* harmony default export */ var is_equal = (is_equal_isEqual);
//# sourceMappingURL=is-equal.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/is-equal-with.js


/**
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [fn] The function to customize comparisons.
 * @returns {boolean} Returns \`true\` if the values are equivalent, else \`false\`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * isEqualWith(array, other, customizer);  // => true
 */
/* harmony default export */ var is_equal_with = (function (value, other, fn) {
    if (!isFunction(fn)) {
        return isEqual(value, other);
    }
    return !!fn(value, other);
});
//# sourceMappingURL=is-equal-with.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/map.js

var map = function (arr, func) {
    if (!is_array_like(arr)) {
        // @ts-ignore
        return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
        var value = arr[index];
        result.push(func(value, index));
    }
    return result;
};
/* harmony default export */ var esm_map = (map);
//# sourceMappingURL=map.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/map-values.js


var identity = function (v) { return v; };
/* harmony default export */ var map_values = (function (object, func) {
    if (func === void 0) { func = identity; }
    var r = {};
    if (is_object(object) && !is_nil(object)) {
        Object.keys(object).forEach(function (key) {
            // @ts-ignore
            r[key] = func(object[key], key);
        });
    }
    return r;
});
//# sourceMappingURL=map-values.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/mix.js
// FIXME: Mutable param should be forbidden in static lang.
function _mix(dist, obj) {
    for (var key in obj) {
        if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
            dist[key] = obj[key];
        }
    }
}
function mix_mix(dist, src1, src2, src3) {
    if (src1)
        _mix(dist, src1);
    if (src2)
        _mix(dist, src2);
    if (src3)
        _mix(dist, src3);
    return dist;
}
//# sourceMappingURL=mix.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/get.js

/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param key
 * @param defaultValue
 */
/* harmony default export */ var get = (function (obj, key, defaultValue) {
    var p = 0;
    var keyArr = is_string(key) ? key.split('.') : key;
    while (obj && p < keyArr.length) {
        obj = obj[keyArr[p++]];
    }
    return (obj === undefined || p < keyArr.length) ? defaultValue : obj;
});
//# sourceMappingURL=get.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/set.js



/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param path
 * @param value
 */
/* harmony default export */ var set = (function (obj, path, value) {
    var o = obj;
    var keyArr = is_string(path) ? path.split('.') : path;
    keyArr.forEach(function (key, idx) {
        // \u4E0D\u662F\u6700\u540E\u4E00\u4E2A
        if (idx < keyArr.length - 1) {
            if (!is_object(o[key])) {
                o[key] = is_number(keyArr[idx + 1]) ? [] : {};
            }
            o = o[key];
        }
        else {
            o[key] = value;
        }
    });
    return obj;
});
//# sourceMappingURL=set.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/pick.js


var pick_hasOwnProperty = Object.prototype.hasOwnProperty;
/* harmony default export */ var pick = (function (object, keys) {
    if (object === null || !is_plain_object(object)) {
        return {};
    }
    var result = {};
    esm_each(keys, function (key) {
        if (pick_hasOwnProperty.call(object, key)) {
            result[key] = object[key];
        }
    });
    return result;
});
//# sourceMappingURL=pick.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/omit.js

/* harmony default export */ var omit = (function (obj, keys) {
    return esm_reduce(obj, function (r, curr, key) {
        if (!keys.includes(key)) {
            r[key] = curr;
        }
        return r;
    }, {});
});
//# sourceMappingURL=omit.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/throttle.js
/* harmony default export */ var throttle = (function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options)
        options = {};
    var later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    var throttled = function () {
        var now = Date.now();
        if (!previous && options.leading === false)
            previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
});
//# sourceMappingURL=throttle.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/to-array.js

/* harmony default export */ var to_array = (function (value) {
    return is_array_like(value) ? Array.prototype.slice.call(value) : [];
});
//# sourceMappingURL=to-array.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/unique-id.js
var unique_id_map = {};
/* harmony default export */ var unique_id = (function (prefix) {
    prefix = prefix || 'g';
    if (!unique_id_map[prefix]) {
        unique_id_map[prefix] = 1;
    }
    else {
        unique_id_map[prefix] += 1;
    }
    return prefix + unique_id_map[prefix];
});
//# sourceMappingURL=unique-id.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/noop.js
/* harmony default export */ var noop = (function () { });
//# sourceMappingURL=noop.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/size.js


function size(o) {
    if (is_nil(o)) {
        return 0;
    }
    if (is_array_like(o)) {
        return o.length;
    }
    return Object.keys(o).length;
}
//# sourceMappingURL=size.js.map
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.mjs
var tslib_es6 = __webpack_require__(97582);
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/measure-text-width.js




var ctx;
/**
 * \u8BA1\u7B97\u6587\u672C\u7684\u5BBD\u5EA6
 */
/* harmony default export */ var measure_text_width = (memoize(function (text, font) {
    if (font === void 0) { font = {}; }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (!ctx) {
        ctx = document.createElement('canvas').getContext('2d');
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ');
    return ctx.measureText(is_string(text) ? text : '').width;
}, function (text, font) {
    if (font === void 0) { font = {}; }
    return (0,tslib_es6/* __spreadArrays */.pr)([text], esm_values(font)).join('');
}));
//# sourceMappingURL=measure-text-width.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/get-ellipsis-text.js



/**
 * \u83B7\u53D6\u6587\u672C\u7684 ... \u6587\u672C\u3002
 * \u7B97\u6CD5\uFF08\u51CF\u5C11\u6BCF\u6B21 measureText \u7684\u957F\u5EA6\uFF0CmeasureText \u7684\u6027\u80FD\u8DDF\u5B57\u7B26\u4E32\u65F6\u95F4\u76F8\u5173\uFF09\uFF1A
 * 1. \u5148\u901A\u8FC7 STEP \u9010\u6B65\u8BA1\u7B97\uFF0C\u627E\u5230\u6700\u540E\u4E00\u4E2A\u5C0F\u4E8E maxWidth \u7684\u5B57\u7B26\u4E32
 * 2. \u7136\u540E\u5BF9\u6700\u540E\u8FD9\u4E2A\u5B57\u7B26\u4E32\u4E8C\u5206\u8BA1\u7B97
 * @param text \u9700\u8981\u8BA1\u7B97\u7684\u6587\u672C, \u7531\u4E8E\u5386\u53F2\u539F\u56E0 \u9664\u4E86\u652F\u6301string\uFF0C\u8FD8\u652F\u6301\u7A7A\u503C,number\u548C\u6570\u7EC4\u7B49
 * @param maxWidth \u6700\u5927\u5BBD\u5EA6
 * @param font \u5B57\u4F53
 * @param str \u8981\u66FF\u6362\u7684\u6587\u672C
 */
/* harmony default export */ var get_ellipsis_text = (function (text, maxWidth, font, str) {
    if (str === void 0) { str = '...'; }
    var STEP = 16; // \u6BCF\u6B21 16\uFF0C\u8C03\u53C2\u5DE5\u7A0B\u5E08
    var PLACEHOLDER_WIDTH = measure_text_width(str, font);
    var leftText = !is_string(text) ? to_string(text) : text;
    var leftWidth = maxWidth;
    var r = []; // \u6700\u7EC8\u7684\u5206\u6BB5\u5B57\u7B26\u4E32
    var currentText;
    var currentWidth;
    if (measure_text_width(text, font) <= maxWidth) {
        return text;
    }
    // \u9996\u5148\u901A\u8FC7 step \u8BA1\u7B97\uFF0C\u627E\u51FA\u6700\u5927\u7684\u672A\u8D85\u51FA\u957F\u5EA6\u7684
    // eslint-disable-next-line no-constant-condition
    while (true) {
        // \u66F4\u65B0\u5B57\u7B26\u4E32
        currentText = leftText.substr(0, STEP);
        // \u8BA1\u7B97\u5BBD\u5EA6
        currentWidth = measure_text_width(currentText, font);
        // \u8D85\u51FA\u5269\u4F59\u5BBD\u5EA6\uFF0C\u5219\u505C\u6B62
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
            if (currentWidth > leftWidth) {
                break;
            }
        }
        r.push(currentText);
        // \u6CA1\u6709\u8D85\u51FA\uFF0C\u5219\u8BA1\u7B97\u5269\u4F59\u5BBD\u5EA6
        leftWidth -= currentWidth;
        leftText = leftText.substr(STEP);
        // \u5B57\u7B26\u4E32\u6574\u4F53\u6CA1\u6709\u8D85\u51FA
        if (!leftText) {
            return r.join('');
        }
    }
    // \u6700\u4E0B\u7684\u6700\u540E\u4E00\u4E2A STEP\uFF0C\u4F7F\u7528 1 \u9012\u589E\uFF08\u7528\u4E8C\u5206\u6548\u679C\u66F4\u9AD8\uFF09
    // eslint-disable-next-line no-constant-condition
    while (true) {
        // \u66F4\u65B0\u5B57\u7B26\u4E32
        currentText = leftText.substr(0, 1);
        // \u8BA1\u7B97\u5BBD\u5EA6
        currentWidth = measure_text_width(currentText, font);
        // \u8D85\u51FA\u5269\u4F59\u5BBD\u5EA6\uFF0C\u5219\u505C\u6B62
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
            break;
        }
        r.push(currentText);
        // \u6CA1\u6709\u8D85\u51FA\uFF0C\u5219\u8BA1\u7B97\u5269\u4F59\u5BBD\u5EA6
        leftWidth -= currentWidth;
        leftText = leftText.substr(1);
        if (!leftText) {
            return r.join('');
        }
    }
    return "" + r.join('') + str;
});
//# sourceMappingURL=get-ellipsis-text.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/cache.js
/**
 * k-v \u5B58\u50A8
 */
var default_1 = /** @class */ (function () {
    function default_1() {
        this.map = {};
    }
    default_1.prototype.has = function (key) {
        return this.map[key] !== undefined;
    };
    default_1.prototype.get = function (key, def) {
        var v = this.map[key];
        return v === undefined ? def : v;
    };
    default_1.prototype.set = function (key, value) {
        this.map[key] = value;
    };
    default_1.prototype.clear = function () {
        this.map = {};
    };
    default_1.prototype.delete = function (key) {
        delete this.map[key];
    };
    default_1.prototype.size = function () {
        return Object.keys(this.map).length;
    };
    return default_1;
}());
/* harmony default export */ var cache = (default_1);
//# sourceMappingURL=cache.js.map
;// CONCATENATED MODULE: ./node_modules/@antv/util/esm/index.js
// array


























// event


// format


// math

















// object







// string





// type























// other

























// text


// \u4E0D\u77E5\u9053\u4E3A\u4EC0\u4E48\uFF0C\u9700\u8981\u628A\u8FD9\u4E2A export\uFF0C\u4E0D\u7136 ts \u4F1A\u62A5\u7C7B\u578B\u9519\u8BEF

//# sourceMappingURL=index.js.map

//# sourceURL=webpack:///./node_modules/@antv/util/esm/index.js_+_104_modules?`)},12690:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ CommonCard_Page; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__(97857);
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var objectWithoutProperties = __webpack_require__(13769);
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties);
// EXTERNAL MODULE: ./node_modules/antd/es/spin/index.js + 2 modules
var spin = __webpack_require__(46572);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
;// CONCATENATED MODULE: ./src/components/CommonCard/Page/index.less?modules
// extracted by mini-css-extract-plugin
/* harmony default export */ var Pagemodules = ({"container":"container____ubNY","content":"content___W1c7E","loading":"loading___oQ9_b"});
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(85893);
;// CONCATENATED MODULE: ./src/components/CommonCard/Page/index.tsx


var _excluded = ["loading", "className", "children", "title"];




var Page = function Page(props) {
  var loading = props.loading,
    className = props.className,
    children = props.children,
    title = props.title,
    restProps = objectWithoutProperties_default()(props, _excluded);
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", objectSpread2_default()(objectSpread2_default()({
    id: "container",
    className: "".concat(Pagemodules.container, " ").concat(className)
  }, restProps), {}, {
    children: loading ? /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: Pagemodules.loading,
      children: /*#__PURE__*/(0,jsx_runtime.jsx)(spin/* default */.Z, {
        tip: "\\u52A0\\u8F7D\\u4E2D..."
      })
    }) : /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
      className: Pagemodules.content,
      children: children
    })
  }));
};
Page.defaultProps = {
  loading: false
};
/* harmony default export */ var CommonCard_Page = (/*#__PURE__*/react.memo(Page));

//# sourceURL=webpack:///./src/components/CommonCard/Page/index.tsx_+_1_modules?`)},4103:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": function() { return /* binding */ FileExportWord; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(19632);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(5574);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);
// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js
var es_button = __webpack_require__(71577);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./src/components/CommonCard/Page/index.tsx + 1 modules
var Page = __webpack_require__(12690);
// EXTERNAL MODULE: ./node_modules/@umijs/babel-preset-umi/node_modules/@babel/runtime/helpers/objectSpread2.js
var objectSpread2 = __webpack_require__(97857);
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2);
// EXTERNAL MODULE: ./node_modules/@ant-design/plots/es/components/line/index.js + 693 modules
var line = __webpack_require__(45634);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(85893);
;// CONCATENATED MODULE: ./src/components/File/FileExportWord/components/chart.tsx





var DemoLine = function DemoLine(props, charts) {
  var _useState = (0,react.useState)([]),
    _useState2 = slicedToArray_default()(_useState, 2),
    data = _useState2[0],
    setData = _useState2[1];
  var ref = (0,react.useRef)(null);
  var asyncFetch = function asyncFetch() {
    fetch('https://gw.alipayobjects.com/os/bmw-prod/1d565782-dde4-4bb6-8946-ea6a38ccf184.json').then(function (response) {
      return response.json();
    }).then(function (json) {
      return setData(json);
    })["catch"](function (error) {
      console.log('fetch data failed', error);
    });
  };
  (0,react.useEffect)(function () {
    asyncFetch();
  }, []);
  (0,react.useImperativeHandle)(charts, function () {
    return {
      downloadImage: function downloadImage() {
        var _ref$current;
        return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.downloadImage();
      },
      getDataURL: function getDataURL() {
        var _ref$current2;
        return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.toDataURL();
      }
    };
  });
  var config = {
    data: data,
    padding: 'auto',
    xField: 'Date',
    yField: 'scales',
    xAxis: {
      // type: 'timeCat',
      tickCount: 5
    },
    smooth: true
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)("div", {
    ref: charts,
    children: /*#__PURE__*/(0,jsx_runtime.jsx)(line/* default */.Z, objectSpread2_default()(objectSpread2_default()({}, config), {}, {
      onReady: function onReady(plot) {
        ref.current = plot;
      }
    }))
  });
};
/* harmony default export */ var chart = (/*#__PURE__*/(0,react.forwardRef)(DemoLine));
// EXTERNAL MODULE: ./node_modules/antd/es/table/index.js + 91 modules
var es_table = __webpack_require__(50168);
;// CONCATENATED MODULE: ./src/components/File/FileExportWord/components/table.tsx



var columns = [{
  title: '\u59D3\u540D',
  dataIndex: 'name',
  key: 'name'
}, {
  title: '\u5E74\u9F84',
  dataIndex: 'age',
  key: 'age'
}, {
  title: '\u4F4F\u5740',
  dataIndex: 'address',
  key: 'address'
}];
var _dataTable = [{
  name: '\u80E1\u5F66\u658C',
  age: 32,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: '\u80E1\u5F66',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: '\u80E1',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'sss',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: '===',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'vvv',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'cc',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'ddd',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'fff',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'eee',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'ggg',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'aaa',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'kkk',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}, {
  name: 'lll',
  age: 42,
  address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
}];
var TableComponent = function TableComponent(props, table) {
  (0,react.useImperativeHandle)(table, function () {
    return {
      dataTable: function dataTable() {
        return _dataTable;
      }
    };
  });
  return /*#__PURE__*/(0,jsx_runtime.jsx)(es_table/* default */.Z, {
    ref: table,
    pagination: false,
    columns: columns,
    dataSource: _dataTable,
    scroll: {
      y: 500
    },
    bordered: true,
    rowKey: function rowKey(record) {
      return record.name;
    }
  });
};
/* harmony default export */ var components_table = (/*#__PURE__*/(0,react.forwardRef)(TableComponent));
;// CONCATENATED MODULE: ./src/components/File/FileExportWord/index.less?modules
// extracted by mini-css-extract-plugin
/* harmony default export */ var FileExportWordmodules = ({"container":"container___vd7BM","btn":"btn___yYKeI","word":"word___bUMzU","title":"title___y01Ph","content":"content___sKf38"});
// EXTERNAL MODULE: ./node_modules/docxtemplater/js/docxtemplater.js
var docxtemplater = __webpack_require__(14522);
var docxtemplater_default = /*#__PURE__*/__webpack_require__.n(docxtemplater);
// EXTERNAL MODULE: ./node_modules/file-saver/dist/FileSaver.min.js
var FileSaver_min = __webpack_require__(93162);
// EXTERNAL MODULE: ./node_modules/jszip-utils/lib/index.js
var lib = __webpack_require__(80925);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
// EXTERNAL MODULE: ./node_modules/pizzip/js/index.js
var js = __webpack_require__(51344);
var js_default = /*#__PURE__*/__webpack_require__.n(js);
;// CONCATENATED MODULE: ./src/components/File/FileExportWord/utils.ts




var path =  false ? 0 : "/Antd-CustomComponent/word.docx";

/**
 * description\uFF1A \u5BFC\u51FAecharts\u56FE\u7247\uFF0C\u683C\u5F0F\u8F6C\u6362
 */
function base64DataURLToArrayBuffer(dataURL) {
  var base64Regex = /^data:image\\/(png|jpg|svg|svg\\+xml);base64,/;
  if (!base64Regex.test(dataURL)) {
    return false;
  }
  var stringBase64 = dataURL.replace(base64Regex, '');
  var binaryString = window.atob(stringBase64);
  var len = binaryString.length;
  var bytes = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    var ascii = binaryString.charCodeAt(i);
    bytes[i] = ascii;
  }
  return bytes.buffer;
}
function exportWord(title, contentWord) {
  var ImageModule = __webpack_require__(78630);
  lib_default().getBinaryContent(path, function (error, content) {
    // input.docx\u662F\u6A21\u677F\u3002\u6211\u4EEC\u5728\u5BFC\u51FA\u7684\u65F6\u5019\uFF0C\u4F1A\u6839\u636E\u6B64\u6A21\u677F\u6765\u5BFC\u51FA\u5BF9\u5E94\u7684\u6570\u636E
    // \u629B\u51FA\u5F02\u5E38
    if (error) {
      throw error;
    }
    // \u56FE\u7247\u5904\u7406
    var opts = {};
    opts.centered = false;
    opts.getImage = function (chartId) {
      return base64DataURLToArrayBuffer(chartId);
    };
    opts.getSize = function () {
      //\u81EA\u5B9A\u4E49\u6307\u5B9A\u56FE\u50CF\u5927\u5C0F\uFF0C\u6B64\u5904\u53EF\u52A8\u6001\u8C03\u8BD5\u5404\u522B\u56FE\u7247\u7684\u5927\u5C0F
      return [600, 290];
    };
    var imageModule = new ImageModule(opts);
    // \u521B\u5EFA\u4E00\u4E2APizZip\u5B9E\u4F8B\uFF0C\u5185\u5BB9\u4E3A\u6A21\u677F\u7684\u5185\u5BB9
    var zip = new (js_default())(content);
    // \u521B\u5EFA\u5E76\u52A0\u8F7Ddocxtemplater\u5B9E\u4F8B\u5BF9\u8C61
    var doc = new (docxtemplater_default())();
    opts.centered = true; // \u56FE\u7247\u5C45\u4E2D\uFF0C\u5728word\u6A21\u677F\u4E2D\u5B9A\u4E49\u65B9\u5F0F\u4E3A{%image}
    opts.fileType = 'docx';
    doc.attachModule(imageModule);
    doc.loadZip(zip);
    // \u8BBE\u7F6E\u6A21\u677F\u53D8\u91CF\u7684\u503C
    doc.setData(contentWord);
    try {
      // \u7528\u6A21\u677F\u53D8\u91CF\u7684\u503C\u66FF\u6362\u6240\u6709\u6A21\u677F\u53D8\u91CF
      doc.render();
    } catch (error) {
      // \u629B\u51FA\u5F02\u5E38
      var e = {
        message: error.message,
        name: error.name,
        stack: error.stack,
        properties: error.properties
      };
      console.log(JSON.stringify({
        error: e
      }));
      throw error;
    }
    // \u751F\u6210\u4E00\u4E2A\u4EE3\u8868docxtemplater\u5BF9\u8C61\u7684zip\u6587\u4EF6\uFF08\u4E0D\u662F\u4E00\u4E2A\u771F\u5B9E\u7684\u6587\u4EF6\uFF0C\u800C\u662F\u5728\u5185\u5B58\u4E2D\u7684\u8868\u793A\uFF09
    var out = doc.getZip().generate({
      type: 'blob',
      mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    });
    // \u5C06\u76EE\u6807\u6587\u4EF6\u5BF9\u8C61\u4FDD\u5B58\u4E3A\u76EE\u6807\u7C7B\u578B\u7684\u6587\u4EF6\uFF0C\u5E76\u547D\u540D
    (0,FileSaver_min.saveAs)(out, title + '.docx');
  });
}
;// CONCATENATED MODULE: ./src/components/File/FileExportWord/index.tsx











var data = {
  p0: '8\u67083\u65E5\uFF0C\u4E2D\u56FD\u4EBA\u6C11\u89E3\u653E\u519B\u4E1C\u90E8\u6218\u533A\u5728\u53F0\u5C9B\u5468\u8FB9\u6D77\u7A7A\u57DF\u7EC4\u7EC7\u5B9E\u6218\u5316\u8054\u5408\u6F14\u8BAD\u3002',
  p1: '\u4ECA\u5929\u4E0A\u5348\uFF0C\u4E1C\u90E8\u6218\u533A\u7A7A\u519B\u51FA\u52A8\u9884\u8B66\u673A\u3001\u6B7C\u51FB\u673A\u3001\u8F70\u70B8\u673A\u7B49\u591A\u578B\u5148\u8FDB\u6218\u673A\uFF0C\u4ECE\u591A\u673A\u573A\u6218\u6597\u8D77\u98DE\u3001\u5230\u591A\u7A7A\u57DF\u6267\u884C\u4EFB\u52A1\uFF0C\u5F00\u5C55\u9884\u8B66\u6307\u6325\u3001\u5E72\u6270\u538B\u5236\u3001\u5175\u529B\u8FDB\u538B\u7B49\u3002\u4E1C\u90E8\u6218\u533A\u6D77\u519B\u5728\u53F0\u5C9B\u5468\u8FB9\u6D77\u57DF\u5F00\u5C55\u8054\u5408\u5C01\u63A7\u548C\u8054\u5408\u5BF9\u9646\u5BF9\u6D77\u6253\u51FB\u7B49\u591A\u8BFE\u76EE\u9488\u5BF9\u6027\u6F14\u7EC3',
  p2: '\u636E\u4E2D\u56FD\u53F0\u6E7E\u7F518\u67084\u65E5\u8BAF \u89E3\u653E\u519B\u4ECA\uFF084\u65E5\uFF09\u8D77\u5728\u53F0\u6E7E\u5468\u8FB9\u7A7A\u6D77\u57DF\u8FDB\u884C\u91CD\u8981\u519B\u4E8B\u6F14\u8BAD\u884C\u52A8\uFF0C\u5E76\u7EC4\u7EC7\u5B9E\u5F39\u5C04\u51FB\u3002\u636E\u53F0\u6E7E\u300A\u8054\u5408\u62A5\u300B\u62A5\u9053\uFF0C\u53F0\u519B\u56E0\u5E94\u60C5\u52BF\uFF0C\u6E05\u6668\u4E0B\u4EE4\u53F0\u519B\u201C\u4E09\u519B\u201D\u5730\u533A\u8F6E\u503C\u7684\u6218\u5907\u90E8\u961F\uFF0C\u5C06\u539F\u5175\u529B\u4E3A\u8FDE\u7EA7\u7684\u201C\u6218\u6597\u961F\u201D\uFF0C\u7ACB\u5373\u63D0\u5347\u4E3A\u8425\u7EA7\u7684\u201C\u7279\u9063\u961F\u201D\uFF0C\u5B9E\u65BD\u5907\u6218\u8B66\u6212\u3002',
  p3: '\u62A5\u9053\u79F0\uFF0C\u89E3\u653E\u519B\u5728\u53F0\u6D77\u5468\u8FB9\u90E8\u7F72\u516D\u4E2A\u64CD\u6F14\u533A\uFF0C\u5C9B\u5185\u7814\u5224\u53EF\u80FD\u6709\u4E1C\u98CE15\u7B49\u5BFC\u5F39\u81EA\u5927\u9646\u5185\u9646\u5347\u7A7A\u98DE\u8D8A\u53F0\u6E7E\u672C\u5C9B\u4E0A\u7A7A\uFF0C\u65B0\u7AF9\u4E50\u5C71\u57FA\u5730\u7684\u957F\u7A0B\u9884\u8B66\u96F7\u8FBE\u4E25\u5BC6\u76D1\u63A7\u5F53\u9762\u9AD8\u4E2D\u4F4E\u7A7A\u72B6\u51B5\uFF0C\u5E76\u4E0E\u4E24\u5EA7\u5C9B\u5185\u9884\u8B66\u4E2D\u5FC3\u8FDE\u7EBF\u3002',
  img: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA7oAAAMgCAYAAAAN+R5IAAAAAXNSR0IArs4c6QAAIABJREFUeF7s3Q+0W9dd4PvfvrqWrjNx4tCStM0/h9KE9kFj0+HRPzPEhgdtGR5x+kon+GaIMwykQ0jiYx25ZfHn2gPTSbhHV05KYIU/Kw5cmTYdGps3Cx5lIM48KARK69CZhpcAsVOHpqVtbCepret7td/ais71uVtHOudIR9KR9NVaXY2ls/999pGt39n/lPBCAAEEEEAAAQQQQAABBBBAYIwE1Bi1haYggAACCCCAAAIIIIAAAgggIKGBbqVSefPy8vL1uVzuH0+dOvW3+/btO9vOSmvdMVhWSul2aR988MF1r7zyyvUrKyvfmsvlPn/FFVf83Qc+8IGVqH4pl8vXisgWEfni6dOnP9upflF58TkCCCCAAAIIIIAAAggggMB4CawGqXNzc9MbNmx4UER2ishUsJlKqcP1ev0nS6XSV4LvVyqVTSsrK89GkHzadd13Ba+5//77L6rVar+rlPpBK21da/0bF1100Z233377ueBnJqD2PO8XlVI/Y9dPRP5ienr6pl27dn15vLqH1iCAAAIIIIAAAggggAACCCQVaAS6jzzySO655577exHZ5GeglPqG1vqCQIYvTk1NXb579+4z/nue582KyGJEoUdd1zWjr41XM6B+XkQuDaQzI8YzgT//leu63x3Mt1wuf1JrfVPgvSURyQfrOzMzc9kdd9zxclIErkcAAQQQQAABBBBAAAEEEBgfgUag63neHhG5t9msJ3K53Hscxzl5//33f/PS0tIhEXmn+UxrvVgqlf6d3/xyufxRrfVPi8jx6enpNYGpf83Zs2fPfvjDHz4VCI49ESk2//xXy8vLP2A+v+eee66anp7+tIhc3ixrtlQqHTT/vbCwcEO9Xj/STPNiLpd7l+M4T+3du/eCCy+88OMi8kPNzz7uuu7N49M9tAQBBBBAAAEEEEAAAQQQQCCpgB/ofl1ELhGRU8Vi8ZLgutrmCKyZsmw+f8F13dcHgta/FBET4P5X13V/JE7hnud9VUReIyIvX3XVVRuDa3Ln5+cvVUp9qTk1eXVUt1wuH9Ja32jyz+VybzFBbrAsz/PMCPEbRGSpWCzOdFoXHKeOXIMAAggggAACCCCAAAIIIDC6An6gazaAMuty513XNaO7a16e531CRN5v3nRdd3Vdr+d5J0XkYqVUsVgsLkQxLCwsXF6v10+Y65RSv1IsFu8MKetxEfkeEam7rpszn3ued1pENojIM67rmo2o7Pqtjkgrpd5RLBZNAM4LAQQQQAABBBBAAAEEEEBgAgXUAw88cOGZM2dearb9x1zX/Z2QQPIxEdlqRkxd1y2Yz+fm5vIbNmyomf+u1+v/KpfLvU5rbUZ3TdD818vLy38SnLJsrltYWHhPvV7/Q/PfWuvtpVLpcEhZ+0TkF8z7+Xz+0jvvvPOr5XK53rzugOu6t9lpyuXyFq31Z5vv3+667q9PYF/SZAQQQAABBBBAAAEEEEAAATOw2gw61Sc+8YmpsKN9PvKRj7wmn8+/ICLTwRHVcrn8Tq31nzcVzRrciy3RZa11qVQq7fff9zzvp0TkAfPnsCnI5v1yuXyL1roRbGut3z49Pf3cysrKPzXz+FnXdT9i91xzre4rzffvcV3X7MzMCwEEEEAAAQQQQAABBBBAYAIFOp6Bu7CwsL5erz8hIt/RDDx/tFQqfawZkO7WWpd9s+Yuzf8gIlc01/P6H+1yXfc+84f5+fmSUuqXm3ldZh9XZN73PO+9IvIHzWu+L5fLPVev158xf1ZKfbBYLJojkFpenuf55/V+1HXduyawL2kyAggggAACCCCAAAIIIICAP6IbJlGpVN68srLypyLyuubn/9113e/3r/U8z+x2/IHmn9dMF24eO/TbzXW/y/l8/g133XXXP5fLZVdrPW/SmGnJ5j277OD05qmpqfcuLy8/MzU1ZY4+Mq+205L9QFdr/WCpVPpgL7379NNPP6S1NucJ80IAAQQQQAABBBBAAAEEEOhN4NR11123sbcskqVuGdHVWquFhYX/YqYdNwNVk+Mni8Xi+4O7Ge/fv/+yer1+pYic3L17tx+IrpY+Pz//M0qpxjRjpdRtxWLxQHBEd2Vl5coPfehDjY2pgq/5+fkblVLmSCMzdXnNiK7W+u5SqXR/WBPTHNEl0E12E3E1AggggAACCCCAAAIIINBBYLiB7vz8/FuVUmbacOMsW7P5lIj8e9d1q0m7bW5ubmbDhg1nmukecF33p4NrdKempr599+7d/8vO1/O8W0XkQDPQtdfo/rzrur9kp7n33ns35HI5szOzebFGN2lncT0CCCCAAAIIIIAAAgggMEYCqyO68/Pz36uU+uPAKO4j+Xz+J+666y4/gEzcbM/zzplNrJRSnyoWi+8Orr8VkZ2u6z4cEuiazavubga6l7mua6Y8N3Zd1lr/XqlUahxzFHzNz89vVUqZnaE7ruNN3AASIIAAAggggAACCCCAAAIIjJxAI9Atl8vXaq2faga5Z+v1+o179uz5VLvWNI8W+ppSypy9u6dYLDZ2Ug6+KpXKxpWVlRebwef9xWLx7nvvvfeKXC73xeZ7v1EsFn/STud53qdF5B1tztH9R9d13xiS5udE5Beb+b6rWCyaPHghgAACCCCAAAIIIIAAAghMoEAj0PU87zMi8rbmVOXrXdf9uygLz/O+3txd+VixWPyW4Ppdk3Z+fv5XlVL/sRl8vr9YLP5esyw/3fLU1NRlu3fvNn9uvJpTp580/621/kypVPquZhpz3u4Pm/+u1+vvDgbhftAtIhea+heLxRm7LlFt4XMEEEAAAQQQQAABBBBAAIHxEVCVSmXTysrKs83g8temp6cbI6Nhr1wut+zvlFwul6ta6x3N645orf+tOS7okUceyR0/fnxOKfXzzc++6LruVX5+nud5IlJs/vmo1vqDpVLpiea05t8UkTc0P7vFXxu8sLBwQ71eP9J8/5RS6ieuvPLKT544ceIt9XrdbE61tfnZx13XvXl8uoeWIIAAAggggAACCCCAAAIIJBVQ8/PzP66UMgFmnNcp13Ub20I3N5s6LiKX+gmbZ+leEMhoqV6vv2PPnj2f9d+bm5ub3rBhw/PBdGagNrA22Fz6hOu6bw9WyPM8MyL8vsB7dpqX169f//o77rjj5TgN4RoEEEAAAQQQQAABBBBAAIHxFFCe5/2W2Vk5ZvNWA11z/T333HPx9PT0R0Vk1gpUTRD6Z/l8/v1hZ+U2d0le9KcjW8Hrr7300ku79u3btxyskzn2yPM8M1L8s2aDq+BnSqk/r9fr7zMjyjHbwWUIIIAAAggggAACCCCAAAJjKtByjm437TTTlZ9//vlr6/X6m5RSXwg7VzcsX5PuxIkT36a1fmOSdJ7nXa21fuvU1NSJ06dPf94OirtpA2kQQAABBBBAAAEEEEAAAQTGQyCVQHc8KGgFAggggAACCCCAAAIIIIDAOAgQ6I5DL9IGBBBAAAEEEEAAAQQQQACBVQECXW4GBBBAAAEEEEAAAQQQQACBsRIg0B2r7qQxCCCAAAIIIIAAAggggAACBLrcAwgggAACCCCAAAIIIIAAAmMlQKA7Vt1JYxBAAAEEEEAAAQQQQAABBAh0uQcQQAABBBBAAAEEEEAAAQTGSoBAd6y6k8YggAACCCCAAAIIIIAAAggQ6HIPIIAAAggggAACCCCAAAIIjJUAge5YdSeNQQABBBBAAAEEEEAAAQQQINDlHkAAAQQQQAABBBBAAAEEEBgrAQLdsepOGoMAAggggAACCCCAAAIIIECgyz2AAAIIIIAAAggggAACCCAwVgIEumPVnTQGAQQQQAABBBBAAAEEEECAQJd7AAEEEEAAAQQQQAABBBBAYKwECHTHqjtpDAIIIIAAAggggAACCCCAAIEu9wACCCCAAAIIIIAAAggggMBYCRDojlV30hgEEEAAAQQQQAABBBBAAAECXe4BBBBAAAEEEEAAAQQQQACBsRIg0B2r7qQxCCCAAAIIIIAAAggggAACBLrcAwgggAACCCCAAAIIIIAAAmMlQKA7Vt1JYxBAAAEEEEAAAQQQQAABBAh0uQcQQAABBBBAAAEEEEAAAQTGSoBAd6y6k8YggAACCCCAAAIIIIAAAggQ6HIPIIAAAggggAACCCCAAAIIjJUAge5YdSeNQQABBBBAAAEEEEAAAQQQINDlHkAAAQQQQAABBBBAAAEEEBgrAQLdsepOGoMAAggggAACCCCAAAIIIECgyz2AAAIIIIAAAggggAACCCAwVgIEumPVnTQGAQQQQAABBBBAAAEEEECAQJd7AAEEEEAAAQQQQAABBBBAYKwECHTHqjtpDAIIIIAAAggggAACCCCAAIEu9wACCCCAAAIIIIAAAggggMBYCRDojlV30hgEEEAAAQQQQAABBBBAAAECXe4BBBBAAAEEEEAAAQQQQACBsRIg0B2r7qQxCCCAAAIIIIAAAggggAACBLrcAwgggAACCCCAAAIIIIAAAmMlQKA7Vt1JYxBAAAEEEEAAAQQQQAABBAh0uQcQQAABBBBAAAEEEEAAAQTGSoBAd6y6k8YggAACCCCAAAIIIIAAAggQ6HIPIIAAAggggAACCCCAAAIIjJUAge5YdSeNQQABBBBAAAEEEEAAAQQQINDlHkAAAQQQQAABBBBAAAEEEBgrAQLdsepOGoMAAggggAACCCCAAAIIIECgyz2AAAIIIIAAAggggAACCCAwVgIEumPVnZPRmB0LtRtNSw/uLhyejBbTSgQQQAABBBBAAAEEEEgiQKCbRItrhy6wo1J7VIlsb1bkQNUp3Db0SlEBBBBAAAEEEEAAAQQQyJQAgW6muoPKdBLYUVnaqUQ/FLxGi7rtoJM/gBwCCCCAAAIIIIAAAggg4AsQ6HIvjIzAbKX2ORHZbFX4WNUpXDMyjaCiCCCAAAIIIIAAAggg0HcBAt2+E1NAGgI3V85sysnUs2F5KZGbFp3CoTTKIQ8EEEAAAQQQQAABBBAYfQEC3dHvw4loQdi0Zb/hWtR9B538romAoJEIIIAAAggggAACCCAQKUCgG0nEBVkQmK3UzDrcWwN1OSUiFzf/zPTlLHQSdUAAAQQQQAABBBBAICMCBLoZ6Qiq0VnAXp9rRnGV6Lv9VCtSv+ZjzvpjOCKAAAIIIIAAAggggAACBLrcAyMhMFup6WBFzbpcLfKo/x7rdEeiG6kkAggggAACCCCAAAIDESDQHQgzhfQiELIR1al1kt90TpZeDAS6+xadwt5eyiEtAggggAACCCCAAAIIjIcAge549ONYt+KWypmtWqYeOx/U6scXnZmtwVFeJa++N9YQNA4BBBBAAAEEEEAAAQRiCRDoxmLiomEK3FKp7dUic34d/F2WZyu1k4ENqY5WncKWYdaTshFAAAEEEEAAAQQQQCAbAgS62egHatFBYEdlaX9w4ykl0pimfEvl7BEt6gY/adUpcD9zJyGAAAIIIIAAAggggIAQGHATZF7ADmiV1LctOuuP2O+z83Lmu5IKIoAAAggggAACCCAwEAEC3YEwU0gvAvbRQn6ga5+t67/fS1mkRQABBBBAAAEEEEAAgdEXINAd/T4c+xbYRwv5U5RD1u7edtDJHxh7EBqIAAIIIIAAAggggAACHQUIdLlBMi0QdrRQ1SlsNJW2A11/7W6mG0TlEEAAAQQQQAABBBBAoO8CBLp9J6aAXgTaHS3UDHS3a5FH/fwJdHuRJi0CCCCAAAIIIIAAAuMjQKA7Pn05li3ZUVnaqUQ/FGjc4apT2P5qoBt+vu5YQtAoBBBAAAEEEEAAAQQQiC1AoBubiguHIdBpejKB7jB6hDIRQAABBBBAAAEEEMi+AIFu9vtooms4W6kdEpEbfQQtanXDKXv9rhL9+KIzs3WiwWg8AggggAACCCCAAAIIcI4u90C2BdqdoevXut2OzNluFbVDAAEEEEAAAQQQQACBfgowottPXfLuWcAOZNdJ/pIDjjpJoNszLRkggAACCCCAAAIIIDC2AgS6Y9u1o9+wnRW98ZwsvRhsiX+GLoHu6PcvLUAAAQQQQAABBBBAoF8CBLr9kiXfngXibDYVNbW550qQAQIIIIAAAggggAACCIycAIHuyHXZ5FS409FCvgKB7uTcD7QUAQQQQAABBBBAAIG4AgS6caW4buACnY4WItAdeHdQIAIIIIAAAggggAACIyNAoDsyXTV5Fe10tJCvMVupHRCRW/0/B48fmjwxWowAAggggAACCCCAAAJGgECX+yCzAnGmJccZ9c1sA6kYAggggAACCCCAAAII9EWAQLcvrGSahkDU0UKmDALdNKTJAwEEEEAAAQQQQACB8RIg0B2v/hyb1txcObMpJ1PPBhtkHy1EoDs23U1DEEAAAQQQQAABBBBIVYBAN1VOMktLIM7RQs1Ad7sWeTRQ7uGqU9ieVj3IBwEEEEAAAQQQQAABBEZPgEB39PpsImpsT0nWou476OR32Y2PGxBPBBqNRAABBBBAAAEEEEAAgYYAgS43QiYF7N2URbRTdWb2E+hmsruoFAIIIIAAAggggAACmRIg0M1Ud1AZXyDOjsvmWkZ0uWcQQAABBBBAAAEEEEDAFiDQ5Z7IpECcHZdNxXdW9MZzsvRisBFhm1ZlspFUCgEEEEAAAQQQQAABBPoiQKDbF1Yy7UUgZMflU1WnsLFdnnZQTKDbiz5pEUAAAQQQQAABBBAYfQEC3dHvw7FrQdLpyAS6Y3cL0CAEEEAAAQQQQAABBHoSINDtiY/E/RCIu+OyXzaBbj96gTwRQAABBBBAAAEEEBhdAQLd0e27sa35bKV2SERuPN/A8B2X/c/jblw1tmA0DAEEEEAAAQQQQAABBNYIEOhyQ2ROYLZSe1ZENvkVU1LftuisP9KuogS6metCKoQAAggggAACCCCAwFAFCHSHyk/htkA3uygT6HIfIYAAAggggAACCCCAQFCAQJf7IVMC9kZUIvJk1Sls7lRJAt1MdSGVQQABBBBAAAEEEEBg6AIEukPvAioQFEi6EZVJu6OytF+Jvvt8Pp3X9CKOAAIIIIAAAggggAAC4y1AoDve/TtyrbNHZ7Wo2w46+QOdR3Rre7XInH+NEtm36BT2jlzjqTACCCCAAAIIIIAAAgikIkCgmwojmaQlMFupvSgiG/38tKgtB538UQLdtITJBwEEEEAAAQQQQACB8Rcg0B3/Ph6ZFt5cObMpJ1Nmx2X/darqFFaD3nYNsac7M6I7Ml1ORRFAAAEEEEAAAQQQ6IsAgW5fWMm0G4EdlaWdSvRDflol+vFFZ2ZrVF52OhF5uOoUdkal43MEEEAAAQQQQAABBBAYTwEC3fHs15Fs1WylZtbi3no+0I231tbeqTlugDySSFQaAQQQQAABBBBAAAEEIgUIdCOJuGBQAvb6XCX1bYvO+iNR5RPoRgnxOQIIIIAAAggggAACkyVAoDtZ/Z3Z1u6oLG1Woj8XqGCs9bnmegLdzHYrFUMAAQQQQAABBBBAYCgCBLpDYadQW2C2cnaXiKoE3j9cdQrb40iFBMlHq05hS5y0XIMAAggggAACCCCAAALjJ0CgO359OpIt6ub83GBDZys1Hfxz1Slwb4/knUClEUAAAQQQQAABBBDoXYBgoHdDcuhRIGREVlakfs3HnPXH4mZNoBtXiusQQAABBBBAAAEEEBh/AQLd8e/jTLdwZ0VvPCdLZm3upkBFn6w6hc1JKk6gm0SLaxFAAAEEEEAAAQQQGG8BAt3x7t9Mt665iZQ5NzcY5IoWddtBJ2+OGor9ItCNTcWFCCCAAAIIIIAAAgiMvQCB7th3cfYa+Ooo7rk5Eb0rpHYPV53CzqS1ttf4xj2aKGk5XI8AAggggAACCCCAAALZFyDQzX4fjVUN243imkYq0Y9PS2H7AUedTNpoAt2kYlyPAAIIIIAAAggggMD4ChDojm/fZq5ls5WamabcbrS2q5Fcv5EEupnrbiqEAAIIIIAAAggggMDQBAh0h0Y/WQXvqNQeVSJh5+IeVyK7Fp3CoV5ECHR70SMtAggggAACCCCAAALjJUCgO179mcnW7Kgs7Vei77Yrp0Xdl5d1e7uZqmznZZehRPYtOoW9mQShUggggAACCCCAAAIIINBXAQLdvvKSeXNN7mOWxHEl9Z2LzvojaQndUqnt1SJzfn4EumnJkg8CCCCAAAIIIIAAAqMnQKA7en02UjWerdTMMUG3Bip9ap3kN6UxihuEINAdqduCyiKAAAIIIIAAAggg0FcBAt2+8pK5fb6tErmp1/W4YaoEutxrCCCAAAIIIIAAAggg4AsQ6HIv9E0gZNry8apT2NSPAm+p1LZrkUfP39j68UVnZms/yiJPBBBAAAEEEEAAAQQQyLYAgW62+2ekazdbObtLRFUCjThcdQphOy/33E47qDZn8hLo9sxKBggggAACCCCAAAIIjKQAge5IdttoVNpen9vPDaIIdEfjnqCWCCCAAAIIIIAAAggMQoBAdxDKE1rGbKX2ORHZ7DdfSX1bmjstB1kJdCf0JqPZCCCAAAIIIIAAAgiECBDoclv0TcDeiGqd5C9Je7flYOXt8qpOgfu7b71LxggggAACCCCAAAIIZFeAQCC7fTPSNdtRWdqsRJsRXf/Vt42o/AIIdEf6lqHyCCCAAAIIIIAAAgikJkCgmxolGQUFhrELMoEu9yACCCCAAAIIIIAAAggYAQJd7oO+CAzjXNvZSu2kiFzsN6jfU6X7AkemCCCAAAIIIIAAAggg0LMAgW7PhGQQJjBbqR0SkRv9z7So2w46+QP91LqlcvaIFnWDX0Y/N7/qZzvIGwEEEEAAAQQQQAABBHoTINDtzY/UbQSGEXQOo0xuAAQQQAABBBBAAAEEEMieAIFu9vpkLGo06B2XDRqB7ljcOjQCAQQQQAABBBBAAIGeBQh0eyYkA1tgZ0VvPCdLLwbfH8RRP7OVmpkafev5crVTdWb200MIIIAAAggggAACCCAwWQIEupPV3wNp7S2VM1u1TD3mF6ZEP77ozGztd+HD2ACr320ifwQQQAABBBBAAAEEEEguQKCb3IwUEQLDOFrIVIlAl1sTAQQQQAABBBBAAAEEjACBLvdB6gLDCjhnK2d3iaiK3yAt6r6DTn5X6g0kQwQQQAABBBBAAAEEEMi0AIFuprtnNCu3o7K0X4m+26+9Etm36BT29rs1w5oy3e92kT8CCCCAAAIIIIAAAggkEyDQTebF1TEEhrX7MYFujM7hEgQQQAABBBBAAAEEJkCAQHcCOnnQTZyt1D4nIpvPj+jWty0664/0ux4Euv0WJn8EEEAAAQQQQAABBEZDgEB3NPpppGppn6E7iKOFDNCwjjUaqc6hsggggAACCCCAAAIITIAAge4EdPKgmzisQNe0c5hlD9qZ8hBAAAEEEEAAAQQQQCBcgECXOyNVgR2Vpc1KtJm67L+OV53CplQL6ZAZge6gpCkHAQQQQAABBBBAAIHsCoQGupVK5c3Ly8vX53K5fzx16tTf7tu372xUEyqVyuuXl5f/91wuV1NK/aXjOCej0jz44IPrXnnlletXVla+NZfLff6KK674uw984AMrUenK5fK1IrJFRL54+vTpz8apX1SefJ6OwLDXyc5WakdF5Hq/NVrUloNO3rzHCwEEEEAAAQQQQAABBCZEYDXQnZubm96wYcODZqmjiEwF26+UOlyv13+yVCp9xXbxPG+7iPyOiFxoffaC1np7qVR6wk5z//33X1Sr1X5XKfWD1md1rfVvXHTRRXfefvvt54Kfaa2V53m/qJT6Gbt+IvIX09PTN+3atevLE9JvmW3mLZXadi3yqF9BJfrxRWdm66AqPKwdnwfVPspBAAEEEEAAAQQQQACBaIFGoPvII4/knnvuub8XkdUppkqpb2itLwhk8eLU1NTlu3fvPuO/Nz8//+NKqd8MXLPcDEJXA2Wt9duDwW4zoH5eRC4NpDMjxjOBP/+V67rfHax+uVz+pNb6psB7SyKSXw2olPrGzMzMZXfcccfL0c3min4J3FKp7dUic+cD3cGcoeuXR6Dbr54lXwQQQAABBBBAAAEERkegEeh6nrdHRO5tVvuJXC73HjP1+P777//mpaWlQyLyTvOZ1nqxVCr9O/PfDzzwwIVnzpz5WjPYrCulbi4Wi58wQfPx48d3K6V+uZnfC67rvt4n8TzPE5Fi889/tby8/AMf/vCHT91zzz1XTU9Pf1pELm+WNVsqlQ6a/15YWLihXq/7x9O8mMvl3uU4zlN79+694MILL/y4iPxQM7+Pu6578+jwj19Nhx3ozlZqB0Tk1vOy2qk6M/vHT5oWIYAAAggggAACCCCAQDsBP9D9uohcIiKnisXiJUop7SdojsCaKcvm89WgNTiaq7XeUyqV5oOFeJ5ngtQfNe/V6/Ute/bsaayT9DzvqyLyGhF5+aqrrtoYXJM7Pz9/qVLqS81R4dVR3XK5fEhrfaNJn8vl3mKCXKssM0L8BhFZKhaLM8H60/WDFZit1MyDkUZfNR5YiLrtoJM3wedAXsMOtAfSSApBAAEEEEAAAQQQQACBjgJ+oGs2gDLTjedd1zWju2tenud9QkTeb950XbeRZn5+/g+VUu8xceyGDRtm7DW1v/zLv/ymqampp821Sql7i8XihxcWFi6v1+snmu/9SrFYvDOkrMdF5HtMvq7r5sznnuedFpENIvKM67pmIyq7fqsj0kqpdxSLxb+k34cjMOypwwS6w+l3SkUAAQQQQAABBBBAIEsCqjkF+aVmpX7MdV2zsZQdSD4mImZDoSXXdQvN4PMZEflWETnuum7o8TGe55kNpaZF5L+5rvt/LiwsvKder/+hSd/cqOpwSFn7ROQXzPv5fP7SO++886vlcrnevO6A67q32WnK5fIWrfVnm+/f7rrur2cJeZLqkoFAd81mWCJyuOoUzIZpvBBAAAEEEEAAAQQQQGDgAAAnAAAgAElEQVRCBBqjs2ZH40984hNTYUf7fOQjH3lNPp9/oRmwro6oep5njg+6WEQ+7bruu8K8PM8zuyCbTaeOuq67xfO8nzLLe821YVOQzfvlcvkWrXUj2DYbWU1PTz+3srLyT838f9Z13Y/YZTXX6r7SfP8e13XNzsy8hiBgn2O7TvKXHHBU5FFTaVV12McbpdUO8kEAAQQQQAABBBBAAIHuBULP0fWzW1hYWF+v183xQN/RDDx/tFQqfawZkL5idmXWWv9BqVT6N20C3X8QkW8Rkf/Pdd1vm5+fL/mbVGmtL2tzXNF7ReQPmuV9Xy6Xe65er5vRYzMF+oPFYtEcgdTy8jzPX1f8Udd17+qehJS9CNiBbtUpdLzHeikrLO2oBLo3V85sysnUnNL66OLumfvSdiA/BBBAAAEEEEAAAQQmWaBtEFKpVN68srLypyLyuibQf3dd9/t9rHK53Ah0lVKfKhaL724TfPrTm//edd03lctlV2vd2LTKTEu+6667/tlOF5zePDU19d7l5eVnpqamzNFH5tV2WrIf6GqtHyyVSh/spVOfeuqpn/TTf+0b0xd86guv/d6vvrLuussvXjr6vs1f/pNe8h73tL/0/3zLmgcRP/eef7x9kG02/fVr/+OqSrDMQdchqr2mjr/16St+bml5ymzKJq+7eOnT/+EdJx6OSsfnCCCAAAIIIIAAAgiMqsCb3/zmgS4vbQl0zTTmhYWF/6K1LjU3qDKWnywWi+8P7mbsB7oi8seu6/5Am0D3mIhcHTaiu7KycuWHPvShxsZUwdf8/PyNSimzc6+ZurxmRFdrfXepVLq/TVmpjeg+/fTTD2mtd5pyHn9mY+N//uuubSdk43pzXDAvW+DY12bkt5/wn4uIXP1NZ+XWt5tZ74N9/ac/WLtk/Bd+0NyG2Xk9cewi+aMvfNOaCv3Yd78gm15jjpPmhQACCCCAAAIIIIDA2Amcuu66684HVQNo3ppAd35+/q1KKTNtuHGWrdl8SkT+veu6VbsugTW6f+G6buOcXfs1Pz//FaXUN4et0Z2amvr23bt3/6+QfM0ZqI3jaELW6P6867q/ZKe59957N+RyObMzs3n1vEb36aefXh2VPPzka9529MSFb/PL3HzFy39z4/Vf+5sB9M3IFfG3z/+LNzx69LX+mcbyzRee+9JP3fBP//egG/Kf//Cqnct1lffLvf1ff+l3X3fRkr/h2qCr01LefX96+f918sx0YzTXf12+sXbsP7zrhU8NvXJUAAEEEEAAAQQQQACBPghce+21A53puRrozs/Pf69S6o8Do7iP5PP5n7jrrrv8AHJNcz3Pa6y/1Vr/c6lUMhtOtbw8z2scW+Sv4/U8b3X9rYjsdF23Zbqm53n7ReRuk5lZx+u67j/7uy5rrX+vVCo1jjkKvubn57cqpczO0B3X8XbTX7OVs7tEVHAqLLv4toHMyvrYYe/83Ok+21nRG8/J0oth1wx6465uvg+kQQABBBBAAAEEEEBgFAQagW65XL5Wa/1UM8g9W6/Xb9yzZ0/H0aVyufxHWuvGlOWXXnqpsG/fPjP6u/paWFj43+r1+v9svtE4n/fee++9IpfLfbEZkP5GsVhcXQvrJ/Q879Mi8o425+j+o+u6b7RhPc/7ORH5xWa+7yoWiyaPVF47KkublejPBTI7VnUK16SS+ZhlYj8U0KLuO+jkdw26mVkOdO2HAUEbJXLTolNoTNvnhQACCCCAAAIIIIAAAt0LNAJdz/M+IyJmeq4JVq93XffvorKcn5//caXUbzaDy18pFot3BtN4nve4iHxP8/PvLBaLjWDR87yvi8glIrI8NTV12e7du82fG6/m1OknzX9rrT9TKpW+q5nGnLf7w+a/6/X6u4NB+NzcXH7Dhg1fE5ELTf2LxeJMcC1xVDvifG7vJLwi9Ws+5qzP1sLPOA3p8zW3VGp7tcicX4wS2bfoFPb2udiW7HdUlvYr0Y1ZAY37b0j1CGu3bRS8ZlgPBgbdP5SHAAIIIIAAAggggEC/BVSlUtm0srLybDO4/LXp6enGyGjYK5fLLfs7JT/wwAMXnjlzxgSYZi1kXUTclZWV3ywUChcsLy+bjayKzTxecF339X5+nud5gc+Oaq0/WCqVnmhOazaB8xua197irw1eWFi4oV6vH2m+f0op9RNXXnnlJ0+cOPGWer1uNqfa2vzs467r3pw2WusIISNvcYK4YQWYWQm4w4xmKzWz/tysQ295KdGPLzoz/r2c9m1MfggggAACCCCAAAIITIyACo7Mxmj1Kdd1V3fLipPWbChlAlk/77m5uekNGzY8LyLBdb0mUJ4KlP+E67pvD9bH87zfE5H3Bd6z07y8fv36199xxx0vx2hHokvswImRt3C+1iBOO1Vnxqy5HuhrR2VppxL9UKDQzKyrbn1ooh/Xom7w6zroc4cH2jEUhgACCCCAAAIIIIDAgASU53m/ZXZWjlnemkDXpCmXyz+stf5tEbnYyuP5qamp7bt37zbTote8mrskL/rTka3g9ddeeumlXfv27Vtzho859sjzvDml1M+KyHQwQ6XUn9fr9feVSqWvxGxHostuqdS2a5FH/USMvIXzZWVtbFY2xQpTmq3UzBT+zcEgXERu9P+sRW056OSPJrpBuRgBBBBAAAEEEEAAAQTWCLSco9utz8LCwjctLy//y+np6VqhUPibOCOrjzzySO7EiRPfprV+o1LqC7t37/77OOV7nne11vqtU1NTJ06fPv15OyiOk0eSa26unNmUk6nG9G7/xchbq2BWAt0sbyBmr/fWom4Ljj4rqW9bdNb70/ST3KZciwACCCCAAAIIIIAAAk2B1ALdcRedrdTM5lNX++1k5C27ga6pmR1QZuXBhF0vE9hqmWocjWVew1rXPO7fX9qHAAIIIIAAAgggMFkCBLox+3u2UjPHvqxOMRUZzvrTmNUdymWzlZo5H3Z1Dfcwd6e2A8osnFEbMtL8pJL6LgLdodyuFIoAAggggAACCCAwxgIEujE71z4jVkQerjqFnTGTT8RlWRpFzco06mDHh60drsvUruA5zaz/noivCo1EAAEEEEAAAQQQ6LMAgW5MYDtIEZFjVadwTczkE3EZgW7nbm63SVbQjUB3Ir4qNBIBBBBAAAEEEECgzwIEugmAszgdNkH1+35plgLdHZWl/Ur03X6js7D2td35vpbbyapTuKTvnUUBCCCAAAIIIIAAAgiMsQCBboLOna3UzLEv1weCp5sWnYJZuzvxr5AR7yerTiF4jM5AjdoFlQOthFVYzEBXsrJx1jCtKBsBBBBAAAEEEEAAgV4ECHQT6GVxlDBB9WNdas4MrovcqkQ2aVH3HXTyB+IkzNrZtVlcU93u/rEfoBDoxrnjuAYBBBBAAAEEEEAAgfYCBLoJ7o4dlaWda8881Y8vOjNbE2SR6UtDdgUWc85rnGA3a4Fu1upjOr7dBln2+xxdlemvCZVDAAEEEEAAAQQQGAEBAt0EnXRz5cymnEw9G0wyTqNvs5WaadsmmyTOMUFZCyyzVp8kga45W3fRWX8kwa3JpQgggAACCCCAAAIIIBAQINBNeDvMVmonReRiP9m4jL7Zo9UWS+RRSllbE7uzojeekyVzru/qa9gPJWYrtc+JyOq6ZT+gtc9oJtBN+KXkcgQQQAABBBBAAAEELAEC3YS3hB2UiGin6szsT5hN5i6frSw9JqL9adjHRcRsvHWjX9GoUd2sBbqm3lnaBbpTfWy7uNPFM3cTUSEEEEAAAQQQQAABBDIiQKCbsCPsoEREIkc7ExYx8MtDpmQ/rEUdWbseWfYtOoW97SqX0UB3zej7OslfcsBR5r2hvNoF3lm0GwoQhSKAAAIIIIAAAgggkJIAgW5CyJBjdI5VncI1CbPJ1OX2tGUzoliXlSPWeuSO7czijtTtNn8aBn6nqdQEusPoEcpEAAEEEEAAAQQQGGcBAt0uetcemRv2SOGOhdqNStTGdWrd4W5GLGcrNXOE0K0+RWDt6JpzgzutR85SUOm3I0t16rQ5FoFuF19CkiCAAAIIIIAAAggg0EGAQLeL28M+91SJ3LToFA51kVVPSZqjhI8FNjg6qUVtO+jkTYAa+2Xvtuxv2mSP0jbP1d0VlnGWgkq/fnYAP8y1r50D3TNbtUyZfvRfh6tOYXvsDuRCBBBAAAEEEEAAAQQQWCNAoNvFDZGVabptjgM6uU7y1yQZ2bVGqI9XnULjiKEk07SzGOhmaaT0lkptuxZ51L/dlJw/gzmLRyF18bUgCQIIIIAAAggggAACmREg0O2iK+w1rcGgpYvsukoSsinWaj5KOm8cFSwwKsiyj1Nqt/uyHXRH7dLcVaMTJspYoLtXi8ydD3TP91FUHyRsNpcjgAACCCCAAAIIIDDxAgS6XdwCIbsUyyDPaG1OWX5WRDYGqv+kiFzf/PPJqlO4JE7TZitnd4moin+tPT057nFKWTvKx7THHkUVkaFNCe4UdBPoxrlTuQYBBBBAAAEEEEAAgfgCBLrxrdZcaY90dtqoqcsi2iazR5TNEUci+mgwYI27brh1ZHjtucB2INwuWMxmoLt27eswRt79Toya7m75xX5Qkfa9RX4IIIAAAggggAACCIyDAIFul70Yd6Szy+w7Jput1D4X2IBKTFBbF3VMiTbv+69Y5/tGra2NM3odcnTOqapTCI4294MhMs8sjZRGOWfxQUEkMBcggAACCCCAAAIIIJBRAQLdLjsmZKQzVmDZZXGryUICz9WgsptRwThra2crtWMicrVfCXu0OEsBZdC309m1vfZD0vQEuknFuB4BBBBAAAEEEEAAge4FCHS7tEuyI3GXRYQm6xRg28FUnOnUcUYSo44ZymqgawDjtC/N/mmXl/1Awe6brNRzEBaUgQACCCCAAAIIIIBAvwUIdHsQtoOTQew0HBLM3nbQyR8wzbADUpG1623tpu6oLG22pjuvHi0UvDZkU6ejVaewxb8m5POBjG7H6Tq7j9ZJ/pIkRy/FKSPONVGBrD1qPoh7KU69uQYBBBBAAAEEEEAAgVEUINDtoddap6PKTYtO4VAPWUYm7RRch21SVXUKO9tlGnckNmwKcDAQy9IxPnZbo6YMR4KndEFUoJuVeqbUXLJBAAEEEEAAAQQQQGCoAgS6PfBHTentIevQpCHTpdeMwIaM0K4ZebUzjTpaKHh9p5FkAt3OPR1n5JxAN+1vC/khgAACCCCAAAIITLIAgW4PvW9P2e338TV2QGmfeWuaEjVyuDZ4re3VInP+e0pk36JT2BtG0noM0fkzaWcrNTN1+tbz+dS3LTrrj/RAm1pSe3fsuMcupVaBxnm+0cccEeimKU5eCCCAAAIIIIAAApMuQKDbwx0w6F1940yVThIwxcnP5wkZlVw96zVJmT1wd5U0C6PNBLpddR2JEEAAAQQQQAABBBDoWoBAt2u6VxO2Hr3Tv9HMOJtf2aOrnTakShqgzlZqJ0XkYp/M3znYPte36hQyc19lI9BdO3IeNhKfhXr2+FUgOQIIIIAAAggggAACmRHITECSGZGEFWmdttt++m/CrNdcHrU+1784zvRm/9qkOxLbbfUDNiufJ6tOYXMvbU0z7bDOOw62IU4QG+eaNF3ICwEEEEAAAQQQQACBcRYg0O2xd+2djvu1TjdkjWzoET5xpsm2C3SjRmJDdnU+uk7y287J0osBxsNVp7C9R9bUkifxSK1QK6OQBwSrR0K1e0DRab10v+pJvggggAACCCCAAAIIjIsAgW6PPXlz5cymnEw9G8hmde1qj1mvSd5p1+PghXHXDYeMEEeOxIblrUXdpkQ/5NchawFaFgLdOFPEGdFN89tCXggggAACCCCAAAKTLkCgm8Id0G7tagpZr2YRZ32uf7Fdn+CZt/413e4Ybe9iLCLHRGSTn6+/bjfNtveS16AeRHSqo72GWUnrOu4kRz314kFaBBBAAAEEEEAAAQQmQYBAN4Vebg3+tFN1ZvankHUji7jrc88HsWePaFE3+H8OO1Kn2xHEkOnLwWauOdc3rfb3mk+SI5d6LSssfZzyszDy3I+2kycCCCCAAAIIIIAAAsMQINBNQT1kw6NU16kmzX9HZWm/En13INBtOR83zjVhNM3py2YUd3X35fPXpRvgp9A1jSySbrqVVrl+PgS6aYuSHwIIIIAAAggggAACnQUIdFO4Q0LOmD1WdQrXpJC1H6gdEpEb4waUcQLjOOtG29U/ZGMsc+mpdZLfdMBR5giiTL1mK7WjInL9+cC/f0dA2Q2PuxaaEd1M3TJUBgEEEEAAAQQQQGDEBQh0U+rAJGtokxY5W6mZXY03+umi1sGGBFdHq05hS7DcOOtGO9VzmMFjUr9egvqkZUUFuu125SbQ7VWa9AgggAACCCCAAAIInBcg0E3pboi7K3LS4kJGi09VncJq0Nsuv6jpslGfR9XTTGFelqVddVEb67Ky/2POejOdOZOvfq+h7vxA4OwuEVXxr2m3K3UWNs3KZOdRKQQQQAABBBBAAAEEuhAg0O0CLSyJPZ1Xi7rvoJPf1Wv2caYhh5UxW6mZwPNq/7PgKHDIMUGxgude2zKs9N1uvJVGfZOU3evDhzTqSx4IIIAAAggggAACCIyDAIFuSr0YZ7pwN0V1OxrZOl1Xblp0Cmatb8suzu2m03ZT3yym6ddDiDhttfsv7GghPx8C3TiiXIMAAggggAACCCCAQLQAgW60UawrQkZJpeoUevZNuj7Xr2ynkcSQI4IerjqFnbEaOoIXdXtmcBpNtR84hJ1pTKCbhjR5IIAAAu0FZheWbhUlm7XIwwedvNmgkBcCCCCAwJgL9ByIjblPoubZ04U7jd7FyThklDj2FGM7uBOR1SOPkkynjVPPrF8zzI2ekozSJrk26+bUDwEEEMiKQMhxeqsznLJSR+qBAAIIIJC+AIFuiqbdTjNuV4WQY3xij7x2OvJotlI7ICK3+uUqOT+tOUWOzGQVYnGy6hQu6XcF7VH+qCniw9wdut8W5I8AAggMQyBkoz9TjZMrUt+S5U0Uh2FFmQgggMC4CRDoptijvQSmYdWwjwDSom476ORNkBrr1W6EMGSH6C3jPpWrl9HSxg7TunZrXamtSuSkEjnsr3fu1BEhI/IdH1QQ6Ma6rbkIAQQQiC3Q+gB69RHvkaqT3xY7Iy5EAAEEEBg5AQLdFLsszQ2pwtb8dlrfGdaMdoGTve43jbXEKTL2JavZSu2kiFzsZx51FrF/XXM0+FER2bS2YuqIFnE6PSCwd8yOelBBoNuXridTBBCYYAHrIeep4L8DvS4vmmBWmo4AAgiMhACBbordlOaGVCEbRj1ZdQqbk1TXXpfkB1rWP/yJ801Sh6xc200Q2Zzy9jkRaXtusRbZe9Ap7AtrZ4h/x5HzbuqYFV/qgQACCGRNoHUjQtmnReYC9Yy9HChrbaM+CCCAAALRAgS60UaJruh0fm2SjFqPpZF9i05hb5I8wv6RF6kf0TL12KT9Qx8yXTtyGrg9dby9vTqyTtbddMBRZtR49WWlj9xILKTP2TAlyQ3PtQgggEBAwHrY+OQ6yW89J0svBpGSzpQCGAEEEEBgdAQIdFPuq24CqrAq2GtK4061DeZlb8JhNkOqy9QBJfoh/7qo6bQp8wwtu6Q7TYeMqIsSaYzcWiMCfpuONi1Xj62w+jBy5CBpHYeGScEIIIDACAjMVmrP+stO/M0A03iIPAJNp4oIIIAAAiLmtzuvNAXSCFZCjgY6XnUK1hrReLWerdRM4HV98+pjSuThYKA2KU+zk2wU1pyCbn4grU5Z1qLuO+jkdxnH5rpdsymY7+p3xkktaptZt2v3YZwHCmncO/HuCq5CAAEExl8g+LDRPKg0s6JCHmIeqzqFa8ZfgxYigAACkydAoJtyn7dOF9aPLzozW5MUYx//EwyykuRjrg0J8Ezg66/17TqATlqPYV+f5CzdkB9Cp9ZJflNwanIzGDbB7o1220xQK6JvVCLbm59FTlsO6yv/h9mw7SgfAQQQGDWB1r/zzy//6XZzwlEzoL4IIIDApAsQ6KZ8B3Q6vzZuUcHpViZNLztDtjlDsFGVOKOMceuc9euSnKXb6t9+fbT9UKKNQ+S0ZQLdrN9B1A8BBEZJwH5gGTwvPuQs+cR7YIySBXVFAAEEJlWAQLcPPW+vr10n+UvsjYraFRsSkMUaDezUjDbBWMsoZR8oMpVlnLN0Q/wlanq3fYyQ1ejYzklGnTMFS2UQQACBjAm0LgWpb1t01h9pPlTcrkXMsXH+62jVKWzJWBOoDgIIIIBAjwIEuj0ChiW31sUmGpENCZoOV52CPwW2q9o2p9keW3t+oEzcjr5xdsQOeSgQy785Zd1MZV49q9d0VpJRcwLdrm5vEiGAAAItAvamU8ENHdM4px5yBBBAAIHsCxDo9qGPWoMl7VSdmf1xirJ3bRaJn7ZT/s2RSrOZ0kYlcmDRKRyKU59xuibO8T2zlZo5emJ1E6rgdLcoi+Y0cdPPzXW7yfqOQDdKmM8RQACBeAL2v6VVp7Dm947970Fa/9bGqx1XIYAAAggMQoBAtw/K9pSpJJtJ2dNro6bN9qH6Y5tl1K7GIbtd9zxtPAkmgW4SLa5FAAEE2gtELVXpx+wp+gMBBBBAIFsCBLp96I9uAxY7nYhMzK7IfeiGlixDfNdMSw6ZthxrE6m06h4yne5k1Slcklb+5IMAAghMioAV6Lb8W5pkg8JJMaOdCCCAwLgJEOj2oUdDdjqOFbAkOeu1D9Ue+yxDAsk1G5D0Mm05LbyoUYi0yiEfBBBAYFwF7CBWSfgxfxwzNK53AO1CAAEEXhUg0O3TndDNFGR7TVGSjYz61Iyxy9bekMpftzXsacs+NIHu2N1yNAgBBAYsEHdWFet0B9wxFIcAAggMWIBAt0/gdtAa5yzcboLjPlV/bLNtPT/x1SMnhj1tmUB3bG85GoYAAgMWsB9cttsng3W6A+4YikMAAQQGLECg2yfwHZWl/Ur03X72SqTjgfQhI4qsz+1D39jOfr+0Tls+f+ZiH6rRNstejqYaZD0pCwEEEMiqQNTGg369Waeb1R6kXggggEA6AgS66Ti25BLypLjjxkZ2YJxkp+Y+NWFss7XWZR01wa4WeTTQ4KE9ZOhmJsDYdhQNQwABBLoQiBvomqxZp9sFMEkQQACBEREg0O1TR4Xs8Ltm4yO72NlK7XMistl/P8n5rX1qwthm2zpNWR0R0Vv9Bg/zIQOB7tjedjQMAQQGJBAyo+qmdmfHs053QJ1CMQgggMAQBAh0+4ged2OhkN2AZZ3kLzngqJN9rN7EZh3yEGKNxTDPLibQndjbkoYjgEBKAkn+HmWdbkroZIMAAghkUIBAt4+dYu/w225DqpD1uU9WncLq6G4fqzixWbc+xV+lGOjZuXYHJJlyN7GdR8MRQACBDgJJAl3W6XIrIYAAAuMrQKDbx76NOyWK9bl97IQ2WTdH0Y+JyMWBS06tSH3zx5z15v2hvAh0h8Ke6UJ3VJZ2KtFzIrJRi+w/6BT2ZbrCVA6BIQvMVmrPisgmvxpRs3RYpzvkDqN4BBBAoE8CBLp9gjXZ2kGLiISOFrI+t4+d0CHr5pP8QyJytbksC+cWE+gO517IaqnNIPehYP2ycJ9m1Yt6jY/AjoXajaLMvhXq8EEnfzRJy+IuG/Lz5Az7JLpciwACCIyOAIFuH/sqzoZUN1fObMrJlHn6vPpifW4fOyUka9NPyyLHhjmS61fLXi82zI2xBtsLlGYLdFhLfnKd5K9hDT/3zDgKNGfbPGZtztjxeD7bIXmgW9urRcysicaLv3fH8c6iTQggMIkCBLp97PWwTaaqTmGNuT1io0Q/vujMrO4A3MfqkXUGBezghvshg500gCo1/+4wD8A2hhennaozs38AVaEIBAYmEBbk+oXHPYkg5N/dU1Wn0OZ79Grureer8+/wwDqdghBAAIE+ChDo9hHXZD1bqZkpV9ef/8e6vm3RWX/E/3PrUTf8gO1zl2Q6ewLdTHfPwCq3o1J7VIlsDxR4SkTM3xs3mvd4ADKwrqCgAQrY+1VYRR+rOoVroqrTzd+hYTOr7IfSUeXyOQIIIIBA9gQIdPvcJ3Ygq0TWTMGardReDI7aaFFbkq5H6nMTyH6AAt38SBtg9ShqAALhU5a1o0Qd0yKP+lXgh/gAOoMiBibQZqr+Yf/hzqsPeKTtebh+Rbv9O9TekCpqA6uBwVAQAggggEDXAgS6XdPFS9hpSlTIsQbHq05hdafIeCVw1TgJhEy7O1l1CpeMUxtpS2eB1s3pXp1G2foDfu3sEFwRiCvw6r9L6gZ/HazS9UPTqvDwMNd92zsl++tkrQD0cNUpBGc6tDS520C39Uii6KA6rjfXIYAAAggMR4BAt8/undbphkzTGuoZrn2mIPuYAkk3UomZLZeNgECbXZZXZ3kE7w17dsgINI8qDlnA/Hu0JEsPWdPiV2ulRfYO4/iqkPv+1DrJbzKBt31MX9Rmjd3uXN9tuiF3KcUjgAACCHQQINAdwO1h/0PtT7+yn2ArYYRmAN2R+SIIdDPfRX2roP13gn0kmXVvRI5u9a2iZDxyAp02erIac3Sd5LcNcnS39d/C80t8QgLQjtOXuw1Y2ZBq5G5pKowAAghEChDoRhL1fkHI0+qHldQPaJkyRyj4ryerTmFz76WRw6gLsFZs1Huwu/qHjeba6wRnK7Vj/rnPbEjVnfOkppqt1Mx5zDtjtv+kFrVtEPtFdBrNNXW1pyJHHf3TbaAbspSIZSMxbxYuQwABBLIqQKA7oJ4J/kBtFml+sK6ux9Wibjvo5A8MqDoUk2GB1rVijPRnuLtSq9psZekxER08WqxlKYN9b7AhVWr8Y51R2EMUETmspL5fZGqrfjUAvtpCGMh5zfaadHsWQ8jyn6NVp7ClXYfZG0Am+bfVnk3DhlRj/bWgcQggMAECBLoD6iZBwB0AACAASURBVOQ2PzT80hnNHVA/jEIxBLqj0Evp1jFsx9mwH9n2vRG1XjHdWpLbqAq0Tg1ee06sCSaXpXaouUFVoJnqSNXJb+tXu0NGUSXsvrcfFHe673v5+7OXtP0yIl8EEEAAge4FCHS7t0uc0j5T18+AtbmJKcc6Abt/jnX3hjbOXsdvRtvCdpdtPa6M0f7Ju1uStdieymtStxupbD3XXSRqqnCy2qy9uvV+XhuA+1cnCUCTXGvX3d4gkg3feuld0iKAAALDFyDQHWAfNKdgHRGR65vFnlIiOxedwqEBVoOiMi7Q7RqzjDeL6rURuLlyZlNOpp4Nftzu4VfrvUGgy43VWcA+q92eGmynDnnoEuv82m76IeQc+dAlPK3Bunaqzsz+sDJbj+eK/x2xy+lnkN+NF2kQQAABBJIJEOgm80rlavPDdlpk07TMHB3kzpapVJ5M+i5AoNt34kwVEHdUy1SaeyNTXZf5ysTZ4MxuRPOB7FFrze6xqlO4Js0Gh21CVXUKG8PKCNvQseoUQjfW6mXX+m7P4E3ThbwQQAABBNITINBNz5KcEEhFgGAmFcaRycQe1fKPHwtrAPfGyHRrJioaZ4OzNoHlZiXazD662P88yaZOcRpv163T6GmSALSXQJedl+P0HNcggAACoyNAoDs6fUVNJ0QgyY+6CSEZ22aGbEJ1qt2olkFoPevz/HmjY4tEw7oSSDIlPqyA1vW66W1MFVa3Tjsch+y83Pbon14CXePQa/quOotECCCAAAJ9ESDQ7QsrmSLQvQCBbvd2o5bS3vwmav0k98ao9fDw6jtbObtLRFUCNThedQqrR9pF1SwsGNWitqRxtq5dtzhnQtvni4ftvBwyIpuozc1A10zb9vfREDaLjLpT+BwBBBDIrgCBbnb7hppNqADBzOR0fOuxL3JTp83puDcm597otaWt59O238CpXVn2xlRpbc5k1y3OtOg4uymn8f1g1/te7zzSI4AAAtkRINDNTl9QEwRWBZg+N/43Q8joU8dpy0YkjR/y4y9LC5NODW4nZk+VF5GjVaewpRfhsLrFOQ/ankodFhyn8f1gHXwvvUtaBBBAIFsCBLrZ6g9qg0BDgEB3/G+EkPNNQ8/ODUqErFXsOfAYf+lst3BHpTanRHZpkSN1qTsfc9Yf67XGIdOWn6w6hc1J8w253yROUNqpnG7rFicAbV3DHn4ub8L6RX4vk7pyPQIIIIDAYAQIdAfjTCkIJBKw16N12qglUcZcnBkBe4pknOmbPATJTPelUpHWEdN0Nnyy7y2R5NOW/QbOVmrWmtXO0+ujYFrP6Y1Xt5DR5ZYANE4wHFW/NEaFo8rgcwQQQACBwQgQ6A7GmVIQSCQQZz1aogy5OHMC9qh93JEyRvsz15VdV8g+WspkFPeBR7tCw0Zhe3lQZm+Y1ss63V7qFicATSPQDZla3XaH5647noQIIIAAAgMRINAdCDOFIJBMgEA3mdeoXd3L7rAEusPt7ebIYkVEHVuRldu6nWocMkLpN6yn6eg7Kks7leiHAkpdTVv206e5TreXuoUFyVWnsOY3TBqBrmk337HhfscoHQEEEEhLgEA3LUnyQSBFgdYzLONN70uxCmTVR4GQdYqx1wHa09rtH/t9rPbEZ9062tf9VGNrCu+TwSNtehmBDdm06b6DTn5Xt50XJ8CMm3evdYuaBWFPi1bS3TRre7p2WscqxXXiOgQQQACBdAQIdNNxJBcEUhVIa2Qi1UqRWWoC9nRQJbJv0SnsjVMAo/1xlPpzTesDKJEegint19L0vxaZO1/r7h9s2dOh0zgHtnWdbn3borP+SFLl1uO0kuUTde9HfR63vmnlE7c8rkMAAQQQ6I8AgW5/XMkVgZ4E7EC3l3VxPVWExH0R6OWHdC9p+9KYCck07FicZtMfrjqFnUkY7PWmZl2uEm0edFzdzCf2CH+w3G6OrIpT7zRmmIT5JZ2NEHXGbVrfjV4eRMXx5BoEEEAAgcEIEOgOxplSEEgkEGfjlUQZcnGmBOwpmEmmqqb1Yz5TICNQmZD1pau1Thqw2VPXzairiNqrRd3QzPRY1Slck5SllynxncpK48FbGkf/RM10ma3UPiciq8coxd3gzW57VDlJ+4XrEUAAAQSGI0CgOxx3SkWgowCB7vjeICEjW6eqTmFj3BYT6MaVSve6sGnLfglJpwfbeZkHHVOS26VE3+3n2U2QZq9R7XUHZ78uafx9lMbuzSGB/JrR9LQ2kUojKE/37iM3BBBAAIFuBAh0u1EjDQJ9FgjZAIYjLvpsPqjsew0a0tpwZ1DtHZdy7PWlwXYlWWNt0tkjj2ZEuHUUMdn61Wa+L4rI6kOTtDZRSmPasd3mbtY2R3130gt0z2zVMvXY+QcZ+vFFZ2bruNzLtAMBBBCYFAEC3Unpado5cgJp/WgbuYaPeYWjRqWims+0yiih9D+3Hzwp0Y8HphmL+XOSQMj6bh+vOoVN9tTopMFzv9bn+pr2bt9Jpts3g/DVzbfMn7sZsQ5p45op3pZr18cqpbnTdPp3IzkigAACCMQVINCNK8V1CAxYoNcflgOuLsXFFOh1oxsC3ZjQKV7WZvOo4Fm1sWdc2MGaHySHlJHoWKB+rc/1GaM2gurE3cu50Xa+7R4ARo32Jr0deNCYVIzrEUAAgewJEOhmr0+oEQINAdZijueN0Gu/EugO/r5oXbNZ3xac2mpqFHeE0g7IRKSxzrRdABy3tfaUdpHujygKK7OXBzSto9XJRsCD9Wn3ALAPge7R4NnGSddhx+03rkMAAQQQ6J8AgW7/bMkZgZ4E+rWxTE+VInHPAvZaz6TrKAl0e+6CxBmErZ+1dkmWuIFQp/6zRhET7bzc630VhRKy63TsI5B6CZLterV7UNTriHjccqKc+BwBBBBAIDsCBLrZ6QtqgsAaAQKa8bwhep0SyX0x+PvCDtTM6O05WdovIreer028EdSQ3YdvO+jkD5h8ur03BrGmtJcR016mPdu93e4BYNrfizTODh78nUqJCCCAAAJBAQJd7gcEMirQ66ZFGW3WRFer16OFDJ49jVZEYo+sTTR+D423A7WwXZK1qFhrajtNXbc/i7vhU8h06K43YmrH1EswPVuprdkNOm67wurSLqANOet39QFCN12fduDcTR1IgwACCCDQmwCBbm9+pEagbwK9jKD0rVJk3JNAGn2aRh49NWICE4cHut0dQWNPMQ4Gfd2u37aDMn/db9pd1c2IcxoPd4LtaDeFOo3jmYLl2A8a4z7ISNuc/BBAAAEEuhcg0O3ejpQI9FUgZKfS2Du79rViZN61QBqj9AS6XfN3nTAswIs66qZdYZ2CxU7TmjtVvt8bUflldxOIp32/tssvZErzloNO3mwo1dUr7Xp3VQkSIYAAAgj0JECg2xMfiRHor0A3Iyj9rRG59yKQxnRIfoD30gPdpQ0799bklPT7GTK62ThD93wgWdurReb8P8c9S3e2UvuciGw+n66+bdFZf6S71rZP1c1a25ApxbGmeLerRbsp1GGj7r20n+9ZL3qkRQABBLIhQKCbjX6gFgiECsxWasdE5Gr/w6Q79MKaLYE0NrjhB/jg+zQY0Prn3jYD3URH0ET1XbfTZZMG3N0KdvOgxr7n4wbvnepot9dsDrYstUNa1A3NdGseIHTT3l7WJHdTHmkQQAABBNIXINBN35QcEUhNoJupgp1/IC5VRPROLXJERO3rZWpfao2coIzS6M9up8xOEHOqTe10vm3SEc6oqetRgXBYwwaxEZVfblT9w+t39kggAI19DFOnTgz7HgXPNQ4+jOjlZhjUA4Re6khaBBBAAIH2AgS63B0IZFggzfMnZyu1h0RkZ6C5R9dJftsBR53MMMFYVS2ts075AT6426JT8Jl0hDPq+m4CXXtzprSCvDhBdZyy0txx+XzAXTPHMa052klEVfzP0xg1Nnkxo2Zw3zNKQgABBPohQKDbD1XyRCAlgbTWt4WM+jRqmNYPwpSaO/bZpBWgppXP2IOn0MBOwWfSEc52Z8AGq5m0b6OC5xQIVrMIWWPccYO8fk3/Ddll+rCI3OhXVIvq6WghP580ZmCk6U9eCCCAAALJBAh0k3lxNQIDFehmhCesgrOVpcdE9NaQz9jJeUA9muaP/qTB0ICaOJbF2N/B4DEzSb+fcQKnpH0bJ3hOs2OS1C+pT9x6tntw56fv5Zxe66HDoX4E0HHbyXUIIIAAAr0JEOj25kdqBPoqEPKD7mjVKWxJUqg9CmOmG65dMyc3LToF84OOVx8F0vzRnyTY6GOTJiJre9Q2OAsi6QhnnGm8SafLDmrHZb+zk9QvZMT7cNUpbE/jxrG/A4E8e96Iys9rkKPlaZiQBwIIIIDAWgECXe4IBDIu0GtQ0/pDvb4tuHFLcIQq4xQjXT0C3dHsvqhgJ8n3M861cUZ9g5Jx8kxTPkn9oux6qddspbZmx2s/rzT/Putn/XtpO2kRQAABBOIJEOjGc+IqBIYmkGQEJayS9tRGcxTHOVkyPxL9Y4sSjxIPDWOEC066nrNTU+0f+Ur6c27qCHOnVvWoYCduX4Tslh068mh/X5W0n3ERN8/UMF7doCn2dN6ku1InqWfI96mRvJNXkvzNtfZGXyKS2oh00rpwPQIIIIBAcgEC3eRmpEBgoAJJRlDaBLo68P6pqlPYaOdpgl92X+5vt0YFTElK7/WeSFLWpF8b1W9xg7m4I/pR5QX745ZKbbsWedR/L84uyL32Z7L6pX+0kF//sDXvabc/bp/1akp6BBBAAIH+CBDo9seVXBFITaCXI4ba/VBrzZMRwdQ6rE1Gs5XWI1Gqzsz+bsol0O1Grbs0dr/Zo+dxA7+4I/px8zOtSWtX9iQyScq0p1Wn/UDNHnHVorakeTY4gW6SO4NrEUAAgewJEOhmr0+oEQJrBJL8sLTp2m2kk+THNN2RjkCawWmaeaXTuvHNJco67QA2yShtaxAu+xadwt5+9kbc4C/NXcY7tccEuyKyuS4r+z/mrD+WZtsH1YY060xeCCCAAALnBQh0uRsQyLhA3B+WYc2wfwj750vaP6ZF5OGqUzA/GHn1SSAqYEpSbJp5JSl3Eq+Nso77/Yy7tjVufqYvourWj/6KW7+41/WjjmnmOejNvtKsO3khgAACky5AoDvpdwDtz7xA0iNMgg2yjx7xp/aNy4/QzHdeoIJxjpaJ255eprPHLYPrXhWICibjfj+j8vG9QzaYOlZ1Cte0eZD1rIhs8j9Le+puWJlxRznHZSOnfk+/5nuGAAIIINA/AQLd/tmSMwKpCXQ7qtApnfXZyapTuCS1CpNRi0C3fRhGydTzwd1gcQLUOH2b5EFHnPyMQNzr0taKU+643KNx+j9tX/JDAAEEEEhHgEA3HUdyQaCvAnGPMAlWwh61FZEnq05hs39NnB+rfW3UiGXeHKGaa46gHag6hduSNCFN73EJIpL4DetaO0CtOoWWfzfjBENJ+j/OtcM4Wijwd8eaM2zDRpLT3HxtWH1vyo3Tt8OsH2UjgAACCLQXINDl7kBgBATiru8LNiVqkxx+wMXv+JA1zSZx7GA36qFD/Jq8eiWBblKx7q+PE3RGfT9DgtI1D53s2sX5bg5z+UG8+vXvaKHuezN5ynb7HCTPiRQIIIAAAoMWINAdtDjlIdCFQDeBTdQ6zjg/Vruo6lgmma3U1qyF9BsZd01k2kGJ/RBDi7rvoJPfNZb4Q25UnEA36vuZtP/jfDftMge5oVyc4C/JVO0hd3HH4qP6Nst1p24IIIDApAsQ6E76HUD7R0IgyZEjfoOifizzAy5e14dsqhNMGGu36m76r1PtkgZO8VrKVWECMQPd7Vrk0UD6w1WnsN3/c9IHE3Gm/Q7z+xun7Dhuo3DHxWnrKLSDOiKAAAKTKECgO4m9TptHTiBk6uPRqlPY0qkhUbuF9nI+78gB9lDhkNGr+5Tou/0s10n+kgOOOtk5MK3t1SJmfW/jpaS3804JdHvo0IRJ4wRs9vdTiX580ZnZev6hU7L+jxNctT7IkpsWncKhhM3r6vKo+g1z/XBXDeqQKGTZwpqHGGmXR34IIIAAAukJEOimZ0lOCPRVIM4Pbr8CIUeenKo6hY3BChIsxesua9rycSWyKzh6559NTKAbz3OUrkqytjZih3MTgN54/kFHfduis/5IO4s4I8D20WFKOueZpnvU3x1Rn6dZl37nNU5t6bcV+SOAAAJZEyDQzVqPUB8E2gjYOy93Wh8aZ6psyAZJkaPEk9Y59gMDM1K3LHpnTqbMml3/FTnCE7VeOqlrNyP8ScvgerPp15mtWqYeOx+grh2pDRrZ38/gSL89+hq1tjtOuUkefKXdl1H1ixOop12nfuUX1dZ+lUu+CCCAAAK9CxDo9m5IDggMRCDOBjB+ReJOSx7mj+WBoPVYiL0+159yPFupmanKF/vZhx05Eyw6ar10N9Wk77pRS5YmSZBj77wcHGGNc0TR2vulc4C9s6I3npOlF4Npou7BZC3vfHXIjJE153BHTW1Osy6DyIvv2iCUKQMBBBBIX4BAN31TckSgLwL2KEmndZ5Rx534FYxaxxvVkMYPXp27QSt58qCTN2drjtWrdWdb7VSdmf2dgpowAALd0bwtkgS67e4V03Lre9bxaKE2300rkIw/0twv+U7B3zDXD/ejvQS6/VAlTwQQQKD/AgS6/TemBARSEUjyozvu+r1eAjB7tFOLHMpL/raojZlSwRhQJu18ko5Yxe2PJM3ix3cSre6uTfKda10u8OqGY0nyCNaycyBZ67jLc3etTZbKntXQaar2INcPJ2tFvKs7tTVeDlyFAAIIIDAMAQLdYahTJgJdClg/fteM8sT9kRy8rtuRl5A1os1s1ZGqk9/WZfMyl6zd2sqkwUs/glJ7TeiK1K/5mLP+WOYQR7hCIUdLtT1OKmw9t9l5uV0AHMXSqX+TPmiJKqubzzs9JOvH/d5NHdNK08sDwbTqQD4IIIAAAskFCHSTm5ECgaEJdNrwxq9UyCZTx6tOYVNYpbv9wTxbWXpMRK8enxLMe9RHb+I8MAhZI9n2oYPJrx8//Pnx3f+vYdLvx2ylZh40XN2s2bGqU7gmJI9YxwBFBJIHROTW8wKvTqnvv8j5EtpN3w/5brTs+D7IeqZRFt+1NBTJAwEEEBi8AIHu4M0pEYGuBewNqcKCypBRqLa7AsfdtCpY4ZBA2mrP+IzqRhwZEwxqpNNOugS6Xd/yQ03YRaC7JgA1G0TZ39k45y6bRofs1L0aIGch8Gpnk3S2w1A7OGbhSTYCjJkllyGAAAIIDECAQHcAyBSBQFoC7XYBDuaf5Cibbn6UhozmPiwiZnTXH8mScZhGG2UTd8OvqHy6vTc6BULd5km6tQJJA93W72d9m4jaq0Xd0My57ewK275T2dbZzkP5vrXbHM+eqi0ibad7j8r9lvQ+GJV2UU8EEEBg3AUIdMe9h2nfWAnYa2PNua5mHWCwkUlGe5KexxpyrEjjR/aU5HYp0Xf79dCibjvo5M3o1si+ogLU1l12w3/QR+XTLRA/vruVi58uqbH9/TDfAyW6IiIbm6XGDvo6re3txwyB+CqvXhkys6MxcySpWdJyh3H9OLZpGI6UiQACCAxaoG2ge//993/zuXPn/o1S6n/u3r37M+0qprXuGCwrpXS7tA8++OC6V1555fqVlZVvzeVyn7/iiiv+7gMf+MBKFEK5XL5WRLaIyBdPnz792X379p2NSsPnCIyLgLUOsGVtqH1mZ9RUySQ/mltHEV8NtENGcdpOlx6VfrBHrLSo+w46+V1+/UN+6B+tOgXz99KaV2vA0vpwohuTOKP73eRLmvMC3UxZtdbRm9kOq2tplUis9blhgaT/UCvk4VSs44rS7td2D93iLK9Iuy79zi/JcpB+14X8EUAAAQTiC7QNUufn539VKfUfReTzruu+NSzLSqWyaWVl5dmI4j7tuu67gtfcf//9F9Vqtd9VSv2glbautf6Niy666M7bb7/9XPAzE1B7nveLSqmfEZEpK91fTE9P37Rr164vx286VyIwmgIhP763+GfYhmwEEzlV0j46o9O0Y3vKpD9yGzLS23FzplGQjzOKE+chQZx8uvGwA207EO8mT9LYDynOHglMO5Y4G62FBEV+ppHfRds/eH/5gW67kdRh9J11/zc331prNgnLGIZhT5kIIIAAAtECoYFuuVzeorX+SxHJdwp0Pc+bFZHFiGKOuq67OsoxNzc3vWHDhudF5NJAOjMiOxP481+5rvvdwXzL5fIntdY3Bd5batav8ZZS6hszMzOX3XHHHS9HN5srEBhdgdYf0ud3XO3mR3Dcqc4ho7an1kl+k39ubpKAeRT07QcKIq0729q7YIcFQv0KdNsdZzMKtqNSx7jfjWB7mg+bzEZlFwffV/LqubpJ2h42e6Pd2tgk+aZ1rX3/NzffejEwVXvkd1w2VnFnb6TlSj4IIIAAAukINAJdM1o6Pz9/fS6Xu0prvUNEfiQwatp2RLdcLn9Ua/3TInJ8enp6TWDqV+/s2bNnP/zhD5/y/+x5nicixeaf/2p5efkHzOf33HPPVdPT058WkcubdZotlUoHzX8vLCzcUK/XjzTTvJjL5d7lOM5Te/fuveDCCy/8uIj8UPOzj7uue3M6NOSCQDYFQkZtV6cJt64bjT52JE5AZyRar1u7JrWboCCbwq/WKk57WqdptgYz9nTvsIC5W4ewEb9u8yJdq0CceyDMLeShUFfTi+0Nz0wgGbJT+tDWw9v3thm9zclUcJbXyC9h8Ps3zuwNvkMIIIAAAtkSaAS6lUpl48rKinkKG/ZqG+h6nmdGfU2A+19d1zXBceTL87yvishrROTlq666amNwTe78/PylSqkvNYPs1VHdcrl8SGt9o8k8l8u9xQS5wYI8zzMjxG8QkaVisTjTaV1wZAW5AIEREAj7AdwMRg+JSOO7Yl6djrzxr4k74miv/bXXGybZ7XkEiGMGumd3iSiz2ZD/avlh322wFMfIynvkp4vHafMgr+ml75rfq50iclSL2usvL0hSf/u7aQLJaVEHgtOp43zHk5SZ5NqwdeJaZO58HtEP2pKUN8xrCXSHqU/ZCCCAQHcCjUD33nvv3ZDL5Y5bWZhpV2YtbKdA96SZnqWUKhaLxYWoKiwsLFxer9dPmOuUUr9SLBbvtNN4nve4iHyPiNRd182Zzz3POy0iG0TkGdd1zUZUa16e5+0xzWjm+45isWgCcF4IjK1AyA/MxiY31hraWNMG4+wKHLLusGW9YTdn8ma5g+L8sA2Z0thYpxhsVy/BUpSPPaJsRvyi0pjPzbRn8/8fc9abKba82ggM+xif1u9mfZuWKfNgZXOzyrG+4/3q4JC1+UcDdYv1oK1fdUs7X3ua9jAfMKTdNvJDAAEExlWg7Y8iz/PMNOJ3tAt05+bm8hs2bKgZmHq9/q9yudzrtNZmdNfsmvzXy8vLfxKcsmyuW1hYeE+9Xv9D899a6+2lUumwDet53j4R+QXzfj6fv/TOO+/8arlcrjevO+C67m12muaa4s8237/ddd1fH9cOo10I+AJr18SqI+tk3U3nZCk4MyPWUSZxjhgKOTN2zQ7Epk5xAuZR6r04ga5pj32dvcu1PRKe5uY8Yee2Ljrr/WUea7ib/WyOgDLHUTUC3cbfxSJ785K/z19rPUp91O+6xr0H+lUPe5lC87iihwLlDX1qsP0gx69b2NFn/XIaRL79fGA1iPpTBgIIIDCJAl0HuuVy+Z1a6z9vopk1uGs23hCRZa11qVQq7fdhPc/7KRF5wPw5bAqyeb9cLt+itf6dxg8wrd8+PT393MrKyj818/hZ13U/YndUc63uK83373Fd1+zMzAuBsRZoXY+rjojo1TN1kxxl0ukHfcia4NCRmpCAuWV0c1Q6JKQtbXfMjfoB3M9gya5n2PnFswtLt4rS5lgkfxQwrBuOrpP8NoLdtTT97Lu43wXrIZN5OLy6NCHN9d5x62NfF7IeuXHJOJylHWxryMO+oa2N7ravSIcAAghMmkAvge5urXXZBzO7Hmut/0FErhCRSwKQu1zXvc/8eX5+vqSU+uVmEHtZqVT6ig3ued57ReQPmtd8Xy6Xe65erz9j/qyU+mCxWHwwrJM8z/PP6/2o67p3TVpH0t7JE2i3u2tTItFRJnawFpyWZ+/yKiJtN9bJQmCQxp2QZHQ6am2yZZL6VNPgzrz+EUPm3liSpbuViFkjujp6G2ETeg5wGp6jmkcW7ucOxxVJmrMDeumjqI3qesk7K2nj7mWQlfpSDwQQQAABka4DXc/zzG7HH2girpku3Dx26Leba3yX8/n8G+66665/LpfLrtZ63qQx05LNe3YnBKc3T01NvXd5efmZqampvw8rJ5jWD3S11g+WSqUP9tK5Tz/99ENa6+/oJQ/SIjAIgc8/v2Hjo0++5o12We99y9ePfdem01+LW4dPfPbSTU+9cIHZJK7xuun6r/3Dd1z+klmDL7/6P65481dfnr7A/2zbtae++K+/9cWWh1Tm83s+dfXmpWXVWFtvXre940tPXXlJ7Rtx65GV6/7fv7/k0seevvhKvz5vft03vvYj3/mV0PWsf33sotf84Re+aTWYvHxj7aUff+eXnjZpn/nKBRt+9zOXru4rEPwsrbb+/t++5sqjJzY0jmvLT9dX3nbVy1/+m+cuvGxpeWq1H+yy8tPaLDGRYF+ZP3fq27TqO0r5/Kc/2PS2YH1/4QeP/c2g63/m3HTuvscu/w67rzrdk4OuoynPfGee/srMxmsvPXuy3d8Pw6hXWmX+0Re+6Q1PHLvo9X5+373p9Jfe/Zav+7PN0iqGfBBAAIGxFrjuuuv+5SAb2HWgu3///svq9br5IXhy9+7dfiC6Wvf5+fmfUUo1phkrpW4rFosHgiO6KysrV37oQx9qbEwVfM3Pz9+olDI7x5qpy2tGdLXWd5dKaCdzmgAAIABJREFUpfvDgNIc0W0GumYkhBcCmRd4/JmNYv7nv66/4mW58a1mc/P4rydPXCiH//a1qwlueNNJMf974XRefv3PzIbm5193bTshG9cvh2b+8F++To5//fyR2D/23S/IpteYY7JH62Wb+h5hrbCNZtbVZc/3P9e49NjXZuS3n3jdarKrv+ms3Pr2F1LFOHlmWu5/zEykiX6Ze+P6y19u9MnZc1Py8BOvky+fNselv/oydb9r64nG/0/6axB9F9fYvh8L0/XGffS6i8xx8rwGIfB3X75AHvmbxvOkxqsf3+VBtIMyEEAAgSEKnLruuuvO/2AdQEW6DnSj6jY3NzezYcOGM83rHnBd96eDa3Snpqa+fffu3f/LzsfzvFtF5IB5P2SN7s+7rvtLdprmrtFmZ2bz6nmN7lNPPbXmKX5UW/kcgWEL/P7nL33bl07l33bJ+uWnP/C2F0I3I+pUx79+7qI3/NEXXvv7/jUX5Fce3/29x4v3Hblq70tnp/1zqsV/v11e9vWvv+jswo+/858a52GP0itpO/7zH33LEa3lQr+N73zj6R3f+6avPv1bn37Dji+dntntv//NFy79+u3/6kTqm+Ut/OnV5W8s5W4IM1ZKXn7tv1g6+J1Xnf5v33XV6TUjUH/6zGuv/fQ/XLSmf0a1z9K+v8x36m+fv3B1qUxheuWzpf/j+E+mXU7c/Px70vTnm177jb3dfM/jlsV1rQJZux/oIwQQQGAUBd785jcPdGZU3wJdg+953jkRmVZKfapYLL47uP5WRHa6rvuw3Ume55nNq8zOoCbQvcx1XTPluTG8oLX+vVKp9H47zfz8/Fal1GPm/U7reEfxhqDOCAxKwDo+4+Q6yV9zTpaeFZHVp29RG1yNyzq2qA2m7D4JWePc2KimdcOw/pwr2ma99nElcmBa8vs7bTIVsr5yZDcRS/O7kmSddprldsrLHOfDkVCD0l5bTshRSpxbPZyuoFQEEEAgtkBXgW7zaKGvKaXMObt7isViYyfl4KtSqWxcWVlpHHWilLq/WCzefe+9916Ry+W+2HzvN4rFYsvT8cCxRmHn6P6j67ot6xE9z/s5EfnFZr7vKhaL5mgkXgggkECg9RxcOaREtgeyiNzgKmTjqlhHHCWo5kAuna3UPhfcpVhJfVu7Y3tMhVoDWmm0296pNSqfXhr36gZU5/Yq0RuVyCFzrnKc/EJ2mB6r80/jGIRdk8VAt9u2kC4dgSxsTpZOS8gFAQQQmAyBrgJdQ+N53tebuysfKxaL36KU8nc9bsjNz8//qlLqPzaDz/cXi8Xfs9ItT01NXbZ7926Tj5/mrUqpJ80ftNafKZVK39VMY45U+GHz3/V6/d179uz5lJ/GD7pFGtMGl4rF4oxdl8noSlqJQG8CISMWazKMc1zIuAQHSX/Q2u02y3OrTuEae6TXPmO3tx5LL7U1mm92Kdy36BT2plfC6OVkP7Txd7QevZZQ47QE1p5dLpnZ9Tqt9pEPAgggMG4CXQe65XK5qrXe0QQ5orX+t+a4oEceeSR3/PjxOaXUzzc/+6Lrulf5cJ7neSJSbP75qNb6g6VS6YnmtObfFBF/55tbXNetmusWFhZuqNfr/rrDU0qpn7jyyis/eeLEibfU63WzOZV/dujHXde9edw6ifYgMCiBkGmsftGRo7nmwnE5SzdpoGvabqcxR7/kZMqMDPtTv2MZDqqvg+WEjMRP/FFD4zINfxj307iWmXRJw7g60C4EEEBgVAS6DnSbm00dF5HVbQibZ+muHkNiRljr9fo79uzZ81kfZG5ubnrDhg3PB9OZgdrmUUT+ZU+4rvv2IKLneWZE+H2B9+w0L69fv/71d9xxx8ujgk89EciaQLuzeYPn6kbVuZsgMSrPQX7e7ai0/SNYRDsiqhKoe2ancYeN5mfljNZB9n2wLALdYclnt1x7KUKcWS7ZbQ01QwABBMZfoFOg+7iIfI+IfN513beGUdxzzz0XT09Pf9QMZliBqglC/yyfz78/7Kzc5i7Ji/50ZCt4/bWXXnpp1759+9acX6K1Vp7nmZHinzUbXAXro5T683q9/j4zojz+XUYLEeivQHNU1ux8fr2InFJS395pfapdm1Gf3ndLpbZdizzqt0uJfnzRmfFnjbTFDxkVNecQr27klfUfxfb05azXt7/fgtZ110zn7rd49vPn4Uf2+4gaIoAAAmtixDQ4zHTl559//tp6vf4mpdQXws7VDSvHpDtx4sS3aa3fmCSd53lXa63fOjU1deL06dOft4PiNNpEHghMuoAZ3e20W287n1Gf3tftj9moNc5ZXZ/r9+OOytJ+Jbqx433zldkR6EF8N0f9Ph6E0aSV0bphn7rvoJPfNWkOtBcBBBAYFYG2I7qj0gDqiQAC2RIY9el9dv3NFOSqM2OOPYt8tU5fHp2gMWRDrYk+PuX/Z+9+oOS67gLP/263VNXKWLYUIAHjxBJ/EpJlI2kZNoFwsDTMEGBmsMRhsl6Vdt06c4Zkxjjup652wjIgaeBw7HS1nmzIzDFwjlvQ1TjZBcu7c2CB3WPpHP6FgbhNZgjrMLgF9hAI4JadIFVLXXfPbdVrvb51q+q9qldV78+3zuFgdb13/3zu60796t77uwS6PR/3wl3Q77aGwkHRYQQQQCAlAgS6KRkImoFAXgT6nRFNS/8HCXAcweJmt+LscR6ng73sPCvtHobZIM/BMNpDmeMXcPx+Fz5p2/hHhRYggAACnQUIdHk6EEAgUYGsn6VrJ9OKu+TYzlydpb2ug8xmJ/oQpaAwO9AtenKuFAxJKpqQ9WR7qUCkEQgggMCIBAh0RwRNNQgURSDLy/taWadfC49V3SvH/jt53F+fFpGDIrK47JVWsjL2ji8pnqt75aNZaX+S7SSgSVIzP2UN+kVYfiToCQIIIJB+gdgf4NLfJVqIAALjFMjyWbpZDtKTGHNXQq1+Av0k2jLuMgh0xz0C6ayfJe3pHBdahQACCLgECHR5LhBAIHGBrAYJWV92ncRAVvzGqojcG5SlRI4teeWLSZSdpTKsZ/hK3Svvy1L7aetwBLKebG84KpSKAAIIpFOAQDed40KrEMi0QFaTGtlH7BTx7FTHHuPCHaFS9Jn9TP/xGXLjs55sb8g8FI8AAgikSoBAN1XDQWMQyIdAVpf3tbe7eLOZJ/zGUS3ybOhJXK175f35eDKj9YJAN5pTEa8y+++V6KdDfS/sPvYijj99RgCBbAkQ6GZrvGgtApkQyOrMqL3kuqiZdm2Hoh0z1B7oytklr3wmE798NHKoAnwJMlReCkcAAQQSFSDQTZSTwhBAwAjYy/u0qNQvf3Uk0bpa98p7ijiijn2IqR+/JMfJ3qtdxCXsSXrmqSxHwra1ulfem6c+0hcEEEAgLwIEunkZSfqBQIoEsjjrwZLE2w+QwyKzH+ZNYLJDq/u1TKzVT5UuRPk1cezDLGRCrihWRbwmq8n2ijhW9BkBBIotQKBb7PGn9wgMRSCLsx5ZXW49lAEUEUdCsZPLXmlxWPUNo9yK3zB7Kc2ZxsFrRYsy/eh6tnH7s9A8suTtujSMNlJm9gQqfsM8PweClivh+cjeKNJiBBAoggCBbhFGmT4iMAaBrM16ZDWB1rCG1g72RNSlulc6Mqz6ki7XnpUNlb+mRR3pFuzaz0JRzxJOekzyUh5J6/IykvQDAQTyLkCgm/cRpn8IjEkga7MedmC+U0p7Fz21Nia+sVfrmJWXrCTncuy3bvNszew6Z6itQIYzdMf+NKarARwxlK7xoDUIIIBAJwECXZ4NBBAYioB9HquI9ure1PmhVDZgoY4jdQhuNpOKXb+kRd0X8GYhqZhpa/uzJ8+JyGERuSv8qHQKdsNfeijRl5e8KXMvLwQ2BexkZSJyoe6Vw0vkkUIAAQQQSIEAgW4KBoEmIJBHAcfS0dR+GLQDo6wEdMN+blxJqXZKaX+aZ7odM9FXd0pp37rc2KdEm322PYPd7YEuRwsN+znLWvlZTLaXNWPaiwACCCQhQKCbhCJlIIBAm4D9YVBEVupe+VAaqSp+42UR2Re0TYmQZbeFkbWkVN2OtmotaXYFu4eCPbvtQQyJhtL4OzvONmUx2d44vagbAQQQGJcAge645KkXgZwLTPt6zw1Zfy3czTQm9eH83O4PomNmPrVfWJie9EoU5JilNrdtJaiy3y/6Xu2c/5nqu3tZS7bXd0e5EQEEEMiwAIFuhgePpiOQdoGK31gVkXuDdmpRWzNnaWl7xV/3RfRMqD3P1b3y0bS0b9ztcCWlSuM4Bk5RApBuwa669Sw8aMpjf+64n7701p+1ZHvplaRlCCCAwPAECHSHZ0vJCBReoOI3LorI/bchxpOQ6vi5xv1KKZNQ6OCttmjz//e4BqhbNt6iDmj7OKYz+Y6dVKxboNop2G2NcevZGM/zWtTnLEv97rVyIEt9oa0IIIBAXgUIdPM6svQLgRQIOLKTjnS2tLUs+enbAW5PlCs7pXQwzcmWevZgCBc4slKvpTEpVbf9uS6WDsFucOlmEiuehSE8UDko0j5nWglJy3IwrHQBAQRyJkCgm7MBpTsIpEnAsf91re6V946ija09wibJlHPm1tGGq1rU4SAp0SjamKU67GXoaTwuynEc0sllr+Q8Kzew7xTsknk7S0/n6Nsa90uV0beQGhFAAAEECHR5BhBAYKgCjqy9I9mna8+4dOnkiyJ6caeUF5m966zkSEq1WvfK+4f68MQsvOI3TPKzrS82lETLmNwKds0Zz8HRQy/ulNJhnoeYA1CgyzliqECDTVcRQCCzAgS6mR06Go5ANgTGtU/XDnpE5DklTRPMyA6ZWiGIiff8pD0p1aBZvlv9O6NFrZVk5xmej3jPR9GudqxWSd0XP0UbE/qLAAII2AIEujwTCCAwVAHHPt2hH0/j2FN6te6Voy5hHqpHlgtPc1Iqx7nNV+peeets5Cy70/Z0CkTJ8J3OltMqBBBAoBgCBLrFGGd6icDYBMYxE1jxG2Zf5uYRMa3XhbpXnh4bQk4qdiWlGtWe616E9l5bjgbqJcb7gwrY2zI2pLn/GW+XOVKNFwIIIIBACgQIdFMwCDQBgbwLjHomsH2vphxb8srmqCNeAwo49lz3TPg0YJWRbic5UCQmLkpQoP2IoWh7whNsAkUhgAACCHQRINDl8UAAgaELjPJ4GsfeOZYtJzjCjiRfIz0yqlNX7Fl8jntJcNApyinQvnKEc5d5VBBAAIE0CRDopmk0aAsCORawj6fRooYyE+jYE8yy5QSfK8cXCbJTSnvHnbyJ2bUEB5miIgnYqwj4ciUSGxchgAACIxMg0B0ZNRUhUGyBUR1PM64sz0Ua3YrfWBGRA7f7PP6ZLHu5uhY1kmOsijTu9HW7gL1Spd994a0vj57ePBpLqzP1U6ULWCOAAAIIDC5AoDu4ISUggEAEAVdSqmHMgBDwRBiMAS8ZRybtXk0mA24vId5PWiCJs3Rbx2K9HD7/eVirXZLuP+UhgAACaRcg0E37CNE+BHIk4JjVXdsppf1JLXtlf+5oHhbXlxbjzDjraA/7skfzKBS6lkHPbjZ4jgzx5seJ/l0s9CDReQQQKLQAgW6hh5/OIzBagdYHQ3P8xl1BzVrUE8teaSaJljhmGlORKCmJvqWtjDQtX05iZi1tvrQnGwL2SoI4X/i4vjC63evxbwfIxgjQSgQQQKCzAIEuTwcCCIxUwBGMSpwPh90aa2cEHsbS6JFipbiyNC1f5gzdFD8oOW/aIEnQHCtcwlorda98KOd8dA8BBBAYqgCB7lB5KRwBBFwC7RmY5eKyVz42qNYgHzoHrbto97tmo8aVfZnst0V7+tLT30GS31X8htmbuy/Um+dE5P7g30l9AZgeLVqCAAIIjFaAQHe03tSGAAIi4jhXV5Q0jyx5uy4NAmQvIxxX4DVIH7J0r718eVxJdAh0s/TU5Kut/T57rmO6TKZwJfqF20IsX87X00JvEEBg1AIEuqMWpz4EENgUsGdfRWS17pX398tDQqJ+5fq/Ly17ottn8uXYkle+2H/PuBOBaAL9HjHkWLa8mU/A+rKOHAPRhoGrEEAAAacAgS4PBgIIjEXANaMxyJ7afj9wjqXzOanUNYZ1rzzy/11hyXpOHqgMdsNOhBb1C7uK3zAztweDLgerIaxVEuzTzeAzQZMRQCA9AiP/QJKertMSBBAYt4DjaI2+j9WwZ0iSzOY8bqc012/vt1Yy+tlU++xk9jam+YnJX9vinuHsOpYo2GZhf2kzji+O8jdC9AgBBIoqQKBb1JGn3wikQMB13JCIXKh75em4zRskKUzcurj+toD9ZcU4vmCIG2gwfggkKdCeXE8dWvZKK53qsLOEi8iLda+8Obvr+H3qWlaS/aAsBBBAIG8CBLp5G1H6g0DGBJI6bsheCphEcquMUY6luY7EYiNdbumaHWMWbCyPQmErjbtH3A5mw1s2HMmt2G9e2CeLjiOAwKACBLqDCnI/AggMLGDPiPQzq8us3sDD0FcBrkBzlEuH7T2SSvTlJW/qcF+d4SYE+hCIm3nZXmpvsi0HM8D2F3+D5C3ooyvcggACCORKgEA3V8NJZxDIpoBjKZ/ECZaY1RvvuI/zmCEC3fGOPbWb5cbXZ0SUH7LomC3ZkcDtat0r7wnudSS36msrB+OCAAIIICBCoMtTgAACqRCwg6U4s7oEO+MdQsdRKSP7cE4SsvGOPbWbo9KuHdYy8XzIouNRab1+V/hbxhOFAAIIJCdAoJucJSUhgMAAAo69npFndR0zwpw/OcBYxL01zgf9uGX3uj7ustFe5fE+Av0IRN060elYoaBOx+qUke5576fv3IMAAgikVYBAN60jQ7sQKKCA46ias0te+UwvCoKdXkLDf9/+oB9n6fkgrWs/okp7dW/q/CBlci8CcQXsFSmuZHjdjhUK1xc1aI7bRq5HAAEEiiZAoFu0Eae/CKRYwDEz23EJoPXBcFFEHrz9M4KdUQ+znXlWizq57JXMuAz11Z7xtnlkydt1aaiVUjgClkCU480cq1a2jhWy/p6tichdwc/IIs7jhgACCPQnQKDbnxt3IYDAEARc5+oqkZ7HaxDsDGEwYhbZa+9hzOIiX86xUpGpuHCIAo6EVG371KOeOe340oizdIc4dhSNAAL5FSDQze/Y0jMEMinQvhRVeiY2so/rGNWy2UwCD6nR49qnyzLPIQ0oxcYScGRTbttbW/EbL4vIvqDg8LFC4cr44i4WPRcjgAACHQUIdHk4EEAgVQKOD4yyU0p7Fz1llvM5XwQ76RjCcezTZezTMfa0whwz1FgVkXsDi/DfrV7HCoX97GXQUVa14I8AAggg0C5AoMtTgQACqROwPzB22+/p+AB5pe6Vt2ZNUte5HDdo1Pt0HbPIzj2POSanaykSsFejhAPUKEubg66QXC9Fg0pTEEAg0wIEupkePhqPQD4FHPs9Ox6xwbmT6XkGRn2mLWOfnrGnJSJ2Mj0t6ollrzRjbNqXI3fOPUCgy9OEAAIIJCNAoJuMI6UggECCAg/41/ZNyoTZz7b16rTvNs5MSYJNpCiHgGOGdahngDL2PIZpEnD83drMGu84Vuhq3Svv6dR2R/b5nnkKwmWZ+m7qxoNNpfY0pXnhGW+XWVLNCwEEECicAIFu4YacDiOQDQH7XEoR95FBzH6kZzyjnhOaVIsZ+6QkKScpAUdm5UMTovdpkWdDdXQNXAddqVDx158X0Ydb9a3tlNL+bjkOkuo75SCAAAJpEyDQTduI0B4EENgUcMxqOGcH7cQtozq/lWFyC9hfUCgZ3rm2jD1PYdoE7CBVi1xUIlfD53x3yrYc9GWQQNexykFMG5a98rG0WdEeBBBAYNgCBLrDFqZ8BBDoS8A1O+j6gMhRHH3xDu2m4/76eSX6kaACJXJ2ySufGUaFjP0wVClzUIH21SjbSuyZMK3TEugo7bKPMAru4ci1KHpcgwACeRMg0M3biNIfBHIk4Jix20ruEnSTM3TTNeD2TLwSfXnJmwqWUSbaWMY+UU4KS0jAdUTa7S9+oq1w6OfYrBN+46i1RPpFETlwq2731o+EujyUYlqOj4ioNS1yYdkrrQylIgpFAIHcChDo5nZo6RgC2RdwLF/eTO4S9Mw161v3yvxdG+PQO2aj1upeee8wmtRPMDCMdlAmAraA42+XhLMw9xLr59m29gdf1aIWQ6srhpoYrld/4r7fWr5t9jVvJe3qteQ7bh1cjwAC+RfgA2H+x5geIpBZgVYgazKG3hV0IvxhZ5C9bJlFyUDDK35jrdOYJdV8ztBNSpJyhiVggt0JaU5rUQdN0BkcNRSlPvt3aKeU9vZKKBVe4WBWUoioS1rkdFBfVpYvt/7uvyAi9nnoqzuldKiXQxRfrkEAgWIIEOgWY5zpJQKZFbCzmIrIVsZSx6zJc3WvfDSznc1Jw0eRJIovOXLysNANp0Dc/ef2cmkzezwhGxe1TDwfVKCk89m9aRoGxznqoeZlbwl2mmxpCwJFEyDQLdqI018EMibg2He2tRSW42XSOZiOD6qxzgGN0iu7jjjLQqOUzzUIjFMgbqDbnm1Ze1omLinRZmZ08zXMxHBJWbVmc80Z6p3OGc7UEuykXCgHAQT6EyDQ7c+NuxBAYIQCFb9hli/fG1QZHCEU98PgCJtc6Kocy4oT/3DaPtPPTE+hH7qcdb79b1v32Vh7FUVwrFd4r+8wE8Mlxe84HumKElnM4hLspEwoBwEE+hcg0O3fjjsRQGBEAo4Zws0lylbClqt1r9xpFmBELaUaIzCKJGF8ycGzlmeBuKtV7GOFgqR81l7foSWGS2os2o9H0p4SvWItwR7akWVJ9YNyEEAgHQIEuukYB1qBAAJdBDokpTqpRD8duo39uSl6iuyzRIMZpqSaaGeljZKsJ6m6KQeBYQvECXQdXyxdqXvlzURO9hdCac5K7zqWyfxeX5freyZlwixnDl6Jb4UY9nhSPgIIjEeAQHc87tSKAAIxBbonKBFzdMfJZa+0GLNYLh+SgL20OMn9gY4jjCTNH+CHREyxORaIE+h2S8yWpZUPx/3186HjkMzobn15aX2xlfhWiBw/SnQNgUILEOgWevjpPALZEXDN6gatz8Les+xIJ9NSx167xGbcybiczBhRSnoF7CR83f7G2b9r4S+VHAHzsSWvfDFOz1tfLG0eU9RK+rYS5/6o19rLlsNZou0VInyxFVWV6xAotgCBbrHHn94jkCkB19I2EbmqRR1e9kpD+fCVKaAUNdYxVqt1r7w/iSaOIqtzEu2kDAT6FYjzZY69eiK8uiXOzLCrrY4syGsb0jz0jLfLJAhM7OX4e7Et50KWZqYTQ6EgBBAYWIBAd2BCCkAAgVEKmA9EE9I8r0XdZ2Y5mjIxQ5A7yhGIXtew9tEOc1l09N5xJQLDE4gT6HYLAu2Z4bjHcNnZnG/1WF2qe6UjSfbesWx52z5c+/2snAmcpBFlIYBAfAEC3fhm3IEAAgggEEEg7hEpEYrcvITZnahSXJdVAcc+9I4rIuwvlMLLeuMEzLaVay98cM2GNPcnOavbbdnyrd/5xpnwEUNJ7vnP6jNCuxFAoLcAgW5vI65AAAEEEOhDwDELk8ixIPYH+6Q/dPfRVW5BIHGBbgFsUJljye9WxmVzjeP9yImcrN/fqyKyFpxnHndmuBtOr2XL5l57H3KS9Sc+cBSIAAKpESDQTc1Q0BAEEEAgXwJxEupE7fkozuiN2hauQ2CYAlEC3Si/Y1HKcfUjPMtqtomYa8yWkda1kQPmXka9li2b+weZme5VP+8jgEB+BQh08zu29AwBBBAYq8AwjgHiA+9Yh5TKRyhQ8RtmBvWuoErXWdFRlvT2E+jav7tmqXBT1J7w8T9JnV3da9kyge4IHzqqQiBnAgS6ORtQuoMAAgikScD+sK5FHRokedhxf31aiX461MfEji1KkxttQSDKXnQ7WZTrPHG7nCi/g/bvmSl3QvQ+a59s7KOK7FF1ZdJ3HR3kWMmxVvfKe3lKEEAAgW4CBLo8HwgggAACQxOI8kE8TuVRZrDilMe1CKRVIGKg+4KIHAz6oKR5ZMnbdSncpyjl2Abtmc2bm1mWtUw8f7suGXjPvWPZcscvrvqZmU7r2NIuBBAYjQCB7micqQUBBBAopEDSZ94mHTgXclDodCYE7GfddaROlOCv2zm7nSAqfmNbAG1mWYexbcBetuyakQ7aOKzjyjLxMNBIBBDoS4BAty82bkIAAQQQiCJgfzgWkY7HpEQr7/qlUEIccc1gRSmHaxBIu0Cv1Qu9Mi4H/etVjsvBCiq3MjlbPx/od9m1bLnbvt9+ZqbTPsa0DwEEhitAoDtcX0pHAAEECi+Q5ExMxW+8JiJ7AlSOFir845VbgF4BapSMywbHLqfX0TzdZm7tPfeu/bRRB8Sx2qPrfnsC3aiyXIcAAoEAgS7PAgIIIIDAUAUqfmNFRA6E/oen7yQ2UZZqDrUzFI7AiATshFAm8/GSVz4TVN8rEL593bXD2/fW6stL3tThTt2wz6wN19tPYqvO9WxfHt1t2fKtgJ3VHCN69KgGgdwIEOjmZijpCAIIIJBOATvhTK8ZpU69iLpUM50KtAqBeAK99sQ6gs6Ty15p0a6lVzn29e0JorRX96bOm+ui7BuO0kvX0WO9jiuKGthHqZ9rEECgGAIEusUYZ3qJAAIIjE0g6hLLXg2M+4G9V3m8j0CaBXo97+3nz7ZnXDb9cwSVXY/m6TZzmlSwGXfZsulHUnWnecxpGwIIJCtAoJusJ6UhgAACCFgCjjMwpZ+9fXH3GjIQCGRZwP69UbJ9yXGcZfwxr922Dz4802ova+53dUacbMvBGBLoZvlppu0IjEeAQHc87tSKAAIIFEqg4jdWReTeoNP9ZEvmg26hHhk6e2upsA5DBF8QObKZv1j3ylvn6dp4cRLCdQuKe80yRxm0uNmWQ4HuUS0nxyREAAAgAElEQVTy7O2/Id33GkdpC9cggEC+BQh08z2+9A4BBBBIhYB9lqfI7X1/URvYvqRS+k5qFbVOrkNgnAKdshzbiapEJJGMxb0CWUeQGvuIofY9wN3bfjvQjZdUa5zjRt0IIJAOAQLddIwDrUAAAQRyLWAveez1wdyFQdbVXD8idM4hYD/zwTJiO1i0MzLbRUX93YkSQMdZBu0a1H6WLZtyegXhPEAIIICALUCgyzOBAAIIIDB0gSRmguIsvxx6h6gAgREIdApQowauQROjrqiIsj3AnmWOc5a1nZhORK7WvfLWudjdSJP4GzKCIaMKBBBIkQCBbooGg6YggAACeRYYNFAddCYpz7b0LZ8C7YHnrczK9u9Cr2AzSgB7a9bUPqu2fXtA3CA7PDLtAbdcqHvl6aijx9+AqFJchwACRoBAl+cAAQQQQGAkAlE+RHdqCGfojmSIqCRlAvZSYi3qpIisKNEvhJrac1Y0asbyit8w5W4ltXIljbPP0jVtcp3f66Ks+I1tGZ2VxNtnT6CbsgeU5iCQcgEC3ZQPEM1DAAEE8iIQd19huN/sz8vLU0A/4gi0P/dytilqVYl+OijHPnbIVX7U358ogWTU2WG7HYMsWw7KitK+OL5ciwAC+RYg0M33+NI7BBBAIDUC9uxUlA/otz/gXp8RUX6oM7GWPKYGgYYgEFMgHNyZpFNNUXuU6EduB7pydskrn+lWbJRA9wH/2r5JmXg5VI5zptiRWC7S76Ij23Kk+8L9qviNFRE5cLvvt5ZyxyTlcgQQKIgAgW5BBppuIoAAAuMWcCw/Xqt75b1R2tXvLFKUsrkGgTQLhM+gNl8OaVF39VpebPfHEcS2/e5FCYZNuVGvs9tgZ1uOu2z5Vt32HmIC3TQ/u7QNgXELEOiOewSoHwEEECiQQL8JqaJmjS0QJV0tiIC1J9bMaG7toTUEda8c6bNcr2W/9pdJIu5EUf1kP3bcE7nd4WEm0C3IQ083EUhIINIfx4TqohgEEEAAgYIL9PtBtd/7Cs5N93Mg4DjbdqtX8Zb/N9ZExMwGb76CM3mDf8fZQ98raLbZkzhH25Rpf+EVJxFWDh4FuoAAAjEFCHRjgnE5AggggED/AnE+TIdrsZc9alGHlr2Smd3ihUCuBaZ9veeGrJtsxW2vOIFery+Ler1v/T5uC5p7HW9kZ3OO0+5wvWxhyPWjTucQSFyAQDdxUgpEAAEEEOgk4Jideq7ulY/2Eos7g9SrPN5HIEsC9pE+rbZf3SmlfYueMkFnz1evQDbOl0m9ygo3xhWo9wqMO3WGQLfnMHMBAgiEBAh0eRwQQAABBEYmYCeyEZHVulfe360Brg/KUfcljqxjVITAEAVce1xNBuZe2ZbDTWrfg6u9ujd1PrgmzpdJcfbMO77cerHulbftM45KR6AbVYrrEEDACBDo8hwggAACCIxUIM4HatOwfrO8jrRTVIbAkAXC+1zj7M0NmtUtSHR8AdU1GI0TcDr21T6x7JVm+uHib0E/atyDQHEFCHSLO/b0HAEEEBiLQNyzMPlwO5ZhotIUCphjgnbIxMElr3wxbvNO+I2jWuTZ4D4taivgjHvGdZwtCBW/YfYX7wnqVdL/kUD8LYg76lyPQLEFCHSLPf70HgEEEBi5QPt+w+1LKO0GxZk9GnlnqBCBjAh0CxLj/o5FDTgdS66v1r3yVtAbly5qvXHL5XoEEMinAIFuPseVXiGAAAKpFYh6XmfQgbgfwlPbcRqGwBgF7L3u4eXP9pdPvbIiR9037/hdj5R8rhtT3K0PYySnagQQGLMAge6YB4DqEUAAgaIJxJ2Vac/wKsf6WbpZNGf6i4At0ClItI//ibK8uOJvP5fXlSAuqWOFwv0g0OW5RgCBqAIEulGluA4BBBBAIBGBqLNBQWVxjjJJpIEUgkBOBezfpSA47Sd47PV7meSxQgS6OX0g6RYCQxYg0B0yMMUjgAACCLQL2LNBWtShZa+04rKyP4TvlNLeqGeHYo8AArcFHEuUD03Ixh4tE8+HnK7UvfK+Xm6ObMonl73SYnBfkscKWYGu+TtxIPhZlNnnXn3hfQQQyKcAgW4+x5VeIYAAAqkWiLMcuZ/ZplR3nsYhMCaB9v3uzSNNmdynRD8dalKkfbS99s4neaxQmKvXTPKYaKkWAQRSKECgm8JBoUkIIIBA3gV6fUgO+h/3fM+8u9E/BAYRaP990p6WCRPoPhKUq0TOLnnlM73qcfxubguQ7WOFuq3a6FVX90CXPftx/LgWgSIJEOgWabTpKwIIIJASAftMz3AG2O0faq8dDi+r7HRdSrpFMxBItUB75mU5q0XuF5GDtwPdaOfcOvbgrtS98iFTjuNYoUjLoaPgRf2SLEpZXIMAAvkWINDN9/jSOwQQQCCVAo4Pwmt1r7zXbqz9oVaLemLZK82kslM0CoEMCFT8xqqI3Guaar440qLuCzfblT25U7cqfmPbftng3uP++vnwLLGIXKh75ekkeAh0k1CkDASKIUCgW4xxppcIIIBA6gSiJJniQ23qho0GZVzA3jsb7k7cFRN2QBssT674jZdFZCuhlZLklhdX/OszIsoPtTuxIDrjQ0vzEUDAEiDQ5ZFAAAEEEBiLQJSkMlGuGUvjqRSBjArY2wa2d0N7dW/qfNSu2ZmVtaiTIrKiRL8QKuNq3SvviVpmr+vinsPdqzzeRwCB/AoQ6OZ3bOkZAgggkGoBezbIlQSn4jfMB+at/YNJJbRJNQyNQ2DIAvbxXkF1cY/ucuzTvaBFrfWT3Cpqlwl0o0pxHQIIEOjyDCCAAAIIjEXAcc5m27EmHC00lqGh0pwLOJb/mh73tQTYWgq91qLbmsHdkOb+Z7xdZl9wIq8H/Gv7JmXCLI0OXs79/YlURiEIIJBpAQLdTA8fjUcAAQSyK+BISLVa98r7gx45PtAmlrk1u2q0HIFkBKxtAVd2SungoqeCQDVyJY5jhrbuHVbyOL4Aizw8XIhAoQUIdAs9/HQeAQQQGK9At4RULFEc79hQe74Fbi07bkybc3SbsnF+kFnXit+4KLeOKQq/+g6ee8nbS6+TnjXuVT/vI4BANgQIdLMxTrQSAQQQyKVAt2RT9vJK1x7eXKLQKQQyJtDaq3tJRA60mn5Fizq67JXM8UOJv9KQpM58EdeUiUeUqNWdsvNsP7PhicNkqMDjfuO0yb8wIc0nlrxd5tnhhUDiAgS6iZNSIAIIIIBAVIFuxwc5klUdW/LKZuaIFwIIpFDAZHRuitpTkp0Xhxn4jTvQdWyrWKx7ZZNxmlcEgfa/+80jBLsR4LgktgCBbmwybkAAAQQQSErAsb9vKyGV/WGW5YlJqVMOAtkWiJKxfZg9PO43nlUiR8N1KCFYi2Lemv03ycRCR06pS3WvdCTK/VyDQBwBAt04WlyLAAIIIJCogON4kq2EVBW/8VrowxCJqBKVpzAEsivQbSXIsHvlSKIXVNlX1uphtzdt5Xc6x5mj49I2UvloD4FuPsaRXiCAAAKZFbAT2ZiZW9MZ6wgRPkRmdoRpOALJCtjBkhJ9ecmbOpxsLe7SOhzNtHlx3SvzubrHINhfUgSXk4NhFE9v8ergF7J4Y06PEUAAgVQJ2B8ctaiTE6LXtMizQUPNz5a90mKqGk5jEEBgLALjzMhub6kIA7B8uffj0MlvlF9W9G4lV+RFgEA3LyNJPxBAAIGMCjgSu1xodeXBoEs7pbR3mMltMkpHsxEopIBjy8Na3SvvHQWGdSTaFRG593a92qt7U+dH0Y6s1lHxGy+YbMuu9jMjntVRTW+7CXTTOza0DAEEECiMQMVvmNnaILBd256oRFi2XJgngY4iEE3APoN7FEGSI3me+VJu6ws5EdlKphetF8W7yh63sAAz4sV7HobdYwLdYQtTPgIIIIBATwHHB8ite/jw05OPCxAonEDFb5gzeoNze2UUfyfa9+dqT0T5IfytZHqFG5CIHSbQjQjFZYkIEOgmwkghCCCAAAKDClizupvFaVFPLHulmUHL5n4EEMiXQPtZujL0c7btREpmFnkcM8tZHUnHF5pXReSuoD8kpMrqyKa33QS66R0bWoYAAggUTiA8S0NyksINPx1GILLAOI4YsoPrVqC7Gt6nO4qZ5chIKbvQlURMi7ovaCZfbKZswHLQHALdHAwiXUAAAQTyJGDOqWzKxtoz3i7zAZIXAggg0CbgOKZm6Hv5K37jZRHZ12rM5tne45hZzurj4DoWKhzo8uVmVkc2ve0m0E3v2NAyBBBAAAEEEEAAAYfAOI4YCi9TDoKyccwsZ/WBcFlpkdNBfwh0szqy6W03gW56x4aWIYAAAggggAACCDgEHMeSDfWIIbu+ICg77q9PK9FPh5pI5uUOT2yvQNfcNors2fxCFUeAQLc4Y01PEUAAAQQQQACB3AjYiaCGed62I5HSZkCbxMyyORd4XdafViJHRWSltVfVHLmWq5cr0BXRh8PLlwl0czXkY+8Mge7Yh4AGIIAAAggggAACCMQVaN8f2zyy5O26FLecKNe3B7RydskrnzFB6g1Zfy1cRtxgreKvP28CvnAZWtTJZa+Uq2DXtZ9ZRM8Q6EZ5ArmmHwEC3X7UuAcBBBBAAAEEEEBgrAL2kWTDPJ6m217cQWaWu5whvrZTSvsXPbU2VuQEK3d9MSGizmxPSDW8LysS7ApFZUSAQDcjA0UzEUAAAQQQQAABBG4LVPzrMyLKD5kMLfNyt0B3kJnlit94QUQOusZ1mIH7OJ4jAt1xqBe7zo6B7pNPPvlVN27c+KdKqf986tSpP+jF5Pv+19y8efN/nJycbCilfs/zvJ7fQD311FM7v/zlLx/Y2Nj4hsnJyc/ec889f/LBD35wo1ddCwsL7xCRQyLyF6+//vpnzp49e73XPbyPAAIIIIAAAgggkB8Bx2zoSt0rm8+Hib+O++vnlehHgoLD5+VW/MZFEbk/eC/qsmNHQq0Lcmuf7l2tslbrXnl/4p0ZU4HuQHfi8PbMy8zojml4clltx0B3fn7+3yul/rWIfLZarb6nU+9rtZr5hfxFEbnDuuYLWuujc3Nzn7bvffLJJ+9sNBq/pJT6Puu9ptb65+68886HP/ShD90Iv6e1VrVa7SeUUj8iIhPWfb+7Y8eOYzMzM3+Vy1GiUwgggAACCCCAAAJtAvay4Q1p7h/GGdzdZm37PWKoPXiWY1pk2gqaDy17pZU8DL1rifdNWZ8JB7pRvyTIgwd9GL6AM9BdWFg4pLX+PREpdQt05+fn/6VS6udDzbzZCkK3AlGt9fvCwe7p06d37N69+1UReUvoPjMjOxX69+9Xq9X3hru/sLDwK1rrY6Gfrbfat/kjpdTfT01NvfWhhx760vDZqAEBBBBAAAEEEEBg3AIVv2GCwANBO4YVKHULdPs9YshetmyyRtuBn4j26t7U+XE7J1G/HeiapF39fkmQRHsoI/8Cm4GumS2dn58/MDk5+Xat9XER+RehWVPnjO4nPvGJO65du/a3rWCzqZR6YHZ29n//1Kc+NXnlypVTSqmPt/i+UK1WvyagrNVqNRGZbf3792/evPndH/vYx64+9thjb9+xY8fviMjXttpUmZubWzb/fe7cufuazWaQRe+1ycnJ93ue97kzZ8686Y477vikiPyzVnmfrFarD+R/2OghAggggAACCCCAgB0oichQ9um6gtIgUVQ/Rww5li1fqXvlfZ2OMcrDSBPo5mEUs9WHzUDX9/09Gxsb21Kjh7rhDHTDs7la60fn5ubmw12v1WomSP2fzc+azeahRx99dHPZRa1W+xsR+QoR+dLb3/72PeE9ufPz829RSv1lK8jemtVdWFi4qLXe3PswOTn5bhPkWnWZGeK7RWR9dnZ2SimlszUMtBYBBBBAAAEEEEAgrsBxf/2gEm0SOgWvoWQrdgVpQYX9HDHkmAXeDNAdAXBu9um6DG2HvCXgivs8c32yApuB7uOPP757cnLyilW02QhvliB3CnR/TSn1PSaO3b1795S9p/bjH//4N05MTLxkylRKPT47O/uxc+fOfW2z2Xyl9bOfmZ2dfdjuTq1Wuywi32nKrVark63g+HUR2S0in69WqyYR1bZXrVZ71HSjVe63zc7OmmXXvBBAAAEEEEAAAQRyLlDxG6sicm/QzWEsX+4W6Jp64x4xZB+NFF6iHLesLAxvEWewszAueW9jx2RUtVrNLCP+tk6Bbq1W+7yIfIOIXKlWq/tcULVazSSU2iEi/7Farf7zc+fOfU+z2fw1c20rUdVzjqD1rIj8uPl5qVR6y8MPP/w3CwsLzdZ1i9Vq9aR9T2tP8WdaP/9QtVr92bwPHP1DAAEEEEAAAQQQELGTOomoS3WvdCRJm16Bbtwjhip+42UR2fr8rEVtJZ2KW1aS/RxWWZ2Wd/ez7HtYbaTc/AkMEuia44PMrO/vVKvV93cIdE0WZJN0aqVarR6q1Wr/RkQ+Ya51LUE2P19YWDihtTZZnE0w/L4dO3b8+cbGxn9rlf+j1Wr1p+y6Wnt1v9z6+WPVatVkZuaFAAIIIIAAAgggkHMBx2yhhAPHQbsfJRiLc8SQo71X6155T9DObrO9g/ZlXPcT6I5Lvtj19h3oLiwsfFlr/Sat9a/Ozc390w6B7n8Vka8Tkf+vWq1+0/z8/FyQpEpr/da5ubm/tu+r1WrfKyK/2gp0v2tycvLPm82mmT02S6A/PDs7+1SHuoJ9uT9drVY/UuxhpfcIIIAAAggggEBxBOxZ0CSTUkUJdONkD27fl6ovL3lTh4PRilNWVkaYQDcrI5Wvdg4c6CqlfmN2dvYDHYLPYHnzn1ar1W9cWFioaq03k1aZZckf+chHvmjfF17ePDEx8b03b978/MTExJ+2ruu4LLlWq20Gulrrp+bm5j48yDB97nOf+5ZB7udeBBBAAAEEEEAAgdEJfOoPv/rwS198kznZY+v1gXf/zfd/69tfD1YF9t2Y//Ozb/mWP3r1jq2JlvKOjc/M/eMrPxQu8Bd//+5/fuXvpk4HP3tTaePyqX90JThlZFvdn7j8ttnXru3cTNhqXl91x/rPfug7Xtnadmf3xVVf350Z043dDH/y//66PwiaNaHkjf/tA3+W6LLzMXWZah0C73rXu/5wlDADB7oi8pvVavW7XY2u1WpBcoC2Gd2NjY23ffSjH91MTBV+zc/P36+Uumh+prXeNqOrtX5kbm7uyQ51JTaj+9JLLz2ttTYHdvNCAAEEEEAAAQQQyIDAE8/fI1evmdQwt14H7vmS3P8ec9jHYK8XX7lDnvujr+xa7urfTskvfPqrt665983X5cH3fcFZ8c/+1t3yhddLW+/9r+/9guz7iutb/7bL+uo71+WHvmPgeH0whAHv/vTqnfLrf/zmrVLeu+91+cC7/27z3//uV7en+vnx7zPhA68cClx95zvfubVEfxT96zvQrdVqwR7d361Wq9/uauz8/PxfK6W+yrVHd2Ji4ptPnTr1X+z7arXagyKyaH7u2KP7Y9Vq9Sfte1pZo01mZvMaeI9uK9D970cxANSBAAIIIIAAAgggMLjAf1q98yt+7Y/fvC1q+uH7Xv3sm//BjfVBSv/1P37z3Z9evfNrgjLeu+/1v/zAu/9uW+R57caOyfnfvOdguJ4f/77Vttkr13Vz/+SVlV07b26E7/13v7pv2+pCV1mD9GnU93YzzFtfR22bpfre+c53/sNRtneQQHdz/63W+otzc3Mm4VTbq1armV/aiWAfb3j/rYhMV6vVC45A97yIPNIKdN9arVa/GGRd1lr/8tzc3A/a98zPzx9WSj1vft5tH+8oYakLAQQQQAABBBBAYLQC9lFDSezVjbpntuI3gkmgzU7vlNLeRU+Zn2297L2qIvJi3StvC5DNxXZZG9Lc/4y3K7NTnd0Me2W0Hu0TRG15Eug70F1YWPh1rfXmkuU33nijfPbs2W3flp07d+6/azab/7mFNV+tVh99/PHH75mcnPyLVkD6c7Ozs9v2N5ifh441cp2j+2fVavXrHcHxvxWRn2iV+/7Z2VlzNBIvBBBAAAEEEEAAgQIJ2ImeTNcHDRKjBrpRjgWyy+oUiEcpK0vD2iPQXTErzYP+DDpeWXKhrcMV6DvQnZ+f/5dKqZ9vBZc/Mzs7+3C4qbVa7bKIfGfr/f9hdnb2hVYgaxbk7xWRmxMTE289derUrQX6IjI/P/8epdSL5r+11n8wNzf3ra17zHm732/+u9lsfuDRRx/9jeCe06dPl3bv3v23InKHiKzPzs5OKaWC/brD1aN0BBBAAAEEEEAAgVQJJD2rax8dpESOLXnlzXwy4Vf7eb7aq3tTZqXi1ssOYLWok8teaXPLXviVtyOGugW6eQvqU/XLUPDG9B3ofuITn7jj2rVrJsA0u+mbIlLd2Nj4+XK5/KabN2/OiUiQae4L1Wp1a19DrVYzGfGC91a01h+em5v7dGtZswmc726NyYlqtVo3/33u3Ln7ms3mpdbPryql/tXb3va2X3nllVfe3Ww2TXKqICX7J6vV6gMFH1O6jwACCCCAAAIIFFYg6VndqIFYxb8+I6L8AF6JnF3yymesAPY1EdlKyNNp9jLqLHJWBtkO3MMBflTfrPSVdqZHoO9A13QhPKvbqUsmoZQJZIP3T58+vWP37t2vikh4X68JlCdCZXy6Wq2+L1xmrVb7ZRH5gdDP7Hu+tGvXrq956KGHvpQeXlqCAAIIIIAAAgggMGqBJGd1owZivc7bPe6vH1SiN1c4tl5X617ZmYXWEaw/V/fKR0ftmFR93Qyj+ibVFsopjkC3QDdYevzZarX6nk4kCwsL36+1/gURucu65tWJiYmjp06d2jobK3i/lSV5KViObAWv/+GNN96YOXv27M1weVprVavVTiulflREbueOv5WA6rebzeYPzM3N/XVxho6eIoAAAggggAACCLgEHEmfREnzyJK3K1ghGBkuaiA27es9N2TdzNgGr9W6V94f/MOe8RWRjsFrr6A5cuNTcmE3w6hLw1PSFZqRIYGOgW7cPpw7d+7NN2/e/Ic7duxolMvlP4wys/qpT31q8pVXXvkmrfXXK6X++NSpU38apd5arXav1vo9ExMTr7z++uuftYPiKGVwDQIIIIAAAggggEB+BezgSkRdqnulI3F7HCcrsD2TXPfKW5+14+y7dQTNEi4rbh/GfX33Gd3GGS1yOmija8n3uNtP/dkUSCzQzWb3aTUCCCCAAAIIIIBAHgVcs7r9ZPSNE+j2mLl8WUS2zvnVog4teyWTcdj5sut1HVeUlXEj0M3KSOWrnQS6+RpPeoMAAggggAACCCDQEqj4jW1H12hRTyx7pZk4QHEC3fblybcyLz/gX9s3KRMm0A1eHffnBhdEXTIdpy/jurbiN7YF+eEvHPKWeGtcxtTbLkCgy1OBAAIIIIAAAgggkEsBR1KntZ1S2r/oqbUoHY4boNoJp4LA+oTfOKpFng3V2TO5lL13tdNRRFH6Me5run1ZQKA77tHJb/0EuvkdW3qGAAIIIIAAAggUXqDiN0xQu5U0NU7A2E9SqHB9SvTlJW/qsH3GbpQ25CkA7BHobvsSIDAr/IMLwMACBLoDE1IAAggggAACCCCAQFoF7IBRRFbqXvlQlPb2GeheFJH7g/JNEqmK3zDHCh0MfhZlr3CejhjqHuheO6xl4vnAhkA3ypPJNVEECHSjKHENAggggAACCCCAQCYFHMuPJUqgaTrbT6BrB6jmWKN+Arl+6k7rABHopnVk8t0uAt18jy+9QwABBBBAAAEECi9gJ6USuZUkqheMnVwqajIra7n0qpVt+eSyV1rsVXdejhjqtc85TwF9rzHl/dEKEOiO1pvaEEAAAQQQQAABBEYs0J4NOdry5X73ydp7ckPdvbpTSvuiJsOy9xdHnYkeMW/X6noFso5AeLXulfenqQ+0JZsCBLrZHDdajQACCCCAAAIIIBBRwLV8Ocq5tP0Guq3ZWDOTu5UEyzQ1ShKqcJfycMRQr0DX9DfOEU4Rh5zLEBACXR4CBBBAAAEEEEAAgdwLOM7U7bmEuN9A12DaAZ6IXKh75ek40PbMsBI5u+SVz8Qpo9u15jikCd28b0MmV37p1M7LSZW7PVjvnWyKQHcY8pRJoMszgAACCCCAAAIIIJB7Acdy4p6B56AzqrdmktVRJWp1ySubbMyxXo4l1z3bHLUCR1bnxZ1S8qIuq45aDzO6UaW4LmkBAt2kRSkPAQQQQAABBBBAIHUCjhnWtbpX3tutoYMGuoMiONoc+WikbnW7lnKb66Mm24rTL0dA3Ras23uRoywrj9MGri2mAIFuMcedXiOAAAIIIIAAAoUTsAMqLerQslda6QQx7kB3WJmXK35j21m/4f4nnfAqyvLvcTsX7hehIB0m0C3IQNNNBBBAAAEEEECg6ALtAV73Y4YqfuPl8NFASQeBUcaj4jdMUqt7g2t7Bee9ynQFz9Y9iS2PNuUS6PYaEd4flgCB7rBkKRcBBBBAAAEEEEAgVQKOPa/P1b3y0U6NTEOSJDs4j5u52e6bw+BFETkQuq7nku44g0qgG0eLa5MUINBNUpOyEEAAAQQQQAABBFIrYLIMK9EvRA3q0hDo2oFiP9mbwwNiLxMW0Z4SOapF3Rdcp6R5ZMnbdSmJgYwS6CYdzCfRbsrIvgCBbvbHkB4ggAACCCCAAAIIRBSwlwJ3C+qsQPdq3SvviVhNYpclnZDKDt7NcuwJmZxRoh+5Hegmd4xR+/5bOWZnoI4SDCcGSkGFESDQLcxQ01EEEEAAAQQQQACBit9YFJEHewV1UY7FGYVmkgmpHEHzlbpX3nfCbxzVIs+G+tN1SXecfkdJNEWgG0eUa6MKEOhGleI6BBBAAAEEEEAAgcwL2MfdKNGXl7ypw3bH0hLomnZV/IbJDL21j7bfpcWdzuV1LOlerXvl/UkMNoFuEoqU0Y8AgW4/atyDAAIIIIAAAgggkPItKeMAACAASURBVEkB1xmyda/c9pnYMfuZ2CxnXLios9C9yu2Wddpe0pzUWbZRAt0oZ+326hvvI2ALEOjyTCCAAAIIIIAAAggUSiDKkT327KeS5PatxsV2BIIrda98KG459nFJ4ZnhKAFp3PrM9XadruOR0jR73k8fuSedAgS66RwXWoUAAggggAACCCAwJIEo5+mmad+oa59u3BnXXnt97Vljk4257k2dH3QIomSuJtAdVJn7XQIEujwXCCCAAAIIIIAAAoUSiHKerh3oDnp+7aDA9j7duO2xE07Ze5Md/X1i2SvNJNBuHS4jyjLxTvumB20L9xdLgEC3WONNbxFAAAEEEEAAgcILRDlP15717TcBVFLYx/318+EjgOKep9srkB3WrGqUGV3HbPNa3SvvTcqOcoopQKBbzHGn1wgggAACCCCAQKEFKn5jTUTuChDsvaPD2rPaL7ojOJc4y5ft/tgzwo4kXYkEm1ECXWMS9bp+/biveAIEusUbc3qMAAIIIIAAAggUXqDXPl07MHQtuR01oiOJ1sllr2TOBe75qviN10RkT6fA3hVsxgmkXQ2IM0tMoNtzCLkgpgCBbkwwLkcAAQQQQAABBBDIvkCvfbp2YJiOQPf6jIjyQ/qRsi87Zmuv1r3yVtAblJf0LHbMQHfbDPugQXb2n1B6MKgAge6ggtyPAAIIIIAAAgggkDmBXvt0rRnGF+te+eC4O+k6A9h1XI/dTvt4ok7JnpLOvBwn0E06yB73WFH/+AUIdMc/BrQAAQQQQAABBBBAYAwC3fbpWoHuc3WvfHQMTWyrsn3JtVyoe+Xpbm2zE1l1OhO4V8KquP23Mz2LSEdHAt24ulzfS4BAt5cQ7yOAAAIIIIAAAgjkUqBTgqb2mUg5u+SVz6QBwRE8yoY09z/j7Vrt1L72IFKOLXnli/b1cWZgo1jEOYuYQDeKKNfEESDQjaPFtQgggAACCCCAAAK5Eei0T9cO+OKeWTtsIDspVa+jhuxET532v7qWRg+yNzlOoBt11nnYtpSfHwEC3fyMJT1BAAEEEEAAAQQQiCHQaZ9u+57W5pElb9elGEUP9VK7faayTrO6dtAuIl33G9tBca/Z4m4djRPoxrl2qLgUnhsBAt3cDCUdQQABBBBAAAEEEIgr4NqnOyH6qBY5HZSVxgzAUWd14+67TXIJsZ3cqtvMOIFu3CeX63sJEOj2EuJ9BBBAAAEEEEAAgdwK2MmdTKImLbJPRB5sdToVGZftAYg6qxt1f25QfpJLiOMEzY7+pCYBWG4f/px3jEA35wNM9xBAAAEEEEAAAQQ6CzgCrBUl+qoWdZ+5S4t6YtkrzaTRsH1WV12qe6UjQVunfb3nhqy/Fm57r9npXucLx3GIE+gmnQgrTju5Np8CBLr5HFd6hQACCCCAAAIIIBBBwBUMhm9Tkq79ueG2uTIwi2iv7k2dN9dFPT83XKZj3/Jq3Svvj0DZdokjq/WhZa+04iqLQLcfYe7pJkCgy/OBAAIIIIAAAgggUGgBey9pCONq3SvvSTOO41zdNS3qiAko7feiZo9OKiGVXU63DM6OjM9rda+8N832tC3dAgS66R4fWocAAggggAACCCAwZAHHLOZmjWa/blrOz+1E0JqRNmfo3hW6Zk2LnFci4bN/Iwftcff1dmpbnEDXlBH3+iE/FhSfcQEC3YwPIM1HAAEEEEAAAQQQGFzATsIkIld2SungoqfWBi99uCU4jhBqqzBO0J5UQiorcL1S98omyVfHF4HucJ+TopVOoFu0Eae/CCCAAAIIIIAAAk6B0BLmK1rU0U77SdPI58rCHGpnzyAz3Cd7768SfXnJmzocp9/2LHmUMuzkWlpUxz29cdrCtcUUINAt5rjTawQQQAABBBBAAAGHgNkr+oy3yywFztyrFaAuWsuYX9SipuME7Y79stJtf60Lqp/kUnGyNGducGjwyAUIdEdOToUIIIAAAggggAACCAxH4Nae3ca0lol9SpqrO6W82M/ya3t2VYkcW/LKF6O2uj3Q7b3fmUA3qi7XRREg0I2ixDUIIIAAAggggAACCBRIwN6nG/c8Yfs83ih7hNuzX98+KqlA9HQ1IQEC3YQgKQYBBBBAAAEEEEAAgbwIOM7oXal75UNR+3fCb5zRIqeD66PMCDvuSX3W66geXDd6AQLd0ZtTIwIIIIAAAggggAACqRZoHVv0WriRG9LcH3X/cnvm5uaRJW/XpW6dJtBN9SORucYR6GZuyGgwAggggAACCCCAAALDF6j4DbMn9/7QrGzkGVZ7v22UZFb9JLAavgI1ZFWAQDerI0e7EUAAAQQQQAABBBAYooDjyKLVulfeH6VKK9C9WvfKe3rdR6DbS4j34wgQ6MbR4loEEEAAAQQQQAABBAoi4Fq+HPVs24rfeFlE9hmqKGfomuvss3dFJHJgXZAhoZsxBAh0Y2BxKQIIIIAAAggggAACRRJoz4QskZJSVfyGDpziZGwO32fuj7LkuUjjQV+jCxDoRrfiSgQQQAABBBBAAAEECiVgLyc2ne91VJA9M6tFnVz2SotR4IYV6Jo2iejTSuSwiFzcKSWvn/OFo/SBa9IhQKCbjnGgFQgggAACCCCAAAIIpFLAMasrSjpnUbaD46jLnU3nK35jRUQOBBDd6omK9YB/bd+kTLwgIuF9wis7pXSEYDeqYvauI9DN3pjRYgQQQAABBBBAAAEERibQ2qu7KiJ3hSvtNFNb8a/PiCi/dW2kRFRBuXa25iQCXVegburTIheXvfKxkUFS0UgFCHRHyk1lCCCAAAIIIIAAAghkT+CE3ziqRZ5tb7k6X/dKXvjnVmD5XN0rH43aYzsojbPs2VVHazbXJMZyvpIIpKP2jetGK0CgO1pvakMAAQQQQAABBBBAIJMCjuOGWv1QlzZk4+Qz3i4z62uWH5tlwgdvvam9ujd1PmqHT/iNM1rkdHB9r/3Avcq1yzOJsZToR0L3xQrEe9XH++kRINBNz1jQEgQQQAABBBBAAAEEUi3Q2n970V7GLCJrWuT8hDQva5l4PujEhjT3BwFwlI65AtNlrzQT5V7XNduDbtlcRl3xG2vh9sdtY79t4b7RChDojtab2hBAAAEEEEAAAQQQyLRAK6vyJUewa/cr9mypncgq6hm8LlD7HOCgrOP++vnwrO6gs8aZHswcN55AN8eDS9cQQAABBBBAAAEEEBiGgAkib0rjohZ1X6fy+9n/6jjOKNK5va422PuKg/N8HfuN+65jGLaUmYwAgW4yjpSCAAIIIIAAAggggEDhBFr7ds0e3G0ZmQeZiU3qLF17GXR4v7BdB8uX8/foEujmb0zpEQIIIIAAAggggAACIxO4tUS4MS2izF7ae0XkuZ1Smu73jFo7CN0ppb39lNXtqKKK3zD7jO8PkAbN7jwybCqKLECgG5mKCxFAAAEEEEAAAQQQQGDYAkmdpVvxG+ZYoX1Be8OzttZZv+aSC3WvPD3svlH+6AQIdEdnTU0IIIAAAggggAACCCDQQ6A90JVjS17ZzMDGenVbAt1KqGWOQQpea3WvvDdWBVycagEC3VQPD41DAAEEEEAAAQQQQKBYAkmcpRsle7N9zJAWdWjZK60USzu/vSXQze/Y0jMEEEAAAQQQQAABBDInkMRZuq0kWU+HOt921BH7dDP3aMRqMIFuLC4uRgABBBBAAAEEEEAAgWEKRJmN7VV/lFnh9qzM7NPt5Zql9wl0szRatBUBBBBAAAEEEEAAgZwLOPbPrta98v443Y6yz9dxZm/seuK0iWtHK0CgO1pvakMAAQQQQAABBBBAAIEeAoOepVvxGybR1MGgGiXNI0verkt2tZynm99HkUA3v2NLzxBAAAEEEEAAAQQQyKRAxW+sts7k3Wx/3ERRUQNle+aX83Qz+bg4G02gm5+xpCcIIIAAAggggAACCORCIMrS404dfcC/tm9SJswZusHrat0r73Fdn0Tiq1yA57ATBLo5HFS6hAACCCCAAAIIIIBAlgUGCUDjJLM64TeOapFnQ1Yrda98KMt2tP2WAIEuTwICCCCAAAIIIIAAAgikSmCQALTiX58RUX6oQxfqXnna1cFpX++5Ieuvhd/bKaW9i55aSxUIjYktQKAbm4wbEEAAAQQQQAABBBBAYJgCgwSgx/3180r0I0H7lMjZJa98plN7K35jRUQO3L7enbhqmP2l7OQFCHSTN6VEBBBAAAEEEEAAAQQQGFCgPQCVY0te+WKvYtv393YPXOMGxr3q5/10CBDopmMcaAUCCCCAAAIIIIAAAgiEBOwAVIt6YtkrzfRCqvgNk4hqX3Bdr4zNx/31aSX66eB6Jfrykjd1uFc9vJ9uAQLddI8PrUMAAQQQQAABBBBAoJAC/e7TjXq0UIDqyNIsda9MnJTxp44BzPgA0nwEEEAAAQQQQAABBPIo4Nqn22t21s64LCIv1r3ywV4+9rm9Stin28ss7e8T6KZ9hGgfAggggAACCCCAAAIFFbD324pIxwzKhsieBY66DLniNxZF5MGAuVcCq4IOR6a6TaCbqeGisQgggAACCCCAAAIIFEfAsXxZuh3/Y5+/GzVgZZ9u/p4pAt38jSk9QgABBBBAAAEEEEAgNwLty4o7HxdU8RsmK/P9oZnZSJma2aebm8dlqyMEuvkbU3qEAAIIIIAAAggggEBuBCr+9RkR5Yc6tFr3yvtdHaz4jRdEZGtPbq89veEy2Kebm0dmsyMEuvkaT3qDAAIIIIAAAggggECuBFpJqVZF5K6gY1rUyWWvZPbVbnvFzbhsBbrs083Rk0Ogm6PBpCsIIIAAAggggAACCORRwE4WJaIu1b3SkXBf7YzLURNRBWXY+3RFZKXulQ/l0bMIfSLQLcIo00cEEEAAAQQQQAABBDIs4NpDa8/q2kuctagnlr3STNRuu44z6pb4Kmq5XDceAQLd8bhTKwIIIIAAAggggAACCMQQaJ/VlW17dR1HBEVKRBVuQsVvrIjIgeBnnZZIx2g2l45JgEB3TPBUiwACCCCAAAIIIIAAAtEFWrO6JhDd2qsbPj6o4jdeFpF9QYl1rxw71rGPJxKR5+pe+Wj0VnJlWgRiD35aGk47EEAAAQQQQAABBBBAoFgCjkBUTGblpmysTcqECXSDV18B6nF//aASbTI3B6+1ulfeWyzlfPSWQDcf40gvEEAAAQQQQAABBBDIvUBrH+2l8PJiEVnTIpeUyNbM6yBLjh3n9sZeAp37gchABwl0MzBINBEBBBBAAAEEEEAAAQRuCbRmXU2wu7WE2bK5UvfKW0uY47rZe33jJrWKWx/XD0eAQHc4rpSKAAIIIIAAAggggAACQxI44TeOapFnXcUrkYFmYB1lb0t6NaQuUWzCAgS6CYNSHAIIIIAAAggggAACCAxfwDWzO8iS5XCLK35Dh/9t9gEveyWTCItXRgQIdDMyUDQTAQQQQAABBBBAAAEEtguYPbs3Zf2wiBxsirqYVDBa8RsXReT+27Vpr+5Nncc/OwIEutkZK1qKAAIIIIAAAggggAACIxA47q9PK9FPh6paqXvlQyOomioSEiDQTQiSYhBAAAEEEEAAAQQQQCAfAq0ze8PHFclOKe1d9NRaPnqY/14Q6OZ/jOkhAggggAACCCCAAAIIxBSo+A2zJ/dAcFtS+39jNoPL+xQg0O0TjtsQQAABBBBAAAEEEEAgvwIn/MYZLXI61MPn6l5566ze/PY8Hz0j0M3HONILBBBAAAEEEEAAAQQQSFCgldX5hVCRa3WvvDfBKihqiAIEukPEpWgEEEAAAQQQQAABBBDIrkDFb6yKyL1BDwY9oze7EtlrOYFu9saMFiOAAAIIIIAAAggggMAIBCp+Y1FEHgyq0qKeWPZKMyOomioGFCDQHRCQ2xFAAAEEEEAAAQQQQCCfAif8xlEt8myod6t1r7w/n73NV68IdPM1nvQGAQQQQAABBBBAAAEEEhKY9vWeG7L+Wri4DWnuf8bbZZY080qxAIFuigeHpiGAAAIIIIAAAggggMB4BSp+46KI3H+7Fdqre1Pnx9sqau8lQKDbS4j3EUAAAQQQQAABBBBAoLACFf/6jIjyAwAl+vKSN3W4sCAZ6TiBbkYGimYigAACCCCAAAIIIIDA6AUe8K/tm5SJl8M175TS3kVPrY2+NdQYVYBAN6oU1yGAAAIIIIAAAggggEAhBThmKHvDTqCbvTGjxQgggAACCCCAAAIIIDBCgeP++nkl+pFQlRfqXnl6hE2gqpgCBLoxwbgcAQQQQAABBBBAAAEEiiXAMUPZG28C3eyNGS1GAAEEEEAAAQQQQACBEQtU/IbZk3tXUK0WdWjZK62MuBlUF1GAQDciFJchgAACCCCAAAIIIIBAcQU4ZihbY0+gm63xorUIIIAAAggggAACCCAwBoHj/vq0Ev10UDXHDI1hEGJUSaAbA4tLEUAAAQQQQAABBBBAoJgCHDOUrXEn0M3WeNFaBBBAAAEEEEAAAQQQGJNAxW+YPbkHbs/qyrElr3xxTM2h2i4CBLo8HggggAACCCCAAAIIIIBABAGOGYqAlJJLCHRTMhA0AwEEEEAAAQQQQAABBNItcMK/dljLxPOhVq7WvfL+dLe6mK0j0C3muNNrBBBAAAEEEEAAAQQQ6EOg4jd0+DaOGeoDcQS3EOiOAJkqEEAAAQQQQAABBBBAIB8CHDOUjXEk0M3GONFKBBBAAAEEEEAAAQQQSIFAxb8+I6L8oCkcM5SCQXE0gUA3neNCqxBAAAEEEEAAAQQQQCCFAq5jhupembgqZWPFgKRsQGgOAggggAACCCCAAAIIpFug4jdWReTe27O6zSNL3q5L6W51sVpHoFus8aa3CCCAAAIIIIAAAgggMKBAxW8sisiDtwNdObvklc8MWCy3JyhAoJsgJkUhgAACCCCAAAIIIIBA/gWO++vTSvTTtwNdfXnJmzqc/55np4cEutkZK1qKAAIIIIAAAggggAACKRBgn24KBqFHEwh00z9GtBABBBBAAAEEEEAAAQRSJsA+3ZQNiNUcAt10jw+tQwABBBBAAAEEEEAAgRQK2Pt0RbRX96bOp7CphWwSgW4hh51OI4AAAggggAACCCCAwCAC9nm6InKh7pWnBymTe5MTINBNzpKSEEAAAQQQQAABBBBAoCACJ/xrh7VMPB/q7mrdK+8vSPdT300C3dQPEQ1EAAEEEEAAAQQQQACBNApU/IYOt6vulYmvUjJQDERKBoJmIIAAAggggAACCCCAQLYEKn5jRUQOBK1W0jyy5O26lK1e5LO1BLr5HFd6hQACCCCAAAIIIIAAAkMWqPiNiyJy/+1qSEg1ZPLIxRPoRqbiQgQQQAABBBBAAAEEEEDgtsAJv3FGi5wOfqJFPbHslWYwGr8Age74x4AWIIAAAggggAACCCCAQAYF7IRUSvTlJW/qcAa7krsmE+jmbkjpEAIIIIAAAggggAACCIxCYNrXe27I+mvhukhINQr53nUQ6PY24goEEEAAAQQQQAABBBBAwClQ8RtrInJX8OaGNPc/4+1ahWu8AgMHulrrrmUopbal3A5396mnntr55S9/+cDGxsY3TE5Ofvaee+75kw9+8IMbvUgWFhbeISKHROQvXn/99c+cPXv2eq97eB8BBBBAAAEEEEAAAQQQSFrghH/9khZ1X1AumZeTFu6vvIECXd/3921sbLzco+rfqVar7w9f8+STT97ZaDR+SSn1fda9Ta31z915550Pf+hDH7oRfs8E1LVa7SeUUj8iIhPWfb+7Y8eOYzMzM3/VHwN3IYAAAggggAACCCCAAALxBY776+eV6EduB7pydskrn4lT0nF//aApQ4vsmdD60tKpqSfi3M+17QIDBbq1Wq0iIks9YFeq1aqZfd18nT59esfu3btfFZG3hO4zM7JToX//frVafW+43IWFhV/RWh8L/WxdREpbD5RSfz81NfXWhx566EsMNAIIIIAAAggggAACCCAwCoGKf31GRPmhui7UvfJ01LpbQe7zIrIndM/KTikdWfSUWRbNqw+BgQLdhYWFn9Za/7CIXNmxY8e2wDRoy/Xr169/7GMfuxr8u1ar1URktvXv37958+Z3m/cfe+yxt+/YseN3RORrzXta68rc3Nyy+e9z587d12w2g4OXX5ucnHy/53mfO3PmzJvuuOOOT4rIP2uV98lqtfpAHw7cggACCCCAAAIIIIAAAgjEFhgk83IrmdULIrLPrliLXFz2yuGJvthtK/INAwW6tVrt90TEBLj/R7Va/RdRIGu12t+IyFeIyJfe/va37wnvyZ2fn3+LUuovW0uTt2Z1FxYWLmqtNw9inpycfLcJcsN11Wo1M0N8t4isz87OTnXbFxyljVyDAAIIIIAAAggggAACCEQRGCTzsn0Or10f+32jjID7mkED3c0MY0qp2dnZ2XO9mnHu3LmvbTabr5jrlFI/Mzs7+7B9T61Wuywi3ykizWq1Omner9Vqr4vIbhH5fLVaNYmotr1qtdqjIvJ4q9xvm52dNQE4LwQQQAABBBBAAAEEEEBg6AL9ZF5uBcgm39HWkmUt6onwfl8RdanulY4MvQM5rKDvQPf06dOl3bt3N4xJs9n8jsnJya/WWpvZXZM1+T/dvHnz/w0vWTbXnTt37nuazeavmf/WWh+dm5t7zhG0nhWRHzc/L5VKb3n44Yf/ZmFhodm6brFarZ6071lYWDiktf5M6+cfqlarP5vDsaJLCCCAAAIIIIAAAgggkEKBfjIvH/fXp5Xop0Pdea7ulY/2EzSnkGTsTeo70F1YWPh2rfVvt3pg9uBunR3V+tlNrfXc3Nzc+aCXtVrt34jIJ8y/XUuQzc8XFhZOaK1/sRUMv2/Hjh1/vrGx8d9aZfxotVr9KVuttVf3y62fP1atVk1mZl4IIIAAAggggAACCCCAwNAF+sm8XPEbZm/uwaBxWtTJZa+0WPEbiyLy4O1Ga6/uTW3FVEPvTE4qGCTQPaW1XggclFJ/r7X+ryJyj4jsDfnMVKvVzfTY8/Pzc0qpj7eC2LfOzc39te1Yq9W+V0R+tXXNd01OTv55s9n8vPm3UurDs7OzT7nsa7VacF7vT1er1Y/kZHzoBgIIIIAAAggggAACCKRcIG7m5VamZRPoBq+rda+8uYT5hN84qkWeDb23UvfKW6fYpJwiNc3rO9Ct1Wom2/EHWz3Ztly4dezQL7SSSt0slUp3f+QjH/niwsJCVWs9b+4xy5LNz2yJ8PLmiYmJ77158+bnJyYm/tRVT/jeINDVWj81Nzf34UGEX3rpJWcwPUiZ3IsAAggggAACCCCAAAL5FPijV//B3c+ufGVwEozs2XXzbx/5R6/+cqfefvIPv+rb/+QLb/rm4P2v+8rrL/0v7/2rzVNm3lifLJ37zXu2HU906p+8sri7tGGOV83s6x3veMeHRtn4vgPd8+fPv7XZbL5NRNZOnToVBKJbbZ+fn/8RpdTmMmOl1MnZ2dnF8IzuxsbG2z760Y9uJqYKv+bn5+9XSl00P9Nab5vR1Vo/Mjc396QLKMkZ3ZdeeulprXXks69GOWDUhQACCCCAAAIIIIAAAukSuH5jQj7+m2/f1qgf/77Vjo0015p7gtcHv+Wv5Zve+vdb/37qt+6Wv3q91PH9dPU+UmuuvvOd7wyfExzppkEu6jvQ7VXp6dOnp3bv3n2tdd0nqtXqD4f36E5MTHzzqVOn/otdTq1WM+vRzbp0E+jae3R/rFqt/qR9z+OPP757cnLSZGY2r4H36H7uc5/7oV79430EEEAAAQQQQAABBBBAIBD4+P+z76fWb06YY1Q3X9//ni/+5HvufuMvbKHnX3rzwd/+sz3/Ovj55IS+9iPf/fJM+Lpf+PTdH/zz16a+K/jZN3zV3//HB77lC/9XlrXf9a53jTRh8NACXTMItVrthojsUEr9xuzs7AfC+29FZLparV5wBLpmo/UjrUD3rdVq1Sx53sy6rLX+5bm5uR+075mfnz+slHre/LzbPt4sPxi0HQEEEEAAAQQQQAABBNIrYGdeDpJL2S1uTzYlF+peedtqUnufrhJ9ecmbOpze3qevZX0Fuq2jhf5WKWXm2x+dnZ3dzKQcfvm+v2djY+O1VvD55Ozs7COPP/74PZOTk5vfaiilfm52drZt5rRWq/2OiHxbh3N0/6xarX69Izj+tyLyE61y3z87O2vK4IUAAggggAACCCCAAAIIjETghN84o0VOB5WZM3GXvdK2mVrzXsVvmBhpaxmvkuaRJW/X5v7c4PWAf23fpEyYM3aD11rdK4cT/o6kT1mupK9A13S4Vqv9XSu78urs7OzXKaWCrMebHvPz8/9eKbU5Ja+U+sHZ2dnNzdih+25OTEy89dSpU6ac4J73KKVeNP/QWv/B3Nzct7buMeftfr/572az+YFHH330N4J7gqBbRO4QkfXZ2dkpuy1ZHiDajgACCCCAAAIIIIAAAukXiDIL68iofKXulfe5esd5uoONed+B7sLCQl1rfbxV/SWt9f9kjgv61Kc+NXnlypXTSqkfa733F9VqdWtndq1Wq4nIbOu9Fa31h+fm5j7dWtb88yJyd+u9E9VqtW7++9y5c/c1m83gW46rSql/9ba3ve1XXnnllXc3m02TnCqYxv9ktVp9YDAS7kYAAQQQQAABBBBAAAEE4gk4ZmGl7pW3xVsVv2GS7t4flNxp1te8by+FViLHlrzyZtJeXr0F+g50W8mmrojIW4JqWmfpvilU7Xqz2fy2Rx999DPBz06fPr1j9+7dr4bvMxO1raOIgss+Xa1W3xdufq1WMzPCPxD6mX3Pl3bt2vU1Dz300Jd6d5srEEAAAQQQQAABBBBAAIFkBSp+w6RavncrPgotS5729Z4bsr65tTN4aVGHlr3SiqsVx/3180r0Zu4i81IiZ5e88plkW5zf0voOdA3JY489dteOHTt+2iw1twJVE4T+VqlU+kHXBc8L3gAAIABJREFUWbmtLMlLwXJkK3j9D2+88cbM2bNnb257CLRWtVrNzBT/qElwFX5PKfXbzWbzB8yMcn6Hip4hgAACCCCAAAIIIIBAmgXaE01pr+5NmWS7ctxfn1ainw61/8W6Vz7YqT/29SSkijfyAwW6QVVmufKrr776jmaz+Y1KqT92navrapa575VXXvkmrfXXx7mvVqvdq7V+z8TExCuvv/76Z+2gOB4BVyOAAAIIIIAAAggggAACgwt0C07tZcsit4NgV83H/fWDSvQLofdW6155/+CtLEYJiQS6xaCilwgggAACCCCAAAIIIIBAZwHX8uSdUtrMlmwvWzY/X/TUWjfPit/YlvDX3vPLWHQWINDl6UAAAQQQQAABBBBAAAEEEhJwJJw6qaS5R0T5oSrazs51VV/xG2b/7oHgPddRRAk1O3fFEOjmbkjpEAIIIIAAAggggAACCIxLwHGEkJm1Nf+3dYxQ1IDVFTQve6XFcfUtS/US6GZptGgrAggggAACCCCAAAIIpF7APhoo3OA4SaVO+I0zWuT07RldMi9HHXwC3ahSXIcAAggggAACCCCAAAIIRBBwJJIK7rqqRR3udKSQXbQ9OxwnSI7QzFxfQqCb6+GlcwgggAACCCCAAAIIIDAOgVawe0lE7mrVb4LcmThLj8m83P/IEej2b8edCCCAAAIIIIAAAggggEBHgQf8a/smZPLwhOh9N6W5+Iy3azUuF5mX44rdup5Atz837kIAAQQQQAABBBBAAAEEhi5A5uX+iAl0+3PjLgQQQAABBBBAAAEEEEBg6AJkXu6PmEC3PzfuQgABBBBAAAEEEEAAAQSGLmBnXtainlj2SjNDrzjjFRDoZnwAaT4CCCCAAAIIIIAAAgjkV4DMy/2NLYFuf27chQACCCCAAAIIIIAAAggMXcAktJqUiZdDFa3VvfLeoVec8QoIdDM+gDQfAQQQQAABBBBAAAEE8i1Q8RtroWOKZEOa+/vJ4Jxvpe29I9At0mjTVwQQQAABBBBAAAEEEMicwAn/+iUt6r6g4Urk2JJXvpi5joywwQS6I8SmKgQQQAABBBBAAAEEEEAgrsBxf/28Ev1IKNA9u+SVz8Qtp0jXE+gWabTpKwIIIIAAAggggAACCGRO4Li/Pq1EPx1q+HN1r3w0cx0ZYYMJdEeITVUIIIAAAggggAACCCCAQFyB4/76QSX6hdB9JKTqgUigG/cp43oEEEAAAQQQQAABBBBAYMQCFb+hw1WSkKr7ABDojvgBpToEEEAAAQQQQAABBBBAIK4ACaniiRHoxvPiagQQQAABBBBAAAEEEEBg5AIn/MYZLXI6qFiLemLZK82MvCEZqZBANyMDRTMRQAABBBBAAAEEEECguAIn/MZRLfJsSGCl7pUPFVeke88JdHkyEEAAAQQQQAABBBBAAIGUC0z7es8NWX8t3MydUtq76Km1lDd9LM0j0B0LO5UigAACCCCAAAIIIIAAAvEEKn5jRUQOBHcpkWNLXvlivFKKcTWBbjHGmV4igAACCCCAAAIIIIBAxgWO++vnlehHQt24UPfK0xnv1lCaT6A7FFYKRQABBBBAAAEEEEAAAQSSFTjhXzusZeL5UKmrda+8P9la8lEagW4+xpFeIIAAAggggAACCCCAQAEEOE832iAT6EZz4ioEEEAAAQQQQAABBBBAYOwC9nm6WtTJZa+0OPaGpawBBLopGxCagwACCCCAAAIIIIAAAgh0Eqj412dElB96/7m6Vz6K2HYBAl2eCAQQQAABBBBAAAEEEEAgIwLH/fWDSvQLoeau1b3y3ow0f2TNJNAdGTUVIYAAAggggAACCCCAAAKDC1T8hjk7966gJC3q0LJXMkcP8WoJEOjyKCCAAAIIIIAAAggggAACGRKo+A1zdu79t5usvbo3dT5DXRh6Uwl0h05MBQgggAACCCCAAAIIIIBAcgLs0+1tSaDb24grEEAAAQQQQAABBBBAAIHUCLBPt/dQEOj2NuIKBBBAAAEEEEAAAQQQQCBVAuzT7T4cBLqpelxpDAIIIIAAAggggAACCCDQW8Dep6tEzi555TO97yzGFQS6xRhneokAAggggAACCCCAAAI5Ejjur08r0U8HXVKiLy95U4dz1MWBukKgOxAfNyOAAAIIIIAAAggggAACoxd4wL+2b1ImXg7XXPfKxHctECBG/0xSIwIIIIAAAggggAACCCAwsEDFb6yKyL1BQUqaR5a8XZcGLjgHBRDo5mAQ6QICCCCAAAIIIIAAAggUT6DiNxZF5MGg51rUE8teaaZ4Eu09JtDlKUAAAQQQQAABBBBAAAEEMihg79MVkZW6Vz6Uwa4k3mQC3cRJKRABBBBAAAEEEEAAAQQQGL7AtK/33JD118I17ZTS3kVPrQ2/9nTXQKCb7vGhdQgggAACCCCAAAIIIIBAR4GK31gRkQPBBUrk2JJXvlh0MgLdoj8B9B8BBBBAAAEEEEAAAQQyK3DcXz+vRD8S6sCFuleezmyHEmo4gW5CkBSDAAIIIIAAAggggAACCIxa4IR/7bCWiedD9a7WvfL+UbcjbfUR6KZtRGgPAggggAACCCCAAAIIIBBDoOI3dPhyLerQslcyS5oL+yLQLezQ03EEEEAAAQQQQAABBBDIg0DFb5g9ufff7ov26t7U+Tz0rd8+EOj2K8d9CCCAAAIIIIAAAggggEAKBCr+9RkR5Yea8lzdKx9NQdPG1gQC3bHRUzECCCCAAAIIIIAAAgggMLjAA/61fZMy8XK4pLpXLnSsV+jOD/5IUQICCCCAAAIIIIAAAgggMH6Bit9YFZF7g5YU/ZghAt3xP5O0AAEEEEAAAQQQQAABBBAYSIBjhrbzEegO9DhxMwIIIIAAAggggAACCCAwfoETfuOoFnk21JJCHzNEoDv+Z5IWIIAAAggggAACCCCAAAIDC1T8xpqI3BUUVORjhgh0B36cKAABBBBAAAEEEEAAAQQQGL+AfcyQEjm75JXPjL9lo28Bge7ozakRAQQQQAABBBBAAAEEEEhc4Li/Pq1EPx0qeKXulQ8lXlEGCiTQzcAg0UQEEEAAAQQQQAABBBBAoJfAtK/33JD118LXbUhz/zPeLpORuVAvAt1CDTedRQABBBBAAAEEEEAAgTwLnPCvX9Ki7rvdR+3Vvanzee6zq28EukUbcfqLAAIIIIAAAggggAACuRWo+NdnRJQfdFCJvrzkTR3ObYc7dIxAt2gjTn8RQAABBBBAAAEEEEAgtwIP+Nf2TcrEy+EO7pTS3kVPmYzMhXkR6BZmqOkoAggggAACCCCAAAIIFEGg4jdWROTA7b4Wb/kygW4RnnT6iAACCCCAAAIIIIAAAoURsJcvi0jhsi8T6BbmcaejCCCAAAIIIIAAAgggUAQB1/LlomVfJtAtwpNOHxFAAAEEEEAAAQQQQKBQAkVfvkygW6jHnc4igAACCCCAAAIIIIBAEQSKvnyZQLcITzl9RAABBBBAAAEEEEAAgUIJFH35MoFuoR53OosAAggggAACCCCAAAJFEaj4jYsicn/QXyVydskrnylC/wl0izDK9BEBBBBAAAEEEEAAAQQKJ3DcX59Wop8OdXy17pX3FwGCQLcIo0wfEUAAAQQQQAABBBBAoHAC077ec0PWV0Xkrtuzus0jS96uS3nHINDN+wjTPwQQQAABBBBAAAEEECisQMVvLIrIgyGAC3WvPJ13EALdvI8w/UMAAQQQQAABBBBAAIHCCpzwrx3WMvF8GGCnlPYuemotzygEunkeXfqGAAIIIIAAAggggAAChReo+A2zfPneAEKLOrnslcxMb25fBLq5HVo6hgACCCCAAAIIIIAAAgiInPAbZ7TI6ZDFSt0rH8qzDYFunkeXviGAAAIIIIAAAggggEDhBVxn6mpRh5a90kpecQh08zqy9AsBBBBAAAEEEEAAAQQQaAnYZ+qKSK6TUhHo8ugjgAACCCCAAAIIIIAAAjkXKFpSKgLdnD/QdA8BBBBAAAEEEEAAAQQQMAJ2UiolcnbJK5/Jow6Bbh5HlT4hgAACCCCAAAIIIIAAApZAxb8+I6L80I9X6155fx6hCHTzOKr0CQEEEEAAAQQQQAABBBCwBKZ9veeGrJujhu4K3srrUUMEujz+CCCAAAIIIIAAAggggEBBBCp+w5yf+2Cou4kdNXTCbxzVImbGeK0VQI8tqzOBbkEeaLqJAAIIIIAAAggggAACCLiOGlLSPLLk7bo0qE7Fb7wmIntMOUr05SVv6vCgZfZ7P4Fuv3LchwACCCCAAAIIIIAAAghkUKB9VlddqnulI4N0pTWb+2xQBoHuIJrciwACCCCAAAIIIIAAAgggEEvguL9+UIl+IXzToLO6jiXRYz2nlxndWI8EFyOAAAIIIIAAAggggAAC2Rc44V+/pEXdd7sng83q/v/t3X2YHVV9B/DfmXvZZHl2Q9RHEYSA8mJJLS8VrUifhrWtL6WKICAl2IrWgo3G3TtnluBLNyuWJjtn7kKQ2rRasQUUFIp9s1pLoK34glIKilisGg0UbSkmm5Bkc+85fX7XM9vZm/syM3du7uy93/kHsnfu3DOfc87M/Oa8Rbst8zEF0fk3Tyy7q1dSCHR7JY/fhQAEIAABCEAAAhCAAAQg0COBy2b3nmPI2Rb9+SrpF35qYphnZU601XdbJqKdt0wsq43V7dWGQLdX8vhdCEAAAhCAAAQgAAEIQAACPRQ4uFWXUnU3zlu3ZSZFoNvDgoWfhgAEIAABCEAAAhCAAAQg0CuBLFp17dq8PNvywtbrbssIdHtVovC7EIAABCAAAQhAAAIQgAAEciCwdnY/r3V7WiQpiVp1187uGycSvHZuuG2/ZWLZ8b0+NbTo9joH8PsQgAAEIAABCEAAAhCAAAR6JHDp7PxbBZmPR38+yVjdtbP7v09EC4GtIXH9rRND4z06nYWfRaDb6xzA70MAAhCAAAQgAAEIQAACEOihwNrZ/TwB1XGRJMRq1c2i63O3ThuBbrdkcVwIQAACEIAABCAAAQhAAAJLQCBtq26DSaj+/ZaJZafn4ZQR6OYhF5AGCEAAAhCAAAQgAAEIQAACPRRI2qp7yeze4wvkcLflhc2QuPzWiaGbengaCz+NQDcPuYA0QAACEIAABCAAAQhAAAIQ6KFA0lbdS2fnrxNk3hNJci4moQrTg0C3h4UJPw0BCEAAAhCAAAQgAAEIQCAvAnFbde2SQtyauzISWE7fPLFsY17OBYFuXnIC6YAABCAAAQhAAAIQgAAEINBDgUatuoL02M0Tw/dEk9WgNXfnYTR0/E0T4qc9TP6in0agm5ecQDogAAEIQAACEIAABCAAAQj0WKBBq+6Dh9HQWBjENhqbK4hy1ZrLhAh0e1yQ8PMQgAAEIAABCEAAAhCAAATyInDZ7P43GqK/qkvPTbdMLLuc/7Z2dn4bkTkn8nmuxuaG6UKgm5cShXRAAAIQgAAEIAABCEAAAhDIgcDa2f13EdF50aQYorsEiZV1QS416tqcg1NAi24eMgFpgAAEIAABCEAAAhCAAAQgkBcBO9nUg0R0XKs0GRLX3zoxNJ6XdEfTgRbdPOYK0gQBCEAAAhCAAAQgAAEIQKCHApfOzp8uyPAkVEc0ScYnbplY9tYeJrHlTyPQzWvOIF0QgAAEIAABCEAAAhCAAAR6KMDBrkP6OkNiTV0yPnEYDY3naZbleiYEuj0sOPhpCEAAAhCAAAQgAAEIQAACeRfgCaqI6HROpyZx160TQ9ytOdcbAt1cZw8SBwEIQAACEIAABCAAAQhAAAJJBRDoJhXD/hCAAAQgAAEIQAACEIAABCCQawEEurnOHiQOAhCAAAQgAAEIQAACEIAABJIKINBNKob9IQABCEAAAhCAAAQgAAEIQCDXAgh0c509SBwEIAABCEAAAhCAAAQgAAEIJBVAoJtUDPtDAAIQgAAEIAABCEAAAhCAQK4FEOjmOnuQOAhAAAIQgAAEIAABCEAAAhBIKoBAN6kY9ocABCAAAQhAAAIQgAAEIACBXAsg0M119iBxEIAABCAAAQhAAAIQgAAEIJBUAIFuUjHsDwEIQAACEIAABCAAAQhAAAK5FkCgm+vsQeIgAAEIQAACEIAABCAAAQhAIKkAAt2kYtgfAhCAAAQgAAEIQAACEIAABHItgEA319mDxEEAAhCAAAQgAAEIQAACEIBAUgEEuknFsD8EIAABCEAAAhCAAAQgAAEI5FoAgW6usweJgwAEIAABCEAAAhCAAAQgAIGkAgh0k4phfwhAAAIQgAAEIAABCEAAAhDItQAC3VxnDxIHAQhAAAIQgAAEIAABCEAAAkkFEOgmFcP+EIAABCAAAQhAAAIQgAAEIJBrAQS6uc4eJA4CEIAABCAAAQhAAAIQgAAEkgog0E0qhv0hAAEIQAACEIAABCAAAQhAINcCCHRznT1IHAQgAAEIQAACEIAABCAAAQgkFUCgm1QM+0MAAhCAAAQgAAEIQAACEIBArgUQ6OY6e5A4CEAAAhCAAAQgAAEIQAACEEgqgEA3qRj2hwAEIAABCEAAAhCAAAQgAIFcCyDQzXX2IHEQgAAEIAABCEAAAhCAAAQgkFQAgW5SMewPAQhAAAIQgAAEIAABCEAAArkWQKCb6+xB4iAAAQhAAAIQgAAEIAABCEAgqQAC3aRi2B8CEIAABCAAAQhAAAIQgAAEci2AQDfX2YPEQQACEIAABCAAAQhAAAIQgEBSAQS6ScWwPwQgAAEIQAACEIAABCAAAQjkWgCBbq6zB4mDAAQgAAEIQAACEIAABCAAgaQCSzLQDYLgZCI6g4h+tGvXrgemp6f3JT1x7A8BCEAAAhCAAAQgAAEIQAAC/SmwZAJdY4xQSl0jhLiaiJy67PhysVg8f3x8/Mf9mU04KwhAAAIQgAAEIAABCEAAAhCIK7BkAt0gCO40xpwfObF5IhoK/y2EeGb58uVHrlu3bnfck8d+EIAABCAAAQhAAAIQgAAEINB/Aksi0C2Xy2u01vdY/qcLhcLZExMT3964cePhIyMjtxHRb9rPbpNSXtJ/2YQzggAEIAABCEAAAhCAAAQgAIG4Aksi0A2C4C5jzHl8UoVCYTUHudETVEo9TkRHE9G867rLhRAmLgD2gwAEIAABCEAAAhCAAAQgAIH+ElgSga5SahcRjRLRY1JKnohq0aaUmiSizfxHIcRZrut+pb+yCWcDAQhAAAIQgAAEIAABCEAAAnEFch/o8iRUQRBoe0I3SSkvrz+5IAjOMMY8YP9+hZTyT+MCYD8IQAACEIAABCAAAQhAAAIQ6C+B3Ae6s7OzR1Wr1Scs+/uklNfWZ4Edq7vH/n2TlJJnZsYGAQhAAAIQgAAEIAABCEAAAgMokPtAt1wun6i1fozzRghxpeu6Wxvlk1IqHJd7g5Ry/QDmJU4ZAhCAAAQgAAEIQAACEIAABDh2zLvCzMzMCY7jfNems2m35DDQNcZs9Tzvyk7O67777nts//79J3ZyDHwXAhCAAAQgAAEIQAACEIAABIgcxzFr1qxxDqVF7gPdaIuuMeY9nudtaQSUZYsuAt1DWQTxWxCAAAQgAAEIQAACEIBAPwsg0G2Qu3VjdD8gpfxQ/W6bN28eLRQKPDMzb5mP0d22bdvNRLSWiC4bGxu7pZ8LIc4NAt0Q2LZt2/uJ6Boi+tDY2NgHuvEbOCYE+lng7rvvfpMQ4jNEdMfY2NiF/XyuODcIdEPg3nvvPUVr/QgRfXtsbGx1N34Dx4RAvwts27atNlR0bGws942lnM7cJzI667Ix5g7P8w66wfu+f44QYlvthFqM401b+BDoppXD9yDwMwEEuigJEOhMAIFuZ374NgQQ6KIMQKBzAQS6nRsedITIOrrfk1KeUL+DUipsLeJA92zXde/LMhkIdLPUxLEGUQCB7iDmOs45SwEEullq4liDKIBAdxBzHeectQAC3axFiUgp9VkiegMfWmv9msnJyS+EPzM1NTU0Ojr6FBGNENG867rLhRDhDMyZpAaBbiaMOMgACyDQHeDMx6lnIoBANxNGHGSABRDoDnDm49QzE0Cgmxnl/x+oXC6v0VrfY/+yUwjxjmOPPfbOHTt2rNZa8+RU59jPbpNSXpJ1EhDoZi2K4w2aAALdQctxnG/WAgh0sxbF8QZNAIHuoOU4zrcbAgh0u6H6s1bdO4jogsjhNRFFp6jePTw8fNS6det2Z50EBLpZi+J4gyaAQHfQchznm7UAAt2sRXG8QRNAoDtoOY7z7YYAAt1uqBIRT0qllJoSQryPiIrRnxFCfElrfYHneT/pxs8j0O2GKo45SAIIdAcpt3Gu3RBAoNsNVRxzkAQQ6A5SbuNcuyWAQLdbspHjKqWOM8ac6jjOjl27dj08PT1dOQQ/i5+AAAQgAAEIQAACEIAABCAAgSUgkPvlhZaAIZIIAQhAAAIQgAAEIAABCEAAAjkSQKCbo8xAUiAAAQhAAAIQgAAEIAABCECgcwEEup0b4ggQgAAEIAABCEAAAhCAAAQgkCMBBLo5ygwkBQIQgAAEIAABCEAAAhCAAAQ6F0Cg27khjgABCEAAAhCAAAQgAAEIQAACORJAoJujzEBSIAABCEAAAhCAAAQgAAEIQKBzAQS6nRviCBCAAAQgAAEIQAACEIAABCCQIwEEujnKDCQFAhCAAAQgAAEIQAACEIAABDoXQKDbuSGOAAEIQAACEIAABCAAAQhAAAI5EshNoLt169bDdu/e/VIiOs5xnIfGx8cfFUKYdlZBEJxMRGcQ0Y927dr1wPT09L523wk/D4LgMq31Ts/z/qbddzh9e/bsOa1arZ5YKBQePuaYYx69+OKLq+2+F+fz2dnZoyqVyssLhcJ+IcRXJiYmfhrne7xPuVz+eWPMyyqVyhevuuqqHXG/h/36TyBtHeqk/Pm+/2tCiBfMzc19cnp6ej6OajfLbJL0dLNOx3HAPvkUmJ2dPaVSqZxWKBS+t3Pnzofi3FM6qUNJ6oMts2dUq9UXFQqF7xLRt0ql0t4sJOPWB2NM7OeGOPfwLNKOY+RLgOuD1vqVWuuni8XiA3GeaTZv3jzqOM7LHMd51oEDB+7fsGHDD+OeVdw61K7sdlpe49ahVudVLpdfboxZfeDAgbuTGMS1wn5LQyBNHeqk/G3ZsuW5Bw4cOFcI8c1SqfT1eqV2dSe6f6f1KOu4LvYNq1tFw/f95xHR3wkhzqz7jYoQwh8ZGZm64oorDkQ/Y3Cl1DVCiKuJyKn73peLxeL54+PjP26V5pmZmVc7jvN5ItJSykKzfbds2bJi//79nxRC/EbdPtoY82crVqx4d3364loppd5IRH9JRCN133nSGPNGz/O+2u5YSqnHiOhEIgqklLLd/vi8/wTS1CFW6LT8bdy48fCRkZE5roNa61+enJz8UhzdbpXZuOnpZp2Oc/7YJ38CU1NTxdHR0a1E9Nb6e4oQ4rNa69/zPO8n9SnvtA7Zetj2Gn7jjTeOPPPMM7c1ug8R0WcKhcIVcYKJRvJJ64NSil/w1t93G2aqEOJK13XZFdsACCilfo+Iriei5XWn+4jW+i2Tk5MP1DPwi6Vqtfq3RPSius/2GWPe5Xnex9rRxbmnzM7OHl+tVr/f5lj3SSnPbvd79Z8nrUPNjm/T+J+2fl0vpRxPmhbsv7QF0tShLMqf7/t/LIR4JxE9LKU8tcG97ltEtDqOrjHm7z3POzfOvuE+3YzrehrozszMnOA4ziNENBQB4RbZhYukEOILruu+JgoWBMGdxpjzI3/jlqSFYwghnlm+fPmR69at290IetOmTUcUi8WHiejYVoGuffh5nIg4GA+3Rekjoq9JKX8pSYbyvr7vv10I8dHI9yr24rbwAGGMeUWrYLfuGAh0k2ZCH+yftg5lUf6UUncQ0QXMGDfQ7WaZjZOebtbpPihOA3kKt99+e+GHP/wht44eHwLwPcQYc3gE5GnHcV4QbT3Nog7FqQ82fU/U3Yf4flGMpO9R13VXJ32TnqY+JAx0Pdd11UAWrAE7aaXUx+2LouizEj+Xhc803Dhwhud5D4U7lMvlE7XW36l7cbKobAshNrquO92MM04d4u8qpdYS0c1tsuVBKSX3EIy9palDjQ7OD/pBEPyHbbjgXRDoxs6F/tgxTR3KovwFQXCGMeYrNo5qFuh+k4h+Pqb0PVLKsZj71nbrZlzX00BXKXUvEf2KxfDn5ubez90fGV1r/XkhxHP5MyHExa7rfpr/v1wur9Fa32O/83ShUDh7YmLi27Y15zYi+k372W1SyktCaA4IhBDcLfr1xpi3E9Go/axpi65Sim/Qrt3va5VK5dUbNmzYuWnTplXFYvE+InoBf2aMWet53q1xM5Xfzu/du/cpW6i0EOISPj9+oNm+fXtJCDFjj/WklPKo8Lh8jitWrHiJ1voUInpbxK5WTtCiGzcH+me/NHUobfnjlmMhxMnGmLOEEL8fDQyaBbrdLLNp0tOtOt0/JWrwzkQpNUlEm+2Zf7VQKLyWW0e5K9f8/PxdRPRKe52/2fO8t/D/p61DaepDEARTxpiNNn2fmpub+x2+T/q+f44QYgsR/YJN3+/Gaf2K5nCa+jAzM3N6sVg8ollJ0VrfYNM0X61WT8CQmv6vU+Vy+Re01mEAu/Bcxg/hIyMjm4UQJavwhJSy9tzEm1KKv1Mrv/wMMzo6ejX3kPN9/1VCiM+Fz0iO46wqlUrc6EBp6lDt4EFwA7cQE9H2YrHYsHFi3759+/gZL0mOpalDjY4fBMEmY8xVkc8Q6CbJiCW+bwd1KHGcwi9VfN/n4TmrjDGXEtFFkZdNzQJdjp8WXgbXc2utufHxPfZexD1SPxs3S7od1/Us0OX+59Vqld9Sc6B4UDO3banit+y8LQStQRDcZYw5j/9YKBRWc5Bbd+Pmi+HRRDTvuu7y8A23Uup/iOg5DeBbBbrhd3avWrVqZXRMrn3I/i+xixyIAAATXElEQVRbOBK16kbfQBpjJj3P8+vOgYPm3+K/aa3PmJycfJD/v0ELQvRrCHTj1qo+2S9tHUpb/qJ1r8FFrmHX5W6W2TTpiVwHMq3TfVKkBvI0lFL/S0TPIqKdrus+K9oqat+Wc5dl/nzhxWPaOpSmPiileO4FDg5+IKV8YTSTbMDNwwf4ProQiMfNyKzrQ53Lr3qed3fctGC/pSuglOJ5TmqNDIVC4YUTExM/iJ6N7/s8PK02/Ktara646qqr5uwzVDjE7J+llGsWPdAEwZuNMZ+yZXva87zay540dYi/p5TiFisOcD8jpeQH+0y2LOpQuVw+U2t9Pz/y8bOr7dWIQDeTHFoaB0lTh2y5ThynzM7OrqxWq083kWkY6LZStMMP+KVVUQix2XXdDUnUux3X9SzQtW+jtzGGEOJs13W5hXTR5vv+T2yr7mNSSp50ii9Wu2xr7MLfol+Kvp0XQpzlui5f3Ph7PN71pMi+w/Zi0jDQLZfLL9Ba1yZ3EkJ82HXdd9enL9Ka1nKcb4Pz+pwQ4rV8URsdHV1eP8Z3ZmbmJMdxuAsL//ZCofF9/zwhBHcPim78AMYbAt0kNasP9k1bh3zfT1X+lFLXEdFvR+i462StZ0SzFt1ultmk6elmne6D4jSwpxDpiutLKbl1d9GmlOLeRBfyH6WUtXtm2jqUpj6E6WvWhVMpxZNR8Uvdf3FdN+wh1TY/s64P9mGd77OOMWaD53lhK3nbtGCHpS2glOIGh59rMb6Pe0L8BZ+lMebXPc/7YhAE64wxH47+rV4hCII9dgjBQ1LK02zdS/UcpJTiST6PEEK4ruuWsxDPog5NTU0NjY6OcqPPc4QQ7zfGXGGH1SHQzSKTlsgx0tShtOWPJ34rFArb62i4lw4PM0gU6EaOxS+JE92Dwt/vdlzXs0A3iLytGx4eHm00njZykfuqlPIVdgwDv/Hi7SYp5eUNLozc1zyc8OAKKeWfNirnSqn3E9E1zcbolsvl12qtuesMX5gbNsMrpXjcyB/wPkNDQ89bv379f8epU5GJE7ZLKRt2BVBK8QRcHEj8rZTy9c2Oq5Tab7v3INCNg99H+6SpQ3z6WZU/nulSa83jNmKP0bW/35Uy2y493azTfVSsBupUoi2i/BJHSsmTAy7alFL8QvYcbmmRUi7Lsg61qw9TU1PLV6xYwd2T+aXnDaVSieeWWNhmZmZ+0XGcb9j71ITnefwyKtaWZX2wE4n82L6YfkRKGXcsV6y0Yqd8Cyilwp50DVtLgyCQxphazzXHcU7lcuz7/p8IITioo7m5uWWNZu33ff9+O1Hp01LKZ6d9DrLBJN93aveqQqHwfGMMt+7yxGr3VyqVf0raZZmPlUUdUkpxq/WbiehRKeUpSimebZrnj0Ggm+9in2nq0tShLMpfeBJKKW5sPCtpoBtpja1Uq9Vnc2+NJDCHIq7rWaDLEDwmlf/baJmeyKzICy2q0a6aRPQ+KeW19aB2rO4e+/dNUkqemfmgrV2gq5TiMYg38hcbdZHmv/PyRMaY2oNRu4mjogkI3ywSUdMZ/pRS3KWHJ8FqOTkCAt0kVar/9k1ah1ggq/LXLrBM+1CSNpfapaebdTptmvG93gvwjfbTn/600+g+dO211z5naGjoSfvSMdqzqNY61KtrOHc9q1Qqb3IcZ4tt8ZqvVCrPS/KwnmV9UEq9l4j+0AYyv1Qqlb7W+5xFCg6VQFiHLrroIp5z5KBlIZVS3EONe9Rp13W5e6NRSv09Eb2OiPZJKbmHXaPnNJ535WIiqkgpD0t7TwmC4JXGmHBVAB6DWz/GvGKM8ZK8KLL30o6eE33ff70Q4q9tl+UXSSm3I9A9VKU2X7+Tsg51VP7q4pLEga6dxKrWsGiMucbzvFrDX5LtUMR1PQ10m2HYmfj+zS67o6vV6nE8oYX9Oy/FwMFv02ULlFLhhfYGKeX6JhfQli26vu974aRQxpgjmywtwRdpvlhzJscejxS2VLeaglspxVPM83T735FScpeghhsC3SRVanD2bVaHWCCr8tcusDzUZbZderpZpwenZA3OmZbL5WGtNXfFDSd7+i3P82pjBrOqQ/ZhOVEPh0hPpzAz9lWr1ZOSTvqUVX2wqxjwODEOYFJ1XRucUjV4Z6qU4u7J6+yZf0pKWZt/JDL0a6eUcmWT5zRemoqXLFoYNtBkv5Z1KAiCkjEmCL9rZ1XnZ6xj7Pj78KNxKSUvjxRr66QOlcvlZ2utuSWcVxlZ+F0EurHoB2qnZnWok/JXD5imRVcp9SgRvZjr08jIyMo0S60eirgud4GuXZeQx0TVlk4QQiwsT1A3QVWrbsm1QNcYs9XzvCubXBhbBrrRrjbNuiVHuw04jvO6Uqn0D3FqX/ig0mjppPD7ke6l35VSRscWL/oJBLpxxAdrn1Z1KPqQ3mn5axdY5i3Q7WadHqwS1v9nayfX4ImUnm/P9otSyl8Pz7yX1/DIsJZoRjxVKBTOrJ8EqFVOZVUffN//SyHEZfxbWuuTJycnay+jsQ22AK/taWctD5cZeaparb4w7NoYGRIwJ6Vc0Ugr2r05HB/f5HmuZaCrlApbhvnri54d7bJDPH6YxydWhoaGjo47DK2TOqSU4hZmntH9G1LKMyPPfui6PNhVZ+Hs29WhTspfp4FuEAQXGWNut7HWezzPqw2xSbodirguN4GunQWM0RYeJowxi/CikX/9Z1HcrFt0q9XqsY3eltuJRXj5iYUWXfsAFF0XeCFpdqzv30XeyP+jlPLVTS7cPGvhcWjRTVptBnf/OHWIdbIqf90KdO0DwMsb5aQQ4k8aTQzH+7ZLT/TtZ5I6PbglavDOnLuPlcvlP+JujJHlFu50XffCaJfMrOoQC6d5WWnTeZId9/gGm1PRrtX8EN2yDmVRH+ys1DwZFr+YTjSJyeCVrsE5Y/sQzMEjt1bytn1+fv6l733ve3lZxdoWadFtGuhG1xXtJNC97rrrjtRa87jXn5ZKpXA1j4UM8X3/aiFEbSicEOJy13VvsnOwcJf8Rhv3tHtJ2joUmYirwku8TExM8AoeoQsC3cGpKk3PNE4dSlv+Gv1o0hZdpRR3WeY1pyujo6OHN2rNDYKA51b6lyYnyZPxjuzZs+c4rXXt5Wi34rpcBLq+719iZxMOL4pPaq1fFy6rEyLV9eX+gJTyQ/WAdgYwnpmZt0zG6DqO85JSqfSt+t9SSv0OT4plM+gVnud9NTKD50F5G663Gxkj+WUpZW2NxvotMuM0xujiotdWIG4dsg8Y4fjCjspfu8CyWaLbPdgrpbiurW7y/UXrY0f3aZee6JjEJHW6LT526AsB3/dPFULwUJRwnU9e5uNtUspbGlz7M6lDtj4m6rrc4F4RzqJO4cSOcepQFvUhOk8FEa2XUvIautgGVMC+bL2DiF4VIbh+1apVbv0Y+MgY3YVJ3hqU7c8IId7U6RjddtnBk76Njo7yCxvebpRSvkspxTMzTzT5bm2psTR1qFAo7NBaczDLLchXDQ0NLVpJY35+nid45DXrP3bYYYddvXfv3n1JJ/hpd774PL8CCevQwhjdTp9pkgS6do15XnaPXwx9wXXd1zQSVUrxKgD3NtOem5sbXrly5bPCpWaJqCtxXc8D3SAIpowxtfXRuOeTEOIPSqXStY0mNIjOzmWMucPzvNqSD9GtbsmVVuN4W3ZdVkotjL8lordKKT/R4GGHZ7gMF0iujeP1ff9cIUTD2QELhcIX+c1dOP7WGPPfnufxhFMHbWHA3GocL3+pXdCQ3+qMlGUlkKQO2TJTG//daflrF1g2O792ZdYuU3JKo+8LIb7pui6P3z9oa5eetHU6q3zCcfIr4Pv+q4QQ/xhpxb19aGjoHevXrw9fmi5K/KG6htvhMby6wH4pZXRpr4X02LT/E/9BCPEW13VvjlOHsqgPkVlx9fDw8BGNVk/Ib64jZVkK2IYInhX8Ofa4jwghznddt7ZUYoPnp4Xxt0NDQ0c0qmuRJVeajuPN6jkoHBIQPrhv3rz5mEKhEHa7rk/+/0gpP5emDhljTncc5/MJ7A9aPzvBd7HrEhJIUYdSxSlN6mPsyaiiK84YY97geR6vo33QxrOdr1ix4mKO3Rp9zvcq/nsQBLXVdLoV1/U00FVK8SQDfLHj7Qd8UWk3xiiy3tL3pJQnNLh4hgFs0/V57YWxZaBrL3I/sg8Pf+a6bm1ChOgWeQOSaB3dIAg+b4ypdVluNK1+9IGdl2xstLZjmI52QcMSquNIagqBNHUoq/LXLrBsdjrdKrPt0tPNOp0i6/CVnAgEQXCyMYbXAeUWln1a6/MmJye/0Cp5WdUhey9q2qLr+/7lQog/5/0KhcLR0S6OkXvAwlvzsNtlHNpO60PdCge1JQDj/C726T8B24WdZyevBblx1lFWSr2biMKls851Xbc2sWe42YaNZ2z355bd4lvdU+zSQk8JIbh+T7quW1tNI7rZVrSn+W9CiC2u69YaMNptaepQdEWRdse3n/9ISrkq5r7YbYkKpKlDacpfM54kLbpKqXBo5bzruryG+0EzrSfJhm7HdT0LdO1NksdrcHfl79lm97DrSFMjpdRniag2Jklr/ZroA0l4QbOzNbfMgHbLC/HxlVL/a2fkqziOc2SpVOJ/1zbbze3f7UX9657nvSxuxvq+/3YhxEftRfXD9WMOI2NX+KL7i81asGwaO+r2FjfN2C9/AmnrUFblr11g2eKC2pUyGyc93arT+SsdSFFcAaXU14nopbxOLhGdJqXkmSRbblnVoXbX8Lr7TMPJFX3fD7t3UrOx5y3qYup7XF23tA9KKafaueHz/hTwff+DQogP2OehtZ7n3druTHncbKVS4eCYt4Xx5eH3lFKTRLTZ/rtl+Wr38jRy3f+B67ovqn8w933/j4UQ77TPZBe6rsvdr2Ntae4pW7dubbpU0tzc3Pft8IkbRkdH3SeeeMJMT09XYiUGOy1ZgTR1yN4/Ul/Do1gJA11ef9oxxiSKfVrch7oa1/Us0PV9f1wIMWsvLOc6jtOwOyJ/XigU9oTdWsrl8hqt9T0WbKcQ4h3HHnvsnTt27Fittea3g+fYz5qO5bOFo2WLrt1HEZFrj/egMeZKOw6XuwtwoHq0/eyyRuO4mmXqjTfeOLJ3714O8nnSKm6yl9Vq9aPLli07vFKp8CQo4W/WxoG0qrntLvBLttYj4W0F0tahrMpfnMCy0Ul0q8zGSY9Sqit1um1mYYdcCszOzh5frVb5wZJboT5SLBavaZbQQqFQCWdjzaoO2ftM0xc/tlXricjsz1Ou617DD+p2PgoePvM2m+bHpZS8XErsrZP6EJ3xs1X3tdiJwY5LVkApNWcbGB4tFArR8bkHndP4+PiTYaCplHooXL6L5zupVCpTe/fu/cno6Ch30+eWV57kTDuOs6pUKvFSPA23dveUIAhuMcZcar98jzHmzTzUjNeh3759+1QYpBNR4tbTTupQk/sjJqNasjUhfcI7qEOZPNPEDXSjsyTzOHLXdX83/Vn/7Jvdjut6FuhGW2ZjIH1OSvkb4X5KKX7bdkHkexwscreUcNs9PDx8VKvxQnFadG1XAr64RsfR1v9Wqi5b0RaBZudvjKlNcNXKp90FPoYtdlmiAp3UoSzKX5zAssmNvGctut2s00u0GA10suPUgwjQonGCcb6bxTXcjre9P5pRdh3QwyN/qxhjTvY8rxa0x906qQ9KKV5T+M38W8Vi8fnj4+M/jvu72K9/BKIT08Q5q2gXfLuSxnfqnt/qn7GmpJQf7OQ5yE42tT36LNegDs1rrc+anJzk2WRjb53UoSb3RwS6sfX7Y8dO6lBW5S9uoOv7/qVCiNoEjUKI33dd9yNZ5EI347peBrphH+84RosCXX7LrZTit3DvC9fbDQ8ihPiS1voCflvX5sIYdotpOb7WvjXnAdPhEg7hYfli/JG5ubnxtN1KgiB4gzGGp+A/oi6tjzuO88ZSqcRd6lpukWUuAimlbLc/Pu8fgcg4iTgntagO8Rc6LX8zMzMnOY5Tm2hEa/3Lk5OTvKRJ261bZTZuerpZp9uePHbIlYBS6mORFtF2aTtoQpxO65Cth3uMMRy0Nr2G23HEvBbo6fWJ5AkLq9XqOzds2MAPyIm3tPVBKcW9sDg9FSll066YiROELywpAVsHuOthrK1+rLkt239NRC+OHoADUa31uzzPWzQrcaMfiXNP2bRp0xHFYpFnBV/bILD+16GhoQvjrp9bn4a0dajRuSilEOjGKkn9s1OndSiL8hcZMtluPPwfEdEG1ncc52Vx4pQ4OdXNuK5ngW6cE4+zj1LqOGPMqY7j7Ni1a9fDaYPOdr/FXVx27Njxc8aYE4QQjzRai63dMZp9Xi6Xn12pVM4sFov7ly1b9g3MXJlWEt9LIzCo5a+bdTpNPuA7S1fgUNUhHtu3e/ful2itVwkhvrNq1arH6pdtSauI+pBWDt/LQqBcLg8bY84wxnBA+kC3eghwOX/88cdP1lqflPWzHOpQFiUBx0gr0C/lL+u4bskHumkLBL4HAQhAAAIQgAAEIAABCEAAAv0pgEC3P/MVZwUBCEAAAhCAAAQgAAEIQGBgBRDoDmzW48QhAAEIQAACEIAABCAAAQj0p8D/Aa97Byll85d9AAAAAElFTkSuQmCC',
  dataTble: [{
    name: '\u80E1\u5F66\u658C',
    age: 32,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: '\u80E1\u5F66',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: '\u80E1',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'sss',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: '===',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'vvv',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'cc',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'ddd',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'fff',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'eee',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'ggg',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'aaa',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'kkk',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }, {
    name: 'lll',
    age: 42,
    address: '\u897F\u6E56\u533A\u6E56\u5E95\u516C\u56ED1\u53F7'
  }]
};
var FileExport = function FileExport() {
  var _useState = (0,react.useState)([]),
    _useState2 = slicedToArray_default()(_useState, 2),
    paragraph = _useState2[0],
    setParagraph = _useState2[1];
  var charts = (0,react.useRef)(null);
  var table = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    var list = toConsumableArray_default()(document.querySelectorAll('.content')).map(function (item) {
      return item.innerText;
    });
    setParagraph(list);
  }, []);
  var wordBtn = function wordBtn() {
    var img = charts.current.getDataURL();
    console.log(paragraph);
    var contentWord = {
      p0: paragraph[0],
      p1: paragraph[1],
      p2: paragraph[2],
      p3: paragraph[3],
      img: img,
      dataTble: table.current.dataTable()
    };
    exportWord('word\u5BFC\u51FA', contentWord);
  };
  return /*#__PURE__*/(0,jsx_runtime.jsx)(Page/* default */.Z, {
    children: /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
      className: FileExportWordmodules.container,
      children: [/*#__PURE__*/(0,jsx_runtime.jsx)(es_button/* default */.ZP, {
        className: FileExportWordmodules.btn,
        type: "primary",
        onClick: function onClick() {
          return wordBtn();
        },
        children: "\\u5BFC\\u51FAword"
      }), /*#__PURE__*/(0,jsx_runtime.jsxs)("div", {
        className: FileExportWordmodules.word,
        children: [/*#__PURE__*/(0,jsx_runtime.jsx)("h1", {
          className: FileExportWordmodules.title,
          children: "word\\u6587\\u6863"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "content",
          children: "8\\u67083\\u65E5\\uFF0C\\u4E2D\\u56FD\\u4EBA\\u6C11\\u89E3\\u653E\\u519B\\u4E1C\\u90E8\\u6218\\u533A\\u5728\\u53F0\\u5C9B\\u5468\\u8FB9\\u6D77\\u7A7A\\u57DF\\u7EC4\\u7EC7\\u5B9E\\u6218\\u5316\\u8054\\u5408\\u6F14\\u8BAD\\u3002"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "content",
          children: "\\u4ECA\\u5929\\u4E0A\\u5348\\uFF0C\\u4E1C\\u90E8\\u6218\\u533A\\u7A7A\\u519B\\u51FA\\u52A8\\u9884\\u8B66\\u673A\\u3001\\u6B7C\\u51FB\\u673A\\u3001\\u8F70\\u70B8\\u673A\\u7B49\\u591A\\u578B\\u5148\\u8FDB\\u6218\\u673A\\uFF0C\\u4ECE\\u591A\\u673A\\u573A\\u6218\\u6597\\u8D77\\u98DE\\u3001\\u5230\\u591A\\u7A7A\\u57DF\\u6267\\u884C\\u4EFB\\u52A1\\uFF0C\\u5F00\\u5C55\\u9884\\u8B66\\u6307\\u6325\\u3001\\u5E72\\u6270\\u538B\\u5236\\u3001\\u5175\\u529B\\u8FDB\\u538B\\u7B49\\u3002\\u4E1C\\u90E8\\u6218\\u533A\\u6D77\\u519B\\u5728\\u53F0\\u5C9B\\u5468\\u8FB9\\u6D77\\u57DF\\u5F00\\u5C55\\u8054\\u5408\\u5C01\\u63A7\\u548C\\u8054\\u5408\\u5BF9\\u9646\\u5BF9\\u6D77\\u6253\\u51FB\\u7B49\\u591A\\u8BFE\\u76EE\\u9488\\u5BF9\\u6027\\u6F14\\u7EC3"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "content",
          children: "\\u636E\\u4E2D\\u56FD\\u53F0\\u6E7E\\u7F518\\u67084\\u65E5\\u8BAF \\u89E3\\u653E\\u519B\\u4ECA\\uFF084\\u65E5\\uFF09\\u8D77\\u5728\\u53F0\\u6E7E\\u5468\\u8FB9\\u7A7A\\u6D77\\u57DF\\u8FDB\\u884C\\u91CD\\u8981\\u519B\\u4E8B\\u6F14\\u8BAD\\u884C\\u52A8\\uFF0C\\u5E76\\u7EC4\\u7EC7\\u5B9E\\u5F39\\u5C04\\u51FB\\u3002\\u636E\\u53F0\\u6E7E\\u300A\\u8054\\u5408\\u62A5\\u300B\\u62A5\\u9053\\uFF0C\\u53F0\\u519B\\u56E0\\u5E94\\u60C5\\u52BF\\uFF0C\\u6E05\\u6668\\u4E0B\\u4EE4\\u53F0\\u519B\\u201C\\u4E09\\u519B\\u201D\\u5730\\u533A\\u8F6E\\u503C\\u7684\\u6218\\u5907\\u90E8\\u961F\\uFF0C\\u5C06\\u539F\\u5175\\u529B\\u4E3A\\u8FDE\\u7EA7\\u7684\\u201C\\u6218\\u6597\\u961F\\u201D\\uFF0C\\u7ACB\\u5373\\u63D0\\u5347\\u4E3A\\u8425\\u7EA7\\u7684\\u201C\\u7279\\u9063\\u961F\\u201D\\uFF0C\\u5B9E\\u65BD\\u5907\\u6218\\u8B66\\u6212\\u3002"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)("p", {
          className: "content",
          children: "\\u62A5\\u9053\\u79F0\\uFF0C\\u89E3\\u653E\\u519B\\u5728\\u53F0\\u6D77\\u5468\\u8FB9\\u90E8\\u7F72\\u516D\\u4E2A\\u64CD\\u6F14\\u533A\\uFF0C\\u5C9B\\u5185\\u7814\\u5224\\u53EF\\u80FD\\u6709\\u4E1C\\u98CE15\\u7B49\\u5BFC\\u5F39\\u81EA\\u5927\\u9646\\u5185\\u9646\\u5347\\u7A7A\\u98DE\\u8D8A\\u53F0\\u6E7E\\u672C\\u5C9B\\u4E0A\\u7A7A\\uFF0C\\u65B0\\u7AF9\\u4E50\\u5C71\\u57FA\\u5730\\u7684\\u957F\\u7A0B\\u9884\\u8B66\\u96F7\\u8FBE\\u4E25\\u5BC6\\u76D1\\u63A7\\u5F53\\u9762\\u9AD8\\u4E2D\\u4F4E\\u7A7A\\u72B6\\u51B5\\uFF0C\\u5E76\\u4E0E\\u4E24\\u5EA7\\u5C9B\\u5185\\u9884\\u8B66\\u4E2D\\u5FC3\\u8FDE\\u7EBF\\u3002"
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(chart, {
          ref: charts
        }), /*#__PURE__*/(0,jsx_runtime.jsx)(components_table, {
          ref: table
        })]
      })]
    })
  });
};
/* harmony default export */ var FileExportWord = (FileExport);

//# sourceURL=webpack:///./src/components/File/FileExportWord/index.tsx_+_4_modules?`)},56645:function(__unused_webpack_module,exports){eval(`// https://github.com/HarryStevens/d3-regression#readme Version 1.3.10. Copyright 2022 Harry Stevens.
(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  // Adapted from vega-statistics by Jeffrey Heer
  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
  // Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/points.js
  function points(data, x, y, sort) {
    data = data.filter(function (d, i) {
      var u = x(d, i),
          v = y(d, i);
      return u != null && isFinite(u) && v != null && isFinite(v);
    });

    if (sort) {
      data.sort(function (a, b) {
        return x(a) - x(b);
      });
    }

    var n = data.length,
        X = new Float64Array(n),
        Y = new Float64Array(n); // extract values, calculate means

    var ux = 0,
        uy = 0,
        xv,
        yv,
        d;

    for (var i = 0; i < n;) {
      d = data[i];
      X[i] = xv = +x(d, i, data);
      Y[i] = yv = +y(d, i, data);
      ++i;
      ux += (xv - ux) / i;
      uy += (yv - uy) / i;
    } // mean center the data


    for (var _i = 0; _i < n; ++_i) {
      X[_i] -= ux;
      Y[_i] -= uy;
    }

    return [X, Y, ux, uy];
  }
  function visitPoints(data, x, y, cb) {
    var iterations = 0;

    for (var i = 0, n = data.length; i < n; i++) {
      var d = data[i],
          dx = +x(d, i, data),
          dy = +y(d, i, data);

      if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
        cb(dx, dy, iterations++);
      }
    }
  }

  // return the coefficient of determination, or R squared.

  function determination(data, x, y, uY, predict) {
    var SSE = 0,
        SST = 0;
    visitPoints(data, x, y, function (dx, dy) {
      var sse = dy - predict(dx),
          sst = dy - uY;
      SSE += sse * sse;
      SST += sst * sst;
    });
    return 1 - SSE / SST;
  }

  // Returns the angle of a line in degrees.
  function angle(line) {
    return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;
  } // Returns the midpoint of a line.

  function midpoint(line) {
    return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];
  }

  // returns a smooth line.

  function interpose(xmin, xmax, predict) {
    var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
    var precision = 1 * Math.pow(10, -l / 2 - 1),
        maxIter = 1e4;
    var points = [px(xmin), px(xmax)],
        iter = 0;

    while (find(points) && iter < maxIter) {
    }

    return points;

    function px(x) {
      return [x, predict(x)];
    }

    function find(points) {
      iter++;
      var n = points.length;
      var found = false;

      for (var i = 0; i < n - 1; i++) {
        var p0 = points[i],
            p1 = points[i + 1],
            m = midpoint([p0, p1]),
            mp = px(m[0]),
            a0 = angle([p0, m]),
            a1 = angle([p0, mp]),
            a = Math.abs(a0 - a1);

        if (a > precision) {
          points.splice(i + 1, 0, mp);
          found = true;
        }
      }

      return found;
    }
  }

  // Ordinary Least Squares from vega-statistics by Jeffrey Heer
  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
  // Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/ols.js
  function ols(uX, uY, uXY, uX2) {
    var delta = uX2 - uX * uX,
        slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
        intercept = uY - slope * uX;
    return [intercept, slope];
  }

  function exponential () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        domain;

    function exponential(data) {
      var n = 0,
          Y = 0,
          YL = 0,
          XY = 0,
          XYL = 0,
          X2Y = 0,
          xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        var ly = Math.log(dy),
            xy = dx * dy;
        ++n;
        Y += (dy - Y) / n;
        XY += (xy - XY) / n;
        X2Y += (dx * xy - X2Y) / n;
        YL += (dy * ly - YL) / n;
        XYL += (xy * ly - XYL) / n;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });

      var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y),
          _ols2 = _slicedToArray(_ols, 2),
          a = _ols2[0],
          b = _ols2[1];

      a = Math.exp(a);

      var fn = function fn(x) {
        return a * Math.exp(b * x);
      },
          out = interpose(xmin, xmax, fn);

      out.a = a;
      out.b = b;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }

    exponential.domain = function (arr) {
      return arguments.length ? (domain = arr, exponential) : domain;
    };

    exponential.x = function (fn) {
      return arguments.length ? (x = fn, exponential) : x;
    };

    exponential.y = function (fn) {
      return arguments.length ? (y = fn, exponential) : y;
    };

    return exponential;
  }

  function linear () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        domain;

    function linear(data) {
      var n = 0,
          X = 0,
          // sum of x
      Y = 0,
          // sum of y
      XY = 0,
          // sum of x * y
      X2 = 0,
          // sum of x * x
      xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        ++n;
        X += (dx - X) / n;
        Y += (dy - Y) / n;
        XY += (dx * dy - XY) / n;
        X2 += (dx * dx - X2) / n;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });

      var _ols = ols(X, Y, XY, X2),
          _ols2 = _slicedToArray(_ols, 2),
          intercept = _ols2[0],
          slope = _ols2[1],
          fn = function fn(x) {
        return slope * x + intercept;
      },
          out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];

      out.a = slope;
      out.b = intercept;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }

    linear.domain = function (arr) {
      return arguments.length ? (domain = arr, linear) : domain;
    };

    linear.x = function (fn) {
      return arguments.length ? (x = fn, linear) : x;
    };

    linear.y = function (fn) {
      return arguments.length ? (y = fn, linear) : y;
    };

    return linear;
  }

  // Returns the medium value of an array of numbers.
  function median(arr) {
    arr.sort(function (a, b) {
      return a - b;
    });
    var i = arr.length / 2;
    return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
  }

  var maxiters = 2,
      epsilon = 1e-12;
  function loess () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        bandwidth = .3;

    function loess(data) {
      var _points = points(data, x, y, true),
          _points2 = _slicedToArray(_points, 4),
          xv = _points2[0],
          yv = _points2[1],
          ux = _points2[2],
          uy = _points2[3],
          n = xv.length,
          bw = Math.max(2, ~~(bandwidth * n)),
          yhat = new Float64Array(n),
          residuals = new Float64Array(n),
          robustWeights = new Float64Array(n).fill(1);

      for (var iter = -1; ++iter <= maxiters;) {
        var interval = [0, bw - 1];

        for (var i = 0; i < n; ++i) {
          var dx = xv[i],
              i0 = interval[0],
              i1 = interval[1],
              edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
          var W = 0,
              X = 0,
              Y = 0,
              XY = 0,
              X2 = 0,
              denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity

          for (var k = i0; k <= i1; ++k) {
            var xk = xv[k],
                yk = yv[k],
                w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
                xkw = xk * w;
            W += w;
            X += xkw;
            Y += yk * w;
            XY += yk * xkw;
            X2 += xk * xkw;
          } // Linear regression fit


          var _ols = ols(X / W, Y / W, XY / W, X2 / W),
              _ols2 = _slicedToArray(_ols, 2),
              a = _ols2[0],
              b = _ols2[1];

          yhat[i] = a + b * dx;
          residuals[i] = Math.abs(yv[i] - yhat[i]);
          updateInterval(xv, i + 1, interval);
        }

        if (iter === maxiters) {
          break;
        }

        var medianResidual = median(residuals);
        if (Math.abs(medianResidual) < epsilon) break;

        for (var _i = 0, arg, _w; _i < n; ++_i) {
          arg = residuals[_i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations
          // Keeping weights tiny but non-zero prevents singularites

          robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
        }
      }

      return output(xv, yhat, ux, uy);
    }

    loess.bandwidth = function (bw) {
      return arguments.length ? (bandwidth = bw, loess) : bandwidth;
    };

    loess.x = function (fn) {
      return arguments.length ? (x = fn, loess) : x;
    };

    loess.y = function (fn) {
      return arguments.length ? (y = fn, loess) : y;
    };

    return loess;
  } // Weighting kernel for local regression

  function tricube(x) {
    return (x = 1 - x * x * x) * x * x;
  } // Advance sliding window interval of nearest neighbors


  function updateInterval(xv, i, interval) {
    var val = xv[i],
        left = interval[0],
        right = interval[1] + 1;
    if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge
    // Step when distance is equal to ensure movement over duplicate x values

    while (i > left && xv[right] - val <= val - xv[left]) {
      interval[0] = ++left;
      interval[1] = right;
      ++right;
    }
  } // Generate smoothed output points
  // Average points with repeated x values


  function output(xv, yhat, ux, uy) {
    var n = xv.length,
        out = [];
    var i = 0,
        cnt = 0,
        prev = [],
        v;

    for (; i < n; ++i) {
      v = xv[i] + ux;

      if (prev[0] === v) {
        // Average output values via online update
        prev[1] += (yhat[i] - prev[1]) / ++cnt;
      } else {
        // Add new output point
        cnt = 0;
        prev[1] += uy;
        prev = [v, yhat[i]];
        out.push(prev);
      }
    }

    prev[1] += uy;
    return out;
  }

  function logarithmic () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        base = Math.E,
        domain;

    function logarithmic(data) {
      var n = 0,
          X = 0,
          Y = 0,
          XY = 0,
          X2 = 0,
          xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity,
          lb = Math.log(base);
      visitPoints(data, x, y, function (dx, dy) {
        var lx = Math.log(dx) / lb;
        ++n;
        X += (lx - X) / n;
        Y += (dy - Y) / n;
        XY += (lx * dy - XY) / n;
        X2 += (lx * lx - X2) / n;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });

      var _ols = ols(X, Y, XY, X2),
          _ols2 = _slicedToArray(_ols, 2),
          intercept = _ols2[0],
          slope = _ols2[1],
          fn = function fn(x) {
        return slope * Math.log(x) / lb + intercept;
      },
          out = interpose(xmin, xmax, fn);

      out.a = slope;
      out.b = intercept;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }

    logarithmic.domain = function (arr) {
      return arguments.length ? (domain = arr, logarithmic) : domain;
    };

    logarithmic.x = function (fn) {
      return arguments.length ? (x = fn, logarithmic) : x;
    };

    logarithmic.y = function (fn) {
      return arguments.length ? (y = fn, logarithmic) : y;
    };

    logarithmic.base = function (n) {
      return arguments.length ? (base = n, logarithmic) : base;
    };

    return logarithmic;
  }

  function quad () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        domain;

    function quadratic(data) {
      var _points = points(data, x, y),
          _points2 = _slicedToArray(_points, 4),
          xv = _points2[0],
          yv = _points2[1],
          ux = _points2[2],
          uy = _points2[3],
          n = xv.length;

      var X2 = 0,
          X3 = 0,
          X4 = 0,
          XY = 0,
          X2Y = 0,
          i,
          dx,
          dy,
          x2;

      for (i = 0; i < n;) {
        dx = xv[i];
        dy = yv[i++];
        x2 = dx * dx;
        X2 += (x2 - X2) / i;
        X3 += (x2 * dx - X3) / i;
        X4 += (x2 * x2 - X4) / i;
        XY += (dx * dy - XY) / i;
        X2Y += (x2 * dy - X2Y) / i;
      }

      var Y = 0,
          n0 = 0,
          xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        n0++;
        Y += (dy - Y) / n0;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });

      var X2X2 = X4 - X2 * X2,
          d = X2 * X2X2 - X3 * X3,
          a = (X2Y * X2 - XY * X3) / d,
          b = (XY * X2X2 - X2Y * X3) / d,
          c = -a * X2,
          fn = function fn(x) {
        x = x - ux;
        return a * x * x + b * x + c + uy;
      };

      var out = interpose(xmin, xmax, fn);
      out.a = a;
      out.b = b - 2 * a * ux;
      out.c = c - b * ux + a * ux * ux + uy;
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }

    quadratic.domain = function (arr) {
      return arguments.length ? (domain = arr, quadratic) : domain;
    };

    quadratic.x = function (fn) {
      return arguments.length ? (x = fn, quadratic) : x;
    };

    quadratic.y = function (fn) {
      return arguments.length ? (y = fn, quadratic) : y;
    };

    return quadratic;
  }

  // Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
  // License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE
  // ...with ideas from vega-statistics by Jeffrey Heer
  // Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/poly.js
  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE

  function polynomial () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        order = 3,
        domain;

    function polynomial(data) {
      // Use more efficient methods for lower orders
      if (order === 1) {
        var o = linear().x(x).y(y).domain(domain)(data);
        o.coefficients = [o.b, o.a];
        delete o.a;
        delete o.b;
        return o;
      }

      if (order === 2) {
        var _o = quad().x(x).y(y).domain(domain)(data);

        _o.coefficients = [_o.c, _o.b, _o.a];
        delete _o.a;
        delete _o.b;
        delete _o.c;
        return _o;
      }

      var _points = points(data, x, y),
          _points2 = _slicedToArray(_points, 4),
          xv = _points2[0],
          yv = _points2[1],
          ux = _points2[2],
          uy = _points2[3],
          n = xv.length,
          lhs = [],
          rhs = [],
          k = order + 1;

      var Y = 0,
          n0 = 0,
          xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        ++n0;
        Y += (dy - Y) / n0;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });
      var i, j, l, v, c;

      for (i = 0; i < k; ++i) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i) * yv[l];
        }

        lhs.push(v);
        c = new Float64Array(k);

        for (j = 0; j < k; ++j) {
          for (l = 0, v = 0; l < n; ++l) {
            v += Math.pow(xv[l], i + j);
          }

          c[j] = v;
        }

        rhs.push(c);
      }

      rhs.push(lhs);

      var coef = gaussianElimination(rhs),
          fn = function fn(x) {
        x -= ux;
        var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;

        for (i = 3; i < k; ++i) {
          y += coef[i] * Math.pow(x, i);
        }

        return y;
      },
          out = interpose(xmin, xmax, fn);

      out.coefficients = uncenter(k, coef, -ux, uy);
      out.predict = fn;
      out.rSquared = determination(data, x, y, Y, fn);
      return out;
    }

    polynomial.domain = function (arr) {
      return arguments.length ? (domain = arr, polynomial) : domain;
    };

    polynomial.x = function (fn) {
      return arguments.length ? (x = fn, polynomial) : x;
    };

    polynomial.y = function (fn) {
      return arguments.length ? (y = fn, polynomial) : y;
    };

    polynomial.order = function (n) {
      return arguments.length ? (order = n, polynomial) : order;
    };

    return polynomial;
  }

  function uncenter(k, a, x, y) {
    var z = Array(k);
    var i, j, v, c; // initialize to zero

    for (i = 0; i < k; ++i) {
      z[i] = 0;
    } // polynomial expansion


    for (i = k - 1; i >= 0; --i) {
      v = a[i];
      c = 1;
      z[i] += v;

      for (j = 1; j <= i; ++j) {
        c *= (i + 1 - j) / j; // binomial coefficent

        z[i - j] += v * Math.pow(x, j) * c;
      }
    } // bias term


    z[0] += y;
    return z;
  } // Given an array for a two-dimensional matrix and the polynomial order,
  // solve A * x = b using Gaussian elimination.


  function gaussianElimination(matrix) {
    var n = matrix.length - 1,
        coef = [];
    var i, j, k, r, t;

    for (i = 0; i < n; ++i) {
      r = i; // max row

      for (j = i + 1; j < n; ++j) {
        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
          r = j;
        }
      }

      for (k = i; k < n + 1; ++k) {
        t = matrix[k][i];
        matrix[k][i] = matrix[k][r];
        matrix[k][r] = t;
      }

      for (j = i + 1; j < n; ++j) {
        for (k = n; k >= i; k--) {
          matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
        }
      }
    }

    for (j = n - 1; j >= 0; --j) {
      t = 0;

      for (k = j + 1; k < n; ++k) {
        t += matrix[k][j] * coef[k];
      }

      coef[j] = (matrix[n][j] - t) / matrix[j][j];
    }

    return coef;
  }

  function power () {
    var x = function x(d) {
      return d[0];
    },
        y = function y(d) {
      return d[1];
    },
        domain;

    function power(data) {
      var n = 0,
          X = 0,
          Y = 0,
          XY = 0,
          X2 = 0,
          YS = 0,
          xmin = domain ? +domain[0] : Infinity,
          xmax = domain ? +domain[1] : -Infinity;
      visitPoints(data, x, y, function (dx, dy) {
        var lx = Math.log(dx),
            ly = Math.log(dy);
        ++n;
        X += (lx - X) / n;
        Y += (ly - Y) / n;
        XY += (lx * ly - XY) / n;
        X2 += (lx * lx - X2) / n;
        YS += (dy - YS) / n;

        if (!domain) {
          if (dx < xmin) xmin = dx;
          if (dx > xmax) xmax = dx;
        }
      });

      var _ols = ols(X, Y, XY, X2),
          _ols2 = _slicedToArray(_ols, 2),
          a = _ols2[0],
          b = _ols2[1];

      a = Math.exp(a);

      var fn = function fn(x) {
        return a * Math.pow(x, b);
      },
          out = interpose(xmin, xmax, fn);

      out.a = a;
      out.b = b;
      out.predict = fn;
      out.rSquared = determination(data, x, y, YS, fn);
      return out;
    }

    power.domain = function (arr) {
      return arguments.length ? (domain = arr, power) : domain;
    };

    power.x = function (fn) {
      return arguments.length ? (x = fn, power) : x;
    };

    power.y = function (fn) {
      return arguments.length ? (y = fn, power) : y;
    };

    return power;
  }

  exports.regressionExp = exponential;
  exports.regressionLinear = linear;
  exports.regressionLoess = loess;
  exports.regressionLog = logarithmic;
  exports.regressionPoly = polynomial;
  exports.regressionPow = power;
  exports.regressionQuad = quad;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


//# sourceURL=webpack:///./node_modules/d3-regression/dist/d3-regression.js?`)},43631:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "qY": function() { return /* binding */ detect; }
/* harmony export */ });
/* unused harmony exports BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, browserName, parseUserAgent, detectOS, getNodeVersion */
/* provided dependency */ var process = __webpack_require__(34155);
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\\/([0-9\\._]+)/],
    ['edge', /Edge\\/([0-9\\._]+)/],
    ['edge-ios', /EdgiOS\\/([0-9\\._]+)/],
    ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/],
    ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/],
    ['samsung', /SamsungBrowser\\/([0-9\\.]+)/],
    ['silk', /\\bSilk\\/([0-9._-]+)\\b/],
    ['miui', /MiuiBrowser\\/([0-9\\.]+)$/],
    ['beaker', /BeakerBrowser\\/([0-9\\.]+)/],
    ['edge-chromium', /EdgA?\\/([0-9\\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],
    ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],
    ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/],
    ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/],
    ['fxios', /FxiOS\\/([0-9\\.]+)/],
    ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/],
    ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/],
    ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/],
    ['pie', /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/],
    ['pie', /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/],
    ['netfront', /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/],
    ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],
    ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],
    ['ie', /MSIE\\s(7\\.0)/],
    ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],
    ['android', /Android\\s([0-9\\.]+)/],
    ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\\/([0-9\\._]+).*Safari/],
    ['facebook', /FB[AS]V\\/([0-9\\.]+)/],
    ['instagram', /Instagram\\s([0-9\\.]+)/],
    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],
    ['curl', /^curl\\/([0-9\\.]+)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


//# sourceURL=webpack:///./node_modules/detect-browser/es/index.js?`)},43707:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(86150),
    DOMParser = _require.DOMParser,
    XMLSerializer = _require.XMLSerializer;

var _require2 = __webpack_require__(27284),
    throwXmlTagNotFound = _require2.throwXmlTagNotFound;

function parser(tag) {
	return _defineProperty({}, "get", function get(scope) {
		if (tag === ".") {
			return scope;
		}
		return scope[tag];
	});
}

function unique(arr) {
	var hash = {},
	    result = [];
	for (var i = 0, l = arr.length; i < l; ++i) {
		if (!hash.hasOwnProperty(arr[i])) {
			hash[arr[i]] = true;
			result.push(arr[i]);
		}
	}
	return result;
}

function chunkBy(parsed, f) {
	return parsed.reduce(function (chunks, p) {
		var currentChunk = last(chunks);
		if (currentChunk.length === 0) {
			currentChunk.push(p);
			return chunks;
		}
		var res = f(p);
		if (res === "start") {
			chunks.push([p]);
		} else if (res === "end") {
			currentChunk.push(p);
			chunks.push([]);
		} else {
			currentChunk.push(p);
		}
		return chunks;
	}, [[]]).filter(function (p) {
		return p.length > 0;
	});
}

function last(a) {
	return a[a.length - 1];
}

var defaults = {
	nullGetter: function nullGetter(part) {
		if (!part.module) {
			return "undefined";
		}
		if (part.module === "rawxml") {
			return "";
		}
		return "";
	},

	xmlFileNames: [],
	parser: parser,
	delimiters: {
		start: "{",
		end: "}"
	}
};

function mergeObjects() {
	var resObj = {};
	var obj = void 0,
	    keys = void 0;
	for (var i = 0; i < arguments.length; i += 1) {
		obj = arguments[i];
		keys = Object.keys(obj);
		for (var j = 0; j < keys.length; j += 1) {
			resObj[keys[j]] = obj[keys[j]];
		}
	}
	return resObj;
}

function xml2str(xmlNode) {
	var a = new XMLSerializer();
	return a.serializeToString(xmlNode).replace(/xmlns:[a-z0-9]+="" ?/g, "");
}

function str2xml(str, errorHandler) {
	var parser = new DOMParser({ errorHandler: errorHandler });
	return parser.parseFromString(str, "text/xml");
}

var charMap = {
	"&": "&amp;",
	"'": "&apos;",
	"<": "&lt;",
	">": "&gt;",
	'"': "&quot;"
};

var regexStripRegexp = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;
function escapeRegExp(str) {
	return str.replace(regexStripRegexp, "\\\\$&");
}

var charMapRegexes = Object.keys(charMap).map(function (endChar) {
	var startChar = charMap[endChar];
	return {
		rstart: new RegExp(escapeRegExp(startChar), "g"),
		rend: new RegExp(escapeRegExp(endChar), "g"),
		start: startChar,
		end: endChar
	};
});

function wordToUtf8(string) {
	var r = void 0;
	for (var i = 0, l = charMapRegexes.length; i < l; i++) {
		r = charMapRegexes[i];
		string = string.replace(r.rstart, r.end);
	}
	return string;
}

function utf8ToWord(string) {
	if (typeof string !== "string") {
		string = string.toString();
	}
	var r = void 0;
	for (var i = 0, l = charMapRegexes.length; i < l; i++) {
		r = charMapRegexes[i];
		string = string.replace(r.rend, r.start);
	}
	return string;
}

// This function is written with for loops for performance
function concatArrays(arrays) {
	var result = [];
	for (var i = 0; i < arrays.length; i++) {
		var array = arrays[i];
		for (var j = 0, len = array.length; j < len; j++) {
			result.push(array[j]);
		}
	}
	return result;
}

var spaceRegexp = new RegExp(String.fromCharCode(160), "g");
function convertSpaces(s) {
	return s.replace(spaceRegexp, " ");
}
function pregMatchAll(regex, content) {
	/* regex is a string, content is the content. It returns an array of all matches with their offset, for example:
 	 regex=la
 	 content=lolalolilala
 returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]
 */
	var matchArray = [];
	var match = void 0;
	while ((match = regex.exec(content)) != null) {
		matchArray.push({ array: match, offset: match.index });
	}
	return matchArray;
}

function getRight(parsed, element, index) {
	for (var i = index, l = parsed.length; i < l; i++) {
		var part = parsed[i];
		if (part.value === "</" + element + ">") {
			return i;
		}
	}
	throwXmlTagNotFound({ position: "right", element: element, parsed: parsed, index: index });
}

function getLeft(parsed, element, index) {
	for (var i = index; i >= 0; i--) {
		var part = parsed[i];
		if (part.value.indexOf("<" + element) === 0 && [">", " "].indexOf(part.value[element.length + 1]) !== -1) {
			return i;
		}
	}
	throwXmlTagNotFound({ position: "left", element: element, parsed: parsed, index: index });
}

function isTagStart(tagType, _ref2) {
	var type = _ref2.type,
	    tag = _ref2.tag,
	    position = _ref2.position;

	return type === "tag" && tag === tagType && position === "start";
}
function isTagEnd(tagType, _ref3) {
	var type = _ref3.type,
	    tag = _ref3.tag,
	    position = _ref3.position;

	return type === "tag" && tag === tagType && position === "end";
}
function isParagraphStart(options) {
	return isTagStart("w:p", options) || isTagStart("a:p", options);
}
function isParagraphEnd(options) {
	return isTagEnd("w:p", options) || isTagEnd("a:p", options);
}
function isTextStart(part) {
	return part.type === "tag" && part.position === "start" && part.text;
}
function isTextEnd(part) {
	return part.type === "tag" && part.position === "end" && part.text;
}

function isContent(p) {
	return p.type === "placeholder" || p.type === "content" && p.position === "insidetag";
}

var corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;
// 00    NUL '\\0' (null character)
// 01    SOH (start of heading)
// 02    STX (start of text)
// 03    ETX (end of text)
// 04    EOT (end of transmission)
// 05    ENQ (enquiry)
// 06    ACK (acknowledge)
// 07    BEL '\\a' (bell)
// 08    BS  '\\b' (backspace)
// 0B    VT  '\\v' (vertical tab)
// 0C    FF  '\\f' (form feed)
// 0E    SO  (shift out)
// 0F    SI  (shift in)
// 10    DLE (data link escape)
// 11    DC1 (device control 1)
// 12    DC2 (device control 2)
// 13    DC3 (device control 3)
// 14    DC4 (device control 4)
// 15    NAK (negative ack.)
// 16    SYN (synchronous idle)
// 17    ETB (end of trans. blk)
// 18    CAN (cancel)
// 19    EM  (end of medium)
// 1A    SUB (substitute)
// 1B    ESC (escape)
// 1C    FS  (file separator)
// 1D    GS  (group separator)
// 1E    RS  (record separator)
// 1F    US  (unit separator)
function hasCorruptCharacters(string) {
	return corruptCharacters.test(string);
}

module.exports = {
	isContent: isContent,
	isParagraphStart: isParagraphStart,
	isParagraphEnd: isParagraphEnd,
	isTagStart: isTagStart,
	isTagEnd: isTagEnd,
	isTextStart: isTextStart,
	isTextEnd: isTextEnd,
	unique: unique,
	chunkBy: chunkBy,
	last: last,
	mergeObjects: mergeObjects,
	xml2str: xml2str,
	str2xml: str2xml,
	getRight: getRight,
	getLeft: getLeft,
	pregMatchAll: pregMatchAll,
	convertSpaces: convertSpaces,
	escapeRegExp: escapeRegExp,
	charMapRegexes: charMapRegexes,
	hasCorruptCharacters: hasCorruptCharacters,
	defaults: defaults,
	wordToUtf8: wordToUtf8,
	utf8ToWord: utf8ToWord,
	concatArrays: concatArrays,
	charMap: charMap
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/doc-utils.js?`)},14522:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DocUtils = __webpack_require__(43707);
DocUtils.traits = __webpack_require__(85955);
DocUtils.moduleWrapper = __webpack_require__(39523);
var defaults = DocUtils.defaults,
    str2xml = DocUtils.str2xml,
    xml2str = DocUtils.xml2str,
    moduleWrapper = DocUtils.moduleWrapper,
    concatArrays = DocUtils.concatArrays,
    unique = DocUtils.unique;

var _require = __webpack_require__(27284),
    XTInternalError = _require.XTInternalError,
    throwFileTypeNotIdentified = _require.throwFileTypeNotIdentified,
    throwFileTypeNotHandled = _require.throwFileTypeNotHandled;

var Docxtemplater = function () {
	function Docxtemplater() {
		_classCallCheck(this, Docxtemplater);

		if (arguments.length > 0) {
			throw new Error("The constructor with parameters has been removed in docxtemplater 3, please check the upgrade guide.");
		}
		this.compiled = {};
		this.modules = [];
		this.setOptions({});
	}

	_createClass(Docxtemplater, [{
		key: "setModules",
		value: function setModules(obj) {
			this.modules.forEach(function (module) {
				module.set(obj);
			});
		}
	}, {
		key: "sendEvent",
		value: function sendEvent(eventName) {
			this.modules.forEach(function (module) {
				module.on(eventName);
			});
		}
	}, {
		key: "attachModule",
		value: function attachModule(module) {
			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			var prefix = options.prefix;

			if (prefix) {
				module.prefix = prefix;
			}
			this.modules.push(moduleWrapper(module));
			return this;
		}
	}, {
		key: "setOptions",
		value: function setOptions(options) {
			var _this = this;

			this.options = options;
			Object.keys(defaults).forEach(function (key) {
				var defaultValue = defaults[key];
				_this.options[key] = _this.options[key] != null ? _this.options[key] : defaultValue;
				_this[key] = _this.options[key];
			});
			if (this.zip) {
				this.updateFileTypeConfig();
			}
			return this;
		}
	}, {
		key: "loadZip",
		value: function loadZip(zip) {
			if (zip.loadAsync) {
				throw new XTInternalError("Docxtemplater doesn't handle JSZip version >=3, see changelog");
			}
			this.zip = zip;
			this.updateFileTypeConfig();

			this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {
				return moduleFunction();
			}), this.modules]);
			return this;
		}
	}, {
		key: "compileFile",
		value: function compileFile(fileName) {
			var currentFile = this.createTemplateClass(fileName);
			currentFile.parse();
			this.compiled[fileName] = currentFile;
		}
	}, {
		key: "resolveData",
		value: function resolveData(data) {
			var _this2 = this;

			return Promise.all(Object.keys(this.compiled).map(function (from) {
				var currentFile = _this2.compiled[from];
				return currentFile.resolveTags(data);
			})).then(function (resolved) {
				return concatArrays(resolved);
			});
		}
	}, {
		key: "compile",
		value: function compile() {
			var _this3 = this;

			if (Object.keys(this.compiled).length) {
				return this;
			}
			this.options = this.modules.reduce(function (options, module) {
				return module.optionsTransformer(options, _this3);
			}, this.options);
			this.options.xmlFileNames = unique(this.options.xmlFileNames);
			this.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {
				var content = _this3.zip.files[fileName].asText();
				xmlDocuments[fileName] = str2xml(content);
				return xmlDocuments;
			}, {});
			this.setModules({
				zip: this.zip,
				xmlDocuments: this.xmlDocuments
			});
			this.getTemplatedFiles();
			this.setModules({ compiled: this.compiled });
			// Loop inside all templatedFiles (ie xml files with content).
			// Sometimes they don't exist (footer.xml for example)
			this.templatedFiles.forEach(function (fileName) {
				if (_this3.zip.files[fileName] != null) {
					_this3.compileFile(fileName);
				}
			});
			return this;
		}
	}, {
		key: "updateFileTypeConfig",
		value: function updateFileTypeConfig() {
			var fileType = void 0;
			if (this.zip.files.mimetype) {
				fileType = "odt";
			}
			if (this.zip.files["word/document.xml"] || this.zip.files["word/document2.xml"]) {
				fileType = "docx";
			}
			if (this.zip.files["ppt/presentation.xml"]) {
				fileType = "pptx";
			}

			if (fileType === "odt") {
				throwFileTypeNotHandled(fileType);
			}
			if (!fileType) {
				throwFileTypeNotIdentified();
			}
			this.fileType = fileType;
			this.fileTypeConfig = this.options.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType];
			return this;
		}
	}, {
		key: "render",
		value: function render() {
			var _this4 = this;

			this.compile();
			this.setModules({
				data: this.data
			});
			this.mapper = this.modules.reduce(function (value, module) {
				return module.getRenderedMap(value);
			}, {});

			this.fileTypeConfig.tagsXmlLexedArray = unique(this.fileTypeConfig.tagsXmlLexedArray);
			this.fileTypeConfig.tagsXmlTextArray = unique(this.fileTypeConfig.tagsXmlTextArray);

			Object.keys(this.mapper).forEach(function (to) {
				var _mapper$to = _this4.mapper[to],
				    from = _mapper$to.from,
				    data = _mapper$to.data;

				var currentFile = _this4.compiled[from];
				currentFile.setTags(data);
				currentFile.render(to);
				_this4.zip.file(to, currentFile.content, { createFolders: true });
			});
			this.sendEvent("syncing-zip");
			this.syncZip();
			return this;
		}
	}, {
		key: "syncZip",
		value: function syncZip() {
			var _this5 = this;

			Object.keys(this.xmlDocuments).forEach(function (fileName) {
				_this5.zip.remove(fileName);
				var content = xml2str(_this5.xmlDocuments[fileName]);
				return _this5.zip.file(fileName, content, { createFolders: true });
			});
		}
	}, {
		key: "setData",
		value: function setData(data) {
			this.data = data;
			return this;
		}
	}, {
		key: "getZip",
		value: function getZip() {
			return this.zip;
		}
	}, {
		key: "createTemplateClass",
		value: function createTemplateClass(path) {
			var usedData = this.zip.files[path].asText();
			return this.createTemplateClassFromContent(usedData, path);
		}
	}, {
		key: "createTemplateClassFromContent",
		value: function createTemplateClassFromContent(content, filePath) {
			var _this6 = this;

			var xmltOptions = {
				filePath: filePath
			};
			Object.keys(defaults).forEach(function (key) {
				xmltOptions[key] = _this6[key];
			});
			xmltOptions.fileTypeConfig = this.fileTypeConfig;
			xmltOptions.modules = this.modules;
			return new Docxtemplater.XmlTemplater(content, xmltOptions);
		}
	}, {
		key: "getFullText",
		value: function getFullText(path) {
			return this.createTemplateClass(path || this.fileTypeConfig.textPath(this.zip)).getFullText();
		}
	}, {
		key: "getTemplatedFiles",
		value: function getTemplatedFiles() {
			this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
			return this.templatedFiles;
		}
	}]);

	return Docxtemplater;
}();

Docxtemplater.DocUtils = DocUtils;
Docxtemplater.Errors = __webpack_require__(27284);
Docxtemplater.XmlTemplater = __webpack_require__(30418);
Docxtemplater.FileTypeConfig = __webpack_require__(36729);
Docxtemplater.XmlMatcher = __webpack_require__(50804);
module.exports = Docxtemplater;

//# sourceURL=webpack:///./node_modules/docxtemplater/js/docxtemplater.js?`)},27284:function(module){"use strict";eval(`

function first(a) {
	return a[0];
}
function last(a) {
	return a[a.length - 1];
}
function XTError(message) {
	this.name = "GenericError";
	this.message = message;
	this.stack = new Error(message).stack;
}
XTError.prototype = Error.prototype;

function XTTemplateError(message) {
	this.name = "TemplateError";
	this.message = message;
	this.stack = new Error(message).stack;
}
XTTemplateError.prototype = new XTError();

function RenderingError(message) {
	this.name = "RenderingError";
	this.message = message;
	this.stack = new Error(message).stack;
}
RenderingError.prototype = new XTError();

function XTScopeParserError(message) {
	this.name = "ScopeParserError";
	this.message = message;
	this.stack = new Error(message).stack;
}
XTScopeParserError.prototype = new XTError();

function XTInternalError(message) {
	this.name = "InternalError";
	this.properties = { explanation: "InternalError" };
	this.message = message;
	this.stack = new Error(message).stack;
}
XTInternalError.prototype = new XTError();

function throwMultiError(errors) {
	var err = new XTTemplateError("Multi error");
	err.properties = {
		errors: errors,
		id: "multi_error",
		explanation: "The template has multiple errors"
	};
	throw err;
}

function getUnopenedTagException(options) {
	var err = new XTTemplateError("Unopened tag");
	err.properties = {
		xtag: last(options.xtag.split(" ")),
		id: "unopened_tag",
		context: options.xtag,
		offset: options.offset,
		lIndex: options.lIndex,
		explanation: "The tag beginning with \\"" + options.xtag.substr(0, 10) + "\\" is unopened"
	};
	return err;
}

function getUnclosedTagException(options) {
	var err = new XTTemplateError("Unclosed tag");
	err.properties = {
		xtag: first(options.xtag.split(" ")).substr(1),
		id: "unclosed_tag",
		context: options.xtag,
		offset: options.offset,
		lIndex: options.lIndex,
		explanation: "The tag beginning with \\"" + options.xtag.substr(0, 10) + "\\" is unclosed"
	};
	return err;
}

function throwXmlTagNotFound(options) {
	var err = new XTTemplateError("No tag \\"" + options.element + "\\" was found at the " + options.position);
	err.properties = {
		id: "no_xml_tag_found_at_" + options.position,
		explanation: "No tag \\"" + options.element + "\\" was found at the " + options.position,
		part: options.parsed[options.index],
		parsed: options.parsed,
		index: options.index,
		element: options.element
	};
	throw err;
}

function throwCorruptCharacters(_ref) {
	var tag = _ref.tag,
	    value = _ref.value;

	var err = new RenderingError("There are some XML corrupt characters");
	err.properties = {
		id: "invalid_xml_characters",
		xtag: tag,
		value: value,
		explanation: "There are some corrupt characters for the field \${name}"
	};
	throw err;
}

function throwContentMustBeString(type) {
	var err = new XTInternalError("Content must be a string");
	err.properties.id = "xmltemplater_content_must_be_string";
	err.properties.type = type;
	throw err;
}

function throwRawTagNotInParagraph(options) {
	var err = new XTTemplateError("Raw tag not in paragraph");
	var _options$part = options.part,
	    value = _options$part.value,
	    offset = _options$part.offset;

	err.properties = {
		id: "raw_tag_outerxml_invalid",
		explanation: "The tag \\"" + value + "\\" is not inside a paragraph",
		rootError: options.rootError,
		xtag: value,
		offset: offset,
		postparsed: options.postparsed,
		expandTo: options.expandTo,
		index: options.index
	};
	throw err;
}

function throwRawTagShouldBeOnlyTextInParagraph(options) {
	var err = new XTTemplateError("Raw tag should be the only text in paragraph");
	var tag = options.part.value;
	err.properties = {
		id: "raw_xml_tag_should_be_only_text_in_paragraph",
		explanation: "The tag \\"" + tag + "\\" should be the only text in this paragraph",
		xtag: options.part.value,
		offset: options.part.offset,
		paragraphParts: options.paragraphParts
	};
	throw err;
}

function getUnmatchedLoopException(options) {
	var location = options.location;

	var t = location === "start" ? "unclosed" : "unopened";
	var T = location === "start" ? "Unclosed" : "Unopened";

	var err = new XTTemplateError(T + " loop");
	var tag = options.part.value;
	err.properties = {
		id: t + "_loop",
		explanation: "The loop with tag \\"" + tag + "\\" is " + t,
		xtag: tag
	};
	return err;
}

function getClosingTagNotMatchOpeningTag(options) {
	var tags = options.tags;


	var err = new XTTemplateError("Closing tag does not match opening tag");
	err.properties = {
		id: "closing_tag_does_not_match_opening_tag",
		explanation: "The tag \\"" + tags[0].value + "\\" is closed by the tag \\"" + tags[1].value + "\\"",
		openingtag: tags[0].value,
		offset: [tags[0].offset, tags[1].offset],
		closingtag: tags[1].value
	};
	return err;
}

function getScopeCompilationError(_ref2) {
	var tag = _ref2.tag,
	    rootError = _ref2.rootError;

	var err = new XTScopeParserError("Scope parser compilation failed");
	err.properties = {
		id: "scopeparser_compilation_failed",
		tag: tag,
		explanation: "The scope parser for the tag \\"" + tag + "\\" failed to compile",
		rootError: rootError
	};
	return err;
}

function getScopeParserExecutionError(_ref3) {
	var tag = _ref3.tag,
	    scope = _ref3.scope,
	    error = _ref3.error;

	var err = new XTScopeParserError("Scope parser execution failed");
	err.properties = {
		id: "scopeparser_execution_failed",
		explanation: "The scope parser for the tag " + tag + " failed to execute",
		scope: scope,
		tag: tag,
		rootError: error
	};
	return err;
}

function getLoopPositionProducesInvalidXMLError(_ref4) {
	var tag = _ref4.tag;

	var err = new XTTemplateError("The position of the loop tags \\"" + tag + "\\" would produce invalid XML");
	err.properties = {
		tag: tag,
		id: "loop_position_invalid",
		explanation: "The tags \\"" + tag + "\\" are misplaced in the document, for example one of them is in a table and the other one outside the table"
	};
	return err;
}

function throwUnimplementedTagType(part) {
	var err = new XTTemplateError("Unimplemented tag type \\"" + part.type + "\\"");
	err.properties = {
		part: part,
		id: "unimplemented_tag_type"
	};
	throw err;
}

function throwMalformedXml(part) {
	var err = new XTInternalError("Malformed xml");
	err.properties = {
		part: part,
		id: "malformed_xml"
	};
	throw err;
}

function throwLocationInvalid(part) {
	throw new XTInternalError("Location should be one of \\"start\\" or \\"end\\" (given : " + part.location + ")");
}

function throwFileTypeNotHandled(fileType) {
	var err = new XTInternalError("The filetype \\"" + fileType + "\\" is not handled by docxtemplater");
	err.properties = {
		id: "filetype_not_handled",
		explanation: "The file you are trying to generate is of type \\"" + fileType + "\\", but only docx and pptx formats are handled"
	};
	throw err;
}

function throwFileTypeNotIdentified() {
	var err = new XTInternalError("The filetype for this file could not be identified, is this file corrupted ?");
	err.properties = {
		id: "filetype_not_identified"
	};
	throw err;
}

module.exports = {
	XTError: XTError,
	XTTemplateError: XTTemplateError,
	XTInternalError: XTInternalError,
	XTScopeParserError: XTScopeParserError,
	RenderingError: RenderingError,
	throwMultiError: throwMultiError,
	throwXmlTagNotFound: throwXmlTagNotFound,
	throwCorruptCharacters: throwCorruptCharacters,
	throwContentMustBeString: throwContentMustBeString,
	getUnmatchedLoopException: getUnmatchedLoopException,
	throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,
	throwRawTagNotInParagraph: throwRawTagNotInParagraph,
	getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,
	throwUnimplementedTagType: throwUnimplementedTagType,
	getScopeCompilationError: getScopeCompilationError,
	getScopeParserExecutionError: getScopeParserExecutionError,
	getUnopenedTagException: getUnopenedTagException,
	getUnclosedTagException: getUnclosedTagException,
	throwMalformedXml: throwMalformedXml,
	throwFileTypeNotIdentified: throwFileTypeNotIdentified,
	throwFileTypeNotHandled: throwFileTypeNotHandled,
	getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,
	throwLocationInvalid: throwLocationInvalid
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/errors.js?`)},36729:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var loopModule = __webpack_require__(87923);
var spacePreserveModule = __webpack_require__(70448);
var rawXmlModule = __webpack_require__(64136);
var expandPairTrait = __webpack_require__(99928);
var render = __webpack_require__(58610);

var PptXFileTypeConfig = {
	getTemplatedFiles: function getTemplatedFiles(zip) {
		var slideTemplates = zip.file(/ppt\\/(slides|slideMasters)\\/(slide|slideMaster)\\d+\\.xml/).map(function (file) {
			return file.name;
		});
		return slideTemplates.concat(["ppt/presentation.xml", "docProps/app.xml", "docProps/core.xml"]);
	},
	textPath: function textPath() {
		return "ppt/slides/slide1.xml";
	},

	tagsXmlTextArray: ["a:t", "m:t", "vt:lpstr", "dc:title", "dc:creator", "cp:keywords"],
	tagsXmlLexedArray: ["p:sp", "a:tc", "a:tr", "a:table", "a:p", "a:r"],
	expandTags: [{ contains: "a:tc", expand: "a:tr" }],
	onParagraphLoop: [{ contains: "a:p", expand: "a:p", onlyTextInTag: true }],
	tagRawXml: "p:sp",
	tagTextXml: "a:t",
	baseModules: [loopModule, expandPairTrait, rawXmlModule, render]
};

var DocXFileTypeConfig = {
	getTemplatedFiles: function getTemplatedFiles(zip) {
		var baseTags = ["docProps/core.xml", "docProps/app.xml", "word/document.xml", "word/document2.xml"];
		var slideTemplates = zip.file(/word\\/(header|footer)\\d+\\.xml/).map(function (file) {
			return file.name;
		});
		return slideTemplates.concat(baseTags);
	},
	textPath: function textPath(zip) {
		if (zip.files["word/document.xml"]) {
			return "word/document.xml";
		}
		if (zip.files["word/document2.xml"]) {
			return "word/document2.xml";
		}
	},

	tagsXmlTextArray: ["w:t", "m:t", "vt:lpstr", "dc:title", "dc:creator", "cp:keywords"],
	tagsXmlLexedArray: ["w:tc", "w:tr", "w:table", "w:p", "w:r", "w:rPr", "w:pPr", "w:spacing"],
	expandTags: [{ contains: "w:tc", expand: "w:tr" }],
	onParagraphLoop: [{ contains: "w:p", expand: "w:p", onlyTextInTag: true }],
	tagRawXml: "w:p",
	tagTextXml: "w:t",
	baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render]
};

module.exports = {
	docx: DocXFileTypeConfig,
	pptx: PptXFileTypeConfig
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/file-type-config.js?`)},33493:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = __webpack_require__(27284),
    getUnclosedTagException = _require.getUnclosedTagException,
    getUnopenedTagException = _require.getUnopenedTagException,
    throwMalformedXml = _require.throwMalformedXml;

var _require2 = __webpack_require__(43707),
    concatArrays = _require2.concatArrays,
    isTextStart = _require2.isTextStart,
    isTextEnd = _require2.isTextEnd;

var EQUAL = 0;
var START = -1;
var END = 1;

function inRange(range, match) {
	return range[0] <= match.offset && match.offset < range[1];
}

function updateInTextTag(part, inTextTag) {
	if (isTextStart(part)) {
		if (inTextTag) {
			throwMalformedXml(part);
		}
		return true;
	}
	if (isTextEnd(part)) {
		if (!inTextTag) {
			throwMalformedXml(part);
		}
		return false;
	}
	return inTextTag;
}

function getTag(tag) {
	var position = "start";
	var start = 1;
	if (tag[tag.length - 2] === "/") {
		position = "selfclosing";
	}
	if (tag[1] === "/") {
		start = 2;
		position = "end";
	}
	var index = tag.indexOf(" ");
	var end = index === -1 ? tag.length - 1 : index;
	return {
		tag: tag.slice(start, end),
		position: position
	};
}

function tagMatcher(content, textMatchArray, othersMatchArray) {
	var cursor = 0;
	var contentLength = content.length;
	var allMatches = concatArrays([textMatchArray.map(function (tag) {
		return { tag: tag, text: true };
	}), othersMatchArray.map(function (tag) {
		return { tag: tag, text: false };
	})]).reduce(function (allMatches, t) {
		allMatches[t.tag] = t.text;
		return allMatches;
	}, {});
	var totalMatches = [];

	while (cursor < contentLength) {
		cursor = content.indexOf("<", cursor);
		if (cursor === -1) {
			break;
		}
		var offset = cursor;
		cursor = content.indexOf(">", cursor);
		var tagText = content.slice(offset, cursor + 1);

		var _getTag = getTag(tagText),
		    tag = _getTag.tag,
		    position = _getTag.position;

		var text = allMatches[tag];
		if (text == null) {
			continue;
		}
		totalMatches.push({
			type: "tag",
			position: position,
			text: text,
			offset: offset,
			value: tagText,
			tag: tag
		});
	}

	return totalMatches;
}

function getDelimiterErrors(delimiterMatches, fullText, ranges) {
	if (delimiterMatches.length === 0) {
		return [];
	}
	var errors = [];
	var inDelimiter = false;
	var lastDelimiterMatch = { offset: 0 };
	var xtag = void 0;
	var rangeIndex = 0;
	delimiterMatches.forEach(function (delimiterMatch) {
		while (ranges[rangeIndex + 1]) {
			if (ranges[rangeIndex + 1].offset > delimiterMatch.offset) {
				break;
			}
			rangeIndex++;
		}
		xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);
		if (delimiterMatch.position === "start" && inDelimiter || delimiterMatch.position === "end" && !inDelimiter) {
			if (delimiterMatch.position === "start") {
				errors.push(getUnclosedTagException({ xtag: xtag, offset: lastDelimiterMatch.offset }));
				delimiterMatch.error = true;
			} else {
				errors.push(getUnopenedTagException({ xtag: xtag, offset: delimiterMatch.offset }));
				delimiterMatch.error = true;
			}
		} else {
			inDelimiter = !inDelimiter;
		}
		lastDelimiterMatch = delimiterMatch;
	});
	var delimiterMatch = { offset: fullText.length };
	xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);
	if (inDelimiter) {
		errors.push(getUnclosedTagException({ xtag: xtag, offset: lastDelimiterMatch.offset }));
		delimiterMatch.error = true;
	}
	return errors;
}

function compareOffsets(startOffset, endOffset) {
	if (startOffset === endOffset) {
		return 0;
	}
	if (startOffset === -1 || endOffset === -1) {
		return endOffset < startOffset ? START : END;
	}
	return startOffset < endOffset ? START : END;
}

function splitDelimiters(inside) {
	var newDelimiters = inside.split(" ");
	if (newDelimiters.length !== 2) {
		throw new Error("New Delimiters cannot be parsed");
	}

	var _newDelimiters = _slicedToArray(newDelimiters, 2),
	    start = _newDelimiters[0],
	    end = _newDelimiters[1];

	if (start.length === 0 || end.length === 0) {
		throw new Error("New Delimiters cannot be parsed");
	}
	return [start, end];
}

function getAllIndexes(fullText, delimiters) {
	var indexes = [];
	var start = delimiters.start,
	    end = delimiters.end;

	var offset = -1;
	while (true) {
		var startOffset = fullText.indexOf(start, offset + 1);
		var endOffset = fullText.indexOf(end, offset + 1);
		var position = null;
		var len = void 0;
		var compareResult = compareOffsets(startOffset, endOffset);
		if (compareResult === EQUAL) {
			return indexes;
		}
		if (compareResult === END) {
			offset = endOffset;
			position = "end";
			len = end.length;
		}
		if (compareResult === START) {
			offset = startOffset;
			position = "start";
			len = start.length;
		}
		if (position === "start" && fullText[offset + start.length] === "=") {
			indexes.push({
				offset: startOffset,
				position: "start",
				length: start.length,
				changedelimiter: true
			});
			var nextEqual = fullText.indexOf("=", offset + start.length + 1);
			var _endOffset = fullText.indexOf(end, nextEqual + 1);

			indexes.push({
				offset: _endOffset,
				position: "end",
				length: end.length,
				changedelimiter: true
			});
			var insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);

			var _splitDelimiters = splitDelimiters(insideTag);

			var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);

			start = _splitDelimiters2[0];
			end = _splitDelimiters2[1];

			offset = _endOffset;
			continue;
		}
		indexes.push({ offset: offset, position: position, length: len });
	}
}

function Reader(innerContentParts) {
	var _this = this;

	this.innerContentParts = innerContentParts;
	this.full = "";
	this.parseDelimiters = function (delimiters) {
		_this.full = _this.innerContentParts.map(function (p) {
			return p.value;
		}).join("");
		var delimiterMatches = getAllIndexes(_this.full, delimiters);

		var offset = 0;
		var ranges = _this.innerContentParts.map(function (part) {
			offset += part.value.length;
			return { offset: offset - part.value.length, lIndex: part.lIndex };
		});

		var errors = getDelimiterErrors(delimiterMatches, _this.full, ranges);
		var cutNext = 0;
		var delimiterIndex = 0;

		_this.parsed = ranges.map(function (p, i) {
			var offset = p.offset;

			var range = [offset, offset + this.innerContentParts[i].value.length];
			var partContent = this.innerContentParts[i].value;
			var delimitersInOffset = [];
			while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {
				delimitersInOffset.push(delimiterMatches[delimiterIndex]);
				delimiterIndex++;
			}
			var parts = [];
			var cursor = 0;
			if (cutNext > 0) {
				cursor = cutNext;
				cutNext = 0;
			}
			var insideDelimiterChange = void 0;
			delimitersInOffset.forEach(function (delimiterInOffset) {
				var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);
				if (value.length > 0) {
					if (insideDelimiterChange) {
						if (delimiterInOffset.changedelimiter) {
							cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;
							insideDelimiterChange = delimiterInOffset.position === "start";
						}
						return;
					}
					parts.push({ type: "content", value: value, offset: cursor + offset });
					cursor += value.length;
				}
				var delimiterPart = {
					type: "delimiter",
					position: delimiterInOffset.position,
					offset: cursor + offset
				};
				if (delimiterInOffset.error) {
					delimiterPart.error = delimiterInOffset.error;
				}
				if (delimiterInOffset.changedelimiter) {
					insideDelimiterChange = delimiterInOffset.position === "start";
					cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;
					return;
				}
				parts.push(delimiterPart);
				cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;
			});
			cutNext = cursor - partContent.length;
			var value = partContent.substr(cursor);
			if (value.length > 0) {
				parts.push({ type: "content", value: value, offset: offset });
			}
			return parts;
		}, _this);
		_this.errors = errors;
	};
}

function getContentParts(xmlparsed) {
	var inTextTag = false;
	var innerContentParts = [];
	xmlparsed.forEach(function (part) {
		inTextTag = updateInTextTag(part, inTextTag);
		if (inTextTag && part.type === "content") {
			innerContentParts.push(part);
		}
	});
	return innerContentParts;
}

module.exports = {
	parse: function parse(xmlparsed, delimiters) {
		var inTextTag = false;
		var reader = new Reader(getContentParts(xmlparsed));
		reader.parseDelimiters(delimiters);

		var lexed = [];
		var index = 0;
		xmlparsed.forEach(function (part) {
			inTextTag = updateInTextTag(part, inTextTag);
			if (part.type === "content") {
				part.position = inTextTag ? "insidetag" : "outsidetag";
			}
			if (inTextTag && part.type === "content") {
				Array.prototype.push.apply(lexed, reader.parsed[index].map(function (p) {
					if (p.type === "content") {
						p.position = "insidetag";
					}
					return p;
				}));
				index++;
			} else {
				lexed.push(part);
			}
		});
		lexed = lexed.map(function (p, i) {
			p.lIndex = i;
			return p;
		});
		return { errors: reader.errors, lexed: lexed };
	},
	xmlparse: function xmlparse(content, xmltags) {
		var matches = tagMatcher(content, xmltags.text, xmltags.other);
		var cursor = 0;
		var parsed = matches.reduce(function (parsed, match) {
			var value = content.substr(cursor, match.offset - cursor);
			if (value.length > 0) {
				parsed.push({ type: "content", value: value });
			}
			cursor = match.offset + match.value.length;
			delete match.offset;
			if (match.value.length > 0) {
				parsed.push(match);
			}
			return parsed;
		}, []);
		var value = content.substr(cursor);
		if (value.length > 0) {
			parsed.push({ type: "content", value: value });
		}
		return parsed;
	}
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/lexer.js?`)},17318:function(module){"use strict";eval(`

function getMinFromArrays(arrays, state) {
	var minIndex = -1;
	for (var i = 0, l = arrays.length; i < l; i++) {
		if (state[i] >= arrays[i].length) {
			continue;
		}
		if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {
			minIndex = i;
		}
	}
	if (minIndex === -1) {
		throw new Error("minIndex negative");
	}
	return minIndex;
}

module.exports = function (arrays) {
	var totalLength = arrays.reduce(function (sum, array) {
		return sum + array.length;
	}, 0);
	arrays = arrays.filter(function (array) {
		return array.length > 0;
	});

	var resultArray = new Array(totalLength);

	var state = arrays.map(function () {
		return 0;
	});

	var i = 0;

	while (i <= totalLength - 1) {
		var arrayIndex = getMinFromArrays(arrays, state);
		resultArray[i] = arrays[arrayIndex][state[arrayIndex]];
		state[arrayIndex]++;
		i++;
	}

	return resultArray;
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/mergesort.js?`)},39523:function(module){"use strict";eval(`

function emptyFun() {}
function identity(i) {
	return i;
}
module.exports = function (module) {
	var defaults = {
		set: emptyFun,
		parse: emptyFun,
		render: emptyFun,
		getTraits: emptyFun,
		optionsTransformer: identity,
		errorsTransformer: identity,
		getRenderedMap: identity,
		postparse: identity,
		on: emptyFun,
		resolve: emptyFun
	};
	if (Object.keys(defaults).every(function (key) {
		return !module[key];
	})) {
		throw new Error("This module cannot be wrapped, because it doesn't define any of the necessary functions");
	}
	Object.keys(defaults).forEach(function (key) {
		module[key] = module[key] || defaults[key];
	});
	return module;
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/module-wrapper.js?`)},99928:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var traitName = "expandPair";
var mergeSort = __webpack_require__(17318);

var _require = __webpack_require__(43707),
    getLeft = _require.getLeft,
    getRight = _require.getRight;

var wrapper = __webpack_require__(39523);

var _require2 = __webpack_require__(85955),
    getExpandToDefault = _require2.getExpandToDefault;

var _require3 = __webpack_require__(27284),
    getUnmatchedLoopException = _require3.getUnmatchedLoopException,
    getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,
    throwLocationInvalid = _require3.throwLocationInvalid;

function getOpenCountChange(part) {
	switch (part.location) {
		case "start":
			return 1;
		case "end":
			return -1;
		default:
			throwLocationInvalid(part);
	}
}

function getPairs(traits) {
	var errors = [];
	var pairs = [];
	if (traits.length === 0) {
		return { pairs: pairs, errors: errors };
	}
	var countOpen = 1;

	var _traits = _slicedToArray(traits, 1),
	    firstTrait = _traits[0];

	if (firstTrait.part.location === "start") {
		for (var i = 1; i < traits.length; i++) {
			var currentTrait = traits[i];
			countOpen += getOpenCountChange(currentTrait.part);
			if (countOpen === 0) {
				var _outer = getPairs(traits.slice(i + 1));
				if (currentTrait.part.value !== firstTrait.part.value && currentTrait.part.value !== "") {
					errors.push(getClosingTagNotMatchOpeningTag({
						tags: [firstTrait.part, currentTrait.part]
					}));
				} else {
					pairs = [[firstTrait, currentTrait]];
				}
				return {
					pairs: pairs.concat(_outer.pairs),
					errors: errors.concat(_outer.errors)
				};
			}
		}
	}
	var part = firstTrait.part;

	errors.push(getUnmatchedLoopException({ part: part, location: part.location }));
	var outer = getPairs(traits.slice(1));
	return { pairs: outer.pairs, errors: errors.concat(outer.errors) };
}

var expandPairTrait = {
	name: "ExpandPairTrait",
	optionsTransformer: function optionsTransformer(options, docxtemplater) {
		this.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);
		return options;
	},
	postparse: function postparse(postparsed, _ref) {
		var _this = this;

		var getTraits = _ref.getTraits,
		    _postparse = _ref.postparse;

		var traits = getTraits(traitName, postparsed);
		traits = traits.map(function (trait) {
			return trait || [];
		});
		traits = mergeSort(traits);

		var _getPairs = getPairs(traits),
		    pairs = _getPairs.pairs,
		    errors = _getPairs.errors;

		var expandedPairs = pairs.map(function (pair) {
			var expandTo = pair[0].part.expandTo;

			if (expandTo === "auto") {
				var result = getExpandToDefault(postparsed, pair, _this.expandTags);
				if (result.error) {
					errors.push(result.error);
				}
				expandTo = result.value;
			}
			if (!expandTo) {
				return [pair[0].offset, pair[1].offset];
			}
			var left = getLeft(postparsed, expandTo, pair[0].offset);
			var right = getRight(postparsed, expandTo, pair[1].offset);
			return [left, right];
		});

		var currentPairIndex = 0;
		var innerParts = void 0;
		var newParsed = postparsed.reduce(function (newParsed, part, i) {
			var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i;
			var pair = pairs[currentPairIndex];
			var expandedPair = expandedPairs[currentPairIndex];
			if (!inPair) {
				newParsed.push(part);
				return newParsed;
			}
			if (expandedPair[0] === i) {
				innerParts = [];
			}
			if (pair[0].offset !== i && pair[1].offset !== i) {
				innerParts.push(part);
			}
			if (expandedPair[1] === i) {
				var basePart = postparsed[pair[0].offset];
				basePart.subparsed = _postparse(innerParts, { basePart: basePart });
				delete basePart.location;
				delete basePart.expandTo;
				newParsed.push(basePart);
				currentPairIndex++;
			}
			return newParsed;
		}, []);
		return { postparsed: newParsed, errors: errors };
	}
};

module.exports = function () {
	return wrapper(expandPairTrait);
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/modules/expand-pair-trait.js?`)},87923:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _require = __webpack_require__(43707),
    mergeObjects = _require.mergeObjects,
    chunkBy = _require.chunkBy,
    last = _require.last,
    isParagraphStart = _require.isParagraphStart,
    isParagraphEnd = _require.isParagraphEnd,
    isContent = _require.isContent;

var dashInnerRegex = /^-([^\\s]+)\\s(.+)$/;
var wrapper = __webpack_require__(39523);

var moduleName = "loop";

function hasContent(parts) {
	return parts.some(function (part) {
		return isContent(part);
	});
}

function isEnclosedByParagraphs(parsed) {
	if (parsed.length === 0) {
		return false;
	}
	return isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));
}

function getOffset(chunk) {
	return hasContent(chunk) ? 0 : chunk.length;
}

var loopModule = {
	name: "LoopModule",
	prefix: {
		start: "#",
		end: "/",
		dash: "-",
		inverted: "^"
	},
	parse: function parse(placeHolderContent) {
		var module = moduleName;
		var type = "placeholder";
		var prefix = this.prefix;
		if (placeHolderContent[0] === prefix.start) {
			return {
				type: type,
				value: placeHolderContent.substr(1),
				expandTo: "auto",
				module: module,
				location: "start",
				inverted: false
			};
		}
		if (placeHolderContent[0] === prefix.inverted) {
			return {
				type: type,
				value: placeHolderContent.substr(1),
				expandTo: "auto",
				module: module,
				location: "start",
				inverted: true
			};
		}
		if (placeHolderContent[0] === prefix.end) {
			return {
				type: type,
				value: placeHolderContent.substr(1),
				module: module,
				location: "end"
			};
		}
		if (placeHolderContent[0] === prefix.dash) {
			var value = placeHolderContent.replace(dashInnerRegex, "$2");
			var expandTo = placeHolderContent.replace(dashInnerRegex, "$1");
			return {
				type: type,
				value: value,
				expandTo: expandTo,
				module: module,
				location: "start",
				inverted: false
			};
		}
		return null;
	},
	getTraits: function getTraits(traitName, parsed) {
		if (traitName !== "expandPair") {
			return;
		}

		return parsed.reduce(function (tags, part, offset) {
			if (part.type === "placeholder" && part.module === moduleName) {
				tags.push({ part: part, offset: offset });
			}
			return tags;
		}, []);
	},
	postparse: function postparse(parsed, _ref) {
		var basePart = _ref.basePart;

		if (!isEnclosedByParagraphs(parsed)) {
			return parsed;
		}
		if (!basePart || basePart.expandTo !== "auto") {
			return parsed;
		}
		var chunks = chunkBy(parsed, function (p) {
			if (isParagraphStart(p)) {
				return "start";
			}
			if (isParagraphEnd(p)) {
				return "end";
			}
			return null;
		});
		if (chunks.length <= 2) {
			return parsed;
		}
		var firstChunk = chunks[0];
		var lastChunk = last(chunks);
		var firstOffset = getOffset(firstChunk);
		var lastOffset = getOffset(lastChunk);
		if (firstOffset === 0 || lastOffset === 0) {
			return parsed;
		}
		var result = parsed.slice(firstOffset, parsed.length - lastOffset);
		return result;
	},
	render: function render(part, options) {
		if (!part.type === "placeholder" || part.module !== moduleName) {
			return null;
		}
		var totalValue = [];
		var errors = [];
		function loopOver(scope, i) {
			var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i);
			var subRendered = options.render(mergeObjects({}, options, {
				compiled: part.subparsed,
				tags: {},
				scopeManager: scopeManager
			}));
			totalValue = totalValue.concat(subRendered.parts);
			errors = errors.concat(subRendered.errors || []);
		}
		options.scopeManager.loopOver(part.value, loopOver, part.inverted);
		return { value: totalValue.join(""), errors: errors };
	},
	resolve: function resolve(part, options) {
		if (!part.type === "placeholder" || part.module !== moduleName) {
			return null;
		}
		var value = options.scopeManager.getValue(part.value);
		var promises = [];
		function loopOver(scope, i) {
			var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i);
			promises.push(options.resolve(mergeObjects(options, {
				compiled: part.subparsed,
				tags: {},
				scopeManager: scopeManager
			})));
		}
		return Promise.resolve(value).then(function (value) {
			options.scopeManager.loopOverValue(value, loopOver, part.inverted);
			return Promise.all(promises).then(function (r) {
				return r.map(function (_ref2) {
					var resolved = _ref2.resolved;

					return resolved;
				});
			});
		});
	}
};

module.exports = function () {
	return wrapper(loopModule);
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/modules/loop.js?`)},64136:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var traits = __webpack_require__(85955);

var _require = __webpack_require__(43707),
    isContent = _require.isContent;

var _require2 = __webpack_require__(27284),
    throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph;

var moduleName = "rawxml";
var wrapper = __webpack_require__(39523);

function getNearestLeft(parsed, elements, index) {
	for (var i = index; i >= 0; i--) {
		var part = parsed[i];
		for (var j = 0, len = elements.length; j < len; j++) {
			var element = elements[j];
			if (part.value.indexOf("<" + element) === 0 && [">", " "].indexOf(part.value[element.length + 1]) !== -1) {
				return elements[j];
			}
		}
	}
	return null;
}

function getNearestRight(parsed, elements, index) {
	for (var i = index, l = parsed.length; i < l; i++) {
		var part = parsed[i];
		for (var j = 0, len = elements.length; j < len; j++) {
			var element = elements[j];
			if (part.value === "</" + element + ">") {
				return elements[j];
			}
		}
	}
	return -1;
}

function getInner(_ref) {
	var part = _ref.part,
	    left = _ref.left,
	    right = _ref.right,
	    postparsed = _ref.postparsed,
	    index = _ref.index;

	var before = getNearestLeft(postparsed, ["w:p", "w:tc"], left - 1);
	var after = getNearestRight(postparsed, ["w:p", "w:tc"], right + 1);
	if (before === after && before === "w:tc") {
		part.emptyValue = "<w:p></w:p>";
	}
	var paragraphParts = postparsed.slice(left + 1, right);
	paragraphParts.forEach(function (p, i) {
		if (i === index - left - 1) {
			return;
		}
		if (isContent(p)) {
			throwRawTagShouldBeOnlyTextInParagraph({ paragraphParts: paragraphParts, part: part });
		}
	});
	return part;
}

var RawXmlModule = function () {
	function RawXmlModule() {
		_classCallCheck(this, RawXmlModule);

		this.name = "RawXmlModule";
		this.prefix = "@";
	}

	_createClass(RawXmlModule, [{
		key: "optionsTransformer",
		value: function optionsTransformer(options, docxtemplater) {
			this.fileTypeConfig = docxtemplater.fileTypeConfig;
			return options;
		}
	}, {
		key: "parse",
		value: function parse(placeHolderContent) {
			var type = "placeholder";
			if (placeHolderContent[0] !== this.prefix) {
				return null;
			}
			return { type: type, value: placeHolderContent.substr(1), module: moduleName };
		}
	}, {
		key: "postparse",
		value: function postparse(postparsed) {
			return traits.expandToOne(postparsed, {
				moduleName: moduleName,
				getInner: getInner,
				expandTo: this.fileTypeConfig.tagRawXml
			});
		}
	}, {
		key: "render",
		value: function render(part, options) {
			if (part.module !== moduleName) {
				return null;
			}
			var value = options.scopeManager.getValue(part.value);
			if (value == null) {
				value = options.nullGetter(part);
			}
			if (!value) {
				return { value: part.emptyValue || "" };
			}
			return { value: value };
		}
	}]);

	return RawXmlModule;
}();

module.exports = function () {
	return wrapper(new RawXmlModule());
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/modules/rawxml.js?`)},58610:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var wrapper = __webpack_require__(39523);

var _require = __webpack_require__(27284),
    getScopeCompilationError = _require.getScopeCompilationError;

var Render = function () {
	function Render() {
		_classCallCheck(this, Render);

		this.name = "Render";
	}

	_createClass(Render, [{
		key: "set",
		value: function set(obj) {
			if (obj.compiled) {
				this.compiled = obj.compiled;
			}
			if (obj.data != null) {
				this.data = obj.data;
			}
		}
	}, {
		key: "getRenderedMap",
		value: function getRenderedMap(mapper) {
			var _this = this;

			return Object.keys(this.compiled).reduce(function (mapper, from) {
				mapper[from] = { from: from, data: _this.data };
				return mapper;
			}, mapper);
		}
	}, {
		key: "optionsTransformer",
		value: function optionsTransformer(options, docxtemplater) {
			this.parser = docxtemplater.parser;
			return options;
		}
	}, {
		key: "postparse",
		value: function postparse(postparsed) {
			var _this2 = this;

			var errors = [];
			postparsed.forEach(function (p) {
				if (p.type === "placeholder") {
					var tag = p.value;
					try {
						_this2.parser(tag);
					} catch (rootError) {
						errors.push(getScopeCompilationError({ tag: tag, rootError: rootError }));
					}
				}
			});
			return { postparsed: postparsed, errors: errors };
		}
	}]);

	return Render;
}();

module.exports = function () {
	return wrapper(new Render());
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/modules/render.js?`)},70448:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var wrapper = __webpack_require__(39523);

var _require = __webpack_require__(43707),
    isTextStart = _require.isTextStart,
    isTextEnd = _require.isTextEnd;

function addXMLPreserve(tag) {
	if (tag.indexOf('xml:space="preserve"') !== -1) {
		return tag;
	}
	return tag.substr(0, tag.length - 1) + ' xml:space="preserve">';
}

var spacePreserve = {
	name: "SpacePreserveModule",
	postparse: function postparse(postparsed) {
		var chunk = [];
		var inChunk = false;
		var endLindex = 0;
		var lastTextTag = 0;
		var result = postparsed.reduce(function (postparsed, part) {
			if (isTextStart(part) && part.tag === "w:t") {
				inChunk = true;
				lastTextTag = chunk.length;
			}
			if (!inChunk) {
				postparsed.push(part);
				return postparsed;
			}
			if (!endLindex && part.type === "placeholder" && !part.module) {
				endLindex = part.endLindex;
				chunk[0].value = addXMLPreserve(chunk[0].value);
			}
			chunk.push(part);
			if (isTextEnd(part)) {
				if (!endLindex) {
					Array.prototype.push.apply(postparsed, chunk);
					inChunk = false;
					lastTextTag = 0;
					endLindex = 0;
					chunk = [];
				} else if (part.lIndex > endLindex) {
					chunk[lastTextTag].value = addXMLPreserve(chunk[lastTextTag].value);
					Array.prototype.push.apply(postparsed, chunk);
					inChunk = false;
					lastTextTag = 0;
					endLindex = 0;
					chunk = [];
				}
			}
			return postparsed;
		}, []);
		Array.prototype.push.apply(result, chunk);
		return result;
	}
};
module.exports = function () {
	return wrapper(spacePreserve);
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/modules/space-preserve.js?`)},2341:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _require = __webpack_require__(43707),
    wordToUtf8 = _require.wordToUtf8,
    concatArrays = _require.concatArrays;

function moduleParse(modules, placeHolderContent, parsed, startOffset, endLindex) {
	var moduleParsed = void 0;
	for (var i = 0, l = modules.length; i < l; i++) {
		var _module = modules[i];
		moduleParsed = _module.parse(placeHolderContent);
		if (moduleParsed) {
			moduleParsed.offset = startOffset;
			parsed.push(moduleParsed);
			return parsed;
		}
	}
	parsed.push({
		type: "placeholder",
		value: placeHolderContent,
		offset: startOffset,
		endLindex: endLindex
	});
	return parsed;
}

var parser = {
	postparse: function postparse(postparsed, modules) {
		function getTraits(traitName, postparsed) {
			return modules.map(function (module) {
				return module.getTraits(traitName, postparsed);
			});
		}
		var errors = [];
		function postparse(postparsed, options) {
			return modules.reduce(function (postparsed, module) {
				var r = module.postparse(postparsed, _extends({}, options, {
					postparse: postparse,
					getTraits: getTraits
				}));
				if (r.errors) {
					errors = concatArrays([errors, r.errors]);
					return r.postparsed;
				}
				return r;
			}, postparsed);
		}
		return { postparsed: postparse(postparsed), errors: errors };
	},
	parse: function parse(lexed, modules) {
		var inPlaceHolder = false;
		var placeHolderContent = "";
		var startOffset = void 0;
		var tailParts = [];
		return lexed.reduce(function lexedToParsed(parsed, token) {
			if (token.type === "delimiter") {
				inPlaceHolder = token.position === "start";
				if (token.position === "end") {
					var endLindex = token.lIndex;
					placeHolderContent = wordToUtf8(placeHolderContent);
					parsed = moduleParse(modules, placeHolderContent, parsed, startOffset, endLindex);
					startOffset = null;
					Array.prototype.push.apply(parsed, tailParts);
					tailParts = [];
				}
				if (token.position === "start") {
					tailParts = [];
					startOffset = token.offset;
				}
				placeHolderContent = "";
				return parsed;
			}
			if (!inPlaceHolder) {
				parsed.push(token);
				return parsed;
			}
			if (token.type !== "content" || token.position !== "insidetag") {
				tailParts.push(token);
				return parsed;
			}
			placeHolderContent += token.value;
			return parsed;
		}, []);
	}
};

module.exports = parser;

//# sourceURL=webpack:///./node_modules/docxtemplater/js/parser.js?`)},17102:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _require = __webpack_require__(43707),
    utf8ToWord = _require.utf8ToWord,
    concatArrays = _require.concatArrays,
    hasCorruptCharacters = _require.hasCorruptCharacters;

var _require2 = __webpack_require__(27284),
    throwUnimplementedTagType = _require2.throwUnimplementedTagType,
    throwCorruptCharacters = _require2.throwCorruptCharacters;

function moduleRender(part, options) {
	var moduleRendered = void 0;
	for (var i = 0, l = options.modules.length; i < l; i++) {
		var _module = options.modules[i];
		moduleRendered = _module.render(part, options);
		if (moduleRendered) {
			return moduleRendered;
		}
	}
	return false;
}

function render(options) {
	var compiled = options.compiled,
	    scopeManager = options.scopeManager,
	    nullGetter = options.nullGetter;

	var errors = [];
	var parts = compiled.map(function (part) {
		var moduleRendered = moduleRender(part, options);
		if (moduleRendered) {
			if (moduleRendered.errors) {
				errors = concatArrays([errors, moduleRendered.errors]);
			}
			return moduleRendered.value;
		}
		if (part.type === "placeholder") {
			var value = scopeManager.getValue(part.value);
			if (value == null) {
				value = nullGetter(part);
			}
			if (hasCorruptCharacters(value)) {
				throwCorruptCharacters({ tag: part.value, value: value });
			}
			return utf8ToWord(value);
		}
		if (part.type === "content" || part.type === "tag") {
			return part.value;
		}
		throwUnimplementedTagType(part);
	});
	return { errors: errors, parts: parts };
}

module.exports = render;

//# sourceURL=webpack:///./node_modules/docxtemplater/js/render.js?`)},24963:function(module){"use strict";eval(`

function moduleResolve(part, options) {
	var moduleResolved = void 0;
	for (var i = 0, l = options.modules.length; i < l; i++) {
		var _module = options.modules[i];
		moduleResolved = _module.resolve(part, options);
		if (moduleResolved) {
			return moduleResolved;
		}
	}
	return false;
}

function resolve(options) {
	var resolved = [];
	var compiled = options.compiled,
	    scopeManager = options.scopeManager,
	    nullGetter = options.nullGetter;

	options.resolved = resolved;
	var errors = [];
	return Promise.all(compiled.map(function (part) {
		var moduleResolved = moduleResolve(part, options);
		if (moduleResolved) {
			return moduleResolved.then(function (value) {
				resolved.push({ tag: part.value, value: value });
			});
		}
		if (part.type === "placeholder") {
			return scopeManager.getValueAsync(part.value).then(function (value) {
				if (value == null) {
					value = nullGetter(part);
				}
				resolved.push({ tag: part.value, value: value });
				return value;
			});
		}
		return;
	}).filter(function (a) {
		return a;
	})).then(function () {
		return { errors: errors, resolved: resolved };
	});
}

module.exports = resolve;

//# sourceURL=webpack:///./node_modules/docxtemplater/js/resolve.js?`)},6752:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(27284),
    getScopeParserExecutionError = _require.getScopeParserExecutionError;

// This class responsibility is to manage the scope


var ScopeManager = function () {
	function ScopeManager(options) {
		_classCallCheck(this, ScopeManager);

		this.scopePath = options.scopePath;
		this.scopePathItem = options.scopePathItem;
		this.scopeList = options.scopeList;
		this.parser = options.parser;
		this.resolved = options.resolved;
	}

	_createClass(ScopeManager, [{
		key: "loopOver",
		value: function loopOver(tag, callback, inverted) {
			inverted = inverted || false;
			return this.loopOverValue(this.getValue(tag), callback, inverted);
		}
	}, {
		key: "functorIfInverted",
		value: function functorIfInverted(inverted, functor, value, i) {
			if (inverted) {
				functor(value, i);
			}
		}
	}, {
		key: "isValueFalsy",
		value: function isValueFalsy(value, type) {
			return value == null || !value || type === "[object Array]" && value.length === 0;
		}
	}, {
		key: "loopOverValue",
		value: function loopOverValue(value, functor, inverted) {
			var type = Object.prototype.toString.call(value);
			var currentValue = this.scopeList[this.num];
			if (this.isValueFalsy(value, type)) {
				return this.functorIfInverted(inverted, functor, currentValue, 0);
			}
			if (type === "[object Array]") {
				for (var i = 0, scope; i < value.length; i++) {
					scope = value[i];
					this.functorIfInverted(!inverted, functor, scope, i);
				}
				return;
			}
			if (type === "[object Object]") {
				return this.functorIfInverted(!inverted, functor, value, 0);
			}
			return this.functorIfInverted(!inverted, functor, currentValue, 0);
		}
	}, {
		key: "getValue",
		value: function getValue(tag, num) {
			var _this = this;

			this.num = num == null ? this.scopeList.length - 1 : num;
			var scope = this.scopeList[this.num];
			if (this.resolved) {
				var w = this.resolved;
				this.scopePath.forEach(function (p, index) {
					w = w.find(function (r) {
						if (r.tag === p) {
							return true;
						}
					});
					w = w.value[_this.scopePathItem[index]];
				});
				return w = w.find(function (r) {
					if (r.tag === tag) {
						return true;
					}
				}).value;
			}
			// search in the scopes (in reverse order) and keep the first defined value
			var result = void 0;
			var parser = this.parser(tag, { scopePath: this.scopePath });
			try {
				result = parser.get(scope, { num: this.num, scopeList: this.scopeList });
			} catch (error) {
				throw getScopeParserExecutionError({ tag: tag, scope: scope, error: error });
			}
			if (result == null && this.num > 0) {
				return this.getValue(tag, this.num - 1);
			}
			return result;
		}
	}, {
		key: "getValueAsync",
		value: function getValueAsync(tag, num) {
			var _this2 = this;

			this.num = num == null ? this.scopeList.length - 1 : num;
			var scope = this.scopeList[this.num];
			// search in the scopes (in reverse order) and keep the first defined value
			var parser = this.parser(tag, { scopePath: this.scopePath });
			return Promise.resolve(parser.get(scope, { num: this.num, scopeList: this.scopeList })).catch(function (error) {
				throw getScopeParserExecutionError({ tag: tag, scope: scope, error: error });
			}).then(function (result) {
				if (result == null && _this2.num > 0) {
					return _this2.getValueAsync(tag, _this2.num - 1);
				}
				return result;
			});
		}
	}, {
		key: "createSubScopeManager",
		value: function createSubScopeManager(scope, tag, i) {
			return new ScopeManager({
				resolved: this.resolved,
				parser: this.parser,
				scopeList: this.scopeList.concat(scope),
				scopePath: this.scopePath.concat(tag),
				scopePathItem: this.scopePathItem.concat(i)
			});
		}
	}]);

	return ScopeManager;
}();

module.exports = function (options) {
	options.scopePath = [];
	options.scopePathItem = [];
	options.scopeList = [options.tags];
	return new ScopeManager(options);
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/scope-manager.js?`)},85955:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = __webpack_require__(43707),
    getRight = _require.getRight,
    getLeft = _require.getLeft,
    concatArrays = _require.concatArrays,
    chunkBy = _require.chunkBy,
    isTagStart = _require.isTagStart,
    isTagEnd = _require.isTagEnd,
    isContent = _require.isContent,
    last = _require.last;

var _require2 = __webpack_require__(27284),
    XTTemplateError = _require2.XTTemplateError,
    throwRawTagNotInParagraph = _require2.throwRawTagNotInParagraph,
    getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;

function lastTagIsOpenTag(array, tag) {
	if (array.length === 0) {
		return false;
	}
	var lastTag = array[array.length - 1];
	var innerLastTag = lastTag.tag.substr(1);
	var innerCurrentTag = tag.substr(2, tag.length - 3);
	return innerLastTag.indexOf(innerCurrentTag) === 0;
}

function addTag(array, tag) {
	array.push({ tag: tag });
	return array;
}

function getListXmlElements(parts) {
	/*
 get the different closing and opening tags between two texts (doesn't take into account tags that are opened then closed (those that are closed then opened are returned)):
 returns:[{"tag":"</w:r>","offset":13},{"tag":"</w:p>","offset":265},{"tag":"</w:tc>","offset":271},{"tag":"<w:tc>","offset":828},{"tag":"<w:p>","offset":883},{"tag":"<w:r>","offset":1483}]
 */
	var tags = parts.filter(function (part) {
		return part.type === "tag";
	});

	var result = [];

	for (var i = 0, tag; i < tags.length; i++) {
		tag = tags[i].value;
		// closing tag
		if (tag[1] === "/") {
			if (lastTagIsOpenTag(result, tag)) {
				result.pop();
			} else {
				result = addTag(result, tag);
			}
		} else if (tag[tag.length - 2] !== "/") {
			result = addTag(result, tag);
		}
	}
	return result;
}

function has(name, xmlElements) {
	for (var i = 0; i < xmlElements.length; i++) {
		var xmlElement = xmlElements[i];
		if (xmlElement.tag.indexOf("<" + name) === 0) {
			return true;
		}
	}
	return false;
}

function getExpandToDefault(postparsed, pair, expandTags) {
	var parts = postparsed.slice(pair[0].offset, pair[1].offset);
	var xmlElements = getListXmlElements(parts);
	var closingTagCount = xmlElements.filter(function (xmlElement) {
		return xmlElement.tag[1] === "/";
	}).length;
	var startingTagCount = xmlElements.filter(function (xmlElement) {
		var tag = xmlElement.tag;

		return tag[1] !== "/" && tag[tag.length - 2] !== "/";
	}).length;
	if (closingTagCount !== startingTagCount) {
		return {
			error: getLoopPositionProducesInvalidXMLError({
				tag: pair[0].part.value
			})
		};
	}

	var _loop = function _loop(i, len) {
		var _expandTags$i = expandTags[i],
		    contains = _expandTags$i.contains,
		    expand = _expandTags$i.expand,
		    onlyTextInTag = _expandTags$i.onlyTextInTag;

		if (has(contains, xmlElements)) {
			if (onlyTextInTag) {
				var left = getLeft(postparsed, contains, pair[0].offset);
				var right = getRight(postparsed, contains, pair[1].offset);

				var chunks = chunkBy(postparsed.slice(left, right), function (p) {
					if (isTagStart(contains, p)) {
						return "start";
					}
					if (isTagEnd(contains, p)) {
						return "end";
					}
					return null;
				});

				if (chunks.length <= 2) {
					return "continue";
				}

				var firstChunk = chunks[0];
				var lastChunk = last(chunks);

				var firstContent = firstChunk.filter(isContent);
				var lastContent = lastChunk.filter(isContent);
				if (firstContent.length !== 1 || lastContent.length !== 1) {
					return "continue";
				}
			}
			return {
				v: { value: expand }
			};
		}
	};

	for (var i = 0, len = expandTags.length; i < len; i++) {
		var _ret = _loop(i, len);

		switch (_ret) {
			case "continue":
				continue;

			default:
				if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
		}
	}
	return false;
}

function expandOne(part, postparsed, options) {
	var expandTo = part.expandTo || options.expandTo;
	var index = postparsed.indexOf(part);
	if (!expandTo) {
		return postparsed;
	}
	var right = void 0,
	    left = void 0;
	try {
		right = getRight(postparsed, expandTo, index);
		left = getLeft(postparsed, expandTo, index);
	} catch (rootError) {
		if (rootError instanceof XTTemplateError) {
			throwRawTagNotInParagraph({
				part: part,
				rootError: rootError,
				postparsed: postparsed,
				expandTo: expandTo,
				index: index
			});
		}
		throw rootError;
	}
	var leftParts = postparsed.slice(left, index);
	var rightParts = postparsed.slice(index + 1, right + 1);
	var inner = options.getInner({
		index: index,
		part: part,
		leftParts: leftParts,
		rightParts: rightParts,
		left: left,
		right: right,
		postparsed: postparsed
	});
	if (!inner.length) {
		inner.expanded = [leftParts, rightParts];
		inner = [inner];
	}
	return concatArrays([postparsed.slice(0, left), inner, postparsed.slice(right + 1)]);
}

function expandToOne(postparsed, options) {
	var errors = [];
	if (postparsed.errors) {
		errors = postparsed.errors;
		postparsed = postparsed.postparsed;
	}
	var expandToElements = postparsed.reduce(function (elements, part) {
		if (part.type === "placeholder" && part.module === options.moduleName) {
			elements.push(part);
		}
		return elements;
	}, []);

	expandToElements.forEach(function (part) {
		try {
			postparsed = expandOne(part, postparsed, options);
		} catch (error) {
			if (error instanceof XTTemplateError) {
				errors.push(error);
			} else {
				throw error;
			}
		}
	});
	return { postparsed: postparsed, errors: errors };
}

module.exports = {
	expandToOne: expandToOne,
	getExpandToDefault: getExpandToDefault
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/traits.js?`)},50804:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`
// res class responsibility is to parse the XML.

var _require = __webpack_require__(43707),
    pregMatchAll = _require.pregMatchAll;

function handleRecursiveCase(res) {
	/*
 	 Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:
 	 For example with res string "I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping",
 	 - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')
 	 - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')
 	 the test: describe "scope calculation" it "should compute the scope between 2 <w:t>" makes sure that res part of code works
 	 It should even work if they is no XML at all, for example if the code is just "I am sleeping", in res case however, they should only be one match
 	 */

	function replacerUnshift() {
		var pn = { array: Array.prototype.slice.call(arguments) };
		pn.array.shift();
		var match = pn.array[0] + pn.array[1];
		// add match so that pn[0] = whole match, pn[1]= first parenthesis,...
		pn.array.unshift(match);
		pn.array.pop();
		var offset = pn.array.pop();
		pn.offset = offset;
		pn.first = true;
		// add at the beginning
		res.matches.unshift(pn);
	}

	if (res.content.indexOf("<") === -1 && res.content.indexOf(">") === -1) {
		res.content.replace(/^()([^<>]*)$/, replacerUnshift);
	}

	var r = new RegExp("^()([^<]+)</(?:" + res.tagsXmlArrayJoined + ")>");
	res.content.replace(r, replacerUnshift);

	function replacerPush() {
		var pn = { array: Array.prototype.slice.call(arguments) };
		pn.array.pop();
		var offset = pn.array.pop();
		pn.offset = offset;
		pn.last = true;
		if (pn.array[0].indexOf("/>") !== -1) {
			return;
		}
		// add at the end
		res.matches.push(pn);
	}

	r = new RegExp("(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^>]+)$");
	res.content.replace(r, replacerPush);
	return res;
}

module.exports = function xmlMatcher(content, tagsXmlArray) {
	var res = {};
	res.content = content;
	res.tagsXmlArray = tagsXmlArray;
	res.tagsXmlArrayJoined = res.tagsXmlArray.join("|");
	var regexp = new RegExp("(?:(<(?:" + res.tagsXmlArrayJoined + ")[^>]*>)([^<>]*)</(?:" + res.tagsXmlArrayJoined + ")>)|(<(?:" + res.tagsXmlArrayJoined + ")[^>]*/>)", "g");
	res.matches = pregMatchAll(regexp, res.content);
	return handleRecursiveCase(res);
};

//# sourceURL=webpack:///./node_modules/docxtemplater/js/xml-matcher.js?`)},30418:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(43707),
    wordToUtf8 = _require.wordToUtf8,
    convertSpaces = _require.convertSpaces,
    defaults = _require.defaults;

var createScope = __webpack_require__(6752);
var xmlMatcher = __webpack_require__(50804);

var _require2 = __webpack_require__(27284),
    throwMultiError = _require2.throwMultiError,
    throwContentMustBeString = _require2.throwContentMustBeString;

var Lexer = __webpack_require__(33493);
var Parser = __webpack_require__(2341);
var _render = __webpack_require__(17102);
var resolve = __webpack_require__(24963);

function _getFullText(content, tagsXmlArray) {
	var matcher = xmlMatcher(content, tagsXmlArray);
	var result = matcher.matches.map(function (match) {
		return match.array[2];
	});
	return wordToUtf8(convertSpaces(result.join("")));
}

module.exports = function () {
	function XmlTemplater(content, options) {
		_classCallCheck(this, XmlTemplater);

		this.fromJson(options);
		this.setModules({ inspect: { filePath: this.filePath } });
		this.load(content);
	}

	_createClass(XmlTemplater, [{
		key: "load",
		value: function load(content) {
			if (typeof content !== "string") {
				throwContentMustBeString(typeof content === "undefined" ? "undefined" : _typeof(content));
			}
			this.content = content;
		}
	}, {
		key: "setTags",
		value: function setTags(tags) {
			this.tags = tags != null ? tags : {};
			this.scopeManager = createScope({ tags: this.tags, parser: this.parser });
			return this;
		}
	}, {
		key: "resolveTags",
		value: function resolveTags(tags) {
			var _this = this;

			this.tags = tags != null ? tags : {};
			this.scopeManager = createScope({ tags: this.tags, parser: this.parser });
			var options = {
				compiled: this.postparsed,
				tags: this.tags,
				modules: this.modules,
				parser: this.parser,
				nullGetter: this.nullGetter,
				filePath: this.filePath,
				resolve: resolve
			};
			options.scopeManager = createScope(options);
			return resolve(options).then(function (_ref) {
				var resolved = _ref.resolved;

				return Promise.all(resolved.map(function (r) {
					return Promise.resolve(r);
				})).then(function (resolved) {
					return _this.resolved = resolved;
				});
			});
		}
	}, {
		key: "fromJson",
		value: function fromJson(options) {
			this.filePath = options.filePath;
			this.modules = options.modules;
			this.fileTypeConfig = options.fileTypeConfig;
			Object.keys(defaults).map(function (key) {
				this[key] = options[key] != null ? options[key] : defaults[key];
			}, this);
		}
	}, {
		key: "getFullText",
		value: function getFullText() {
			return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);
		}
	}, {
		key: "setModules",
		value: function setModules(obj) {
			this.modules.forEach(function (module) {
				module.set(obj);
			});
		}
	}, {
		key: "parse",
		value: function parse() {
			var allErrors = [];
			this.xmllexed = Lexer.xmlparse(this.content, {
				text: this.fileTypeConfig.tagsXmlTextArray,
				other: this.fileTypeConfig.tagsXmlLexedArray
			});
			this.setModules({ inspect: { xmllexed: this.xmllexed } });

			var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters),
			    lexed = _Lexer$parse.lexed,
			    lexerErrors = _Lexer$parse.errors;

			allErrors = allErrors.concat(lexerErrors);
			this.lexed = lexed;
			this.setModules({ inspect: { lexed: this.lexed } });
			this.parsed = Parser.parse(this.lexed, this.modules);
			this.setModules({ inspect: { parsed: this.parsed } });

			var _Parser$postparse = Parser.postparse(this.parsed, this.modules),
			    postparsed = _Parser$postparse.postparsed,
			    postparsedErrors = _Parser$postparse.errors;

			this.postparsed = postparsed;
			this.setModules({ inspect: { postparsed: this.postparsed } });
			allErrors = allErrors.concat(postparsedErrors);
			this.errorChecker(allErrors);
			return this;
		}
	}, {
		key: "errorChecker",
		value: function errorChecker(errors) {
			var _this2 = this;

			if (errors.length) {
				this.modules.forEach(function (module) {
					errors = module.errorsTransformer(errors);
				});
				errors.forEach(function (error) {
					error.properties.file = _this2.filePath;
				});
				throwMultiError(errors);
			}
		}
		/*
  content is the whole content to be tagged
  scope is the current scope
  returns the new content of the tagged content
  */

	}, {
		key: "render",
		value: function render(to) {
			this.filePath = to;
			var options = {
				compiled: this.postparsed,
				tags: this.tags,
				resolved: this.resolved,
				modules: this.modules,
				parser: this.parser,
				nullGetter: this.nullGetter,
				filePath: this.filePath,
				render: _render
			};
			options.scopeManager = createScope(options);

			var _render2 = _render(options),
			    errors = _render2.errors,
			    parts = _render2.parts;

			this.errorChecker(errors);
			this.content = parts.join("");
			this.setModules({ inspect: { content: this.content } });
			return this;
		}
	}]);

	return XmlTemplater;
}();

//# sourceURL=webpack:///./node_modules/docxtemplater/js/xml-templater.js?`)},93162:function(module,exports,__webpack_require__){eval(`var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob(["\\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error("could not download file")},d.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});

//# sourceMappingURL=FileSaver.min.js.map

//# sourceURL=webpack:///./node_modules/file-saver/dist/FileSaver.min.js?`)},87026:function(__unused_webpack_module,exports){eval(`(function (global, factory) {
     true ? factory(exports) :
    0;
}(this, function (exports) { 'use strict';

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    function bisect(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    }

    // need some basic operations on vectors, rather than adding a dependency,
    // just define here
    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }
    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }

    function dot(a, b) {
        var ret = 0;
        for (var i = 0; i < a.length; ++i) {
            ret += a[i] * b[i];
        }
        return ret;
    }

    function norm2(a)  {
        return Math.sqrt(dot(a, a));
    }

    function scale(ret, value, c) {
        for (var i = 0; i < value.length; ++i) {
            ret[i] = value[i] * c;
        }
    }

    function weightedSum(ret, w1, v1, w2, v2) {
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
        }
    }

    /** minimizes a function using the downhill simplex method */
    function nelderMead(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.05,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-6,
            minTolerance = parameters.minErrorDelta || 1e-5,
            rho = (parameters.rho !== undefined) ? parameters.rho : 1,
            chi = (parameters.chi !== undefined) ? parameters.chi : 2,
            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,
            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,
            maxDiff;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        simplex[0].id = 0;
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
            simplex[i+1].id = i+1;
        }

        function updateSimplex(value) {
            for (var i = 0; i < value.length; i++) {
                simplex[N][i] = value[i];
            }
            simplex[N].fx = value.fx;
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        var centroid = x0.slice(),
            reflected = x0.slice(),
            contracted = x0.slice(),
            expanded = x0.slice();

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);

            if (parameters.history) {
                // copy the simplex (since later iterations will mutate) and
                // sort it to have a consistent order between iterations
                var sortedSimplex = simplex.map(function (x) {
                    var state = x.slice();
                    state.fx = x.fx;
                    state.id = x.id;
                    return state;
                });
                sortedSimplex.sort(function(a,b) { return a.id - b.id; });

                parameters.history.push({x: simplex[0].slice(),
                                         fx: simplex[0].fx,
                                         simplex: sortedSimplex});
            }

            maxDiff = 0;
            for (i = 0; i < N; ++i) {
                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }

            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&
                (maxDiff < minTolerance)) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            weightedSum(reflected, 1+rho, centroid, -rho, worst);
            reflected.fx = f(reflected);

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx < simplex[0].fx) {
                weightedSum(expanded, 1+chi, centroid, -chi, worst);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    updateSimplex(expanded);
                }  else {
                    updateSimplex(reflected);
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;

                if (reflected.fx > worst.fx) {
                    // do an inside contraction
                    weightedSum(contracted, 1+psi, centroid, -psi, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);
                    contracted.fx = f(contracted);
                    if (contracted.fx < reflected.fx) {
                        updateSimplex(contracted);
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // if we don't contract here, we're done
                    if (sigma >= 1) break;

                    // do a reduction
                    for (i = 1; i < simplex.length; ++i) {
                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            } else {
                updateSimplex(reflected);
            }
        }

        simplex.sort(sortOrder);
        return {fx : simplex[0].fx,
                x : simplex[0]};
    }

    /// searches along line 'pk' for a point that satifies the wolfe conditions
    /// See 'Numerical Optimization' by Nocedal and Wright p59-60
    /// f : objective function
    /// pk : search direction
    /// current: object containing current gradient/loss
    /// next: output: contains next gradient/loss
    /// returns a: step size taken
    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),
            phi = phi0, phi_old = phi0,
            phiPrime = phiPrime0,
            a0 = 0;

        a = a || 1;
        c1 = c1 || 1e-6;
        c2 = c2 || 0.1;

        function zoom(a_lo, a_high, phi_lo) {
            for (var iteration = 0; iteration < 16; ++iteration) {
                a = (a_lo + a_high)/2;
                weightedSum(next.x, 1.0, current.x, a, pk);
                phi = next.fx = f(next.x, next.fxprime);
                phiPrime = dot(next.fxprime, pk);

                if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                    (phi >= phi_lo)) {
                    a_high = a;

                } else  {
                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                        return a;
                    }

                    if (phiPrime * (a_high - a_lo) >=0) {
                        a_high = a_lo;
                    }

                    a_lo = a;
                    phi_lo = phi;
                }
            }

            return 0;
        }

        for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1.0, current.x, a, pk);
            phi = next.fx = f(next.x, next.fxprime);
            phiPrime = dot(next.fxprime, pk);
            if ((phi > (phi0 + c1 * a * phiPrime0)) ||
                (iteration && (phi >= phi_old))) {
                return zoom(a0, a, phi_old);
            }

            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
                return a;
            }

            if (phiPrime >= 0 ) {
                return zoom(a, a0, phi);
            }

            phi_old = phi;
            a0 = a;
            a *= 2;
        }

        return a;
    }

    function conjugateGradient(f, initial, params) {
        // allocate all memory up front here, keep out of the loop for perfomance
        // reasons
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            yk = initial.slice(),
            pk, temp,
            a = 1,
            maxIterations;

        params = params || {};
        maxIterations = params.maxIterations || initial.length * 20;

        current.fx = f(current.x, current.fxprime);
        pk = current.fxprime.slice();
        scale(pk, current.fxprime,-1);

        for (var i = 0; i < maxIterations; ++i) {
            a = wolfeLineSearch(f, pk, current, next, a);

            // todo: history in wrong spot?
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     alpha: a});
            }

            if (!a) {
                // faiiled to find point that satifies wolfe conditions.
                // reset direction for next iteration
                scale(pk, current.fxprime, -1);

            } else {
                // update direction using Polak\u2013Ribiere CG method
                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);

                var delta_k = dot(current.fxprime, current.fxprime),
                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);

                weightedSum(pk, beta_k, pk, -1, next.fxprime);

                temp = current;
                current = next;
                next = temp;
            }

            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        if (params.history) {
            params.history.push({x: current.x.slice(),
                                 fx: current.fx,
                                 fxprime: current.fxprime.slice(),
                                 alpha: a});
        }

        return current;
    }

    function gradientDescent(f, initial, params) {
        params = params || {};
        var maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 0.001,
            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};

        for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice()});
            }

            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm2(current.fxprime) <= 1e-5) {
                break;
            }
        }

        return current;
    }

    function gradientDescentLineSearch(f, initial, params) {
        params = params || {};
        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},
            maxIterations = params.maxIterations || initial.length * 100,
            learnRate = params.learnRate || 1,
            pk = initial.slice(),
            c1 = params.c1 || 1e-3,
            c2 = params.c2 || 0.1,
            temp,
            functionCalls = [];

        if (params.history) {
            // wrap the function call to track linesearch samples
            var inner = f;
            f = function(x, fxprime) {
                functionCalls.push(x.slice());
                return inner(x, fxprime);
            };
        }

        current.fx = f(current.x, current.fxprime);
        for (var i = 0; i < maxIterations; ++i) {
            scale(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);

            if (params.history) {
                params.history.push({x: current.x.slice(),
                                     fx: current.fx,
                                     fxprime: current.fxprime.slice(),
                                     functionCalls: functionCalls,
                                     learnRate: learnRate,
                                     alpha: learnRate});
                functionCalls = [];
            }


            temp = current;
            current = next;
            next = temp;

            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;
        }

        return current;
    }

    exports.bisect = bisect;
    exports.nelderMead = nelderMead;
    exports.conjugateGradient = conjugateGradient;
    exports.gradientDescent = gradientDescent;
    exports.gradientDescentLineSearch = gradientDescentLineSearch;
    exports.zeros = zeros;
    exports.zerosM = zerosM;
    exports.norm2 = norm2;
    exports.weightedSum = weightedSum;
    exports.scale = scale;

}));

//# sourceURL=webpack:///./node_modules/fmin/build/fmin.js?`)},49685:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WT": function() { return /* binding */ ARRAY_TYPE; }
/* harmony export */ });
/* unused harmony exports EPSILON, RANDOM, setMatrixArrayType, toRadian, equals */
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

//# sourceURL=webpack:///./node_modules/gl-matrix/esm/common.js?`)},35600:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Jp": function() { return /* binding */ multiply; },
/* harmony export */   "U_": function() { return /* binding */ invert; },
/* harmony export */   "Us": function() { return /* binding */ fromRotation; },
/* harmony export */   "vc": function() { return /* binding */ fromTranslation; },
/* harmony export */   "xJ": function() { return /* binding */ fromScaling; }
/* harmony export */ });
/* unused harmony exports create, fromMat4, clone, copy, fromValues, set, identity, transpose, adjoint, determinant, translate, rotate, scale, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = (/* unused pure expression or super */ null && (multiply));
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = (/* unused pure expression or super */ null && (subtract));

//# sourceURL=webpack:///./node_modules/gl-matrix/esm/mat3.js?`)},31437:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval(`/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$X": function() { return /* binding */ subtract; },
/* harmony export */   "AK": function() { return /* binding */ dot; },
/* harmony export */   "EU": function() { return /* binding */ angle; },
/* harmony export */   "Fp": function() { return /* binding */ max; },
/* harmony export */   "Fv": function() { return /* binding */ normalize; },
/* harmony export */   "I6": function() { return /* binding */ exactEquals; },
/* harmony export */   "IH": function() { return /* binding */ add; },
/* harmony export */   "TE": function() { return /* binding */ distance; },
/* harmony export */   "VV": function() { return /* binding */ min; },
/* harmony export */   "bA": function() { return /* binding */ scale; },
/* harmony export */   "kE": function() { return /* binding */ length; },
/* harmony export */   "kK": function() { return /* binding */ transformMat3; },
/* harmony export */   "lu": function() { return /* binding */ sub; }
/* harmony export */ });
/* unused harmony exports create, clone, fromValues, copy, set, multiply, divide, ceil, floor, round, scaleAndAdd, squaredDistance, squaredLength, negate, inverse, cross, lerp, random, transformMat2, transformMat2d, transformMat4, rotate, zero, str, equals, len, mul, div, dist, sqrDist, sqrLen, forEach */
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49685);

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__/* .ARRAY_TYPE */ .WT(2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__/* .ARRAY_TYPE */ .WT != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = (/* unused pure expression or super */ null && (length));
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = (/* unused pure expression or super */ null && (multiply));
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = (/* unused pure expression or super */ null && (divide));
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = (/* unused pure expression or super */ null && (distance));
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = (/* unused pure expression or super */ null && (squaredDistance));
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = (/* unused pure expression or super */ null && (squaredLength));
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

//# sourceURL=webpack:///./node_modules/gl-matrix/esm/vec2.js?`)},80925:function(module){"use strict";eval(`
/*globals Promise */

var JSZipUtils = {};
// just use the responseText with xhr1, response with xhr2.
// The transformation doesn't throw away high-order byte (with responseText)
// because JSZip handles that case. If not used with JSZip, you may need to
// do it, see https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
JSZipUtils._getBinaryFromXHR = function (xhr) {
    // for xhr.responseText, the 0xFF mask is applied by JSZip
    return xhr.response || xhr.responseText;
};

// taken from jQuery
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch( e ) {}
}

// Create the request object
var createXHR = (typeof window !== "undefined" && window.ActiveXObject) ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    function() {
    return createStandardXHR() || createActiveXHR();
} :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;


/**
 * @param  {string} path    The path to the resource to GET.
 * @param  {function|{callback: function, progress: function}} options
 * @return {Promise|undefined} If no callback is passed then a promise is returned
 */
JSZipUtils.getBinaryContent = function (path, options) {
    var promise, resolve, reject;
    var callback;

    if (!options) {
        options = {};
    }

    // backward compatible callback
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (typeof options.callback === 'function') {
        // callback inside options object
        callback = options.callback;
    }

    if (!callback && typeof Promise !== "undefined") {
        promise = new Promise(function (_resolve, _reject) {
            resolve = _resolve;
            reject = _reject;
        });
    } else {
        resolve = function (data) { callback(null, data); };
        reject = function (err) { callback(err, null); };
    }

    /*
     * Here is the tricky part : getting the data.
     * In firefox/chrome/opera/... setting the mimeType to 'text/plain; charset=x-user-defined'
     * is enough, the result is in the standard xhr.responseText.
     * cf https://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Receiving_binary_data_in_older_browsers
     * In IE <= 9, we must use (the IE only) attribute responseBody
     * (for binary data, its content is different from responseText).
     * In IE 10, the 'charset=x-user-defined' trick doesn't work, only the
     * responseType will work :
     * http://msdn.microsoft.com/en-us/library/ie/hh673569%28v=vs.85%29.aspx#Binary_Object_upload_and_download
     *
     * I'd like to use jQuery to avoid this XHR madness, but it doesn't support
     * the responseType attribute : http://bugs.jquery.com/ticket/11461
     */
    try {
        var xhr = createXHR();

        xhr.open('GET', path, true);

        // recent browsers
        if ("responseType" in xhr) {
            xhr.responseType = "arraybuffer";
        }

        // older browser
        if(xhr.overrideMimeType) {
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }

        xhr.onreadystatechange = function (event) {
            // use \`xhr\` and not \`this\`... thanks IE
            if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                    try {
                        resolve(JSZipUtils._getBinaryFromXHR(xhr));
                    } catch(err) {
                        reject(new Error(err));
                    }
                } else {
                    reject(new Error("Ajax error for " + path + " : " + this.status + " " + this.statusText));
                }
            }
        };

        if(options.progress) {
            xhr.onprogress = function(e) {
                options.progress({
                    path: path,
                    originalEvent: e,
                    percent: e.loaded / e.total * 100,
                    loaded: e.loaded,
                    total: e.total
                });
            };
        }

        xhr.send();

    } catch (e) {
        reject(new Error(e), null);
    }

    // returns a promise or undefined depending on whether a callback was
    // provided
    return promise;
};

// export
module.exports = JSZipUtils;

// enforcing Stuk's coding style
// vim: set shiftwidth=4 softtabstop=4:


//# sourceURL=webpack:///./node_modules/jszip-utils/lib/index.js?`)},70949:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var DocUtils = (__webpack_require__(14522).DocUtils);
DocUtils.convertPixelsToEmus = function (pixel) {
	return Math.round(pixel * 9525);
};
module.exports = DocUtils;

//# sourceURL=webpack:///./node_modules/open-docxtemplater-image-module/js/docUtils.js?`)},56380:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DocUtils = __webpack_require__(70949);
var extensionRegex = /[^.]+\\.([^.]+)/;

var rels = {
	getPrefix: function getPrefix(fileType) {
		return fileType === "docx" ? "word" : "ppt";
	},
	getFileTypeName: function getFileTypeName(fileType) {
		return fileType === "docx" ? "document" : "presentation";
	},
	getRelsFileName: function getRelsFileName(fileName) {
		return fileName.replace(/^.*?([a-zA-Z0-9]+)\\.xml$/, "$1") + ".xml.rels";
	},
	getRelsFilePath: function getRelsFilePath(fileName, fileType) {
		var relsFileName = rels.getRelsFileName(fileName);
		var prefix = fileType === "pptx" ? "ppt/slides" : "word";
		return prefix + "/_rels/" + relsFileName;
	}
};

module.exports = function () {
	function ImgManager(zip, fileName, xmlDocuments, fileType) {
		_classCallCheck(this, ImgManager);

		this.fileName = fileName;
		this.prefix = rels.getPrefix(fileType);
		this.zip = zip;
		this.xmlDocuments = xmlDocuments;
		this.fileTypeName = rels.getFileTypeName(fileType);
		this.mediaPrefix = fileType === "pptx" ? "../media" : "media";
		var relsFilePath = rels.getRelsFilePath(fileName, fileType);
		this.relsDoc = xmlDocuments[relsFilePath] || this.createEmptyRelsDoc(xmlDocuments, relsFilePath);
	}

	_createClass(ImgManager, [{
		key: "createEmptyRelsDoc",
		value: function createEmptyRelsDoc(xmlDocuments, relsFileName) {
			var mainRels = this.prefix + "/_rels/" + this.fileTypeName + ".xml.rels";
			var doc = xmlDocuments[mainRels];
			if (!doc) {
				var err = new Error("Could not copy from empty relsdoc");
				err.properties = {
					mainRels: mainRels,
					relsFileName: relsFileName,
					files: Object.keys(this.zip.files)
				};
				throw err;
			}
			var relsDoc = DocUtils.str2xml(DocUtils.xml2str(doc));
			var relationships = relsDoc.getElementsByTagName("Relationships")[0];
			var relationshipChilds = relationships.getElementsByTagName("Relationship");
			for (var i = 0, l = relationshipChilds.length; i < l; i++) {
				relationships.removeChild(relationshipChilds[i]);
			}
			xmlDocuments[relsFileName] = relsDoc;
			return relsDoc;
		}
	}, {
		key: "loadImageRels",
		value: function loadImageRels() {
			var iterable = this.relsDoc.getElementsByTagName("Relationship");
			return Array.prototype.reduce.call(iterable, function (max, relationship) {
				var id = relationship.getAttribute("Id");
				if (/^rId[0-9]+$/.test(id)) {
					return Math.max(max, parseInt(id.substr(3), 10));
				}
				return max;
			}, 0);
		}
		// Add an extension type in the [Content_Types.xml], is used if for example you want word to be able to read png files (for every extension you add you need a contentType)

	}, {
		key: "addExtensionRels",
		value: function addExtensionRels(contentType, extension) {
			var contentTypeDoc = this.xmlDocuments["[Content_Types].xml"];
			var defaultTags = contentTypeDoc.getElementsByTagName("Default");
			var extensionRegistered = Array.prototype.some.call(defaultTags, function (tag) {
				return tag.getAttribute("Extension") === extension;
			});
			if (extensionRegistered) {
				return;
			}
			var types = contentTypeDoc.getElementsByTagName("Types")[0];
			var newTag = contentTypeDoc.createElement("Default");
			newTag.namespaceURI = null;
			newTag.setAttribute("ContentType", contentType);
			newTag.setAttribute("Extension", extension);
			types.appendChild(newTag);
		}
		// Add an image and returns it's Rid

	}, {
		key: "addImageRels",
		value: function addImageRels(imageName, imageData, i) {
			if (i == null) {
				i = 0;
			}
			var realImageName = i === 0 ? imageName : imageName + ("(" + i + ")");
			var imagePath = this.prefix + "/media/" + realImageName;
			if (this.zip.files[imagePath] != null) {
				return this.addImageRels(imageName, imageData, i + 1);
			}
			var image = {
				name: imagePath,
				data: imageData,
				options: {
					binary: true
				}
			};
			this.zip.file(image.name, image.data, image.options);
			var extension = realImageName.replace(extensionRegex, "$1");
			this.addExtensionRels("image/" + extension, extension);
			var relationships = this.relsDoc.getElementsByTagName("Relationships")[0];
			var newTag = this.relsDoc.createElement("Relationship");
			newTag.namespaceURI = null;
			var maxRid = this.loadImageRels() + 1;
			newTag.setAttribute("Id", "rId" + maxRid);
			newTag.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");
			newTag.setAttribute("Target", this.mediaPrefix + "/" + realImageName);
			relationships.appendChild(newTag);
			return maxRid;
		}
	}]);

	return ImgManager;
}();

//# sourceURL=webpack:///./node_modules/open-docxtemplater-image-module/js/imgManager.js?`)},78630:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var templates = __webpack_require__(77887);
var DocUtils = (__webpack_require__(14522).DocUtils);
var DOMParser = (__webpack_require__(86150).DOMParser);

function isNaN(number) {
	return !(number === number);
}

var ImgManager = __webpack_require__(56380);
var moduleName = "open-xml-templating/docxtemplater-image-module";

function getInnerDocx(_ref) {
	var part = _ref.part;

	return part;
}

function getInnerPptx(_ref2) {
	var part = _ref2.part,
	    left = _ref2.left,
	    right = _ref2.right,
	    postparsed = _ref2.postparsed;

	var xmlString = postparsed.slice(left + 1, right).reduce(function (concat, item) {
		return concat + item.value;
	}, "");
	var xmlDoc = new DOMParser().parseFromString("<xml>" + xmlString + "</xml>");
	part.offset = { x: 0, y: 0 };
	part.ext = { cx: 0, cy: 0 };
	var offset = xmlDoc.getElementsByTagName("a:off");
	var ext = xmlDoc.getElementsByTagName("a:ext");
	if (ext.length > 0) {
		part.ext.cx = parseInt(ext[ext.length - 1].getAttribute("cx"), 10);
		part.ext.cy = parseInt(ext[ext.length - 1].getAttribute("cy"), 10);
	}
	if (offset.length > 0) {
		part.offset.x = parseInt(offset[offset.length - 1].getAttribute("x"), 10);
		part.offset.y = parseInt(offset[offset.length - 1].getAttribute("y"), 10);
	}
	return part;
}

var ImageModule = function () {
	function ImageModule(options) {
		_classCallCheck(this, ImageModule);

		this.name = "ImageModule";
		this.options = options || {};
		this.imgManagers = {};
		if (this.options.centered == null) {
			this.options.centered = false;
		}
		if (this.options.getImage == null) {
			throw new Error("You should pass getImage");
		}
		if (this.options.getSize == null) {
			throw new Error("You should pass getSize");
		}
		this.imageNumber = 1;
	}

	_createClass(ImageModule, [{
		key: "optionsTransformer",
		value: function optionsTransformer(options, docxtemplater) {
			var relsFiles = docxtemplater.zip.file(/\\.xml\\.rels/).concat(docxtemplater.zip.file(/\\[Content_Types\\].xml/)).map(function (file) {
				return file.name;
			});
			this.fileTypeConfig = docxtemplater.fileTypeConfig;
			this.fileType = docxtemplater.fileType;
			this.zip = docxtemplater.zip;
			options.xmlFileNames = options.xmlFileNames.concat(relsFiles);
			return options;
		}
	}, {
		key: "set",
		value: function set(options) {
			if (options.zip) {
				this.zip = options.zip;
			}
			if (options.xmlDocuments) {
				this.xmlDocuments = options.xmlDocuments;
			}
		}
	}, {
		key: "parse",
		value: function parse(placeHolderContent) {
			var module = moduleName;
			var type = "placeholder";
			if (placeHolderContent.substring(0, 2) === "%%") {
				return { type: type, value: placeHolderContent.substr(2), module: module, centered: true };
			}
			if (placeHolderContent.substring(0, 1) === "%") {
				return { type: type, value: placeHolderContent.substr(1), module: module, centered: false };
			}
			return null;
		}
	}, {
		key: "postparse",
		value: function postparse(parsed) {
			var expandTo = void 0;
			var getInner = void 0;
			if (this.fileType === "pptx") {
				expandTo = "p:sp";
				getInner = getInnerPptx;
			} else {
				expandTo = this.options.centered ? "w:p" : "w:t";
				getInner = getInnerDocx;
			}
			return DocUtils.traits.expandToOne(parsed, { moduleName: moduleName, getInner: getInner, expandTo: expandTo });
		}
	}, {
		key: "render",
		value: function render(part, options) {
			this.imgManagers[options.filePath] = this.imgManagers[options.filePath] || new ImgManager(this.zip, options.filePath, this.xmlDocuments, this.fileType);
			var imgManager = this.imgManagers[options.filePath];
			if (!part.type === "placeholder" || part.module !== moduleName) {
				return null;
			}
			var tagValue = options.scopeManager.getValue(part.value);
			if (!tagValue) {
				return { value: this.fileTypeConfig.tagTextXml };
			}
			var imgBuffer = this.options.getImage(tagValue, part.value);
			if (!imgBuffer) {
				return { value: this.fileTypeConfig.tagTextXml };
			}
			var rId = imgManager.addImageRels(this.getNextImageName(), imgBuffer);
			var sizePixel = this.options.getSize(imgBuffer, tagValue, part.value);
			return this.getRenderedPart(part, rId, sizePixel);
		}
	}, {
		key: "getRenderedPart",
		value: function getRenderedPart(part, rId, sizePixel) {
			if (isNaN(rId)) {
				throw new Error("rId is NaN, aborting");
			}
			var size = [DocUtils.convertPixelsToEmus(sizePixel[0]), DocUtils.convertPixelsToEmus(sizePixel[1])];
			var centered = this.options.centered || part.centered;
			var newText = void 0;
			if (this.fileType === "pptx") {
				newText = this.getRenderedPartPptx(part, rId, size, centered);
			} else {
				newText = this.getRenderedPartDocx(rId, size, centered);
			}
			return { value: newText };
		}
	}, {
		key: "getRenderedPartPptx",
		value: function getRenderedPartPptx(part, rId, size, centered) {
			var offset = { x: parseInt(part.offset.x, 10), y: parseInt(part.offset.y, 10) };
			var cellCX = parseInt(part.ext.cx, 10) || 1;
			var cellCY = parseInt(part.ext.cy, 10) || 1;
			var imgW = parseInt(size[0], 10) || 1;
			var imgH = parseInt(size[1], 10) || 1;
			if (centered) {
				offset.x = Math.round(offset.x + cellCX / 2 - imgW / 2);
				offset.y = Math.round(offset.y + cellCY / 2 - imgH / 2);
			}
			return templates.getPptxImageXml(rId, [imgW, imgH], offset);
		}
	}, {
		key: "getRenderedPartDocx",
		value: function getRenderedPartDocx(rId, size, centered) {
			return centered ? templates.getImageXmlCentered(rId, size) : templates.getImageXml(rId, size);
		}
	}, {
		key: "getNextImageName",
		value: function getNextImageName() {
			var name = "image_generated_" + this.imageNumber + ".png";
			this.imageNumber++;
			return name;
		}
	}]);

	return ImageModule;
}();

module.exports = ImageModule;

//# sourceURL=webpack:///./node_modules/open-docxtemplater-image-module/js/index.js?`)},77887:function(module){"use strict";eval(`

module.exports = {
	getImageXml: function getImageXml(rId, size) {
		return ("<w:drawing>\\n\\t\\t<wp:inline distT=\\"0\\" distB=\\"0\\" distL=\\"0\\" distR=\\"0\\">\\n\\t\\t\\t<wp:extent cx=\\"" + size[0] + "\\" cy=\\"" + size[1] + "\\"/>\\n\\t\\t\\t<wp:effectExtent l=\\"0\\" t=\\"0\\" r=\\"0\\" b=\\"0\\"/>\\n\\t\\t\\t<wp:docPr id=\\"2\\" name=\\"Image 2\\" descr=\\"image\\"/>\\n\\t\\t\\t<wp:cNvGraphicFramePr>\\n\\t\\t\\t\\t<a:graphicFrameLocks xmlns:a=\\"http://schemas.openxmlformats.org/drawingml/2006/main\\" noChangeAspect=\\"1\\"/>\\n\\t\\t\\t</wp:cNvGraphicFramePr>\\n\\t\\t\\t<a:graphic xmlns:a=\\"http://schemas.openxmlformats.org/drawingml/2006/main\\">\\n\\t\\t\\t\\t<a:graphicData uri=\\"http://schemas.openxmlformats.org/drawingml/2006/picture\\">\\n\\t\\t\\t\\t\\t<pic:pic xmlns:pic=\\"http://schemas.openxmlformats.org/drawingml/2006/picture\\">\\n\\t\\t\\t\\t\\t\\t<pic:nvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t<pic:cNvPr id=\\"0\\" name=\\"Picture 1\\" descr=\\"image\\"/>\\n\\t\\t\\t\\t\\t\\t\\t<pic:cNvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:picLocks noChangeAspect=\\"1\\" noChangeArrowheads=\\"1\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</pic:cNvPicPr>\\n\\t\\t\\t\\t\\t\\t</pic:nvPicPr>\\n\\t\\t\\t\\t\\t\\t<pic:blipFill>\\n\\t\\t\\t\\t\\t\\t\\t<a:blip r:embed=\\"rId" + rId + "\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:extLst>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<a:ext uri=\\"{28A0092B-C50C-407E-A947-70E740481C1C}\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<a14:useLocalDpi xmlns:a14=\\"http://schemas.microsoft.com/office/drawing/2010/main\\" val=\\"0\\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t</a:ext>\\n\\t\\t\\t\\t\\t\\t\\t\\t</a:extLst>\\n\\t\\t\\t\\t\\t\\t\\t</a:blip>\\n\\t\\t\\t\\t\\t\\t\\t<a:srcRect/>\\n\\t\\t\\t\\t\\t\\t\\t<a:stretch>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:fillRect/>\\n\\t\\t\\t\\t\\t\\t\\t</a:stretch>\\n\\t\\t\\t\\t\\t\\t</pic:blipFill>\\n\\t\\t\\t\\t\\t\\t<pic:spPr bwMode=\\"auto\\">\\n\\t\\t\\t\\t\\t\\t\\t<a:xfrm>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:off x=\\"0\\" y=\\"0\\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:ext cx=\\"" + size[0] + "\\" cy=\\"" + size[1] + "\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</a:xfrm>\\n\\t\\t\\t\\t\\t\\t\\t<a:prstGeom prst=\\"rect\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:avLst/>\\n\\t\\t\\t\\t\\t\\t\\t</a:prstGeom>\\n\\t\\t\\t\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t\\t\\t\\t<a:ln>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t\\t\\t\\t</a:ln>\\n\\t\\t\\t\\t\\t\\t</pic:spPr>\\n\\t\\t\\t\\t\\t</pic:pic>\\n\\t\\t\\t\\t</a:graphicData>\\n\\t\\t\\t</a:graphic>\\n\\t\\t</wp:inline>\\n\\t</w:drawing>\\n\\t\\t").replace(/\\t|\\n/g, "");
	},
	getImageXmlCentered: function getImageXmlCentered(rId, size) {
		return ("<w:p>\\n\\t\\t\\t<w:pPr>\\n\\t\\t\\t\\t<w:jc w:val=\\"center\\"/>\\n\\t\\t\\t</w:pPr>\\n\\t\\t\\t<w:r>\\n\\t\\t\\t\\t<w:rPr/>\\n\\t\\t\\t\\t<w:drawing>\\n\\t\\t\\t\\t\\t<wp:inline distT=\\"0\\" distB=\\"0\\" distL=\\"0\\" distR=\\"0\\">\\n\\t\\t\\t\\t\\t<wp:extent cx=\\"" + size[0] + "\\" cy=\\"" + size[1] + "\\"/>\\n\\t\\t\\t\\t\\t<wp:docPr id=\\"0\\" name=\\"Picture\\" descr=\\"\\"/>\\n\\t\\t\\t\\t\\t<a:graphic xmlns:a=\\"http://schemas.openxmlformats.org/drawingml/2006/main\\">\\n\\t\\t\\t\\t\\t\\t<a:graphicData uri=\\"http://schemas.openxmlformats.org/drawingml/2006/picture\\">\\n\\t\\t\\t\\t\\t\\t<pic:pic xmlns:pic=\\"http://schemas.openxmlformats.org/drawingml/2006/picture\\">\\n\\t\\t\\t\\t\\t\\t\\t<pic:nvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t<pic:cNvPr id=\\"0\\" name=\\"Picture\\" descr=\\"\\"/>\\n\\t\\t\\t\\t\\t\\t\\t<pic:cNvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:picLocks noChangeAspect=\\"1\\" noChangeArrowheads=\\"1\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</pic:cNvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t</pic:nvPicPr>\\n\\t\\t\\t\\t\\t\\t\\t<pic:blipFill>\\n\\t\\t\\t\\t\\t\\t\\t<a:blip r:embed=\\"rId" + rId + "\\"/>\\n\\t\\t\\t\\t\\t\\t\\t<a:stretch>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:fillRect/>\\n\\t\\t\\t\\t\\t\\t\\t</a:stretch>\\n\\t\\t\\t\\t\\t\\t\\t</pic:blipFill>\\n\\t\\t\\t\\t\\t\\t\\t<pic:spPr bwMode=\\"auto\\">\\n\\t\\t\\t\\t\\t\\t\\t<a:xfrm>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:off x=\\"0\\" y=\\"0\\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:ext cx=\\"" + size[0] + "\\" cy=\\"" + size[1] + "\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</a:xfrm>\\n\\t\\t\\t\\t\\t\\t\\t<a:prstGeom prst=\\"rect\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:avLst/>\\n\\t\\t\\t\\t\\t\\t\\t</a:prstGeom>\\n\\t\\t\\t\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t\\t\\t\\t<a:ln w=\\"9525\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:miter lim=\\"800000\\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:headEnd/>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:tailEnd/>\\n\\t\\t\\t\\t\\t\\t\\t</a:ln>\\n\\t\\t\\t\\t\\t\\t\\t</pic:spPr>\\n\\t\\t\\t\\t\\t\\t</pic:pic>\\n\\t\\t\\t\\t\\t\\t</a:graphicData>\\n\\t\\t\\t\\t\\t</a:graphic>\\n\\t\\t\\t\\t\\t</wp:inline>\\n\\t\\t\\t\\t</w:drawing>\\n\\t\\t\\t</w:r>\\n\\t\\t</w:p>\\n\\t\\t").replace(/\\t|\\n/g, "");
	},
	getPptxImageXml: function getPptxImageXml(rId, size, offset) {
		return ("<p:pic>\\n\\t\\t\\t<p:nvPicPr>\\n\\t\\t\\t\\t<p:cNvPr id=\\"6\\" name=\\"Picture 2\\"/>\\n\\t\\t\\t\\t<p:cNvPicPr>\\n\\t\\t\\t\\t\\t<a:picLocks noChangeAspect=\\"1\\" noChangeArrowheads=\\"1\\"/>\\n\\t\\t\\t\\t</p:cNvPicPr>\\n\\t\\t\\t\\t<p:nvPr/>\\n\\t\\t\\t</p:nvPicPr>\\n\\t\\t\\t<p:blipFill>\\n\\t\\t\\t\\t<a:blip r:embed=\\"rId" + rId + "\\" cstate=\\"print\\">\\n\\t\\t\\t\\t\\t<a:extLst>\\n\\t\\t\\t\\t\\t\\t<a:ext uri=\\"{28A0092B-C50C-407E-A947-70E740481C1C}\\">\\n\\t\\t\\t\\t\\t\\t\\t<a14:useLocalDpi xmlns:a14=\\"http://schemas.microsoft.com/office/drawing/2010/main\\" val=\\"0\\"/>\\n\\t\\t\\t\\t\\t\\t</a:ext>\\n\\t\\t\\t\\t\\t</a:extLst>\\n\\t\\t\\t\\t</a:blip>\\n\\t\\t\\t\\t<a:srcRect/>\\n\\t\\t\\t\\t<a:stretch>\\n\\t\\t\\t\\t\\t<a:fillRect/>\\n\\t\\t\\t\\t</a:stretch>\\n\\t\\t\\t</p:blipFill>\\n\\t\\t\\t<p:spPr bwMode=\\"auto\\">\\n\\t\\t\\t\\t<a:xfrm>\\n\\t\\t\\t\\t\\t<a:off x=\\"" + offset.x + "\\" y=\\"" + offset.y + "\\"/>\\n\\t\\t\\t\\t\\t<a:ext cx=\\"" + size[0] + "\\" cy=\\"" + size[1] + "\\"/>\\n\\t\\t\\t\\t</a:xfrm>\\n\\t\\t\\t\\t<a:prstGeom prst=\\"rect\\">\\n\\t\\t\\t\\t\\t<a:avLst/>\\n\\t\\t\\t\\t</a:prstGeom>\\n\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t<a:ln>\\n\\t\\t\\t\\t\\t<a:noFill/>\\n\\t\\t\\t\\t</a:ln>\\n\\t\\t\\t\\t<a:effectLst/>\\n\\t\\t\\t\\t<a:extLst>\\n\\t\\t\\t\\t\\t<a:ext uri=\\"{909E8E84-426E-40DD-AFC4-6F175D3DCCD1}\\">\\n\\t\\t\\t\\t\\t\\t<a14:hiddenFill xmlns:a14=\\"http://schemas.microsoft.com/office/drawing/2010/main\\">\\n\\t\\t\\t\\t\\t\\t\\t<a:solidFill>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:schemeClr val=\\"accent1\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</a:solidFill>\\n\\t\\t\\t\\t\\t\\t</a14:hiddenFill>\\n\\t\\t\\t\\t\\t</a:ext>\\n\\t\\t\\t\\t\\t<a:ext uri=\\"{91240B29-F687-4F45-9708-019B960494DF}\\">\\n\\t\\t\\t\\t\\t\\t<a14:hiddenLine xmlns:a14=\\"http://schemas.microsoft.com/office/drawing/2010/main\\" w=\\"9525\\">\\n\\t\\t\\t\\t\\t\\t\\t<a:solidFill>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:schemeClr val=\\"tx1\\"/>\\n\\t\\t\\t\\t\\t\\t\\t</a:solidFill>\\n\\t\\t\\t\\t\\t\\t\\t<a:miter lim=\\"800000\\"/>\\n\\t\\t\\t\\t\\t\\t\\t<a:headEnd/>\\n\\t\\t\\t\\t\\t\\t\\t<a:tailEnd/>\\n\\t\\t\\t\\t\\t\\t</a14:hiddenLine>\\n\\t\\t\\t\\t\\t</a:ext>\\n\\t\\t\\t\\t\\t<a:ext uri=\\"{AF507438-7753-43E0-B8FC-AC1667EBCBE1}\\">\\n\\t\\t\\t\\t\\t\\t<a14:hiddenEffects xmlns:a14=\\"http://schemas.microsoft.com/office/drawing/2010/main\\">\\n\\t\\t\\t\\t\\t\\t\\t<a:effectLst>\\n\\t\\t\\t\\t\\t\\t\\t\\t<a:outerShdw dist=\\"35921\\" dir=\\"2700000\\" algn=\\"ctr\\" rotWithShape=\\"0\\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<a:schemeClr val=\\"bg2\\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t</a:outerShdw>\\n\\t\\t\\t\\t\\t\\t\\t</a:effectLst>\\n\\t\\t\\t\\t\\t\\t</a14:hiddenEffects>\\n\\t\\t\\t\\t\\t</a:ext>\\n\\t\\t\\t\\t</a:extLst>\\n\\t\\t\\t</p:spPr>\\n\\t\\t</p:pic>\\n\\t\\t").replace(/\\t|\\n/g, "");
	}
};

//# sourceURL=webpack:///./node_modules/open-docxtemplater-image-module/js/templates.js?`)},73807:function(module){"use strict";eval(`

var self = module.exports;

module.exports.isNumber = function (x) {
  return (typeof x === 'number');
};

module.exports.findMin = function (arr) {
  if (arr.length === 0) {
    return Infinity;
  }

  var curr = arr[0];
  for (var i = 1; i < arr.length; i++) {
    curr = Math.min(curr, arr[i]);
  }
  return curr;
};

module.exports.findMax = function (arr) {
  if (arr.length === 0) {
    return -Infinity;
  }

  var curr = arr[0];
  for (var i = 1; i < arr.length; i++) {
    curr = Math.max(curr, arr[i]);
  }
  return curr;
};

module.exports.findMinMulti = function (arr) {
  var curr = self.findMin(arr[0]);
  for (var i = 1; i < arr.length; i++) {
    curr = Math.min(curr, self.findMin(arr[i]));
  }
  return curr;
};

module.exports.findMaxMulti = function (arr) {
  var curr = self.findMax(arr[0]);
  for (var i = 1; i < arr.length; i++) {
    curr = Math.max(curr, self.findMax(arr[i]));
  }
  return curr;
};

module.exports.inside = function (min, max, x) {
  return (min <= x) && (x <= max);
};


//# sourceURL=webpack:///./node_modules/pdfast/src/helper.js?`)},53843:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var DEFAULT_SIZE = 50;
var DEFAULT_WIDTH = 2;

var LN_2 = Math.log(2);
var self = module.exports;

var helper = __webpack_require__(73807);

// Triangle
function kernel(x) {
  return 1 - Math.abs(x);
}

/**
 * Get min and max value for the pdf, covering all arr data range while respecting options' data
 * @param arr
 * @param options
 * @returns {*}
 */
module.exports.getUnifiedMinMax = function (arr, options) {
  return self.getUnifiedMinMaxMulti([arr], options);
};

module.exports.getUnifiedMinMaxMulti = function (arrMulti, options) {
  options = options || {};

  var relaxMin = false;
  var relaxMax = false;

  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
  var min = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
  var max = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));

  var range = max - min;
  var step = range / (size - 1);

  // Relax?
  if (relaxMin) {
    min = min - 2 * width * step;
  }
  if (relaxMax) {
    max = max + 2 * width * step;
  }

  return {
    min: min,
    max: max
  };
};

module.exports.create = function (arr, options) {
  options = options || {};

  if (!arr || (arr.length === 0)) {
    return [];
  }

  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
  var normalizedMinMax = self.getUnifiedMinMax(arr, {
    size: size,
    width: width,
    min: options.min,
    max: options.max
  });

  var min = normalizedMinMax.min;
  var max = normalizedMinMax.max;

  var range = max - min;
  var step = range / (size - 1);
  if (range === 0) {
    // Special case...
    return [{x: min, y: 1}];
  }

  // Good to go

  var buckets = [];
  for (var i = 0; i < size; i++) {
    buckets.push({
      x: min + i * step,
      y: 0
    });
  }

  var xToBucket = function (x) {
    return Math.floor((x - min) / step);
  };

  var partialArea = generatePartialAreas(kernel, width);
  var fullArea = partialArea[width];
  var c = partialArea[width-1] - partialArea[width-2];

  var initalValue = 0;
  arr.forEach(function (x) {
    var bucket = xToBucket(x);

    // Totally outside?
    if ((bucket + width < 0) || (bucket - width >= buckets.length)) {
      return;
    }

    var start = Math.max(bucket - width, 0);
    var mid = bucket;
    var end = Math.min(bucket + width, buckets.length - 1);

    var leftBlockCount = start - (bucket - width);
    var rightBlockCount = (bucket + width) - end;
    var spilledAreaLeft = partialArea[-width-1 + leftBlockCount] || 0;
    var spilledAreaRight = partialArea[-width-1 + rightBlockCount] || 0;
    var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);

    if (leftBlockCount > 0) {
      initalValue += weight * (leftBlockCount - 1) * c;
    }

    // Add grads
    var startGradPos = Math.max(0, bucket-width+1);
    if (helper.inside(0, buckets.length-1, startGradPos)) {
      buckets[startGradPos].y += weight * 1 * c;
    }
    if (helper.inside(0, buckets.length-1, mid + 1)) {
      buckets[mid + 1].y -= weight * 2 * c;
    }
    if (helper.inside(0, buckets.length-1, end + 1)) {
      buckets[end + 1].y += weight * 1 * c;
    }
  });

  var accumulator = initalValue;
  var gradAccumulator = 0;
  var area = 0;
  buckets.forEach(function (bucket) {
    gradAccumulator += bucket.y;
    accumulator += gradAccumulator;

    bucket.y = accumulator;
    area += accumulator;
  });

  // Normalize
  if (area > 0) {
    buckets.forEach(function (bucket) {
      bucket.y /= area;
    });
  }

  return buckets;
};

function generatePartialAreas(kernel, width) {
  var partialAreas = {};

  var accumulator = 0;
  for (var i = -width; i <= width; i++) {
    accumulator += kernel(i/width);
    partialAreas[i] = accumulator;
  }

  return partialAreas;
}

module.exports.getExpectedValueFromPdf = function (pdf) {
  if (!pdf || (pdf.length === 0)) {
    return undefined;
  }

  var expected = 0;

  pdf.forEach(function (obj) {
    expected += obj.x * obj.y;
  });

  return expected;
};

module.exports.getXWithLeftTailArea = function (pdf, area) {
  if (!pdf || (pdf.length === 0)) {
    return undefined;
  }

  var accumulator = 0;
  var last = 0;
  for (var i = 0; i < pdf.length; i++) {
    last = i;
    accumulator += pdf[i].y;

    if (accumulator >= area) {
      break;
    }
  }

  return pdf[last].x;
};

module.exports.getPerplexity = function (pdf) {
  if (!pdf || (pdf.length === 0)) {
    return undefined;
  }

  var entropy = 0;
  pdf.forEach(function (obj) {
    var ln = Math.log(obj.y);

    if (isFinite(ln)) {
      entropy += obj.y * ln;
    }
  });
  entropy = -entropy / LN_2;

  return Math.pow(2, entropy);
};


//# sourceURL=webpack:///./node_modules/pdfast/src/index.js?`)},49451:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var DataReader = __webpack_require__(56611);
function ArrayReader(data) {
  if (data) {
    this.data = data;
    this.length = this.data.length;
    this.index = 0;
    this.zero = 0;
    for (var i = 0; i < this.data.length; i++) {
      data[i] &= data[i];
    }
  }
}
ArrayReader.prototype = new DataReader();
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function (i) {
  return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function (sig) {
  var sig0 = sig.charCodeAt(0),
    sig1 = sig.charCodeAt(1),
    sig2 = sig.charCodeAt(2),
    sig3 = sig.charCodeAt(3);
  for (var i = this.length - 4; i >= 0; --i) {
    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
      return i - this.zero;
    }
  }
  return -1;
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);
  if (size === 0) {
    return [];
  }
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
module.exports = ArrayReader;

//# sourceURL=webpack:///./node_modules/pizzip/js/arrayReader.js?`)},68436:function(__unused_webpack_module,exports){"use strict";eval(`

// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

// public method for encoding
exports.encode = function (input) {
  var output = "";
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0;
  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
  }
  return output;
};

// public method for decoding
exports.decode = function (input) {
  var output = "";
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");
  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output += String.fromCharCode(chr1);
    if (enc3 !== 64) {
      output += String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output += String.fromCharCode(chr3);
    }
  }
  return output;
};

//# sourceURL=webpack:///./node_modules/pizzip/js/base64.js?`)},93726:function(module){"use strict";eval(`

function CompressedObject() {
  this.compressedSize = 0;
  this.uncompressedSize = 0;
  this.crc32 = 0;
  this.compressionMethod = null;
  this.compressedContent = null;
}
CompressedObject.prototype = {
  /**
   * Return the decompressed content in an unspecified format.
   * The format will depend on the decompressor.
   * @return {Object} the decompressed content.
   */
  getContent: function getContent() {
    return null; // see implementation
  },
  /**
   * Return the compressed content in an unspecified format.
   * The format will depend on the compressed conten source.
   * @return {Object} the compressed content.
   */
  getCompressedContent: function getCompressedContent() {
    return null; // see implementation
  }
};

module.exports = CompressedObject;

//# sourceURL=webpack:///./node_modules/pizzip/js/compressedObject.js?`)},24084:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`

exports.STORE = {
  magic: "\\x00\\x00",
  compress: function compress(content) {
    return content; // no compression
  },
  uncompress: function uncompress(content) {
    return content; // no compression
  },

  compressInputType: null,
  uncompressInputType: null
};
exports.DEFLATE = __webpack_require__(1500);

//# sourceURL=webpack:///./node_modules/pizzip/js/compressions.js?`)},76201:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);

// prettier-ignore
var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

/**
 *
 *  Javascript crc32
 *  http://www.webtoolkit.info/
 *
 */
module.exports = function crc32(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray = utils.getTypeOf(input) !== "string";
  if (typeof crc == "undefined") {
    crc = 0;
  }
  var x = 0;
  var y = 0;
  var b = 0;
  crc ^= -1;
  for (var i = 0, iTop = input.length; i < iTop; i++) {
    b = isArray ? input[i] : input.charCodeAt(i);
    y = (crc ^ b) & 0xff;
    x = table[y];
    crc = crc >>> 8 ^ x;
  }
  return crc ^ -1;
};

//# sourceURL=webpack:///./node_modules/pizzip/js/crc32.js?`)},56611:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);
function DataReader() {
  this.data = null; // type : see implementation
  this.length = 0;
  this.index = 0;
  this.zero = 0;
}
DataReader.prototype = {
  /**
   * Check that the offset will not go too far.
   * @param {string} offset the additional offset to check.
   * @throws {Error} an Error if the offset is out of bounds.
   */
  checkOffset: function checkOffset(offset) {
    this.checkIndex(this.index + offset);
  },
  /**
   * Check that the specifed index will not be too far.
   * @param {string} newIndex the index to check.
   * @throws {Error} an Error if the index is out of bounds.
   */
  checkIndex: function checkIndex(newIndex) {
    if (this.length < this.zero + newIndex || newIndex < 0) {
      throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
    }
  },
  /**
   * Change the index.
   * @param {number} newIndex The new index.
   * @throws {Error} if the new index is out of the data.
   */
  setIndex: function setIndex(newIndex) {
    this.checkIndex(newIndex);
    this.index = newIndex;
  },
  /**
   * Skip the next n bytes.
   * @param {number} n the number of bytes to skip.
   * @throws {Error} if the new index is out of the data.
   */
  skip: function skip(n) {
    this.setIndex(this.index + n);
  },
  /**
   * Get the byte at the specified index.
   * @param {number} i the index to use.
   * @return {number} a byte.
   */
  byteAt: function byteAt() {
    // see implementations
  },
  /**
   * Get the next number with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {number} the corresponding number.
   */
  readInt: function readInt(size) {
    var result = 0,
      i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i >= this.index; i--) {
      result = (result << 8) + this.byteAt(i);
    }
    this.index += size;
    return result;
  },
  /**
   * Get the next string with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {string} the corresponding string.
   */
  readString: function readString(size) {
    return utils.transformTo("string", this.readData(size));
  },
  /**
   * Get raw data without conversion, <size> bytes.
   * @param {number} size the number of bytes to read.
   * @return {Object} the raw data, implementation specific.
   */
  readData: function readData() {
    // see implementations
  },
  /**
   * Find the last occurence of a zip signature (4 bytes).
   * @param {string} sig the signature to find.
   * @return {number} the index of the last occurence, -1 if not found.
   */
  lastIndexOfSignature: function lastIndexOfSignature() {
    // see implementations
  },
  /**
   * Get the next date.
   * @return {Date} the date.
   */
  readDate: function readDate() {
    var dostime = this.readInt(4);
    return new Date((dostime >> 25 & 0x7f) + 1980,
    // year
    (dostime >> 21 & 0x0f) - 1,
    // month
    dostime >> 16 & 0x1f,
    // day
    dostime >> 11 & 0x1f,
    // hour
    dostime >> 5 & 0x3f,
    // minute
    (dostime & 0x1f) << 1); // second
  }
};

module.exports = DataReader;

//# sourceURL=webpack:///./node_modules/pizzip/js/dataReader.js?`)},30506:function(__unused_webpack_module,exports){"use strict";eval(`

exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = false;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

//# sourceURL=webpack:///./node_modules/pizzip/js/defaults.js?`)},66870:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.string2binary = function (str) {
  return utils.string2binary(str);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.string2Uint8Array = function (str) {
  return utils.transformTo("uint8array", str);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.uint8Array2String = function (array) {
  return utils.transformTo("string", array);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.string2Blob = function (str) {
  var buffer = utils.transformTo("arraybuffer", str);
  return utils.arrayBuffer2Blob(buffer);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.arrayBuffer2Blob = function (buffer) {
  return utils.arrayBuffer2Blob(buffer);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.transformTo = function (outputType, input) {
  return utils.transformTo(outputType, input);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.getTypeOf = function (input) {
  return utils.getTypeOf(input);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.checkSupport = function (type) {
  return utils.checkSupport(type);
};

/**
 * @deprecated
 * This value will be removed in a future version without replacement.
 */
exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;

/**
 * @deprecated
 * This value will be removed in a future version without replacement.
 */
exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.pretty = function (str) {
  return utils.pretty(str);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.findCompression = function (compressionMethod) {
  return utils.findCompression(compressionMethod);
};

/**
 * @deprecated
 * This function will be removed in a future version without replacement.
 */
exports.isRegExp = function (object) {
  return utils.isRegExp(object);
};

//# sourceURL=webpack:///./node_modules/pizzip/js/deprecatedPublicUtils.js?`)},1500:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`

var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
var pako = __webpack_require__(80956);
exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
exports.magic = "\\x08\\x00";
exports.compress = function (input, compressionOptions) {
  return pako.deflateRaw(input, {
    level: compressionOptions.level || -1 // default compression
  });
};

exports.uncompress = function (input) {
  return pako.inflateRaw(input);
};

//# sourceURL=webpack:///./node_modules/pizzip/js/flate.js?`)},51344:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var base64 = __webpack_require__(68436);

/**
Usage:
   zip = new PizZip();
   zip.file("hello.txt", "Hello, World!").file("tempfile", "nothing");
   zip.folder("images").file("smile.gif", base64Data, {base64: true});
   zip.file("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});
   zip.remove("tempfile");

   base64zip = zip.generate();

**/

/**
 * Representation a of zip file in js
 * @constructor
 * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).
 * @param {Object=} options the options for creating this objects (optional).
 */
function PizZip(data, options) {
  // if this constructor is used without \`new\`, it adds \`new\` before itself:
  if (!(this instanceof PizZip)) {
    return new PizZip(data, options);
  }

  // object containing the files :
  // {
  //   "folder/" : {...},
  //   "folder/data.txt" : {...}
  // }
  this.files = {};
  this.comment = null;

  // Where we are in the hierarchy
  this.root = "";
  if (data) {
    this.load(data, options);
  }
  this.clone = function () {
    var _this = this;
    var newObj = new PizZip();
    Object.keys(this.files).forEach(function (file) {
      newObj.file(file, _this.files[file].asUint8Array());
    });
    return newObj;
  };
  this.shallowClone = function () {
    var newObj = new PizZip();
    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }
    return newObj;
  };
}
PizZip.prototype = __webpack_require__(40343);
PizZip.prototype.load = __webpack_require__(64833);
PizZip.support = __webpack_require__(73615);
PizZip.defaults = __webpack_require__(30506);

/**
 * @deprecated
 * This namespace will be removed in a future version without replacement.
 */
PizZip.utils = __webpack_require__(66870);
PizZip.base64 = {
  /**
   * @deprecated
   * This method will be removed in a future version without replacement.
   */
  encode: function encode(input) {
    return base64.encode(input);
  },
  /**
   * @deprecated
   * This method will be removed in a future version without replacement.
   */
  decode: function decode(input) {
    return base64.decode(input);
  }
};
PizZip.compressions = __webpack_require__(24084);
module.exports = PizZip;

//# sourceURL=webpack:///./node_modules/pizzip/js/index.js?`)},64833:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var base64 = __webpack_require__(68436);
var utf8 = __webpack_require__(96435);
var utils = __webpack_require__(96913);
var ZipEntries = __webpack_require__(89771);
module.exports = function (data, options) {
  var i, input;
  options = utils.extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
  });
  if (options.base64) {
    data = base64.decode(data);
  }
  var zipEntries = new ZipEntries(data, options);
  var files = zipEntries.files;
  for (i = 0; i < files.length; i++) {
    input = files[i];
    this.file(input.fileNameStr, input.decompressed, {
      binary: true,
      optimizedBinaryString: true,
      date: input.date,
      dir: input.dir,
      comment: input.fileCommentStr.length ? input.fileCommentStr : null,
      unixPermissions: input.unixPermissions,
      dosPermissions: input.dosPermissions,
      createFolders: options.createFolders
    });
  }
  if (zipEntries.zipComment.length) {
    this.comment = zipEntries.zipComment;
  }
  return this;
};

//# sourceURL=webpack:///./node_modules/pizzip/js/load.js?`)},23514:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`/* provided dependency */ var Buffer = __webpack_require__(48764)["lW"];


module.exports = function (data, encoding) {
  if (typeof data === "number") {
    return Buffer.alloc(data);
  }
  return Buffer.from(data, encoding);
};
module.exports.test = function (b) {
  return Buffer.isBuffer(b);
};

//# sourceURL=webpack:///./node_modules/pizzip/js/nodeBuffer.js?`)},2873:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var Uint8ArrayReader = __webpack_require__(54602);
function NodeBufferReader(data) {
  this.data = data;
  this.length = this.data.length;
  this.index = 0;
  this.zero = 0;
}
NodeBufferReader.prototype = new Uint8ArrayReader();

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function (size) {
  this.checkOffset(size);
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
module.exports = NodeBufferReader;

//# sourceURL=webpack:///./node_modules/pizzip/js/nodeBufferReader.js?`)},40343:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var support = __webpack_require__(73615);
var utils = __webpack_require__(96913);
var _crc = __webpack_require__(76201);
var signature = __webpack_require__(21160);
var defaults = __webpack_require__(30506);
var base64 = __webpack_require__(68436);
var compressions = __webpack_require__(24084);
var CompressedObject = __webpack_require__(93726);
var nodeBuffer = __webpack_require__(23514);
var utf8 = __webpack_require__(96435);
var StringWriter = __webpack_require__(47407);
var Uint8ArrayWriter = __webpack_require__(90189);

/**
 * Returns the raw data of a ZipObject, decompress the content if necessary.
 * @param {ZipObject} file the file to use.
 * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.
 */
function getRawData(file) {
  if (file._data instanceof CompressedObject) {
    file._data = file._data.getContent();
    file.options.binary = true;
    file.options.base64 = false;
    if (utils.getTypeOf(file._data) === "uint8array") {
      var copy = file._data;
      // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.
      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).
      file._data = new Uint8Array(copy.length);
      // with an empty Uint8Array, Opera fails with a "Offset larger than array size"
      if (copy.length !== 0) {
        file._data.set(copy, 0);
      }
    }
  }
  return file._data;
}

/**
 * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.
 * @param {ZipObject} file the file to use.
 * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.
 */
function getBinaryData(file) {
  var result = getRawData(file),
    type = utils.getTypeOf(result);
  if (type === "string") {
    if (!file.options.binary) {
      // unicode text !
      // unicode string => binary string is a painful process, check if we can avoid it.
      if (support.nodebuffer) {
        return nodeBuffer(result, "utf-8");
      }
    }
    return file.asBinary();
  }
  return result;
}

// return the actual prototype of PizZip
var out = {
  /**
   * Read an existing zip and merge the data in the current PizZip object.
   * The implementation is in pizzip-load.js, don't forget to include it.
   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load
   * @param {Object} options Options for loading the stream.
   *  options.base64 : is the stream in base64 ? default : false
   * @return {PizZip} the current PizZip object
   */
  load: function load() {
    throw new Error("Load method is not defined. Is the file pizzip-load.js included ?");
  },
  /**
   * Filter nested files/folders with the specified function.
   * @param {Function} search the predicate to use :
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   * @return {Array} An array of matching elements.
   */
  filter: function filter(search) {
    var result = [];
    var filename, relativePath, file, fileClone;
    for (filename in this.files) {
      if (!this.files.hasOwnProperty(filename)) {
        continue;
      }
      file = this.files[filename];
      // return a new object, don't let the user mess with our internal objects :)
      fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));
      relativePath = filename.slice(this.root.length, filename.length);
      if (filename.slice(0, this.root.length) === this.root &&
      // the file is in the current root
      search(relativePath, fileClone)) {
        // and the file matches the function
        result.push(fileClone);
      }
    }
    return result;
  },
  /**
   * Add a file to the zip file, or search a file.
   * @param   {string|RegExp} name The name of the file to add (if data is defined),
   * the name of the file to find (if no data) or a regex to match files.
   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
   * @param   {Object} o     File options
   * @return  {PizZip|Object|Array} this PizZip object (when adding a file),
   * a file (when searching by string) or an array of files (when searching by regex).
   */
  file: function file(name, data, o) {
    if (arguments.length === 1) {
      if (utils.isRegExp(name)) {
        var regexp = name;
        return this.filter(function (relativePath, file) {
          return !file.dir && regexp.test(relativePath);
        });
      }
      // text
      return this.filter(function (relativePath, file) {
        return !file.dir && relativePath === name;
      })[0] || null;
    }
    // more than one argument : we have data !
    name = this.root + name;
    fileAdd.call(this, name, data, o);
    return this;
  },
  /**
   * Add a directory to the zip file, or search.
   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
   * @return  {PizZip} an object with the new directory as the root, or an array containing matching folders.
   */
  folder: function folder(arg) {
    if (!arg) {
      return this;
    }
    if (utils.isRegExp(arg)) {
      return this.filter(function (relativePath, file) {
        return file.dir && arg.test(relativePath);
      });
    }

    // else, name is a new folder
    var name = this.root + arg;
    var newFolder = folderAdd.call(this, name);

    // Allow chaining by returning a new object with this folder as the root
    var ret = this.shallowClone();
    ret.root = newFolder.name;
    return ret;
  },
  /**
   * Delete a file, or a directory and all sub-files, from the zip
   * @param {string} name the name of the file to delete
   * @return {PizZip} this PizZip object
   */
  remove: function remove(name) {
    name = this.root + name;
    var file = this.files[name];
    if (!file) {
      // Look for any folders
      if (name.slice(-1) !== "/") {
        name += "/";
      }
      file = this.files[name];
    }
    if (file && !file.dir) {
      // file
      delete this.files[name];
    } else {
      // maybe a folder, delete recursively
      var kids = this.filter(function (relativePath, file) {
        return file.name.slice(0, name.length) === name;
      });
      for (var i = 0; i < kids.length; i++) {
        delete this.files[kids[i].name];
      }
    }
    return this;
  },
  /**
   * Generate the complete zip file
   * @param {Object} options the options to generate the zip file :
   * - base64, (deprecated, use type instead) true to generate base64.
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
   */
  generate: function generate(options) {
    options = utils.extend(options || {}, {
      base64: true,
      compression: "STORE",
      compressionOptions: null,
      type: "base64",
      platform: "DOS",
      comment: null,
      mimeType: "application/zip",
      encodeFileName: utf8.utf8encode
    });
    utils.checkSupport(options.type);

    // accept nodejs \`process.platform\`
    if (options.platform === "darwin" || options.platform === "freebsd" || options.platform === "linux" || options.platform === "sunos") {
      options.platform = "UNIX";
    }
    if (options.platform === "win32") {
      options.platform = "DOS";
    }
    var zipData = [],
      encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));
    var localDirLength = 0,
      centralDirLength = 0,
      writer,
      i;

    // first, generate all the zip parts.
    for (var name in this.files) {
      if (!this.files.hasOwnProperty(name)) {
        continue;
      }
      var file = this.files[name];
      var compressionName = file.options.compression || options.compression.toUpperCase();
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
      var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);
      var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);
      localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
      centralDirLength += zipPart.dirRecord.length;
      zipData.push(zipPart);
    }
    var dirEnd = "";

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
    // number of this disk
    "\\x00\\x00" +
    // number of the disk with the start of the central directory
    "\\x00\\x00" +
    // total number of entries in the central directory on this disk
    decToHex(zipData.length, 2) +
    // total number of entries in the central directory
    decToHex(zipData.length, 2) +
    // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) +
    // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) +
    // .ZIP file comment length
    decToHex(encodedComment.length, 2) +
    // .ZIP file comment
    encodedComment;

    // we have all the parts (and the total length)
    // time to create a writer !
    var typeName = options.type.toLowerCase();
    if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);
    } else {
      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);
    }
    for (i = 0; i < zipData.length; i++) {
      writer.append(zipData[i].fileRecord);
      writer.append(zipData[i].compressedObject.compressedContent);
    }
    for (i = 0; i < zipData.length; i++) {
      writer.append(zipData[i].dirRecord);
    }
    writer.append(dirEnd);
    var zip = writer.finalize();
    switch (options.type.toLowerCase()) {
      // case "zip is an Uint8Array"
      case "uint8array":
      case "arraybuffer":
      case "nodebuffer":
        return utils.transformTo(options.type.toLowerCase(), zip);
      case "blob":
        return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);
      // case "zip is a string"
      case "base64":
        return options.base64 ? base64.encode(zip) : zip;
      default:
        // case "string" :
        return zip;
    }
  },
  /**
   * @deprecated
   * This method will be removed in a future version without replacement.
   */
  crc32: function crc32(input, crc) {
    return _crc(input, crc);
  },
  /**
   * @deprecated
   * This method will be removed in a future version without replacement.
   */
  utf8encode: function utf8encode(string) {
    return utils.transformTo("string", utf8.utf8encode(string));
  },
  /**
   * @deprecated
   * This method will be removed in a future version without replacement.
   */
  utf8decode: function utf8decode(input) {
    return utf8.utf8decode(input);
  }
};
/**
 * Transform this._data into a string.
 * @param {function} filter a function String -> String, applied if not null on the result.
 * @return {String} the string representing this._data.
 */
function dataToString(asUTF8) {
  var result = getRawData(this);
  if (result === null || typeof result === "undefined") {
    return "";
  }
  // if the data is a base64 string, we decode it before checking the encoding !
  if (this.options.base64) {
    result = base64.decode(result);
  }
  if (asUTF8 && this.options.binary) {
    // PizZip.prototype.utf8decode supports arrays as input
    // skip to array => string step, utf8decode will do it.
    result = out.utf8decode(result);
  } else {
    // no utf8 transformation, do the array => string step.
    result = utils.transformTo("string", result);
  }
  if (!asUTF8 && !this.options.binary) {
    result = utils.transformTo("string", out.utf8encode(result));
  }
  return result;
}
/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
function ZipObject(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this.options = options;

  /*
   * This object contains initial values for dir and date.
   * With them, we can check if the user changed the deprecated metadata in
   * \`ZipObject#options\` or not.
   */
  this._initialMetadata = {
    dir: options.dir,
    date: options.date
  };
}
ZipObject.prototype = {
  /**
   * Return the content as UTF8 string.
   * @return {string} the UTF8 string.
   */
  asText: function asText() {
    return dataToString.call(this, true);
  },
  /**
   * Returns the binary content.
   * @return {string} the content as binary.
   */
  asBinary: function asBinary() {
    return dataToString.call(this, false);
  },
  /**
   * Returns the content as a nodejs Buffer.
   * @return {Buffer} the content as a Buffer.
   */
  asNodeBuffer: function asNodeBuffer() {
    var result = getBinaryData(this);
    return utils.transformTo("nodebuffer", result);
  },
  /**
   * Returns the content as an Uint8Array.
   * @return {Uint8Array} the content as an Uint8Array.
   */
  asUint8Array: function asUint8Array() {
    var result = getBinaryData(this);
    return utils.transformTo("uint8array", result);
  },
  /**
   * Returns the content as an ArrayBuffer.
   * @return {ArrayBuffer} the content as an ArrayBufer.
   */
  asArrayBuffer: function asArrayBuffer() {
    return this.asUint8Array().buffer;
  }
};

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
function decToHex(dec, bytes) {
  var hex = "",
    i;
  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 0xff);
    dec >>>= 8;
  }
  return hex;
}

/**
 * Transforms the (incomplete) options from the user into the complete
 * set of options to create a file.
 * @private
 * @param {Object} o the options from the user.
 * @return {Object} the complete set of options.
 */
function prepareFileAttrs(o) {
  o = o || {};
  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
    o.binary = true;
  }
  o = utils.extend(o, defaults);
  o.date = o.date || new Date();
  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }
  return o;
}

/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} o the options of the file
 * @return {Object} the new file.
 */
function fileAdd(name, data, o) {
  // be sure sub folders exist
  var dataType = utils.getTypeOf(data),
    parent;
  o = prepareFileAttrs(o);
  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  }

  // UNX_IFDIR  0040000 see zipinfo.c
  if (o.unixPermissions && o.unixPermissions & 0x4000) {
    o.dir = true;
  }
  // Bit 4    Directory
  if (o.dosPermissions && o.dosPermissions & 0x0010) {
    o.dir = true;
  }
  if (o.dir) {
    name = forceTrailingSlash(name);
  }
  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }
  if (o.dir || data === null || typeof data === "undefined") {
    o.base64 = false;
    o.binary = false;
    data = null;
    dataType = null;
  } else if (dataType === "string") {
    if (o.binary && !o.base64) {
      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask
      if (o.optimizedBinaryString !== true) {
        // this is a string, not in a base64 format.
        // Be sure that this is a correct "binary string"
        data = utils.string2binary(data);
      }
    }
  } else {
    // arraybuffer, uint8array, ...
    o.base64 = false;
    o.binary = true;
    if (!dataType && !(data instanceof CompressedObject)) {
      throw new Error("The data of '" + name + "' is in an unsupported format !");
    }

    // special case : it's way easier to work with Uint8Array than with ArrayBuffer
    if (dataType === "arraybuffer") {
      data = utils.transformTo("uint8array", data);
    }
  }
  var object = new ZipObject(name, data, o);
  this.files[name] = object;
  return object;
}

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
function parentFolder(path) {
  if (path.slice(-1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  var lastSlash = path.lastIndexOf("/");
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
}

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
function forceTrailingSlash(path) {
  // Check the name ends with a /
  if (path.slice(-1) !== "/") {
    path += "/"; // IE doesn't like substr(-1)
  }

  return path;
}
/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
function folderAdd(name, createFolders) {
  createFolders = typeof createFolders !== "undefined" ? createFolders : false;
  name = forceTrailingSlash(name);

  // Does this folder already exist?
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders
    });
  }
  return this.files[name];
}

/**
 * Generate a PizZip.CompressedObject for a given zipOject.
 * @param {ZipObject} file the object to read.
 * @param {PizZip.compression} compression the compression to use.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {PizZip.CompressedObject} the compressed result.
 */
function generateCompressedObjectFrom(file, compression, compressionOptions) {
  var result = new CompressedObject();
  var content;

  // the data has not been decompressed, we might reuse things !
  if (file._data instanceof CompressedObject) {
    result.uncompressedSize = file._data.uncompressedSize;
    result.crc32 = file._data.crc32;
    if (result.uncompressedSize === 0 || file.dir) {
      compression = compressions.STORE;
      result.compressedContent = "";
      result.crc32 = 0;
    } else if (file._data.compressionMethod === compression.magic) {
      result.compressedContent = file._data.getCompressedContent();
    } else {
      content = file._data.getContent();
      // need to decompress / recompress
      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
    }
  } else {
    // have uncompressed data
    content = getBinaryData(file);
    if (!content || content.length === 0 || file.dir) {
      compression = compressions.STORE;
      content = "";
    }
    result.uncompressedSize = content.length;
    result.crc32 = _crc(content);
    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
  }
  result.compressedSize = result.compressedContent.length;
  result.compressionMethod = compression.magic;
  return result;
}

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
function generateUnixExternalFileAttr(unixPermissions, isDir) {
  var result = unixPermissions;
  if (!unixPermissions) {
    // I can't use octal values in strict mode, hence the hexa.
    //  040775 => 0x41fd
    // 0100664 => 0x81b4
    result = isDir ? 0x41fd : 0x81b4;
  }
  return (result & 0xffff) << 16;
}

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
function generateDosExternalFileAttr(dosPermissions) {
  // the dir flag is already set for compatibility

  return (dosPermissions || 0) & 0x3f;
}

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {string} name the file name.
 * @param {ZipObject} file the file content.
 * @param {PizZip.CompressedObject} compressedObject the compressed object.
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {object} the zip parts.
 */
function generateZipParts(name, file, compressedObject, offset, platform, encodeFileName) {
  var useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment || "",
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    o = file.options;
  var dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir,
    date;

  // handle the deprecated options.dir
  if (file._initialMetadata.dir !== file.dir) {
    dir = file.dir;
  } else {
    dir = o.dir;
  }

  // handle the deprecated options.date
  if (file._initialMetadata.date !== file.date) {
    date = file.date;
  } else {
    date = o.date;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir) {
    // dos or unix, we set the dos dir flag
    extFileAttr |= 0x00010;
  }
  if (platform === "UNIX") {
    versionMadeBy = 0x031e; // UNIX, version 3.0
    extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
  } else {
    // DOS or other, fallback to DOS
    versionMadeBy = 0x0014; // DOS, version 2.0
    extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
  }

  // date
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

  dosTime = date.getHours();
  dosTime <<= 6;
  dosTime |= date.getMinutes();
  dosTime <<= 5;
  dosTime |= date.getSeconds() / 2;
  dosDate = date.getFullYear() - 1980;
  dosDate <<= 4;
  dosDate |= date.getMonth() + 1;
  dosDate <<= 5;
  dosDate |= date.getDate();
  if (useUTF8ForFileName) {
    // set the unicode path extra field. unzip needs at least one extra
    // field to correctly handle unicode path, so using the path is as good
    // as any other information. This could improve the situation with
    // other archive managers too.
    // This field is usually used without the utf8 flag, with a non
    // unicode path in the header (winrar, winzip). This helps (a bit)
    // with the messy Windows' default compressed folders feature but
    // breaks on p7zip which doesn't seek the unicode path extra field.
    // So for now, UTF-8 everywhere !
    unicodePathExtraField =
    // Version
    decToHex(1, 1) +
    // NameCRC32
    decToHex(_crc(encodedFileName), 4) +
    // UnicodeName
    utfEncodedFileName;
    extraFields +=
    // Info-ZIP Unicode Path Extra Field
    "\\x75\\x70" +
    // size
    decToHex(unicodePathExtraField.length, 2) +
    // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField =
    // Version
    decToHex(1, 1) +
    // CommentCRC32
    decToHex(this.crc32(encodedComment), 4) +
    // UnicodeName
    utfEncodedComment;
    extraFields +=
    // Info-ZIP Unicode Path Extra Field
    "\\x75\\x63" +
    // size
    decToHex(unicodeCommentExtraField.length, 2) +
    // content
    unicodeCommentExtraField;
  }
  var header = "";

  // version needed to extract
  header += "\\x0A\\x00";
  // general purpose bit flag
  // set bit 11 if utf8
  header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\\x00\\x08" : "\\x00\\x00";
  // compression method
  header += compressedObject.compressionMethod;
  // last mod file time
  header += decToHex(dosTime, 2);
  // last mod file date
  header += decToHex(dosDate, 2);
  // crc-32
  header += decToHex(compressedObject.crc32, 4);
  // compressed size
  header += decToHex(compressedObject.compressedSize, 4);
  // uncompressed size
  header += decToHex(compressedObject.uncompressedSize, 4);
  // file name length
  header += decToHex(encodedFileName.length, 2);
  // extra field length
  header += decToHex(extraFields.length, 2);
  var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = signature.CENTRAL_FILE_HEADER +
  // version made by (00: DOS)
  decToHex(versionMadeBy, 2) +
  // file header (common to file and central directory)
  header +
  // file comment length
  decToHex(encodedComment.length, 2) +
  // disk number start
  "\\x00\\x00" +
  // internal file attributes
  "\\x00\\x00" +
  // external file attributes
  decToHex(extFileAttr, 4) +
  // relative offset of local header
  decToHex(offset, 4) +
  // file name
  encodedFileName +
  // extra field
  extraFields +
  // file comment
  encodedComment;
  return {
    fileRecord: fileRecord,
    dirRecord: dirRecord,
    compressedObject: compressedObject
  };
}
module.exports = out;

//# sourceURL=webpack:///./node_modules/pizzip/js/object.js?`)},21160:function(__unused_webpack_module,exports){"use strict";eval(`

exports.LOCAL_FILE_HEADER = "PK\\x03\\x04";
exports.CENTRAL_FILE_HEADER = "PK\\x01\\x02";
exports.CENTRAL_DIRECTORY_END = "PK\\x05\\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\\x06\\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\\x06\\x06";
exports.DATA_DESCRIPTOR = "PK\\x07\\x08";

//# sourceURL=webpack:///./node_modules/pizzip/js/signature.js?`)},98077:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var DataReader = __webpack_require__(56611);
var utils = __webpack_require__(96913);
function StringReader(data, optimizedBinaryString) {
  this.data = data;
  if (!optimizedBinaryString) {
    this.data = utils.string2binary(this.data);
  }
  this.length = this.data.length;
  this.index = 0;
  this.zero = 0;
}
StringReader.prototype = new DataReader();
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function (i) {
  return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function (sig) {
  return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function (size) {
  this.checkOffset(size);
  // this will work because the constructor applied the "& 0xff" mask.
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
module.exports = StringReader;

//# sourceURL=webpack:///./node_modules/pizzip/js/stringReader.js?`)},47407:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);

/**
 * An object to write any content to a string.
 * @constructor
 */
function StringWriter() {
  this.data = [];
}
StringWriter.prototype = {
  /**
   * Append any content to the current string.
   * @param {Object} input the content to add.
   */
  append: function append(input) {
    input = utils.transformTo("string", input);
    this.data.push(input);
  },
  /**
   * Finalize the construction an return the result.
   * @return {string} the generated string.
   */
  finalize: function finalize() {
    return this.data.join("");
  }
};
module.exports = StringWriter;

//# sourceURL=webpack:///./node_modules/pizzip/js/stringWriter.js?`)},73615:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`/* provided dependency */ var Buffer = __webpack_require__(48764)["lW"];


exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
// contains true if PizZip can read/generate nodejs Buffer, false otherwise.
// Browserify will provide a Buffer implementation for browsers, which is
// an augmented Uint8Array (i.e., can be used as either Buffer or U8).
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if PizZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";
if (typeof ArrayBuffer === "undefined") {
  exports.blob = false;
} else {
  var buffer = new ArrayBuffer(0);
  try {
    exports.blob = new Blob([buffer], {
      type: "application/zip"
    }).size === 0;
  } catch (e) {
    try {
      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
      var builder = new Builder();
      builder.append(buffer);
      exports.blob = builder.getBlob("application/zip").size === 0;
    } catch (e) {
      exports.blob = false;
    }
  }
}

//# sourceURL=webpack:///./node_modules/pizzip/js/support.js?`)},54602:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var ArrayReader = __webpack_require__(49451);
function Uint8ArrayReader(data) {
  if (data) {
    this.data = data;
    this.length = this.data.length;
    this.index = 0;
    this.zero = 0;
  }
}
Uint8ArrayReader.prototype = new ArrayReader();
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function (size) {
  this.checkOffset(size);
  if (size === 0) {
    // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
    return new Uint8Array(0);
  }
  var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
module.exports = Uint8ArrayReader;

//# sourceURL=webpack:///./node_modules/pizzip/js/uint8ArrayReader.js?`)},90189:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);

/**
 * An object to write any content to an Uint8Array.
 * @constructor
 * @param {number} length The length of the array.
 */
function Uint8ArrayWriter(length) {
  this.data = new Uint8Array(length);
  this.index = 0;
}
Uint8ArrayWriter.prototype = {
  /**
   * Append any content to the current array.
   * @param {Object} input the content to add.
   */
  append: function append(input) {
    if (input.length !== 0) {
      // with an empty Uint8Array, Opera fails with a "Offset larger than array size"
      input = utils.transformTo("uint8array", input);
      this.data.set(input, this.index);
      this.index += input.length;
    }
  },
  /**
   * Finalize the construction an return the result.
   * @return {Uint8Array} the generated array.
   */
  finalize: function finalize() {
    return this.data;
  }
};
module.exports = Uint8ArrayWriter;

//# sourceURL=webpack:///./node_modules/pizzip/js/uint8ArrayWriter.js?`)},96435:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`

var utils = __webpack_require__(96913);
var support = __webpack_require__(73615);
var nodeBuffer = __webpack_require__(23514);

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i = 0; i < 256; i++) {
  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
function string2buf(str) {
  var buf,
    c,
    c2,
    mPos,
    i,
    bufLen = 0;
  var strLen = str.length;

  // count binary size
  for (mPos = 0; mPos < strLen; mPos++) {
    c = str.charCodeAt(mPos);
    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {
      c2 = str.charCodeAt(mPos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        mPos++;
      }
    }
    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  if (support.uint8array) {
    buf = new Uint8Array(bufLen);
  } else {
    buf = new Array(bufLen);
  }

  // convert
  for (i = 0, mPos = 0; i < bufLen; mPos++) {
    c = str.charCodeAt(mPos);
    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {
      c2 = str.charCodeAt(mPos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        mPos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xc0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xe0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }
  return buf;
}

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
function utf8border(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xc0) === 0x80) {
    pos--;
  }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
}

// convert array to string
function buf2string(buf) {
  var i, out, c, cLen;
  var len = buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }
    cLen = _utf8len[c];
    // skip 5 & 6 byte codes
    if (cLen > 4) {
      utf16buf[out++] = 0xfffd;
      i += cLen - 1;
      continue;
    }

    // apply mask on first byte
    c &= cLen === 2 ? 0x1f : cLen === 3 ? 0x0f : 0x07;
    // join the rest
    while (cLen > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      cLen--;
    }

    // terminated by end of string?
    if (cLen > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }
    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }

  // shrinkBuf(utf16buf, out)
  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  }

  // return String.fromCharCode.apply(null, utf16buf);
  return utils.applyFromCharCode(utf16buf);
}

// That's all for the pako functions.

/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
  if (support.nodebuffer) {
    return nodeBuffer(str, "utf-8");
  }
  return string2buf(str);
};

/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
  if (support.nodebuffer) {
    return utils.transformTo("nodebuffer", buf).toString("utf-8");
  }
  buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

  // return buf2string(buf);
  // Chrome prefers to work with "small" chunks of data
  // for the method buf2string.
  // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.
  var result = [],
    len = buf.length,
    chunk = 65536;
  var k = 0;
  while (k < len) {
    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
    if (support.uint8array) {
      result.push(buf2string(buf.subarray(k, nextBoundary)));
    } else {
      result.push(buf2string(buf.slice(k, nextBoundary)));
    }
    k = nextBoundary;
  }
  return result.join("");
};

//# sourceURL=webpack:///./node_modules/pizzip/js/utf8.js?`)},96913:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval(`

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var support = __webpack_require__(73615);
var compressions = __webpack_require__(24084);
var nodeBuffer = __webpack_require__(23514);
/**
 * Convert a string to a "binary string" : a string containing only char codes between 0 and 255.
 * @param {string} str the string to transform.
 * @return {String} the binary string.
 */
exports.string2binary = function (str) {
  var result = "";
  for (var i = 0; i < str.length; i++) {
    result += String.fromCharCode(str.charCodeAt(i) & 0xff);
  }
  return result;
};
exports.arrayBuffer2Blob = function (buffer, mimeType) {
  exports.checkSupport("blob");
  mimeType = mimeType || "application/zip";
  try {
    // Blob constructor
    return new Blob([buffer], {
      type: mimeType
    });
  } catch (e) {
    try {
      // deprecated, browser only, old way
      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
      var builder = new Builder();
      builder.append(buffer);
      return builder.getBlob(mimeType);
    } catch (e) {
      // well, fuck ?!
      throw new Error("Bug : can't construct the Blob.");
    }
  }
};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
  return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 0xff;
  }
  return array;
}

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
  // Performances notes :
  // --------------------
  // String.fromCharCode.apply(null, array) is the fastest, see
  // see http://jsperf.com/converting-a-uint8array-to-a-string/2
  // but the stack is limited (and we can get huge arrays !).
  //
  // result += String.fromCharCode(array[i]); generate too many strings !
  //
  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
  var chunk = 65536;
  var result = [],
    len = array.length,
    type = exports.getTypeOf(array);
  var k = 0,
    canUseApply = true;
  try {
    switch (type) {
      case "uint8array":
        String.fromCharCode.apply(null, new Uint8Array(0));
        break;
      case "nodebuffer":
        String.fromCharCode.apply(null, nodeBuffer(0));
        break;
    }
  } catch (e) {
    canUseApply = false;
  }

  // no apply : slow and painful algorithm
  // default browser on android 4.*
  if (!canUseApply) {
    var resultStr = "";
    for (var i = 0; i < array.length; i++) {
      resultStr += String.fromCharCode(array[i]);
    }
    return resultStr;
  }
  while (k < len && chunk > 1) {
    try {
      if (type === "array" || type === "nodebuffer") {
        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
      } else {
        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
      }
      k += chunk;
    } catch (e) {
      chunk = Math.floor(chunk / 2);
    }
  }
  return result.join("");
}
exports.applyFromCharCode = arrayLikeToString;

/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }
  return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform.string = {
  string: identity,
  array: function array(input) {
    return stringToArrayLike(input, new Array(input.length));
  },
  arraybuffer: function arraybuffer(input) {
    return transform.string.uint8array(input).buffer;
  },
  uint8array: function uint8array(input) {
    return stringToArrayLike(input, new Uint8Array(input.length));
  },
  nodebuffer: function nodebuffer(input) {
    return stringToArrayLike(input, nodeBuffer(input.length));
  }
};

// array to ?
transform.array = {
  string: arrayLikeToString,
  array: identity,
  arraybuffer: function arraybuffer(input) {
    return new Uint8Array(input).buffer;
  },
  uint8array: function uint8array(input) {
    return new Uint8Array(input);
  },
  nodebuffer: function nodebuffer(input) {
    return nodeBuffer(input);
  }
};

// arraybuffer to ?
transform.arraybuffer = {
  string: function string(input) {
    return arrayLikeToString(new Uint8Array(input));
  },
  array: function array(input) {
    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
  },
  arraybuffer: identity,
  uint8array: function uint8array(input) {
    return new Uint8Array(input);
  },
  nodebuffer: function nodebuffer(input) {
    return nodeBuffer(new Uint8Array(input));
  }
};

// uint8array to ?
transform.uint8array = {
  string: arrayLikeToString,
  array: function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  arraybuffer: function arraybuffer(input) {
    return input.buffer;
  },
  uint8array: identity,
  nodebuffer: function nodebuffer(input) {
    return nodeBuffer(input);
  }
};

// nodebuffer to ?
transform.nodebuffer = {
  string: arrayLikeToString,
  array: function array(input) {
    return arrayLikeToArrayLike(input, new Array(input.length));
  },
  arraybuffer: function arraybuffer(input) {
    return transform.nodebuffer.uint8array(input).buffer;
  },
  uint8array: function uint8array(input) {
    return arrayLikeToArrayLike(input, new Uint8Array(input.length));
  },
  nodebuffer: identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function (outputType, input) {
  if (!input) {
    // undefined, null, etc
    // an empty string won't harm.
    input = "";
  }
  if (!outputType) {
    return input;
  }
  exports.checkSupport(outputType);
  var inputType = exports.getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for PizZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function (input) {
  if (input == null) {
    return;
  }
  if (typeof input === "string") {
    return "string";
  }
  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }
  if (support.nodebuffer && nodeBuffer.test(input)) {
    return "nodebuffer";
  }
  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }
  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
  if (input instanceof Promise) {
    throw new Error("Cannot read data from a promise, you probably are running new PizZip(data) with a promise");
  }
  if (_typeof(input) === "object" && typeof input.file === "function") {
    throw new Error("Cannot read data from a pizzip instance, you probably are running new PizZip(zip) with a zipinstance");
  }
  if (input instanceof Date) {
    throw new Error("Cannot read data from a Date, you probably are running new PizZip(data) with a date");
  }
  if (_typeof(input) === "object" && input.crc32 == null) {
    throw new Error("Unsupported data given to new PizZip(data) (object given)");
  }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function (type) {
  var supported = support[type.toLowerCase()];
  if (!supported) {
    throw new Error(type + " is not supported by this browser");
  }
};
exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function (str) {
  var res = "",
    code,
    i;
  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += "\\\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }
  return res;
};

/**
 * Find a compression registered in PizZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the PizZip compression object, null if none found.
 */
exports.findCompression = function (compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }
    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }
  return null;
};
/**
 * Cross-window, cross-Node-context regular expression detection
 * @param  {Object}  object Anything
 * @return {Boolean}        true if the object is a regular expression,
 * false otherwise
 */
exports.isRegExp = function (object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function () {
  var result = {};
  var i, attr;
  for (i = 0; i < arguments.length; i++) {
    // arguments is not enumerable in some browsers
    for (attr in arguments[i]) {
      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments[i][attr];
      }
    }
  }
  return result;
};

//# sourceURL=webpack:///./node_modules/pizzip/js/utils.js?`)},89771:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var StringReader = __webpack_require__(98077);
var NodeBufferReader = __webpack_require__(2873);
var Uint8ArrayReader = __webpack_require__(54602);
var ArrayReader = __webpack_require__(49451);
var utils = __webpack_require__(96913);
var sig = __webpack_require__(21160);
var ZipEntry = __webpack_require__(86609);
var support = __webpack_require__(73615);
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(data, loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
  if (data) {
    this.load(data);
  }
}
ZipEntries.prototype = {
  /**
   * Check that the reader is on the speficied signature.
   * @param {string} expectedSignature the expected signature.
   * @throws {Error} if it is an other signature.
   */
  checkSignature: function checkSignature(expectedSignature) {
    var signature = this.reader.readString(4);
    if (signature !== expectedSignature) {
      throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
    }
  },
  /**
   * Check if the given signature is at the given index.
   * @param {number} askedIndex the index to check.
   * @param {string} expectedSignature the signature to expect.
   * @return {boolean} true if the signature is here, false otherwise.
   */
  isSignature: function isSignature(askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature = this.reader.readString(4);
    var result = signature === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
  },
  /**
   * Read the end of the central directory.
   */
  readBlockEndOfCentral: function readBlockEndOfCentral() {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);
    this.zipCommentLength = this.reader.readInt(2);
    // warning : the encoding depends of the system locale
    // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
    // On a windows machine, this field is encoded with the localized windows code page.
    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    // To get consistent behavior with the generation part, we will assume that
    // this is utf8 encoded unless specified otherwise.
    var decodeContent = utils.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
  },
  /**
   * Read the end of the Zip 64 central directory.
   * Not merged with the method readEndOfCentral :
   * The end of central can coexist with its Zip64 brother,
   * I don't want to read the wrong number of bytes !
   */
  readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.versionMadeBy = this.reader.readString(2);
    this.versionNeeded = this.reader.readInt(2);
    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);
    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44;
    var index = 0;
    var extraFieldId, extraFieldLength, extraFieldValue;
    while (index < extraDataSize) {
      extraFieldId = this.reader.readInt(2);
      extraFieldLength = this.reader.readInt(4);
      extraFieldValue = this.reader.readString(extraFieldLength);
      this.zip64ExtensibleData[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },
  /**
   * Read the end of the Zip 64 central directory locator.
   */
  readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);
    if (this.disksCount > 1) {
      throw new Error("Multi-volumes zip are not supported");
    }
  },
  /**
   * Read the local files, based on the offset read in the central part.
   */
  readLocalFiles: function readLocalFiles() {
    var i, file;
    for (i = 0; i < this.files.length; i++) {
      file = this.files[i];
      this.reader.setIndex(file.localHeaderOffset);
      this.checkSignature(sig.LOCAL_FILE_HEADER);
      file.readLocalPart(this.reader);
      file.handleUTF8();
      file.processAttributes();
    }
  },
  /**
   * Read the central directory.
   */
  readCentralDir: function readCentralDir() {
    var file;
    this.reader.setIndex(this.centralDirOffset);
    while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
      file = new ZipEntry({
        zip64: this.zip64
      }, this.loadOptions);
      file.readCentralPart(this.reader);
      this.files.push(file);
    }
    if (this.centralDirRecords !== this.files.length) {
      if (this.centralDirRecords !== 0 && this.files.length === 0) {
        // We expected some records but couldn't find ANY.
        // This is really suspicious, as if something went wrong.
        throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      } else {
        // We found some records but not all.
        // Something is wrong but we got something for the user: no error here.
        // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
      }
    }
  },
  /**
   * Read the end of central directory.
   */
  readEndOfCentral: function readEndOfCentral() {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
    if (offset < 0) {
      // Check if the content is a truncated zip or complete garbage.
      // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
      // extractible zip for example) but it can give a good hint.
      // If an ajax request was used without responseType, we will also
      // get unreadable data.
      var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
      if (isGarbage) {
        throw new Error("Can't find end of central directory : is this a zip file ?");
      } else {
        throw new Error("Corrupted zip : can't find end of central directory");
      }
    }
    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();

    /* extract from the zip spec :
              4)  If one of the fields in the end of central directory
                  record is too small to hold required data, the field
                  should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                  ZIP64 format record should be created.
              5)  The end of central directory record and the
                  Zip64 end of central directory locator record must
                  reside on the same disk when splitting or spanning
                  an archive.
           */
    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
      this.zip64 = true;

      /*
               Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
               the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents
               all numbers as 64-bit double precision IEEE 754 floating point numbers.
               So, we have 53bits for integers and bitwise operations treat everything as 32bits.
               see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
               and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
               */

      // should look for a zip64 EOCD locator
      offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      if (offset < 0) {
        throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");
      }
      this.reader.setIndex(offset);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      this.readBlockZip64EndOfCentralLocator();

      // now the zip64 EOCD record
      if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
        // console.warn("ZIP64 end of central directory not where expected.");
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        if (this.relativeOffsetEndOfZip64CentralDir < 0) {
          throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");
        }
      }
      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
      this.readBlockZip64EndOfCentral();
    }
    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
    if (this.zip64) {
      expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
      expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
    }
    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
    if (extraBytes > 0) {
      // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
      if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
        // The offsets seem wrong, but we have something at the specified offset.
        // So\u2026 we keep it.
      } else {
        // the offset is wrong, update the "zero" of the reader
        // this happens if data has been prepended (crx files for example)
        this.reader.zero = extraBytes;
      }
    } else if (extraBytes < 0) {
      throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
    }
  },
  prepareReader: function prepareReader(data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
      this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);
    } else if (type === "nodebuffer") {
      this.reader = new NodeBufferReader(data);
    } else if (support.uint8array) {
      this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));
    } else if (support.array) {
      this.reader = new ArrayReader(utils.transformTo("array", data));
    } else {
      throw new Error("Unexpected error: unsupported type '" + type + "'");
    }
  },
  /**
   * Read a zip file and create ZipEntries.
   * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
   */
  load: function load(data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
  }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

//# sourceURL=webpack:///./node_modules/pizzip/js/zipEntries.js?`)},86609:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval(`

var StringReader = __webpack_require__(98077);
var utils = __webpack_require__(96913);
var CompressedObject = __webpack_require__(93726);
var pizzipProto = __webpack_require__(40343);
var support = __webpack_require__(73615);
var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
  /**
   * say if the file is encrypted.
   * @return {boolean} true if the file is encrypted, false otherwise.
   */
  isEncrypted: function isEncrypted() {
    // bit 1 is set
    return (this.bitFlag & 0x0001) === 0x0001;
  },
  /**
   * say if the file has utf-8 filename/comment.
   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
   */
  useUTF8: function useUTF8() {
    // bit 11 is set
    return (this.bitFlag & 0x0800) === 0x0800;
  },
  /**
   * Prepare the function used to generate the compressed content from this ZipFile.
   * @param {DataReader} reader the reader to use.
   * @param {number} from the offset from where we should read the data.
   * @param {number} length the length of the data to read.
   * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).
   */
  prepareCompressedContent: function prepareCompressedContent(reader, from, length) {
    return function () {
      var previousIndex = reader.index;
      reader.setIndex(from);
      var compressedFileData = reader.readData(length);
      reader.setIndex(previousIndex);
      return compressedFileData;
    };
  },
  /**
   * Prepare the function used to generate the uncompressed content from this ZipFile.
   * @param {DataReader} reader the reader to use.
   * @param {number} from the offset from where we should read the data.
   * @param {number} length the length of the data to read.
   * @param {PizZip.compression} compression the compression used on this file.
   * @param {number} uncompressedSize the uncompressed size to expect.
   * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).
   */
  prepareContent: function prepareContent(reader, from, length, compression, uncompressedSize) {
    return function () {
      var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
      var uncompressedFileData = compression.uncompress(compressedFileData);
      if (uncompressedFileData.length !== uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
      }
      return uncompressedFileData;
    };
  },
  /**
   * Read the local part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readLocalPart: function readLocalPart(reader) {
    // we already know everything from the central dir !
    // If the central dir data are false, we are doomed.
    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
    // The less data we get here, the more reliable this should be.
    // Let's skip the whole header and dash to the data !
    reader.skip(22);
    // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.
    // Strangely, the filename here is OK.
    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
    // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
    // Search "unzip mismatching "local" filename continuing with "central" filename version" on
    // the internet.
    //
    // I think I see the logic here : the central directory is used to display
    // content and the local directory is used to extract the files. Mixing / and \\
    // may be used to display \\ to windows users and use / when extracting the files.
    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
    this.fileNameLength = reader.readInt(2);
    var localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
    this.fileName = reader.readData(this.fileNameLength);
    reader.skip(localExtraFieldsLength);
    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
      throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
    }
    var compression = utils.findCompression(this.compressionMethod);
    if (compression === null) {
      // no compression found
      throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
    }
    this.decompressed = new CompressedObject();
    this.decompressed.compressedSize = this.compressedSize;
    this.decompressed.uncompressedSize = this.uncompressedSize;
    this.decompressed.crc32 = this.crc32;
    this.decompressed.compressionMethod = this.compressionMethod;
    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);

    // we need to compute the crc32...
    if (this.loadOptions.checkCRC32) {
      this.decompressed = utils.transformTo("string", this.decompressed.getContent());
      if (pizzipProto.crc32(this.decompressed) !== this.crc32) {
        throw new Error("Corrupted zip : CRC32 mismatch");
      }
    }
  },
  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readCentralPart: function readCentralPart(reader) {
    this.versionMadeBy = reader.readInt(2);
    this.versionNeeded = reader.readInt(2);
    this.bitFlag = reader.readInt(2);
    this.compressionMethod = reader.readString(2);
    this.date = reader.readDate();
    this.crc32 = reader.readInt(4);
    this.compressedSize = reader.readInt(4);
    this.uncompressedSize = reader.readInt(4);
    this.fileNameLength = reader.readInt(2);
    this.extraFieldsLength = reader.readInt(2);
    this.fileCommentLength = reader.readInt(2);
    this.diskNumberStart = reader.readInt(2);
    this.internalFileAttributes = reader.readInt(2);
    this.externalFileAttributes = reader.readInt(4);
    this.localHeaderOffset = reader.readInt(4);
    if (this.isEncrypted()) {
      throw new Error("Encrypted zip are not supported");
    }
    this.fileName = reader.readData(this.fileNameLength);
    this.readExtraFields(reader);
    this.parseZIP64ExtraField(reader);
    this.fileComment = reader.readData(this.fileCommentLength);
  },
  /**
   * Parse the external file attributes and get the unix/dos permissions.
   */
  processAttributes: function processAttributes() {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy >> 8;

    // Check if we have the DOS directory flag set.
    // We look for it in the DOS and UNIX permissions
    // but some unknown platform could set it as a compatibility flag.
    this.dir = !!(this.externalFileAttributes & 0x0010);
    if (madeBy === MADE_BY_DOS) {
      // first 6 bits (0 to 5)
      this.dosPermissions = this.externalFileAttributes & 0x3f;
    }
    if (madeBy === MADE_BY_UNIX) {
      this.unixPermissions = this.externalFileAttributes >> 16 & 0xffff;
      // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
    }

    // fail safe : if the name ends with a / it probably means a folder
    if (!this.dir && this.fileNameStr.slice(-1) === "/") {
      this.dir = true;
    }
  },
  /**
   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
   */
  parseZIP64ExtraField: function parseZIP64ExtraField() {
    if (!this.extraFields[0x0001]) {
      return;
    }

    // should be something, preparing the extra reader
    var extraReader = new StringReader(this.extraFields[0x0001].value);

    // I really hope that these 64bits integer can fit in 32 bits integer, because js
    // won't let us have more.
    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
      this.uncompressedSize = extraReader.readInt(8);
    }
    if (this.compressedSize === utils.MAX_VALUE_32BITS) {
      this.compressedSize = extraReader.readInt(8);
    }
    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
      this.localHeaderOffset = extraReader.readInt(8);
    }
    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
      this.diskNumberStart = extraReader.readInt(4);
    }
  },
  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readExtraFields: function readExtraFields(reader) {
    var start = reader.index;
    var extraFieldId, extraFieldLength, extraFieldValue;
    this.extraFields = this.extraFields || {};
    while (reader.index < start + this.extraFieldsLength) {
      extraFieldId = reader.readInt(2);
      extraFieldLength = reader.readInt(2);
      extraFieldValue = reader.readString(extraFieldLength);
      this.extraFields[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },
  /**
   * Apply an UTF8 transformation if needed.
   */
  handleUTF8: function handleUTF8() {
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
      this.fileNameStr = pizzipProto.utf8decode(this.fileName);
      this.fileCommentStr = pizzipProto.utf8decode(this.fileComment);
    } else {
      var upath = this.findExtraFieldUnicodePath();
      if (upath !== null) {
        this.fileNameStr = upath;
      } else {
        var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
      }
      var ucomment = this.findExtraFieldUnicodeComment();
      if (ucomment !== null) {
        this.fileCommentStr = ucomment;
      } else {
        var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
      }
    }
  },
  /**
   * Find the unicode path declared in the extra field, if any.
   * @return {String} the unicode path, null otherwise.
   */
  findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
    var upathField = this.extraFields[0x7075];
    if (upathField) {
      var extraReader = new StringReader(upathField.value);

      // wrong version
      if (extraReader.readInt(1) !== 1) {
        return null;
      }

      // the crc of the filename changed, this field is out of date.
      if (pizzipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
        return null;
      }
      return pizzipProto.utf8decode(extraReader.readString(upathField.length - 5));
    }
    return null;
  },
  /**
   * Find the unicode comment declared in the extra field, if any.
   * @return {String} the unicode comment, null otherwise.
   */
  findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
    var ucommentField = this.extraFields[0x6375];
    if (ucommentField) {
      var extraReader = new StringReader(ucommentField.value);

      // wrong version
      if (extraReader.readInt(1) !== 1) {
        return null;
      }

      // the crc of the comment changed, this field is out of date.
      if (pizzipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
        return null;
      }
      return pizzipProto.utf8decode(extraReader.readString(ucommentField.length - 5));
    }
    return null;
  }
};
module.exports = ZipEntry;

//# sourceURL=webpack:///./node_modules/pizzip/js/zipEntry.js?`)},86150:function(__unused_webpack_module,exports,__webpack_require__){eval(`function DOMParser(options){\r
	this.options = options ||{locator:{}};\r
	\r
}\r
DOMParser.prototype.parseFromString = function(source,mimeType){\r
	var options = this.options;\r
	var sax =  new XMLReader();\r
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler\r
	var errorHandler = options.errorHandler;\r
	var locator = options.locator;\r
	var defaultNSMap = options.xmlns||{};\r
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}\r
	if(locator){\r
		domBuilder.setDocumentLocator(locator)\r
	}\r
	\r
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);\r
	sax.domBuilder = options.domBuilder || domBuilder;\r
	if(/\\/x?html?$/.test(mimeType)){\r
		entityMap.nbsp = '\\xa0';\r
		entityMap.copy = '\\xa9';\r
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';\r
	}\r
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';\r
	if(source){\r
		sax.parse(source,defaultNSMap,entityMap);\r
	}else{\r
		sax.errorHandler.error("invalid doc source");\r
	}\r
	return domBuilder.doc;\r
}\r
function buildErrorHandler(errorImpl,domBuilder,locator){\r
	if(!errorImpl){\r
		if(domBuilder instanceof DOMHandler){\r
			return domBuilder;\r
		}\r
		errorImpl = domBuilder ;\r
	}\r
	var errorHandler = {}\r
	var isCallback = errorImpl instanceof Function;\r
	locator = locator||{}\r
	function build(key){\r
		var fn = errorImpl[key];\r
		if(!fn && isCallback){\r
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;\r
		}\r
		errorHandler[key] = fn && function(msg){\r
			fn('[xmldom '+key+']\\t'+msg+_locator(locator));\r
		}||function(){};\r
	}\r
	build('warning');\r
	build('error');\r
	build('fatalError');\r
	return errorHandler;\r
}\r
\r
//console.log('#\\n\\n\\n\\n\\n\\n\\n####')\r
/**\r
 * +ContentHandler+ErrorHandler\r
 * +LexicalHandler+EntityResolver2\r
 * -DeclHandler-DTDHandler \r
 * \r
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\r
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\r
 */\r
function DOMHandler() {\r
    this.cdata = false;\r
}\r
function position(locator,node){\r
	node.lineNumber = locator.lineNumber;\r
	node.columnNumber = locator.columnNumber;\r
}\r
/**\r
 * @see org.xml.sax.ContentHandler#startDocument\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\r
 */ \r
DOMHandler.prototype = {\r
	startDocument : function() {\r
    	this.doc = new DOMImplementation().createDocument(null, null, null);\r
    	if (this.locator) {\r
        	this.doc.documentURI = this.locator.systemId;\r
    	}\r
	},\r
	startElement:function(namespaceURI, localName, qName, attrs) {\r
		var doc = this.doc;\r
	    var el = doc.createElementNS(namespaceURI, qName||localName);\r
	    var len = attrs.length;\r
	    appendElement(this, el);\r
	    this.currentElement = el;\r
	    \r
		this.locator && position(this.locator,el)\r
	    for (var i = 0 ; i < len; i++) {\r
	        var namespaceURI = attrs.getURI(i);\r
	        var value = attrs.getValue(i);\r
	        var qName = attrs.getQName(i);\r
			var attr = doc.createAttributeNS(namespaceURI, qName);\r
			this.locator &&position(attrs.getLocator(i),attr);\r
			attr.value = attr.nodeValue = value;\r
			el.setAttributeNode(attr)\r
	    }\r
	},\r
	endElement:function(namespaceURI, localName, qName) {\r
		var current = this.currentElement\r
		var tagName = current.tagName;\r
		this.currentElement = current.parentNode;\r
	},\r
	startPrefixMapping:function(prefix, uri) {\r
	},\r
	endPrefixMapping:function(prefix) {\r
	},\r
	processingInstruction:function(target, data) {\r
	    var ins = this.doc.createProcessingInstruction(target, data);\r
	    this.locator && position(this.locator,ins)\r
	    appendElement(this, ins);\r
	},\r
	ignorableWhitespace:function(ch, start, length) {\r
	},\r
	characters:function(chars, start, length) {\r
		chars = _toString.apply(this,arguments)\r
		//console.log(chars)\r
		if(chars){\r
			if (this.cdata) {\r
				var charNode = this.doc.createCDATASection(chars);\r
			} else {\r
				var charNode = this.doc.createTextNode(chars);\r
			}\r
			if(this.currentElement){\r
				this.currentElement.appendChild(charNode);\r
			}else if(/^\\s*$/.test(chars)){\r
				this.doc.appendChild(charNode);\r
				//process xml\r
			}\r
			this.locator && position(this.locator,charNode)\r
		}\r
	},\r
	skippedEntity:function(name) {\r
	},\r
	endDocument:function() {\r
		this.doc.normalize();\r
	},\r
	setDocumentLocator:function (locator) {\r
	    if(this.locator = locator){// && !('lineNumber' in locator)){\r
	    	locator.lineNumber = 0;\r
	    }\r
	},\r
	//LexicalHandler\r
	comment:function(chars, start, length) {\r
		chars = _toString.apply(this,arguments)\r
	    var comm = this.doc.createComment(chars);\r
	    this.locator && position(this.locator,comm)\r
	    appendElement(this, comm);\r
	},\r
	\r
	startCDATA:function() {\r
	    //used in characters() methods\r
	    this.cdata = true;\r
	},\r
	endCDATA:function() {\r
	    this.cdata = false;\r
	},\r
	\r
	startDTD:function(name, publicId, systemId) {\r
		var impl = this.doc.implementation;\r
	    if (impl && impl.createDocumentType) {\r
	        var dt = impl.createDocumentType(name, publicId, systemId);\r
	        this.locator && position(this.locator,dt)\r
	        appendElement(this, dt);\r
	    }\r
	},\r
	/**\r
	 * @see org.xml.sax.ErrorHandler\r
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\r
	 */\r
	warning:function(error) {\r
		console.warn('[xmldom warning]\\t'+error,_locator(this.locator));\r
	},\r
	error:function(error) {\r
		console.error('[xmldom error]\\t'+error,_locator(this.locator));\r
	},\r
	fatalError:function(error) {\r
		console.error('[xmldom fatalError]\\t'+error,_locator(this.locator));\r
	    throw error;\r
	}\r
}\r
function _locator(l){\r
	if(l){\r
		return '\\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'\r
	}\r
}\r
function _toString(chars,start,length){\r
	if(typeof chars == 'string'){\r
		return chars.substr(start,length)\r
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")\r
		if(chars.length >= start+length || start){\r
			return new java.lang.String(chars,start,length)+'';\r
		}\r
		return chars;\r
	}\r
}\r
\r
/*\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\r
 * used method of org.xml.sax.ext.LexicalHandler:\r
 *  #comment(chars, start, length)\r
 *  #startCDATA()\r
 *  #endCDATA()\r
 *  #startDTD(name, publicId, systemId)\r
 *\r
 *\r
 * IGNORED method of org.xml.sax.ext.LexicalHandler:\r
 *  #endDTD()\r
 *  #startEntity(name)\r
 *  #endEntity(name)\r
 *\r
 *\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\r
 * IGNORED method of org.xml.sax.ext.DeclHandler\r
 * 	#attributeDecl(eName, aName, type, mode, value)\r
 *  #elementDecl(name, model)\r
 *  #externalEntityDecl(name, publicId, systemId)\r
 *  #internalEntityDecl(name, value)\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\r
 * IGNORED method of org.xml.sax.EntityResolver2\r
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\r
 *  #resolveEntity(publicId, systemId)\r
 *  #getExternalSubset(name, baseURI)\r
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\r
 * IGNORED method of org.xml.sax.DTDHandler\r
 *  #notationDecl(name, publicId, systemId) {};\r
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\r
 */\r
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\\w+/g,function(key){\r
	DOMHandler.prototype[key] = function(){return null}\r
})\r
\r
/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\r
function appendElement (hander,node) {\r
    if (!hander.currentElement) {\r
        hander.doc.appendChild(node);\r
    } else {\r
        hander.currentElement.appendChild(node);\r
    }\r
}//appendChild and setAttributeNS are preformance key\r
\r
//if(typeof require == 'function'){\r
	var XMLReader = (__webpack_require__(36147)/* .XMLReader */ .G);\r
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(29541).DOMImplementation;\r
	exports.XMLSerializer = __webpack_require__(29541).XMLSerializer ;\r
	exports.DOMParser = DOMParser;\r
//}\r


//# sourceURL=webpack:///./node_modules/xmldom/dom-parser.js?`)},29541:function(__unused_webpack_module,exports){eval(`/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?
^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE\uFF1A
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


//# sourceURL=webpack:///./node_modules/xmldom/dom.js?`)},36147:function(__unused_webpack_module,exports){eval(`//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\r
//[5]   	Name	   ::=   	NameStartChar (NameChar)*\r
var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]///\\u10000-\\uEFFFF\r
var nameChar = new RegExp("[\\\\-\\\\.0-9"+nameStartChar.source.slice(1,-1)+"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]");\r
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\\:'+nameStartChar.source+nameChar.source+'*)?$');\r
//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\r
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\r
\r
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE\r
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE\r
var S_TAG = 0;//tag name offerring\r
var S_ATTR = 1;//attr name offerring \r
var S_ATTR_SPACE=2;//attr name end and space offer\r
var S_EQ = 3;//=space?\r
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)\r
var S_ATTR_END = 5;//attr value end and no space(quot end)\r
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)\r
var S_TAG_CLOSE = 7;//closed el<el />\r
\r
function XMLReader(){\r
	\r
}\r
\r
XMLReader.prototype = {\r
	parse:function(source,defaultNSMap,entityMap){\r
		var domBuilder = this.domBuilder;\r
		domBuilder.startDocument();\r
		_copy(defaultNSMap ,defaultNSMap = {})\r
		parse(source,defaultNSMap,entityMap,\r
				domBuilder,this.errorHandler);\r
		domBuilder.endDocument();\r
	}\r
}\r
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){\r
	function fixedFromCharCode(code) {\r
		// String.prototype.fromCharCode does not supports\r
		// > 2 bytes unicode chars directly\r
		if (code > 0xffff) {\r
			code -= 0x10000;\r
			var surrogate1 = 0xd800 + (code >> 10)\r
				, surrogate2 = 0xdc00 + (code & 0x3ff);\r
\r
			return String.fromCharCode(surrogate1, surrogate2);\r
		} else {\r
			return String.fromCharCode(code);\r
		}\r
	}\r
	function entityReplacer(a){\r
		var k = a.slice(1,-1);\r
		if(k in entityMap){\r
			return entityMap[k]; \r
		}else if(k.charAt(0) === '#'){\r
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))\r
		}else{\r
			errorHandler.error('entity not found:'+a);\r
			return a;\r
		}\r
	}\r
	function appendText(end){//has some bugs\r
		if(end>start){\r
			var xt = source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);\r
			locator&&position(start);\r
			domBuilder.characters(xt,0,end-start);\r
			start = end\r
		}\r
	}\r
	function position(p,m){\r
		while(p>=lineEnd && (m = linePattern.exec(source))){\r
			lineStart = m.index;\r
			lineEnd = lineStart + m[0].length;\r
			locator.lineNumber++;\r
			//console.log('line++:',locator,startPos,endPos)\r
		}\r
		locator.columnNumber = p-lineStart+1;\r
	}\r
	var lineStart = 0;\r
	var lineEnd = 0;\r
	var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g\r
	var locator = domBuilder.locator;\r
	\r
	var parseStack = [{currentNSMap:defaultNSMapCopy}]\r
	var closeMap = {};\r
	var start = 0;\r
	while(true){\r
		try{\r
			var tagStart = source.indexOf('<',start);\r
			if(tagStart<0){\r
				if(!source.substr(start).match(/^\\s*$/)){\r
					var doc = domBuilder.doc;\r
	    			var text = doc.createTextNode(source.substr(start));\r
	    			doc.appendChild(text);\r
	    			domBuilder.currentElement = text;\r
				}\r
				return;\r
			}\r
			if(tagStart>start){\r
				appendText(tagStart);\r
			}\r
			switch(source.charAt(tagStart+1)){\r
			case '/':\r
				var end = source.indexOf('>',tagStart+3);\r
				var tagName = source.substring(tagStart+2,end);\r
				var config = parseStack.pop();\r
				if(end<0){\r
					\r
	        		tagName = source.substring(tagStart+2).replace(/[\\s<].*/,'');\r
	        		//console.error('#@@@@@@'+tagName)\r
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);\r
	        		end = tagStart+1+tagName.length;\r
	        	}else if(tagName.match(/\\s</)){\r
	        		tagName = tagName.replace(/[\\s<].*/,'');\r
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');\r
	        		end = tagStart+1+tagName.length;\r
				}\r
				//console.error(parseStack.length,parseStack)\r
				//console.error(config);\r
				var localNSMap = config.localNSMap;\r
				var endMatch = config.tagName == tagName;\r
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()\r
		        if(endIgnoreCaseMach){\r
		        	domBuilder.endElement(config.uri,config.localName,tagName);\r
					if(localNSMap){\r
						for(var prefix in localNSMap){\r
							domBuilder.endPrefixMapping(prefix) ;\r
						}\r
					}\r
					if(!endMatch){\r
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );\r
					}\r
		        }else{\r
		        	parseStack.push(config)\r
		        }\r
				\r
				end++;\r
				break;\r
				// end elment\r
			case '?':// <?...?>\r
				locator&&position(tagStart);\r
				end = parseInstruction(source,tagStart,domBuilder);\r
				break;\r
			case '!':// <!doctype,<![CDATA,<!--\r
				locator&&position(tagStart);\r
				end = parseDCC(source,tagStart,domBuilder,errorHandler);\r
				break;\r
			default:\r
				locator&&position(tagStart);\r
				var el = new ElementAttributes();\r
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r
				//elStartEnd\r
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);\r
				var len = el.length;\r
				\r
				\r
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){\r
					el.closed = true;\r
					if(!entityMap.nbsp){\r
						errorHandler.warning('unclosed xml attribute');\r
					}\r
				}\r
				if(locator && len){\r
					var locator2 = copyLocator(locator,{});\r
					//try{//attribute position fixed\r
					for(var i = 0;i<len;i++){\r
						var a = el[i];\r
						position(a.offset);\r
						a.locator = copyLocator(locator,{});\r
					}\r
					//}catch(e){console.error('@@@@@'+e)}\r
					domBuilder.locator = locator2\r
					if(appendElement(el,domBuilder,currentNSMap)){\r
						parseStack.push(el)\r
					}\r
					domBuilder.locator = locator;\r
				}else{\r
					if(appendElement(el,domBuilder,currentNSMap)){\r
						parseStack.push(el)\r
					}\r
				}\r
				\r
				\r
				\r
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){\r
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)\r
				}else{\r
					end++;\r
				}\r
			}\r
		}catch(e){\r
			errorHandler.error('element parse error: '+e)\r
			//errorHandler.error('element parse error: '+e);\r
			end = -1;\r
			//throw e;\r
		}\r
		if(end>start){\r
			start = end;\r
		}else{\r
			//TODO: \u8FD9\u91CC\u6709\u53EF\u80FDsax\u56DE\u9000\uFF0C\u6709\u4F4D\u7F6E\u9519\u8BEF\u98CE\u9669\r
			appendText(Math.max(tagStart,start)+1);\r
		}\r
	}\r
}\r
function copyLocator(f,t){\r
	t.lineNumber = f.lineNumber;\r
	t.columnNumber = f.columnNumber;\r
	return t;\r
}\r
\r
/**\r
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\r
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r
 */\r
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){\r
	var attrName;\r
	var value;\r
	var p = ++start;\r
	var s = S_TAG;//status\r
	while(true){\r
		var c = source.charAt(p);\r
		switch(c){\r
		case '=':\r
			if(s === S_ATTR){//attrName\r
				attrName = source.slice(start,p);\r
				s = S_EQ;\r
			}else if(s === S_ATTR_SPACE){\r
				s = S_EQ;\r
			}else{\r
				//fatalError: equal must after attrName or space after attrName\r
				throw new Error('attribute equal must after attrName');\r
			}\r
			break;\r
		case '\\'':\r
		case '"':\r
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\r
				){//equal\r
				if(s === S_ATTR){\r
					errorHandler.warning('attribute value must after "="')\r
					attrName = source.slice(start,p)\r
				}\r
				start = p+1;\r
				p = source.indexOf(c,start)\r
				if(p>0){\r
					value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r
					el.add(attrName,value,start-1);\r
					s = S_ATTR_END;\r
				}else{\r
					//fatalError: no end quot match\r
					throw new Error('attribute value no end \\''+c+'\\' match');\r
				}\r
			}else if(s == S_ATTR_NOQUOT_VALUE){\r
				value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r
				//console.log(attrName,value,start,p)\r
				el.add(attrName,value,start);\r
				//console.dir(el)\r
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');\r
				start = p+1;\r
				s = S_ATTR_END\r
			}else{\r
				//fatalError: no equal before\r
				throw new Error('attribute value must after "="');\r
			}\r
			break;\r
		case '/':\r
			switch(s){\r
			case S_TAG:\r
				el.setTagName(source.slice(start,p));\r
			case S_ATTR_END:\r
			case S_TAG_SPACE:\r
			case S_TAG_CLOSE:\r
				s =S_TAG_CLOSE;\r
				el.closed = true;\r
			case S_ATTR_NOQUOT_VALUE:\r
			case S_ATTR:\r
			case S_ATTR_SPACE:\r
				break;\r
			//case S_EQ:\r
			default:\r
				throw new Error("attribute invalid close char('/')")\r
			}\r
			break;\r
		case ''://end document\r
			//throw new Error('unexpected end of input')\r
			errorHandler.error('unexpected end of input');\r
			if(s == S_TAG){\r
				el.setTagName(source.slice(start,p));\r
			}\r
			return p;\r
		case '>':\r
			switch(s){\r
			case S_TAG:\r
				el.setTagName(source.slice(start,p));\r
			case S_ATTR_END:\r
			case S_TAG_SPACE:\r
			case S_TAG_CLOSE:\r
				break;//normal\r
			case S_ATTR_NOQUOT_VALUE://Compatible state\r
			case S_ATTR:\r
				value = source.slice(start,p);\r
				if(value.slice(-1) === '/'){\r
					el.closed  = true;\r
					value = value.slice(0,-1)\r
				}\r
			case S_ATTR_SPACE:\r
				if(s === S_ATTR_SPACE){\r
					value = attrName;\r
				}\r
				if(s == S_ATTR_NOQUOT_VALUE){\r
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');\r
					el.add(attrName,value.replace(/&#?\\w+;/g,entityReplacer),start)\r
				}else{\r
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){\r
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')\r
					}\r
					el.add(value,value,start)\r
				}\r
				break;\r
			case S_EQ:\r
				throw new Error('attribute value missed!!');\r
			}\r
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\r
			return p;\r
		/*xml space '\\x20' | #x9 | #xD | #xA; */\r
		case '\\u0080':\r
			c = ' ';\r
		default:\r
			if(c<= ' '){//space\r
				switch(s){\r
				case S_TAG:\r
					el.setTagName(source.slice(start,p));//tagName\r
					s = S_TAG_SPACE;\r
					break;\r
				case S_ATTR:\r
					attrName = source.slice(start,p)\r
					s = S_ATTR_SPACE;\r
					break;\r
				case S_ATTR_NOQUOT_VALUE:\r
					var value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');\r
					el.add(attrName,value,start)\r
				case S_ATTR_END:\r
					s = S_TAG_SPACE;\r
					break;\r
				//case S_TAG_SPACE:\r
				//case S_EQ:\r
				//case S_ATTR_SPACE:\r
				//	void();break;\r
				//case S_TAG_CLOSE:\r
					//ignore warning\r
				}\r
			}else{//not space\r
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE\r
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE\r
				switch(s){\r
				//case S_TAG:void();break;\r
				//case S_ATTR:void();break;\r
				//case S_ATTR_NOQUOT_VALUE:void();break;\r
				case S_ATTR_SPACE:\r
					var tagName =  el.tagName;\r
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){\r
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')\r
					}\r
					el.add(attrName,attrName,start);\r
					start = p;\r
					s = S_ATTR;\r
					break;\r
				case S_ATTR_END:\r
					errorHandler.warning('attribute space is required"'+attrName+'"!!')\r
				case S_TAG_SPACE:\r
					s = S_ATTR;\r
					start = p;\r
					break;\r
				case S_EQ:\r
					s = S_ATTR_NOQUOT_VALUE;\r
					start = p;\r
					break;\r
				case S_TAG_CLOSE:\r
					throw new Error("elements closed character '/' and '>' must be connected to");\r
				}\r
			}\r
		}//end outer switch\r
		//console.log('p++',p)\r
		p++;\r
	}\r
}\r
/**\r
 * @return true if has new namespace define\r
 */\r
function appendElement(el,domBuilder,currentNSMap){\r
	var tagName = el.tagName;\r
	var localNSMap = null;\r
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r
	var i = el.length;\r
	while(i--){\r
		var a = el[i];\r
		var qName = a.qName;\r
		var value = a.value;\r
		var nsp = qName.indexOf(':');\r
		if(nsp>0){\r
			var prefix = a.prefix = qName.slice(0,nsp);\r
			var localName = qName.slice(nsp+1);\r
			var nsPrefix = prefix === 'xmlns' && localName\r
		}else{\r
			localName = qName;\r
			prefix = null\r
			nsPrefix = qName === 'xmlns' && ''\r
		}\r
		//can not set prefix,because prefix !== ''\r
		a.localName = localName ;\r
		//prefix == null for no ns prefix attribute \r
		if(nsPrefix !== false){//hack!!\r
			if(localNSMap == null){\r
				localNSMap = {}\r
				//console.log(currentNSMap,0)\r
				_copy(currentNSMap,currentNSMap={})\r
				//console.log(currentNSMap,1)\r
			}\r
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\r
			a.uri = 'http://www.w3.org/2000/xmlns/'\r
			domBuilder.startPrefixMapping(nsPrefix, value) \r
		}\r
	}\r
	var i = el.length;\r
	while(i--){\r
		a = el[i];\r
		var prefix = a.prefix;\r
		if(prefix){//no prefix attribute has no namespace\r
			if(prefix === 'xml'){\r
				a.uri = 'http://www.w3.org/XML/1998/namespace';\r
			}if(prefix !== 'xmlns'){\r
				a.uri = currentNSMap[prefix || '']\r
				\r
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\r
			}\r
		}\r
	}\r
	var nsp = tagName.indexOf(':');\r
	if(nsp>0){\r
		prefix = el.prefix = tagName.slice(0,nsp);\r
		localName = el.localName = tagName.slice(nsp+1);\r
	}else{\r
		prefix = null;//important!!\r
		localName = el.localName = tagName;\r
	}\r
	//no prefix element has default namespace\r
	var ns = el.uri = currentNSMap[prefix || ''];\r
	domBuilder.startElement(ns,localName,tagName,el);\r
	//endPrefixMapping and startPrefixMapping have not any help for dom builder\r
	//localNSMap = null\r
	if(el.closed){\r
		domBuilder.endElement(ns,localName,tagName);\r
		if(localNSMap){\r
			for(prefix in localNSMap){\r
				domBuilder.endPrefixMapping(prefix) \r
			}\r
		}\r
	}else{\r
		el.currentNSMap = currentNSMap;\r
		el.localNSMap = localNSMap;\r
		//parseStack.push(el);\r
		return true;\r
	}\r
}\r
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){\r
	if(/^(?:script|textarea)$/i.test(tagName)){\r
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);\r
		var text = source.substring(elStartEnd+1,elEndStart);\r
		if(/[&<]/.test(text)){\r
			if(/^script$/i.test(tagName)){\r
				//if(!/\\]\\]>/.test(text)){\r
					//lexHandler.startCDATA();\r
					domBuilder.characters(text,0,text.length);\r
					//lexHandler.endCDATA();\r
					return elEndStart;\r
				//}\r
			}//}else{//text area\r
				text = text.replace(/&#?\\w+;/g,entityReplacer);\r
				domBuilder.characters(text,0,text.length);\r
				return elEndStart;\r
			//}\r
			\r
		}\r
	}\r
	return elStartEnd+1;\r
}\r
function fixSelfClosed(source,elStartEnd,tagName,closeMap){\r
	//if(tagName in closeMap){\r
	var pos = closeMap[tagName];\r
	if(pos == null){\r
		//console.log(tagName)\r
		pos =  source.lastIndexOf('</'+tagName+'>')\r
		if(pos<elStartEnd){//\u5FD8\u8BB0\u95ED\u5408\r
			pos = source.lastIndexOf('</'+tagName)\r
		}\r
		closeMap[tagName] =pos\r
	}\r
	return pos<elStartEnd;\r
	//} \r
}\r
function _copy(source,target){\r
	for(var n in source){target[n] = source[n]}\r
}\r
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'\r
	var next= source.charAt(start+2)\r
	switch(next){\r
	case '-':\r
		if(source.charAt(start + 3) === '-'){\r
			var end = source.indexOf('-->',start+4);\r
			//append comment source.substring(4,end)//<!--\r
			if(end>start){\r
				domBuilder.comment(source,start+4,end-start-4);\r
				return end+3;\r
			}else{\r
				errorHandler.error("Unclosed comment");\r
				return -1;\r
			}\r
		}else{\r
			//error\r
			return -1;\r
		}\r
	default:\r
		if(source.substr(start+3,6) == 'CDATA['){\r
			var end = source.indexOf(']]>',start+9);\r
			domBuilder.startCDATA();\r
			domBuilder.characters(source,start+9,end-start-9);\r
			domBuilder.endCDATA() \r
			return end+3;\r
		}\r
		//<!DOCTYPE\r
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \r
		var matchs = split(source,start);\r
		var len = matchs.length;\r
		if(len>1 && /!doctype/i.test(matchs[0][0])){\r
			var name = matchs[1][0];\r
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]\r
			var sysid = len>4 && matchs[4][0];\r
			var lastMatch = matchs[len-1]\r
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\\1$/,'$2'),\r
					sysid && sysid.replace(/^(['"])(.*?)\\1$/,'$2'));\r
			domBuilder.endDTD();\r
			\r
			return lastMatch.index+lastMatch[0].length\r
		}\r
	}\r
	return -1;\r
}\r
\r
\r
\r
function parseInstruction(source,start,domBuilder){\r
	var end = source.indexOf('?>',start);\r
	if(end){\r
		var match = source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\r
		if(match){\r
			var len = match[0].length;\r
			domBuilder.processingInstruction(match[1], match[2]) ;\r
			return end+2;\r
		}else{//error\r
			return -1;\r
		}\r
	}\r
	return -1;\r
}\r
\r
/**\r
 * @param source\r
 */\r
function ElementAttributes(source){\r
	\r
}\r
ElementAttributes.prototype = {\r
	setTagName:function(tagName){\r
		if(!tagNamePattern.test(tagName)){\r
			throw new Error('invalid tagName:'+tagName)\r
		}\r
		this.tagName = tagName\r
	},\r
	add:function(qName,value,offset){\r
		if(!tagNamePattern.test(qName)){\r
			throw new Error('invalid attribute:'+qName)\r
		}\r
		this[this.length++] = {qName:qName,value:value,offset:offset}\r
	},\r
	length:0,\r
	getLocalName:function(i){return this[i].localName},\r
	getLocator:function(i){return this[i].locator},\r
	getQName:function(i){return this[i].qName},\r
	getURI:function(i){return this[i].uri},\r
	getValue:function(i){return this[i].value}\r
//	,getIndex:function(uri, localName)){\r
//		if(localName){\r
//			\r
//		}else{\r
//			var qName = uri\r
//		}\r
//	},\r
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\r
//	getType:function(uri,localName){}\r
//	getType:function(i){},\r
}\r
\r
\r
\r
\r
function _set_proto_(thiz,parent){\r
	thiz.__proto__ = parent;\r
	return thiz;\r
}\r
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){\r
	_set_proto_ = function(thiz,parent){\r
		function p(){};\r
		p.prototype = parent;\r
		p = new p();\r
		for(parent in thiz){\r
			p[parent] = thiz[parent];\r
		}\r
		return p;\r
	}\r
}\r
\r
function split(source,start){\r
	var match;\r
	var buf = [];\r
	var reg = /'[^']+'|"[^"]+"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\r
	reg.lastIndex = start;\r
	reg.exec(source);//skip <\r
	while(match = reg.exec(source)){\r
		buf.push(match);\r
		if(match[1])return buf;\r
	}\r
}\r
\r
exports.G = XMLReader;\r
\r


//# sourceURL=webpack:///./node_modules/xmldom/sax.js?`)}}]);
